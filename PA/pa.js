Ext.namespace('Pan.base.widgets');
Pan.base.widgets.PagingToolbar = Ext.extend(Ext.PagingToolbar, {
    initComponent: function () {
        if (this.supportLocalPaging) {
            this.cls = this.cls || "";
            this.cls += " " + "x-toolbar-local-paging";
            if (this.showLocalPagingBarOnDemand) {
                this.setVisible(false);
            }
        }
        Pan.base.widgets.PagingToolbar.superclass.initComponent.apply(this, arguments);
        if (this.hideRefresh) {
            var pagingItems = this.items.items;
            for (var i = 0; i < pagingItems.length; i++) {
                if (pagingItems[i].iconCls && pagingItems[i].iconCls === 'x-tbar-loading') {
                    pagingItems[i].hide();
                    pagingItems[i - 1].hide();
                }
            }
        }
    }, doRefresh: function () {
        this.doLoad(this.cursor, this.supportLocalPaging);
    }, doLoad: function (start, forceRefresh) {
        var o = {}, pn = this.getParams();
        o[pn.start] = start;
        o[pn.limit] = this.pageSize;
        var options = {params: o};
        if (!forceRefresh && this.supportLocalPaging) {
            o['supportLocalPaging'] = true;
            this.onLoad(undefined, undefined, options);
        }
        if (this.fireEvent('beforechange', this, o) !== false) {
            this.store.load(options);
        }
    }, bindStore: function (store, initial) {
        if (!initial && this.store) {
            if (store !== this.store && this.store.autoDestroy) {
            }
            else {
                this.store.un('localPagingChanged', this.onLocalPagingChanged, this);
            }
        }
        if (store) {
            store = Ext.StoreMgr.lookup(store);
            store.on({scope: this, localPagingChanged: this.onLocalPagingChanged});
        }
        Pan.base.widgets.PagingToolbar.superclass.bindStore.apply(this, arguments);
    }, onLocalPagingChanged: function (store, params) {
        this.onLoad(store, undefined, {params: params});
        if (this.showLocalPagingBarOnDemand) {
            var pn = this.getParams();
            if (this.isVisible() !== (params[pn.limit] < this.store.getTotalCount())) {
                this.setVisible(!this.isVisible());
            }
        }
    }, updateInfo: function () {
        if (this.hideDisplayMsg && this.displayItem) {
            this.displayItem.setText('');
            return;
        }
        if (this.pageableCheckBoxSelection) {
            if (this.displayItem) {
                var count = this.store.getCount();
                var msg = count == 0 ? this.emptyMsg : String.format(this.displayMsg, this.cursor + 1, this.cursor + count, this.store.getTotalCount());
                this.displayItem.setText(msg);
            }
        }
        else {
            Pan.base.widgets.PagingToolbar.superclass.updateInfo.apply(this, arguments);
        }
    }
});
Ext.reg("pan-paging", Pan.base.widgets.PagingToolbar);
Pan.base.widgets.MessageBox = (function () {
    var msg = Ext.MessageBox;
    msg.minWidth = Pan.base.Constants.minWindowWidth;
    msg.promptDialogMaxWidth = 800;
    msg.promptDialogMaxHeight = 500;
    return Ext.applyIf({
        setDefaultButton: function (defaultButton) {
            msg.getDialog().defaultButton = defaultButton;
        }, focusOn: function (defaultButton) {
            var dialog = msg.getDialog();
            if (dialog.getHeight() < Pan.base.Constants.minWindowHeight) {
                dialog.setHeight(Pan.base.Constants.minWindowHeight);
            }
            if (dialog.getHeight() > msg.promptDialogMaxHeight) {
                dialog.setHeight(msg.promptDialogMaxHeight);
            }
            if (dialog.getWidth() > msg.promptDialogMaxWidth) {
                dialog.setWidth(msg.promptDialogMaxWidth);
            }
            if (Ext.isDefined(defaultButton)) {
                dialog.defaultButton = defaultButton;
            }
            else if (!Ext.isDefined(dialog.defaultButton)) {
                dialog.defaultButton = 1;
            }
            Ext.each(dialog.buttons, function (btn) {
                btn.removeClass('default-btn');
            }, dialog);
            dialog.buttons[dialog.defaultButton].addClass('default-btn');
            dialog.focus();
            delete dialog.defaultButton;
        }, alert: function (title, msg, fn, scope) {
            this.show({
                title: title,
                msg: msg,
                buttons: {'ok': _T('Close')},
                defaultButton: 1,
                closable: false,
                fn: fn,
                scope: scope,
                minWidth: this.minWidth
            });
            return this;
        }, confirm: function (title, msg, fn, scope, icon) {
            this.show({
                title: title,
                msg: msg,
                buttons: this.YESNO,
                fn: fn,
                scope: scope,
                icon: icon ? icon : this.QUESTION,
                closable: false,
                minWidth: this.minWidth
            });
            return this;
        }, prompt: function (title, msg, fn, scope, multiline, value) {
            this.show({
                title: title,
                msg: msg,
                buttons: this.OKCANCEL,
                fn: fn,
                minWidth: this.minPromptWidth,
                scope: scope,
                prompt: true,
                closable: false,
                multiline: multiline,
                value: value
            });
            return this;
        }, show: function () {
            Ext.applyIf(arguments[0], {closable: false});
            msg.show.apply(msg, arguments);
            this.focusOn(arguments[0].defaultButton);
        }, textarea: function (text, title, height, width) {
            var win = new Ext.Window({
                modal: true,
                minWidth: 400,
                plain: true,
                border: false,
                resizable: true,
                maximizable: true,
                draggable: true,
                closable: true,
                closeAction: 'destroy',
                title: title || '',
                autoScroll: false,
                layout: 'fit',
                items: [{height: height || 500, width: width || 400, xtype: 'textarea', readOnly: true, value: text}]
            });
            win.show();
        }, resizableAlert: function (title, msg, height, width) {
            var win = new Ext.Window({
                modal: true,
                minWidth: this.minWidth,
                minHeight: 200,
                height: height || 500,
                width: width || 400,
                plain: true,
                border: false,
                resizable: true,
                maximizable: true,
                draggable: true,
                closable: false,
                title: title || '',
                buttonAlign: 'center',
                html: msg,
                buttons: [{
                    text: 'Close', handler: function () {
                        win.close();
                    }
                }],
                autoScroll: true
            });
            win.show();
        }, showCountDown: function () {
            msg.show.apply(msg, arguments);
            this.focusOn(arguments[0].defaultButton);
            var update = function (newMsg, t) {
                msg.updateText(newMsg);
                if (t == Pan.base.Constants.countDownTimeForDialog + 1)
                    msg.hide();
            };
            var configuredMsg = arguments[0].msg;
            if (!Ext.isDefined(configuredMsg))
                configuredMsg = '<strong>' + _T('The operation succeeded.') + '</strong>'; else
                configuredMsg = '<strong>' + configuredMsg + '</strong>';
            update(configuredMsg);
            for (var t = Pan.base.Constants.countDownTimeForDialog + 1; t >= 1; t--) {
                var newMsg = configuredMsg + '</br></br>This dialog will be closed in ' + (Pan.base.Constants.countDownTimeForDialog + 1 - t) + ' seconds.';
                update.defer(t * 1000, this, [newMsg, t]);
            }
        }, showConfirmationOnOKDialog: function (options) {
            var myHandler = function (btn) {
                if (btn.itemId == "confirm-yes") {
                    if (options.onYes) {
                        options.onYes.call(this);
                    }
                    else if (options.onOk) {
                        options.onOk.call(this);
                    }
                }
                else if (btn.itemId == "confirm-no") {
                    if (options.onNo) {
                        options.onNo.call(this);
                    }
                }
                else if (btn.itemId == "confirm-cancel") {
                    if (options.onCancel) {
                        options.onCancel.call(this);
                    }
                }
                btn.ownerCt.ownerCt.hide();
            };
            var btns = [];
            var bs = options.buttons;
            if (bs && bs.ok) {
                btns.push({text: _T('OK'), itemId: 'confirm-yes', handler: myHandler.createDelegate(options.scope)});
            }
            if (bs && bs.yes) {
                btns.push({text: _T('Yes'), itemId: 'confirm-yes', handler: myHandler.createDelegate(options.scope)});
            }
            if (bs && bs.no) {
                btns.push({text: _T('No'), itemId: 'confirm-no', handler: myHandler.createDelegate(options.scope)});
            }
            if (bs && bs.cancel) {
                btns.push({
                    text: _T('Cancel'),
                    itemId: 'confirm-cancel',
                    handler: myHandler.createDelegate(options.scope)
                });
            }
            var items = [{
                xtype: 'pan-displayfield',
                cls: 'ext-mb-text',
                hideLabel: true,
                readOnly: true,
                value: options.msg
            }];
            var cfg = {
                autoCreate: true,
                cls: 'x-window-dlg',
                autoHeight: true,
                style: 'padding:10px',
                layout: 'form',
                icon: options.icon || '',
                title: options.title || _T("Confirm"),
                items: items,
                resizable: false,
                shadow: false,
                bodyStyle: 'padding: 5px;',
                doHTMLEncode: false,
                constrain: true,
                constrainHeader: true,
                minimizable: false,
                maximizable: false,
                stateful: false,
                modal: true,
                buttonAlign: "center",
                minHeight: 80,
                width: options.width || 400,
                closable: false,
                plain: true,
                buttons: btns
            };
            var dlg = new Ext.Window(cfg);
            dlg.show();
            dlg.defaultButton = options.defaultButton || btns.length - 1;
            dlg.buttons[dlg.defaultButton].addClass('default-btn');
            dlg.focus();
            delete dlg.defaultButton;
        }
    }, msg);
})();
Pan.Msg = Pan.base.widgets.MessageBox;
Pan.base.widgets.LoadMask = function (el, config) {
    if (config) {
        config.msg = config.msg || _T('Loading...');
    }
    Pan.base.widgets.LoadMask.superclass.constructor.call(this, el, config);
};
Ext.extend(Pan.base.widgets.LoadMask, Ext.LoadMask, {
    useLoadMaskDisplayerClassAsMaskEl: false, showMask: true, msgCls: 'x-mask-loading-no-img', onLoad: function () {
        this.setLoadingIndication(false);
        if (this.showMask) {
            if (this.cmp) {
                this.cmp.el.unmask(this.removeMask);
                delete this.cmp;
            }
            else {
                Pan.base.widgets.LoadMask.superclass.onLoad.apply(this);
            }
        }
    }, onBeforeLoad: function () {
        var cmp = this.setLoadingIndication(true);
        if (this.showMask && !this.disabled) {
            if (this.useLoadMaskDisplayerClassAsMaskEl && cmp) {
                this.cmp = cmp;
                this.cmp.el.mask(this.msg, this.msgCls);
            }
            else {
                Pan.base.widgets.LoadMask.superclass.onBeforeLoad.apply(this);
            }
        }
    }, getLoadingIndication: function (el) {
        var simpleSelector = '.' + Pan.base.Constants.loadMaskDisplayerClass;
        el = el || this.el;
        var dom = el.findParentNode(simpleSelector);
        if (dom) {
            return Ext.getCmp(dom.id);
        }
    }, setLoadingIndicationTooltip: function (tooltip, el) {
        var log = PanLogging.getLogger('base:widgets:LoadMask');
        try {
            var cmp = this.getLoadingIndication(el);
            if (cmp && cmp.setLoadingIndication) {
                cmp.setLoadingIndicationTooltip(tooltip);
            }
        }
        catch (ex) {
            log.error("exception in LoadMask::setTooltip");
        }
    }, setLoadingIndication: function (on, el, initiatorId) {
        var log = PanLogging.getLogger('base:widgets:LoadMask');
        try {
            var cmp = this.getLoadingIndication(el);
            if (cmp && cmp.setLoadingIndication) {
                if (Ext.isDefined(initiatorId)) {
                    if (on) {
                        cmp.__loadingIndicationInitiatorMap = cmp.__loadingIndicationInitiatorMap || {};
                        cmp.__loadingIndicationInitiatorMap[initiatorId] = initiatorId;
                        cmp.setLoadingIndication(on);
                    }
                    else if (cmp.__loadingIndicationInitiatorMap) {
                        delete cmp.__loadingIndicationInitiatorMap[initiatorId];
                        if (Pan.base.isEmpty(cmp.__loadingIndicationInitiatorMap)) {
                            delete cmp.__loadingIndicationInitiatorMap;
                            cmp.setLoadingIndication(on);
                        }
                    }
                }
                else {
                    cmp.setLoadingIndication(on);
                }
                return cmp;
            }
        }
        catch (ex) {
            log.error('exception in LoadMask::setLoadingIndication');
        }
    }
});
Pan.base.widgets.ProgressBar = Ext.extend(Ext.ProgressBar, {
    constructor: function (config) {
        config = Ext.apply({}, config);
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.widgets.ProgressBar.superclass.constructor.call(this, config);
    }, setValue: function (v) {
        this.updateProgress(v / 100, v + '%');
    }, getValue: function () {
        return this.value;
    }
});
Ext.reg('pan-progress', Pan.base.widgets.ProgressBar);
Ext.ns("Pan.base.renderer");
Pan.base.renderer.RendererCommon = function () {
    var defaultAlign = 'right';
    return {
        createActionImage: function (action, config) {
            if (!action.isAction) {
                config = Ext.apply({}, config, action);
                action = Pan.createAction(action);
            }
            if (!action.initialConfig.actionImageAvail || action.initialConfig.actionImageAvail.call(this, config)) {
                var align = action.initialConfig.align;
                if (align === undefined) {
                    align = defaultAlign;
                }
                if (align) {
                    align = ' align="' + align + '"';
                }
                var id = '';
                var tip = '';
                var additionalClass = '';
                if (config) {
                    if (config.component) {
                        var extid = config.component.getId() + '-action';
                        id = ' id="' + extid + '"';
                        config.component.addListener('render', function (c) {
                            var image = Ext.get(extid);
                            if (image) {
                                c.mon(image, "click", function (event) {
                                    event.stopEvent();
                                    event.preventDefault();
                                    event.stopPropagation();
                                    action.execute(c, config, event);
                                });
                            }
                        });
                    }
                    tip = config.tip ? (' ext:qtip="' + Pan.base.htmlEncode(config.tip) + '"') : '';
                    additionalClass = config.additionalClass || '';
                }
                return '<img ' + id + align + tip + ' class="x-cursor-pointer ' + additionalClass + ' ' + action.initialConfig.iconCls + '" src="/images/s.gif"/>';
            }
            return "";
        }, createImageIcon: function (value, meta, record, config) {
            var iconAlign = 'left';
            meta.css = 'x-grid-icon-col';
            config = Ext.apply({}, config);
            var id = '';
            var tip = '';
            var additionalClass = '';
            var text = '';
            if (config) {
                var align = config.align;
                if (align === undefined) {
                    align = iconAlign;
                } else {
                    iconAlign = align;
                }
                if (align) {
                    align = ' align="' + align + '"';
                }
                if (config.id) {
                    id = ' id="' + config.id + '"';
                }
                tip = config.tip ? (' ext:qtip="' + Pan.base.htmlEncode(config.tip) + '"') : '';
                additionalClass = config.additionalClass || '';
                text = config.text || '';
                return '<img ' + id + align + tip + ' class="' + additionalClass + ' ' + config.iconCls + '" style="width:16px;height:16px;vertical-align:middle;" src="/images/s.gif"/>' + '<span class="x-grid-col-span-with-icon-' + iconAlign + '">' + text + '</span>';
            }
            return "";
        }
    };
}();
Ext.ns('Pan', 'Pan.base', 'Pan.base.renderer');
Pan.base.renderer.RendererMgr = function () {
    var returnSelfFunction = function (value) {
        return value;
    };
    var types = {};
    return {
        renderer: function () {
            var fn = returnSelfFunction;
            var scope = undefined;
            var onClick = undefined;
            var beforeClick = undefined;
            if (arguments.length == 0) {
            } else if (Ext.isObject(arguments[0])) {
                var config = arguments[0];
                if (config.xtype) {
                    fn = new types[config.xtype](config);
                } else if (config.fn) {
                    fn = config.fn;
                }
                scope = config.scope || scope;
                onClick = config.onClick;
                if (config.beforeClick && fn.beforeClick) {
                    var fnBeforeClick = fn.beforeClick;
                    beforeClick = function () {
                        return config.beforeClick.apply(this, arguments) && fnBeforeClick.apply(this, arguments);
                    };
                } else {
                    beforeClick = config.beforeClick ? config.beforeClick : fn.beforeClick;
                }
            } else if (Ext.isFunction(arguments[0])) {
                fn = arguments[0];
                if (arguments.length > 1) {
                    scope = arguments[1];
                }
            }
            if (onClick) {
                fn.onClick = onClick;
                fn.beforeClick = beforeClick;
                fn.scope = scope;
            }
            return fn;
        }, registerType: function (xtype, cls) {
            types[xtype] = cls;
            cls.xtype = xtype;
        }
    };
}();
Pan.renderer = Pan.base.renderer.RendererMgr.renderer;
Pan.rreg = Pan.base.renderer.RendererMgr.registerType;
Ext.ns('Pan', 'Pan.base', 'Pan.base.renderer');
Pan.rreg("LabelRenderer", function (config) {
    var linkConfig = config.link;
    var linkcls = config.linkcls;
    var imgcls = config.imgcls;
    var textConfig = config.text;
    var imageConfig = config.image;
    var scopeConfig = config.scope;
    var preConfig = config.pre;
    var postConfig = config.post;
    var trigger = config.trigger || '';
    var preTextConfig = config.preText;
    var postTextConfig = config.postText;
    var tipConfig = config.tip;
    var postImageConfig = config.postImage;
    var fn = function (value) {
        var that = scopeConfig || this;
        var image = "", text = "", link = "", pre = preConfig || "", post = postConfig || "", tip = "";
        var postImage = "";
        var preText = preTextConfig || "", postText = postTextConfig || "";
        if (tipConfig) {
            if (Ext.isFunction(tipConfig)) {
                tip = tipConfig.apply(that, arguments);
            } else {
                tip = tipConfig.toString();
            }
            if (tip && tip.length > 0) {
                tip = 'title="' + tip + '"';
            }
        }
        if (linkConfig) {
            if (Ext.isFunction(linkConfig)) {
                link = linkConfig.apply(that, arguments);
            } else {
                link = linkConfig.toString();
            }
            if (link && link.length > 0) {
                if (linkcls && linkcls.length > 0)
                    link = '<a class="x-hyperlink ' + linkcls + tip + '">' + link + '</a>'; else
                    link = '<a class="x-hyperlink" ' + tip + '>' + link + '</a>';
            }
        }
        if (imageConfig) {
            if (Ext.isFunction(imageConfig)) {
                image = imageConfig.apply(that, arguments);
            } else {
                image = imageConfig;
            }
            if (Ext.isObject(image)) {
                var imageSrc = image.src || '/images/s.gif';
                var imageCls = image.cls;
                var imageTip = (image.tip && image.tip.length > 0) ? 'title="' + image.tip + '"' : '';
                if (imageCls) {
                    image = '<img ' + imageTip + ' class="' + imageCls + '" border="0" src="' + imageSrc + '"/>';
                } else {
                    image = '<img border="0" ' + imageTip + ' src="' + image + '"/>';
                }
            } else if (image) {
                image = image.toString();
                if (image && image.length > 0) {
                    if (imgcls) {
                        image = '<img ' + tip + ' class="' + imgcls + '" border="0" src="' + image + '"/>';
                    } else {
                        image = '<img border="0" ' + tip + ' src="' + image + '"/>';
                    }
                }
            } else {
                image = "";
            }
        }
        if (postImageConfig) {
            if (Ext.isFunction(postImageConfig)) {
                postImage = postImageConfig.apply(that, arguments);
            } else {
                postImage = postImageConfig;
            }
            if (Ext.isObject(postImage)) {
                var postImageSrc = postImage.src || '/images/s.gif';
                var postImageCls = postImage.cls;
                var postImageTip = (postImage.tip && postImage.tip.length > 0) ? 'title="' + postImage.tip + '"' : '';
                if (postImageCls) {
                    postImage = '<img ' + postImageTip + ' class="' + postImageCls + '" border="0" src="' + postImageSrc + '"/>';
                } else {
                    postImage = '<img border="0" ' + postImageTip + ' src="' + image + '"/>';
                }
            } else {
                postImage = "";
            }
        }
        if (textConfig) {
            if (Ext.isFunction(textConfig)) {
                text = textConfig.apply(that, arguments);
            } else {
                text = textConfig.toString();
            }
        }
        if (preTextConfig) {
            if (Ext.isFunction(preTextConfig)) {
                preText = preTextConfig.apply(that, arguments);
            } else {
                preText = preTextConfig.toString();
            }
        }
        if (postTextConfig) {
            if (Ext.isFunction(postTextConfig)) {
                postText = postTextConfig.apply(that, arguments);
                if (!Ext.isDefined(postText)) {
                    postText = "";
                }
            } else {
                postText = postTextConfig.toString();
            }
        }
        if (!Ext.isEmpty(trigger)) {
            trigger = '<span class="x-toolbar-trigger">&nbsp;&nbsp;&nbsp;&nbsp;</span>';
        }
        var ret = [];
        if (Ext.isArray(text)) {
            for (var i = 0; i < text.length; i++) {
                ret.push(preText + pre + image + '' + link + text[i] + postImage + trigger + post + postText);
            }
            return ret;
        }
        return preText + pre + image + '' + link + text + postImage + trigger + post + postText;
    };
    fn.beforeClick = function (component, config, event) {
        var target = event.getTarget();
        return target.tagName != "DIV" && target.tagName != "TD";
    };
    return fn;
});
Ext.ns('Pan', 'Pan.base', 'Pan.base.renderer');
Pan.rreg("DraggableRenderer", function (config) {
    var linkConfig = config.link;
    var linkcls = config.linkcls;
    var imgcls = config.imgcls;
    var textConfig = config.text;
    var imageConfig = config.image;
    var scopeConfig = config.scope;
    var trigger = config.trigger || '';
    var fn = function (value) {
        var that = scopeConfig || this;
        var image = "", text = "", link = "", pre = '<span class="x-draggable">', post = '</span>';
        if (linkConfig) {
            if (Ext.isFunction(linkConfig)) {
                link = linkConfig.apply(that, arguments);
            } else {
                link = linkConfig.toString();
            }
            if (link && link.length > 0) {
                if (linkcls && linkcls.length > 0)
                    link = '<a class="x-hyperlink ' + linkcls + '">' + link + '</a>'; else
                    link = '<a class="x-hyperlink">' + link + '</a>';
            }
        }
        if (imageConfig) {
            if (Ext.isFunction(imageConfig)) {
                image = imageConfig.apply(that, arguments);
            } else {
                image = imageConfig.toString();
            }
            if (image && image.length > 0) {
                if (imgcls)
                    image = '<img class="' + imgcls + '" border="0" src="' + image + '"/>'; else
                    image = '<img border="0" src="' + image + '"/>';
            }
        }
        if (textConfig) {
            if (Ext.isFunction(textConfig)) {
                text = textConfig.apply(that, arguments);
            } else {
                text = textConfig.toString();
            }
        }
        if (!Ext.isEmpty(trigger)) {
            trigger = '<span class="x-toolbar-trigger">&nbsp;&nbsp;&nbsp;&nbsp;</span>';
        }
        return pre + image + ' ' + link + text + trigger + post;
    };
    fn.beforeClick = function (component, config, event) {
        var target = event.getTarget();
        return target.tagName != "DIV";
    };
    return fn;
});
Ext.ns('Pan', 'Pan.base', 'Pan.base.renderer');
Pan.rreg("ButtonRenderer", function (config) {
    var linkConfig = config.link;
    var linkcls = config.linkcls;
    var imgcls = config.imgcls;
    var textConfig = config.text;
    var imageConfig = config.image;
    var scopeConfig = config.scope;
    var preConfig = config.pre;
    var postConfig = config.post;
    var fn = function (value) {
        var that = scopeConfig || this;
        var image = "", text = "", link = "", pre = preConfig || "", post = postConfig || "";
        if (linkConfig) {
            if (Ext.isFunction(linkConfig)) {
                link = linkConfig.apply(that, arguments);
            } else {
                link = linkConfig.toString();
            }
            if (link && link.length > 0) {
                if (linkcls && linkcls.length > 0)
                    link = '<a class="x-hyperlink ' + linkcls + '">' + link + '</a>'; else
                    link = '<a class="x-hyperlink">' + link + '</a>';
            }
        }
        if (imageConfig) {
            if (Ext.isFunction(imageConfig)) {
                image = imageConfig.apply(that, arguments);
            } else {
                image = imageConfig.toString();
            }
            if (image && image.length > 0) {
                if (imgcls)
                    image = '<img class="' + imgcls + '" border="0" src="' + image + '"/>'; else
                    image = '<img border="0" src="' + image + '"/>';
            }
        }
        if (textConfig) {
            if (Ext.isFunction(textConfig)) {
                text = textConfig.apply(that, arguments);
            } else {
                text = textConfig.toString();
            }
        }
        return pre + image + ' ' + link + text + post;
    };
    fn.beforeClick = function (component, config, event) {
        var target = event.getTarget();
        return target.tagName != "DIV";
    };
    return fn;
});
Pan.rreg("CellActionRenderer", function (config) {
    var fn = config.fn;
    if (!fn) {
        fn = function (value) {
            return value;
        };
    }
    if (config.cellActions) {
        var defaultAlign = config.align;
        if (defaultAlign === undefined) {
            defaultAlign = "right";
        }
        else if (defaultAlign === "") {
            defaultAlign = undefined;
        }
        var actions = Pan.createActionBar(config.cellActions);
        var iconActionMap = {};
        var hyperlinkActionMap = {};
        for (var j = 0; j < actions.length; j++) {
            var action = actions[j];
            if (!action.initialConfig) {
                continue;
            }
            var iconCls = action.initialConfig.iconCls;
            var text = action.initialConfig.text;
            if (Ext.isDefined(iconCls)) {
                iconActionMap[iconCls] = action;
            }
            if (Ext.isDefined(text)) {
                hyperlinkActionMap[text] = action;
            }
        }
        fn = Pan.base.util.createExtension(function (value, meta, record, row, col, store, grid) {
            var rv = arguments.callee.superFunction.apply(this, arguments);
            var arr = rv;
            var returnArray = true;
            if (!Ext.isArray(arr)) {
                arr = [rv];
                returnArray = false;
            }
            var i = 0;
            for (i = 0; i < arr.length; i++) {
                arr[i] = "";
                for (var j = 0; j < actions.length; j++) {
                    if (!actions[j].initialConfig.actionAvail || actions[j].initialConfig.actionAvail.call(this, {
                        actionObj: actions[j],
                        record: record,
                        grid: grid
                    })) {
                        arr[i] += (Ext.isDefined(actions[j].initialConfig.text) ? '<em class="x-hyperlink">' + actions[j].initialConfig.text + '</em>' : "")
                            + (Ext.isFunction(actions[j].initialConfig.normalText) ? actions[j].initialConfig.normalText.call(this, {
                                actionObj: actions[j],
                                record: record,
                                grid: grid
                            }) : (actions[j].initialConfig.normalText || ""))
                            + (Ext.isDefined(actions[j].initialConfig.iconCls) ? Pan.base.renderer.RendererCommon.createActionImage(actions[j], {
                                tip: Ext.isFunction(actions[j].initialConfig.tooltip) ? actions[j].initialConfig.tooltip.call(this, {
                                    actionObj: actions[j],
                                    record: record,
                                    grid: grid
                                }) : actions[j].initialConfig.tooltip || undefined,
                                record: record,
                                defaultAlign: defaultAlign
                            }) : "");
                        arr[i] += '<br/>';
                    }
                }
            }
            if (!returnArray) {
                rv = arr[0];
            }
            return rv;
        }, fn);
        var onClick = function (component, config, event) {
            var a;
            if (event.target.className.indexOf("x-hyperlink") >= 0) {
                var text = event.target.textContent || event.target.innerText || event.target.innerHTML;
                a = hyperlinkActionMap[text];
            }
            else {
                for (var iconCls in iconActionMap) {
                    if (iconActionMap.hasOwnProperty(iconCls)) {
                        if (event.target.className.indexOf(iconCls) >= 0) {
                            a = iconActionMap[iconCls];
                        }
                    }
                }
            }
            if (a) {
                a.execute(component, config, event);
            }
            else if (arguments.callee.superFunction) {
                return arguments.callee.superFunction.apply(this, arguments);
            }
        };
        if (config.onClick) {
            config.onClick = Pan.base.util.createExtension(onClick, config.onClick);
        }
        else {
            config.onClick = onClick;
        }
    }
    fn.beforeClick = function (component, config, event) {
        var target = event.getTarget();
        return target.tagName != "DIV";
    };
    return fn;
});
Ext.ns('Pan.base.renderer');
Pan.base.renderer.ThreatVaultLinkRenderer = Pan.renderer({
    onClick: function (component, config, event) {
        var tid = parseInt(this.tid, 10);
        window.open(Pan.base.Constants.THREAT_VAULT_API + tid, '_blank');
    }, beforeClick: function (component, config, event) {
        var target = event.getTarget();
        return target.tagName != "DIV";
    }, fn: function (v) {
        this.tid = v;
        return v + ', <em class="x-hyperlink"><span>View in Threat Vault</span></em>';
    }
});
Ext.ns('Pan.base.action');
Pan.base.action.Action = Ext.extend(Ext.Action, {
    constructor: function (config) {
        if (config.availConfig) {
            this.addAvail(Pan.createAvail(config.availConfig));
        }
        config.itemId = config.itemId || (config.scope ? config.scope.itemId + '-' + (config.text ? config.text : config.atype) : config.treePath);
        if (Ext.isDefined(config.xtype)) {
            Ext.applyIf(this, {xtype: config.xtype});
        }
        Pan.base.action.Action.superclass.constructor.apply(this, arguments);
    }, addAvail: function (avail) {
        this.avail = Pan.base.util.integrateArray(this.avail, avail);
    }, addComponent: function (c) {
        this.lastAssociatedComponent = c;
        if (!c.disableAssociation) {
            if (c.avail || this.avail) {
                c.avail = Pan.base.util.integrateArray(c.avail, this.avail);
            }
            if (c.avail) {
                if (!c.plugins) {
                    c.plugins = [];
                }
                if (!Ext.isArray(c.plugins)) {
                    c.plugins = [c.plugins];
                }
                c.plugins.push({ptype: "association"});
            }
        }
        if (this.initialConfig.isInMenu && this.initialConfig.listeners) {
            c.listeners = Ext.apply({}, c.listeners, this.listeners);
        }
        Pan.base.action.Action.superclass.addComponent.apply(this, arguments);
    }, setTooltip: function (tooltip) {
        this.initialConfig.tooltip = tooltip;
        this.callEach('setTooltip', [tooltip]);
    }, getTooltip: function () {
        return this.initialConfig.tooltip;
    }
});
Pan.base.action.ActionTypes = (function () {
    var actionTypes = {};
    return {
        areg: function (type, action, avail) {
            actionTypes[type] = action;
            if (avail) {
                this.setActionAvail(type, avail);
            }
        }, setActionAvail: function (type, avail) {
            var a = this.getAction(type);
            if (a) {
                a.prototype.avail = avail;
            }
        }, getAction: function (type) {
            return actionTypes[type];
        }, createAction: function (config, scope, makeHandler) {
            var Action;
            if (Ext.isString(config)) {
                Action = Pan.getAction(config);
                if (Action) {
                    return new Action({scope: scope || window});
                }
            }
            else if (Ext.isObject(config)) {
                if (config.atype) {
                    Action = Pan.getAction(config.atype);
                    if (Action) {
                        return new Action(Ext.apply({scope: scope || window}, config));
                    }
                }
                else if (config.isCreateAction && config.handler) {
                    return new Pan.base.action.Action(Ext.apply({scope: scope || window}, config));
                }
                else if (config.menu) {
                    var items;
                    if (config.menu.items) {
                        items = config.menu.items = config.menu.items.slice(0);
                    }
                    else {
                        items = config.menu = config.menu.slice(0);
                    }
                    config = Ext.apply({xtype: 'pan-button'}, config);
                    var menuListenersConfig = {
                        'enable': function () {
                            this.ownerCt.ownerCt.enable();
                        }, 'disable': function () {
                            var allDisabled = true;
                            this.ownerCt.items.each(function (item) {
                                if (Ext.isDefined(item.atype) && !item.disabled) {
                                    allDisabled = false;
                                    return false;
                                }
                            });
                            this.ownerCt.ownerCt.setDisabled(allDisabled);
                        }
                    };
                    for (var i = 0; i < items.length; i++) {
                        var configMenu = items[i];
                        configMenu.isInMenu = true;
                        configMenu.listeners = Ext.apply({}, configMenu.listeners, menuListenersConfig);
                        configMenu = Pan.createAction(configMenu, scope, makeHandler);
                        if (configMenu.handler && makeHandler) {
                            makeHandler.call(scope, configMenu, configMenu);
                        }
                        else if (configMenu.initialConfig && configMenu.initialConfig.handler && makeHandler) {
                            makeHandler.call(scope, configMenu.initialConfig, configMenu);
                        }
                        items[i] = configMenu;
                    }
                    if (items.length > 0) {
                        config.listeners = Ext.apply({
                            'beforerender': function () {
                                this.menu.render();
                                this.menu.doLayout(false, true);
                                return true;
                            }
                        }, config.listeners);
                    }
                }
            }
            return config;
        }, createActionBar: function (bar, makeHandler, scope) {
            for (var i = 0; i < bar.length; i++) {
                bar[i] = Pan.createAction(bar[i], scope, makeHandler);
                if (bar[i].handler && makeHandler) {
                    makeHandler.call(scope, bar[i], bar[i]);
                }
                else if (bar[i].initialConfig && bar[i].initialConfig.handler && makeHandler) {
                    makeHandler.call(scope, bar[i].initialConfig, bar[i]);
                }
            }
            return bar;
        }, createActions: function (config, makeHandler, scope) {
            var i;
            if (config.menu && config.menu.items) {
                config.menu.items = config.menu.items.slice(0);
                for (i = 0; i < config.menu.items.length; i++) {
                    config.menu.items[i] = Pan.createActions(config.menu.items[i], makeHandler, scope);
                }
                return config;
            }
            else if (config.menu) {
                config.menu = config.menu.slice(0);
                for (i = 0; i < config.menu.length; i++) {
                    config.menu[i] = Pan.createActions(config.menu[i], makeHandler, scope);
                }
                return config;
            }
            else {
                config = Pan.createAction(config, scope);
                if (config.handler && makeHandler) {
                    makeHandler.call(scope, config, config);
                }
                else if (config.initialConfig && config.initialConfig.handler && makeHandler) {
                    makeHandler.call(scope, config.initialConfig, config);
                }
                return config;
            }
        }
    };
})();
Pan.areg = Pan.base.action.ActionTypes.areg;
Pan.getAction = Pan.base.action.ActionTypes.getAction;
Pan.createAction = Pan.base.action.ActionTypes.createAction;
Pan.createActions = Pan.base.action.ActionTypes.createActions;
Pan.createActionBar = Pan.base.action.ActionTypes.createActionBar;
Pan.setActionAvail = Pan.base.action.ActionTypes.setActionAvail;
Ext.ns('Pan.base.action');
Pan.base.action.BaseAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.base.action.BaseAction.superclass.constructor.call(this, Ext.apply({ref: '../baseAction'}, config));
    }
});
Pan.areg('baseAction', Pan.base.action.BaseAction);
Ext.ns('Pan.base.action');
Pan.base.action.RemoteAction = Ext.extend(Pan.base.action.Action, {
    doAction: Ext.emptyFn,
    preAction: Ext.emptyFn,
    action: Ext.emptyFn,
    postSucceedAction: Ext.emptyFn,
    postFailedAction: Ext.emptyFn
});
Ext.ns('Pan.base.action');
Pan.base.action.WindowCloseAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.base.action.WindowCloseAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Close'),
            ref: '../closeWindowAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element) {
        var ownerCt = element.ownerCt;
        while (ownerCt) {
            if (ownerCt.floating) {
                ownerCt.close();
                break;
            }
            ownerCt = ownerCt.ownerCt;
        }
    }
});
Pan.areg("windowCloseAction", Pan.base.action.WindowCloseAction);
Ext.ns('Pan.base.association');
Pan.base.association.AssociationPlugin = function (config) {
    Ext.apply(this, config);
};
Pan.base.association.Identification = (function () {
    var id = 0;
    return function () {
        return "" + (++id);
    };
})();
Pan.base.association.availIfPhantomRecordCfg = (function () {
    return {
        match: {
            evaluate: function () {
                return this.__component.getRecord().phantom;
            }
        }, availHide: false
    };
})();
Pan.base.association.availHideIfHavingTemplateCfg = (function () {
    return {
        match: {
            evaluate: '&&', operands: [{
                evaluate: function () {
                    return !Ext.isDefined(Pan.global.getTemplate());
                }
            }]
        }, availHide: true
    };
})();
Pan.base.association.availIfFirewalOrTemplateCfg = (function () {
    return {
        match: {
            evaluate: '&&', operands: [{
                evaluate: function () {
                    return !Pan.global.isCmsSelected() || (Pan.global.isCmsSelected() && Ext.isDefined(Pan.global.getTemplate()));
                }
            }]
        }, availHide: true
    };
})();
Pan.base.association.availActionIfNotInTemplateStack = (function () {
    return {
        match: {
            evaluate: '&&', operands: [{
                evaluate: function () {
                    return !Pan.global.isCmsSelected() || !Pan.common.PanConfigStates.prototype.isShowingTemplateStackComboOnTop();
                }
            }]
        }, availHide: false
    };
})();
Pan.base.association.reloadStoreIfFieldChanged = function (field, action, alwaysEvaluate) {
    return {
        listenToAfterInit: false, match: {evaluate: 'fieldEvt', field: field, event: 'select'}, exec: {
            evaluate: function () {
                if (alwaysEvaluate === undefined)
                    alwaysEvaluate = false;
                if (this.__component.getRecord().phantom || alwaysEvaluate) {
                    if (action === 'reload')
                        this.__component.store.reload(); else if (action === 'clearValue') {
                        this.__component.clearValueEx(true, true);
                    }
                    else if (action === 'removeAll') {
                        this.__component.store.removeAll();
                    }
                }
            }
        }
    };
};
Ext.extend(Pan.base.association.AssociationPlugin, Object, {
    init: function (c) {
        this.associations = [];
        this.addTo(this.associations, c.association);
        this.addTo(this.associations, c.avail, {availHide: false});
        c.addListener({render: {fn: this.setup, scope: this}});
    }, setup: function (c) {
        var listenToAfterInit = false;
        var processAfterRender = false;
        for (var i = 0; i < this.associations.length; i++) {
            if (this.associations[i].listenToAfterInit !== false) {
                listenToAfterInit = true;
            }
            if (this.associations[i].processAfterRender === true) {
                processAfterRender = true;
                break;
            }
        }
        if (!processAfterRender && listenToAfterInit !== false) {
            var ownerCt = c;
            while (ownerCt) {
                if (Ext.isFunction(ownerCt.hasEvent)) {
                    if (ownerCt.hasEvent('afterformload')) {
                        ownerCt.addListener('afterformload', function () {
                            this.processAssociation(c, this.associations, {
                                __afterInit: true,
                                __exec: true,
                                __scope: this,
                                __component: c,
                                __event: null,
                                __listenFieldName: null,
                                __listenField: null
                            });
                        }, this);
                        break;
                    }
                    if (ownerCt.hasEvent('afterinit')) {
                        if (ownerCt.afterinitCompleted) {
                            processAfterRender = true;
                        }
                        else {
                            ownerCt.addListener('afterinit', function () {
                                this.processAssociation(c, this.associations, {
                                    __afterInit: true,
                                    __exec: true,
                                    __scope: this,
                                    __component: c,
                                    __event: null,
                                    __listenFieldName: null,
                                    __listenField: null
                                });
                            }, this);
                        }
                        break;
                    }
                }
                ownerCt = ownerCt.ownerCt;
            }
        }
        if (processAfterRender) {
            this.processAssociation(c, this.associations, {
                __afterInit: true,
                __exec: true,
                __scope: this,
                __component: c,
                __event: null,
                __listenFieldName: null,
                __listenField: null
            });
        }
        this.setupAssociation(c, this.associations);
    }, hasAfterInitCompleted: function (c) {
        var ownerCt = c;
        while (ownerCt) {
            if (Ext.isFunction(ownerCt.hasEvent)) {
                if (ownerCt.hasEvent('afterinit')) {
                    if (ownerCt.afterinitCompleted) {
                        return true;
                    }
                }
            }
            ownerCt = ownerCt.ownerCt;
        }
        return false;
    }, addTo: function (array, members, defaults) {
        if (members) {
            if (Ext.isArray(members)) {
                for (var i = 0; i < members.length; i++) {
                    var copy = Pan.base.clone(members[i]);
                    Ext.applyIf(copy, defaults);
                    array.push(copy);
                }
            }
            else {
                var acopy = Pan.base.clone(members);
                Ext.applyIf(acopy, defaults);
                array.push(acopy);
            }
        }
        return array;
    }, setupAssociation: function (c, associations) {
        if (!Ext.isArray(associations)) {
            associations = [associations];
        }
        for (var k = 0; k < associations.length; k++) {
            var association = associations[k];
            association.identification = Pan.base.association.Identification();
            var match = {association: association.match};
            this.setupNoPreprocess(match);
            var i, j, doExec = false, event;
            var results = jsonPath(match, "$..[?(!@.nopreprocess && (@.evaluate || (!@.event && @.field)))]");
            if (results) {
                for (i = 0; i < results.length; i++) {
                    var result = results[i];
                    this.preprocessEvaluate(result);
                    var operands = result.operands;
                    switch (result.evaluate) {
                        case'fieldFn':
                            if (Ext.isArray(operands)) {
                                operands = operands[0];
                            }
                            if (operands.fn === 'getValue') {
                                event = this.attach({
                                    component: c,
                                    listenField: operands.field || c,
                                    event: undefined,
                                    listenToIfExists: association.listenToIfExists,
                                    identification: association.identification
                                });
                                if (event) {
                                    doExec = true;
                                }
                            }
                            break;
                        case'fieldEvt':
                            if (!Ext.isArray(operands)) {
                                operands = [operands];
                            }
                            for (j = 0; j < operands.length; j++) {
                                event = this.attach({
                                    component: c,
                                    listenField: operands[j].field || c,
                                    event: operands[j].event,
                                    listenToIfExists: association.listenToIfExists,
                                    identification: association.identification
                                });
                                if (event) {
                                    doExec = true;
                                    if (!operands[j].event) {
                                        operands[j].event = event;
                                    }
                                }
                            }
                            break;
                        case'fieldDataEvt':
                            if (!operands) {
                                operands = [];
                            }
                            else if (!Ext.isArray(operands)) {
                                operands = [operands];
                            }
                            for (j = 0; j < operands.length; j++) {
                                event = this.attach({
                                    component: c,
                                    listenField: operands[j].field || c,
                                    event: operands[j].event,
                                    listenToIfExists: association.listenToIfExists,
                                    callChain: operands[j].observableCallChain,
                                    identification: association.identification
                                });
                                if (event) {
                                    doExec = true;
                                    if (!operands[j].event) {
                                        operands[j].event = event;
                                    }
                                }
                            }
                            break;
                        default:
                            doExec = true;
                            break;
                    }
                }
            }
            else {
                doExec = true;
            }
            if (doExec) {
                var exec = {association: association.exec};
                this.setupNoPreprocess(exec);
                results = jsonPath(exec, "$..[?(!@.nopreprocess && (@.evaluate || @.field))]");
                if (results) {
                    for (i = 0; i < results.length; i++) {
                        this.preprocessEvaluate(results[i]);
                    }
                }
            }
            else {
                association.skipExec = true;
            }
        }
    }, setupNoPreprocess: function (cond) {
        var doNotPrepocessList = jsonPath(cond, "$..[?(@.evaluate==='fieldFn' && !@.fn && @.operands)]");
        if (doNotPrepocessList) {
            for (var i = 0; i < doNotPrepocessList.length; i++) {
                var operands = doNotPrepocessList[i].operands;
                if (!Ext.isArray(operands)) {
                    operands = [operands];
                }
                for (var j = 0; j < operands.length; j++) {
                    if (operands[j].field) {
                        operands[j].nopreprocess = true;
                    }
                }
            }
        }
    }, preprocessEvaluate: function (result) {
        if (!result.evaluate) {
            result.evaluate = 'fieldFn';
        }
        var operands = result.operands;
        if (operands === undefined || (result.fn)) {
            operands = {};
            for (var m in result) {
                if (m !== 'fallback' && m !== 'evaluate' && result.hasOwnProperty(m)) {
                    operands[m] = result[m];
                    delete result[m];
                }
            }
            result.operands = operands;
        }
        if (result.evaluate === 'fieldFn') {
            if (Ext.isArray(operands)) {
                operands = operands[0];
            }
            if (!operands.fn) {
                operands.fn = 'getValue';
            }
        }
    }, attach: function (config) {
        var c = config.component;
        var listenFieldName = config.listenField;
        var listenField = listenFieldName;
        if (Ext.isString(listenFieldName)) {
            var ownerCt = c;
            while (ownerCt.ownerCt) {
                ownerCt = ownerCt.ownerCt;
            }
            listenField = ownerCt.findByItemId(listenFieldName);
        }
        else {
            listenFieldName = listenField.fieldName || listenField.itemId || listenField.name;
        }
        if (listenField && config.callChain) {
            listenField = Pan.callChain(listenField, config.callChain);
        }
        if (!listenField) {
            if (!config.listenToIfExists) {
                var log = PanLogging.getLogger('AssociationPlugin');
                log.error("Unable to locate listenField: " + listenFieldName);
            }
            return undefined;
        }
        var event = config.event || listenField.associationEvent || ['valid', 'invalid'];
        if (!Ext.isArray(event)) {
            event = [event];
        }
        for (var i = 0; i < event.length; i++) {
            if (listenField.hasEvent(event[i])) {
                listenField.addListener(event[i], this.listener, {
                    __scope: this,
                    __component: c,
                    __event: event,
                    __listenFieldName: listenFieldName,
                    __listenField: listenField,
                    __identification: config.identification
                });
            }
        }
        return event;
    }, listener: function () {
        if (this.__listenField) {
            this.__scope.processAssociation(this.__component, this.__scope.associations, this, arguments);
        }
        else if (!this.__scope.task) {
            this.__scope.task = new Ext.util.DelayedTask(this.__scope.processAssociation, this.__scope, [this.__component, this.__scope.associations, this, arguments]);
            this.__scope.task.delay(100);
        }
    }, processAssociation: function (c, associations, config, listenEventArguments) {
        var log = PanLogging.getLogger('base:association:AssociationPlugin');
        config = Ext.applyIf({__eventArg: listenEventArguments}, config);
        try {
            var continueEvaluationAvailHideMap = {'true': true, 'false': true};
            for (var k = 0; k < associations.length; k++) {
                var association = associations[k];
                if (association.listenToAfterInit === false) {
                    if (config.__afterInit) {
                        continue;
                    }
                }
                if (association.blockAssociationUntilAfterInit) {
                    if (!listenEventArguments || !listenEventArguments[0] || !listenEventArguments[0].isFieldDirty || !listenEventArguments[0].isFieldDirty() || !this.hasAfterInitCompleted(c)) {
                        continue;
                    }
                }
                if (!association.skipExec) {
                    if (!association.exec) {
                        var availHideValue = !!association.availHide;
                        if (!continueEvaluationAvailHideMap[true] || !continueEvaluationAvailHideMap[availHideValue]) {
                            continue;
                        }
                        var match = this.evaluate(association.match, config);
                        c.setIsAvail(match, availHideValue, {
                            initialAvail: config.__afterInit,
                            availDisableReason: association.availDisableReason || c.availDisableReason
                        });
                        if (!match) {
                            continueEvaluationAvailHideMap[availHideValue] = false;
                        }
                    }
                    else if (config.__exec || this.evaluate(association.match, config)) {
                        if (!association.cyclicCheck) {
                            association.cyclicCheck = true;
                            this.evaluate(association.exec, config);
                        }
                        association.cyclicCheck = false;
                    }
                }
            }
        }
        catch (ex) {
            log.error(ex);
            association.cyclicCheck = false;
        }
        delete this.task;
    }, evaluate: function (cond, config) {
        if (Ext.isObject(cond)) {
            cond = Ext.apply({}, cond);
            var operands = cond.operands;
            if (!Ext.isArray(operands)) {
                operands = [operands];
            }
            var args = [];
            for (var i = 0; i < operands.length; i++) {
                var operand = operands[i];
                if (Ext.isObject(operand)) {
                    args[i] = this.evaluate(operand, config);
                }
                else {
                    args[i] = operand;
                }
            }
            cond.operands = args;
            if (cond.evaluate) {
                var result;
                var evl = cond.evaluate;
                if (Ext.isFunction(evl)) {
                    result = this.callFn(evl, args, config);
                    if (!Ext.isDefined(result)) {
                        result = cond.fallback;
                    }
                    return result;
                }
                else if (Ext.isString(evl)) {
                    var rv = this.map2Function(evl);
                    if (Ext.isObject(rv)) {
                        result = this.callFn(rv.fn, args, config);
                    }
                    else {
                        var hash = Ext.apply({}, args, config);
                        result = this.callFn(Pan.base.Evaluation.evaluate, [evl, hash], config);
                    }
                    if (!Ext.isDefined(result)) {
                        result = cond.fallback;
                    }
                    return result;
                }
            }
        }
        return cond;
    }, callFn: function (fn, args, config) {
        return fn.apply(config, args);
    }, map2Function: function (s) {
        var fn = this.functionMap[s];
        if (Ext.isFunction(fn)) {
            return {fn: fn};
        }
        else {
            return s;
        }
    }, getAvailDisableReason: function (operation, count) {
        var availDisableReason;
        switch (operation) {
            case'<':
                availDisableReason = _T("Number of entries must be less than {count}", {count: count});
                break;
            case'>':
                availDisableReason = _T("Number of entries must be greater than {count}", {count: count});
                break;
            case'==':
            case'===':
                availDisableReason = _T("Number of entries must be equal to {count}", {count: count});
                break;
            case'<=':
                availDisableReason = _T("Number of entries must be less than or equal to {count}", {count: count});
                break;
            case'>=':
                availDisableReason = _T("Number of entries must be greater than or equal to {count}", {count: count});
                break;
            case'!=':
            case'!==':
                availDisableReason = _T("Number of entries must not be equal to {count}", {count: count});
                break;
            default:
                break;
        }
        return availDisableReason;
    }, functionMap: {
        'contains': function (arg1, arg2) {
            if (Ext.isString(arg1) && Ext.isString(arg2)) {
                return arg1.indexOf(arg2) >= 0;
            }
            return false;
        }, '!!': function () {
            return !!arguments[0];
        }, '&&': function () {
            var result = arguments[0];
            if (result) {
                for (var i = 1; i < arguments.length; i++) {
                    result = result && arguments[i];
                    if (!result) {
                        break;
                    }
                }
            }
            return result;
        }, '||': function () {
            var result = arguments[0];
            if (!result) {
                for (var i = 1; i < arguments.length; i++) {
                    result = result || arguments[i];
                    if (result) {
                        break;
                    }
                }
            }
            return result;
        }, '==': function (arg1, arg2) {
            return arg1 == arg2;
        }, '===': function (arg1, arg2) {
            return arg1 === arg2;
        }, '!=': function (arg1, arg2) {
            return arg1 != arg2;
        }, '!==': function (arg1, arg2) {
            return arg1 !== arg2;
        }, '<=': function (arg1, arg2) {
            return arg1 <= arg2;
        }, '>=': function (arg1, arg2) {
            return arg1 >= arg2;
        }, '<': function (arg1, arg2) {
            return arg1 < arg2;
        }, '>': function (arg1, arg2) {
            return arg1 > arg2;
        }, 'in': function (arg1, arg2) {
            if (!Ext.isArray(arg2)) {
                arg2 = [arg2];
            }
            for (var i = 0; i < arg2.length; i++) {
                if (arg2[i] == arg1) {
                    return true;
                }
            }
            return false;
        }, '!in': function (arg1, arg2) {
            if (!Ext.isArray(arg2)) {
                arg2 = [arg2];
            }
            for (var i = 0; i < arg2.length; i++) {
                if (arg2[i] == arg1) {
                    return false;
                }
            }
            return true;
        }, 'lastOperand': function () {
            if (arguments.length > 0) {
                return arguments[arguments.length - 1];
            }
            else {
                return false;
            }
        }, 'firstOperand': function (arg1) {
            return arg1;
        }, 'fieldFn': function () {
            var operands = arguments[0];
            var field = operands.field || this.__component;
            if (Ext.isString(field)) {
                var ownerCt = this.__component;
                while (ownerCt.ownerCt) {
                    ownerCt = ownerCt.ownerCt;
                }
                field = ownerCt.findByItemId(field);
            }
            if (Ext.isFunction(operands.fn)) {
                return operands.fn.call(this, field, operands.operands);
            }
            else {
                return Pan.callChain(field, operands.fn, operands.operands);
            }
        }, 'fieldEvt': function () {
            if (this.__afterInit) {
                return true;
            }
            var operands = arguments[0];
            if (!Ext.isArray(operands)) {
                operands = [operands];
            }
            for (var i = 0; i < operands.length; i++) {
                var sameEvent = false;
                var operand = operands[i];
                var event = operand.event;
                if (this.__event && event && this.__event.toString && event.toString) {
                    sameEvent = this.__event.toString() == event.toString();
                }
                else {
                    sameEvent = this.__event == event;
                }
                if (sameEvent && (this.__listenFieldName == operand.field || operand.field === undefined)) {
                    return true;
                }
            }
            return false;
        }, 'fieldDataEvt': function () {
            if (!this.__event) {
                return true;
            }
            var rv = this.__scope.map2Function('fieldEvt');
            if (Ext.isObject(rv)) {
                return this.__scope.callFn(rv.fn, arguments, this);
            }
            return false;
        }
    }
});
Ext.ComponentMgr.registerPlugin("association", Pan.base.association.AssociationPlugin);
Ext.ns('Pan.base.avail');
Pan.base.avail.AvailMgr = function () {
    var availTypes = {};
    return {
        availReg: function (type, avail) {
            availTypes[type] = avail;
        }, createAvail: function (config) {
            var avail;
            if (Ext.isArray(config)) {
                avail = [];
                for (var i = 0; i < config.length; i++) {
                    avail.push(Pan.createAvail(config[i]));
                }
            } else {
                var type;
                if (Ext.isString(config)) {
                    type = config;
                    config = undefined;
                } else {
                    type = config.type;
                }
                if (type) {
                    avail = availTypes[type];
                    if (Ext.isFunction(avail)) {
                        avail = avail(config);
                    }
                } else {
                    avail = config;
                }
            }
            return avail;
        }
    };
}();
Pan.availReg = Pan.base.avail.AvailMgr.availReg;
Pan.createAvail = Pan.base.avail.AvailMgr.createAvail;
Pan.base.avail.CheckCountAvail = function (config) {
    var totalCountMethod = config.totalCountMethod;
    if (!Ext.isDefined(totalCountMethod)) {
        totalCountMethod = 'store.getTotalCount';
    }
    var observableCallChain = config.observableCallChain;
    if (!Ext.isDefined(observableCallChain)) {
        observableCallChain = 'store';
    }
    var callChainPrepend = Ext.isDefined(config.callChainPrepend) ? config.callChainPrepend : 'findParentByInstanceof(Ext.grid.GridPanel)';
    if (callChainPrepend) {
        observableCallChain = callChainPrepend + "." + observableCallChain;
        totalCountMethod = callChainPrepend + "." + totalCountMethod;
    }
    var count;
    if (Ext.isDefined(config.count)) {
        if (Ext.isNumber(config.count)) {
            count = config.count;
        } else if (Ext.isString(config.count)) {
            count = {
                evaluate: 'fieldFn', operands: {
                    fn: function (field, operands) {
                        var callChain = callChainPrepend ? (callChainPrepend + "." + config.count) : config.count;
                        var value = Pan.callChain(field, callChain, operands.operands);
                        var operation = config.operation || '<=';
                        field.availDisableReason = Pan.base.association.AssociationPlugin.prototype.getAvailDisableReason(operation, value);
                        return value;
                    }, field: config.field
                }, fallback: Number.MAX_VALUE
            };
        } else {
            count = config.count;
        }
    }
    return Ext.applyIf({
        match: {
            evaluate: '&&',
            operands: [{
                evaluate: config.operation || '<',
                operands: [{
                    evaluate: 'fieldFn',
                    operands: {fn: totalCountMethod, operands: [true], field: config.field},
                    fallback: 0
                }, Ext.isDefined(count) ? count : Number.MAX_VALUE]
            }, {
                evaluate: 'fieldDataEvt',
                operands: [{
                    event: config.event || ['add', 'remove', 'datachanged'],
                    field: config.field,
                    observableCallChain: observableCallChain
                }]
            }]
        }, availHide: Ext.isDefined(config.availHide) ? config.availHide : false
    }, config);
};
Pan.availReg("CheckCountAvail", Pan.base.avail.CheckCountAvail);
Pan.base.avail.HasSelectionAvail = function (config) {
    var hasSelectionMethod = config.hasSelectionMethod;
    if (!Ext.isDefined(hasSelectionMethod)) {
        hasSelectionMethod = 'getSelectionModel.hasSelection';
    }
    var observableCallChain = config.observableCallChain;
    if (!Ext.isDefined(observableCallChain)) {
        observableCallChain = 'getSelectionModel';
    }
    var callChainPrepend = Ext.isDefined(config.callChainPrepend) ? config.callChainPrepend : 'findParentByInstanceof(Ext.grid.GridPanel)';
    if (callChainPrepend) {
        observableCallChain = callChainPrepend + "." + observableCallChain;
        if (Ext.isString(hasSelectionMethod)) {
            hasSelectionMethod = callChainPrepend + "." + hasSelectionMethod;
        }
    }
    var hasSelectionConfig = {};
    if (Ext.isString(hasSelectionMethod)) {
        Ext.applyIf(hasSelectionConfig, {
            evaluate: 'fieldFn',
            operands: {fn: hasSelectionMethod, field: config.field},
            fallback: true
        });
    } else {
        Ext.applyIf(hasSelectionConfig, {evaluate: hasSelectionMethod});
    }
    return Ext.applyIf({
        listenToIfExists: true,
        match: {
            evaluate: '&&',
            operands: [{
                evaluate: '==',
                operands: [hasSelectionConfig, Ext.isDefined(config.hasSelection) ? config.hasSelection : true]
            }, {
                evaluate: 'fieldDataEvt',
                operands: [{
                    event: config.event || ['selectionchange'],
                    field: config.field,
                    observableCallChain: observableCallChain
                }]
            }]
        },
        availHide: Ext.isDefined(config.availHide) ? config.availHide : false
    }, config);
};
Pan.availReg("HasSelectionAvail", Pan.base.avail.HasSelectionAvail);
Pan.base.avail.GetSelectionAvail = function (config) {
    var getSelectionMethod = config.getSelectionMethod;
    if (!Ext.isDefined(getSelectionMethod)) {
        getSelectionMethod = 'getSelectionModel.getCount';
    }
    var observableCallChain = config.observableCallChain;
    if (!Ext.isDefined(observableCallChain)) {
        observableCallChain = 'getSelectionModel';
    }
    var callChainPrepend = Ext.isDefined(config.callChainPrepend) ? config.callChainPrepend : 'findParentByInstanceof(Ext.grid.GridPanel)';
    if (callChainPrepend) {
        observableCallChain = callChainPrepend + "." + observableCallChain;
        getSelectionMethod = callChainPrepend + "." + getSelectionMethod;
    }
    var count;
    if (Ext.isDefined(config.count)) {
        if (Ext.isNumber(config.count)) {
            count = config.count;
        } else if (Ext.isString(config.count)) {
            count = {
                evaluate: 'fieldFn',
                operands: {
                    fn: callChainPrepend ? (callChainPrepend + "." + config.count) : config.count,
                    field: config.field
                },
                fallback: Number.MAX_VALUE
            };
        } else {
            count = config.count;
        }
    }
    return Ext.applyIf({
        listenToIfExists: true,
        match: {
            evaluate: '&&',
            operands: [{
                evaluate: config.operation || '<',
                operands: [{
                    evaluate: 'fieldFn',
                    operands: {fn: getSelectionMethod, field: config.field},
                    fallback: Number.MAX_VALUE
                }, Ext.isDefined(count) ? count : Number.MAX_VALUE]
            }, {
                evaluate: 'fieldDataEvt',
                operands: [{
                    event: config.event || ['selectionchange'],
                    field: config.field,
                    observableCallChain: observableCallChain
                }]
            }]
        },
        availHide: Ext.isDefined(config.availHide) ? config.availHide : false
    }, config);
};
Pan.availReg("GetSelectionAvail", Pan.base.avail.GetSelectionAvail);
Pan.base.avail.CheckCountAndSelectionAvail = function (config) {
    var hasSelectionMethod = config.hasSelectionMethod;
    if (!Ext.isDefined(hasSelectionMethod)) {
        hasSelectionMethod = 'getSelectionModel.hasSelection';
    }
    var totalCountMethod = config.totalCountMethod;
    if (!Ext.isDefined(totalCountMethod)) {
        totalCountMethod = 'store.getTotalCount';
    }
    var observableCallChain = config.observableCallChain;
    if (!Ext.isDefined(observableCallChain)) {
        observableCallChain = 'getSelectionModel';
    }
    var callChainPrepend = Ext.isDefined(config.callChainPrepend) ? config.callChainPrepend : 'findParentByInstanceof(Ext.grid.GridPanel)';
    if (callChainPrepend) {
        observableCallChain = callChainPrepend + "." + observableCallChain;
        if (Ext.isString(hasSelectionMethod)) {
            hasSelectionMethod = callChainPrepend + "." + hasSelectionMethod;
        }
        totalCountMethod = callChainPrepend + "." + totalCountMethod;
    }
    var hasSelectionConfig = {};
    if (Ext.isString(hasSelectionMethod)) {
        Ext.applyIf(hasSelectionConfig, {
            evaluate: 'fieldFn',
            operands: {fn: hasSelectionMethod, field: config.field},
            fallback: true
        });
    } else {
        Ext.applyIf(hasSelectionConfig, {evaluate: hasSelectionMethod});
    }
    var count;
    if (Ext.isDefined(config.count)) {
        if (Ext.isNumber(config.count)) {
            count = config.count;
        } else if (Ext.isString(config.count)) {
            count = {
                evaluate: 'fieldFn',
                operands: {
                    fn: callChainPrepend ? (callChainPrepend + "." + config.count) : config.count,
                    field: config.field
                },
                fallback: Number.MAX_VALUE
            };
        } else {
            count = config.count;
        }
    }
    return Ext.applyIf({
        listenToIfExists: true,
        match: {
            evaluate: '&&',
            operands: [{
                evaluate: '==',
                operands: [hasSelectionConfig, Ext.isDefined(config.hasSelection) ? config.hasSelection : true]
            }, {
                evaluate: config.operation || '<',
                operands: [{
                    evaluate: 'fieldFn',
                    operands: {fn: totalCountMethod, operands: [true], field: config.field},
                    fallback: 0
                }, Ext.isDefined(count) ? count : Number.MAX_VALUE]
            }, {
                evaluate: 'fieldDataEvt',
                operands: [{
                    event: config.event || ['selectionchange'],
                    field: config.field,
                    observableCallChain: observableCallChain
                }]
            }]
        },
        availHide: Ext.isDefined(config.availHide) ? config.availHide : false
    }, config);
};
Pan.availReg("CheckCountAndSelectionAvail", Pan.base.avail.CheckCountAndSelectionAvail);
Pan.base.association.checkBoxAvail = function (path, availHide) {
    return {
        match: {
            evaluate: '&&', operands: [{evaluate: 'fieldEvt', field: path}, {
                evaluate: function () {
                    return this.__component.__pdefaults.__dataExtractor(path);
                }
            }], availHide: availHide
        }
    };
};
Ext.namespace('Pan.base.layout');
Ext.apply(Pan.base.layout, {
    tableFormLayout: function (config) {
        var items = [];
        var args = Array.prototype.slice.call(arguments, 1);
        Ext.each(args, function (item) {
            var formconfig = {
                "xtype": "container",
                "autoEl": "div",
                "layout": "form",
                layoutConfig: {trackLabels: true},
                "items": [item]
            };
            Pan.base.util.selectiveApply(['colspan', 'rowspan'], formconfig, item);
            items.push(formconfig);
        });
        return Ext.apply({"xtype": "container", "autoEl": "div", "layout": 'table', "items": items}, config);
    }, boxFormLayout: function (box) {
        var items = [];
        var args = Array.prototype.slice.call(arguments, 1);
        Ext.each(args, function (item) {
            var formconfig = {
                "xtype": "container",
                "autoEl": "div",
                "layout": "form",
                layoutConfig: {trackLabels: true},
                "items": [item]
            };
            Pan.base.util.selectiveApply(['flex', 'labelWidth'], formconfig, item);
            items.push(formconfig);
        });
        return {"xtype": "container", "autoEl": "div", "layout": box, "items": items};
    }, hboxFormLayout: function () {
        Array.prototype.splice.call(arguments, 0, 0, 'hbox');
        return Pan.base.layout.boxFormLayout.apply(this, arguments);
    }, vboxFormLayout: function () {
        Array.prototype.splice.call(arguments, 0, 0, 'vbox');
        return Pan.base.layout.boxFormLayout.apply(this, arguments);
    }, fieldsetLayout: function (title) {
        return {xtype: "pan-fieldset", autoHeight: true, title: title, items: Array.prototype.slice.call(arguments, 1)};
    }, columnFormLayout: function () {
        var defaultColWidth = 1.0 / arguments.length;
        var config = {layout: 'column', border: false, items: []};
        for (var i = 0; i < arguments.length; i++) {
            var formConfig = arguments[i];
            if (formConfig === null) {
                formConfig = {html: ''};
            }
            var subColConfig = {
                layout: 'form',
                layoutConfig: {trackLabels: true},
                border: false,
                defaults: {anchor: '100%'},
                items: formConfig
            };
            subColConfig.columnWidth = formConfig.columnWidth ? formConfig.columnWidth : defaultColWidth;
            config.items.push(subColConfig);
        }
        return config;
    }
});
Pan.base.layout.TabCardLayout = Ext.extend(Ext.layout.CardLayout, {
    type: 'tabcard', setItemSize: function (item, size) {
        if (item) {
            if (this.container.autoHeight) {
                size = {width: size.width, height: undefined};
            }
            if (size.height > 0) {
                item.setSize(size);
            } else {
                item.setWidth(size.width);
            }
            if (this.activeItem && this.activeItem.syncFloatingShadow) {
                this.activeItem.syncFloatingShadow();
            }
        }
    }, renderAll: function (ct, target) {
        if (this.deferredRender && !this.fastRender && !this.renderAllCt) {
            this.renderAllCt = ct;
            this.renderAllTarget = target;
            ct.addListener('afterrender', function () {
                this.renderAllCt.removeListener('afterrender', arguments.callee, this);
                this.renderAllInactiveItems(this.renderAllCt, this.renderAllTarget);
            }, this, {delay: 50});
        }
        Pan.base.layout.TabCardLayout.superclass.renderAll.apply(this, arguments);
    }, renderAllInactiveItems: function (ct, target) {
        var items = ct.items.items, i, c, len = items.length;
        for (i = 0; i < len; i++) {
            c = items[i];
            if (c && (!c.rendered || !this.isValidParent(c, target))) {
                if (!c.fastRender && (!c.items || (c.items.items.length === 1 && !c.items.items[0].fastRender))) {
                    this.firstTimeRenderItem(c, i, target);
                }
            }
        }
    }, setActiveItem: function (c) {
        if (this.activeItem && this.activeItem.findByType) {
            var grids = this.activeItem.findByType("pan-grid");
            for (var j = 0; j < grids.length; j++) {
                grids[j].stopEditing();
            }
        }
        var ct = this.container;
        c = ct.getComponent(c);
        if (c) {
            if (this.deferredRender && this.fastRender) {
                var i = ct.items.indexOf(c);
                var target = ct.getLayoutTarget();
                if (!c.rendered || !this.isValidParent(c, target)) {
                    this.firstTimeRenderItem(c, i, target);
                }
            }
            var originalLayoutOnCardChange = this.layoutOnCardChange;
            if (c.rendered && this.layoutOnCardChangeFirstTimeOnly && this.layoutOnCardChange === false && c.doLayout && !c.wasLayoutOnCardChange) {
                this.layoutOnCardChange = true;
                c.wasLayoutOnCardChange = true;
            }
            Pan.base.layout.TabCardLayout.superclass.setActiveItem.apply(this, arguments);
            this.layoutOnCardChange = originalLayoutOnCardChange;
        }
    }, firstTimeRenderItem: function (c, i, target) {
        this.renderItem(c, i, target);
        c.doLayout(true, true);
        c.addListener('afterlayout', function () {
            c.removeListener('afterlayout', arguments.callee, this);
            if (c.syncFloatingShadow) {
                c.syncFloatingShadow();
            }
        });
    }
});
Ext.Container.LAYOUTS['tabcard'] = Pan.base.layout.TabCardLayout;
Pan.base.layout.GridLayout = Ext.extend(Ext.layout.TableLayout, {
    monitorResize: true, type: 'grid', defaultAnchor: '100%', getLayoutTargetSize: function () {
        var target = this.container.ownerCt.getLayoutTarget();
        return target ? target.getViewSize() : {};
    }, onLayout: function (container, target) {
        Pan.base.layout.GridLayout.superclass.onLayout.apply(this, arguments);
        var items = this.container.items.items, i, c, len = items.length;
        var doChildResize = true;
        for (i = 0; i < len; i++) {
            c = items[i];
            if (!c.layout || c.layout.type != 'form' || !c.items.items[0].getResizeEl()) {
                doChildResize = false;
                break;
            }
        }
        if (doChildResize) {
            this.setSize(items);
        }
    }, setSize: function (items) {
        var colRow = [], c = 0, i = 0;
        for (c = 0; c < this.columns; c++) {
            colRow[c] = [];
        }
        var hasVflex = [];
        for (i = 0; i < items.length; i++) {
            var rowIndex = items[i].rowIndex;
            var colIndex = items[i].colIndex;
            colRow[colIndex][rowIndex] = items[i];
            if (items[i].vflex) {
                hasVflex[colIndex] = true;
            }
        }
        var allColumnsHaveVflex = true;
        for (c = 0; c < colRow.length; c++) {
            if (!hasVflex[c]) {
                allColumnsHaveVflex = false;
                break;
            }
        }
        var flexCells = [], col, j;
        var maxColumnHeight = 0;
        var useTallestColumn = this.container.ownerCt.useTallestColumn;
        for (c = 0; c < colRow.length; c++) {
            col = colRow[c];
            var beforeFlexHeight = 0;
            var afterFlexHeight = 0;
            var flexObjectHeight = 0;
            var flexRow = undefined;
            for (i = 0; i < col.length; i++) {
                if (col[i]) {
                    var tdheight;
                    var tdheightAdjusted;
                    if (col[i].spanslot) {
                        tdheightAdjusted = tdheight = col[i].tdheight;
                    } else {
                        var itm = col[i].items.items[0];
                        var vmargins = Ext.isNumber(itm.gridLayoutMarginBottomOffset) ? itm.gridLayoutMarginBottomOffset : Pan.base.Constants.gridLayoutMarginBottomOffset;
                        if (col[i].vflex && useTallestColumn) {
                            itm.setHeight("auto");
                        }
                        tdheight = itm.getHeight() + vmargins;
                        tdheightAdjusted = this.adjustHeight(tdheight, itm, col[i]);
                    }
                    if (col[i].vflex) {
                        flexRow = i;
                        if (allColumnsHaveVflex) {
                            flexObjectHeight = tdheightAdjusted;
                        } else {
                            flexObjectHeight = 0;
                        }
                    } else if (Ext.isNumber(flexRow)) {
                        afterFlexHeight += tdheightAdjusted;
                    } else {
                        beforeFlexHeight += tdheightAdjusted;
                    }
                    var colspan = col[i].colspan;
                    if (Ext.isNumber(colspan)) {
                        for (j = c + 1; j < colspan + c; j++) {
                            if (flexRow != undefined && colRow[j][flexRow]) {
                                throw"GridLayout: col: " + j + " row: " + flexRow + " is already occupied";
                            }
                            colRow[j][i] = Ext.apply({spanslot: true}, (flexRow == i ? {
                                vflex: true,
                                flexCell: col[flexRow]
                            } : {tdheight: tdheight}));
                        }
                    }
                }
            }
            if (Ext.isNumber(flexRow)) {
                var flexCell = col[flexRow];
                if (flexCell.flexCell) {
                    flexCell = flexCell.flexCell;
                } else {
                    flexCells.push(flexCell);
                }
                flexCell.beforeFlexHeight = Math.max(flexCell.beforeFlexHeight || 0, beforeFlexHeight);
                flexCell.afterFlexHeight = Math.max(flexCell.afterFlexHeight || 0, afterFlexHeight);
            }
            maxColumnHeight = Math.max(maxColumnHeight, beforeFlexHeight + flexObjectHeight + afterFlexHeight);
        }
        var item, ct, box;
        var s = this.getLayoutTargetSize();
        var width = s.width;
        for (i = 0; i < flexCells.length; i++) {
            ct = flexCells[i];
            item = ct.items.items[0];
            var flexItemMargin = Ext.isNumber(item.gridLayoutMarginBottomOffset) ? item.gridLayoutMarginBottomOffset : Pan.base.Constants.gridLayoutMarginBottomOffset;
            var maxHeight = useTallestColumn ? maxColumnHeight : s.height;
            var flexHeight = maxHeight - flexCells[i].beforeFlexHeight - flexCells[i].afterFlexHeight - flexItemMargin;
            var adjustedWidth = this.adjustWidth(width, item, ct);
            box = this.getAnchorAdjustmentSize(adjustedWidth, undefined, item);
            item.setSize(box.width, flexHeight);
            delete flexCells[i].beforeFlexHeight;
            delete flexCells[i].afterFlexHeight;
        }
        for (c = 0; c < colRow.length; c++) {
            col = colRow[c];
            for (i = 0; i < col.length; i++) {
                if (col[i]) {
                    if (!col[i].vflex) {
                        if (!col[i].spanslot) {
                            ct = col[i];
                            item = ct.items.items[0];
                            var adjWidth = this.adjustWidth(width, item, ct);
                            box = this.getAnchorAdjustmentSize(adjWidth, undefined, item);
                            item.setWidth(box.width);
                        }
                    }
                }
            }
        }
    }, getAnchorAdjustmentSize: function (w, h, c) {
        var el = c.el;
        if (!c.anchor) {
            c.anchor = this.defaultAnchor;
        }
        var a = c.gridLayoutAnchorSpec;
        if (!a) {
            {
                var vs = c.anchor.split(' ');
                c.gridLayoutAnchorSpec = a = {right: this.parseAnchor(vs[0]), bottom: this.parseAnchor(vs[1])};
                c.anchorSpec = {right: false, bottom: false};
            }
        }
        if (a.right) {
            w = a.right(w) || w;
        }
        if (a.bottom) {
            h = a.bottom(h) || h;
        }
        var cw = w ? w - el.getMargins('lr') : undefined;
        var ch = h ? h - el.getMargins('tb') : undefined;
        return {width: cw || undefined, height: ch || undefined};
    }, parseAnchor: function (a) {
        if (a && a != 'none') {
            if (a.indexOf('%') != -1) {
                var ratio = parseFloat(a.replace('%', '')) * 0.01;
                return function (v) {
                    return Math.floor(v * ratio);
                };
            } else {
                a = parseInt(a, 10);
                if (!isNaN(a)) {
                    return function (v) {
                        return v + a;
                    };
                }
            }
        }
        return false;
    }, isHide: function (c) {
        return c.hideLabel || this.container.hideLabels;
    }, adjustWidth: function (value, c, ct) {
        var offset = 0;
        if (c.label && !this.isHide(c) && (ct.labelAlign != 'top')) {
            var labelAdjust = 0;
            var pad = 0;
            var labelWidth = ct.labelWidth || 100;
            if (Ext.isNumber(labelWidth)) {
                pad = Ext.isNumber(ct.labelPad) ? ct.labelPad : 5;
            }
            labelAdjust = labelWidth + pad;
            var adjust = Ext.isIE6 || (Ext.isIE && !Ext.isStrict);
            offset = -labelAdjust + (adjust ? -3 : 0);
        }
        return value / this.columns * (ct.colspan || 1) + offset;
    }, adjustHeight: function (value, c, ct, reduce) {
        if (c.label && !this.isHide(c) && (ct.labelAlign == 'top')) {
            if (reduce) {
                return value - c.label.getHeight();
            } else {
                return value + c.label.getHeight();
            }
        }
        return value;
    }, getNextCell: function (c) {
        var td = Pan.base.layout.GridLayout.superclass.getNextCell.apply(this, arguments);
        td.vAlign = 'top';
        return td;
    }
});
Ext.Container.LAYOUTS['grid'] = Pan.base.layout.GridLayout;
Ext.namespace('Pan.base.container');
Pan.base.container.Container = Ext.extend(Ext.Container, {
    constructor: function (config) {
        this.gridLayoutMarginBottomOffset = 0;
        Pan.base.container.Container.superclass.constructor.apply(this, arguments);
    }, onDisable: function () {
        if (this.rendered) {
            this.el.mask();
        }
        Pan.base.container.Container.superclass.onDisable.call(this);
    }, onEnable: function () {
        if (this.rendered) {
            this.el.unmask();
        }
        Pan.base.container.Container.superclass.onEnable.call(this);
    }
});
Ext.reg('pan-container', Pan.base.container.Container);
Pan.base.container.BoxComponent = Ext.extend(Ext.BoxComponent, {});
Ext.reg('pan-boxcomponent', Pan.base.container.BoxComponent);
Pan.base.container.DataView = Ext.extend(Ext.DataView, {});
Ext.reg('pan-dataview', Pan.base.container.DataView);
Pan.base.container.Panel = Ext.extend(Ext.Panel, {
    createToolbar: function (tb, options) {
        if (this.theme) {
            options = options || {};
            options.cls = options.cls ? this.theme + ' ' + options.cls : this.theme;
        }
        return Pan.base.container.Panel.superclass.createToolbar.call(this, tb, options);
    }
});
Ext.reg('pan-panel', Pan.base.container.Panel);
Pan.base.container.FormPanel = Ext.extend(Ext.form.FormPanel, {
    initComponent: function () {
        if (this.isExplicitTabKeyControl) {
            this.keys = setupExplicitTabKeyControl();
        }
        Pan.base.container.FormPanel.superclass.initComponent.apply(this, arguments);
        this.relayEvents(this.form, ['afterinit']);
    }, createForm: function () {
        var config = Ext.applyIf({formPanel: this, trackResetOnLoad: true, listeners: {}}, this.initialConfig);
        return new Pan.base.container.BasicForm(null, config);
    }, createToolbar: function (tb, options) {
        if (this.theme) {
            options = options || {};
            options.cls = options.cls ? this.theme + ' ' + options.cls : this.theme;
        }
        return Pan.base.container.FormPanel.superclass.createToolbar.call(this, tb, options);
    }
});

function setupExplicitTabKeyControl() {
    var tabKeyConfig = {key: Ext.EventObject.TAB, fn: explicitTabKeyHandler, stopEvent: true};
    var keysConfig = this.keys;
    if (keysConfig) {
        if (!hasTabKeyConfig(keysConfig)) {
            if (Ext.isArray(keysConfig)) {
                keysConfig.push(tabKeyConfig);
            } else if (Ext.isObject(keysConfig)) {
                var originKeyConfig = keysConfig;
                keysConfig = [originKeyConfig, tabKeyConfig];
            }
        }
        return keysConfig;
    }
    return tabKeyConfig;
}

function hasTabKeyConfig(keysConfig) {
    if (Ext.isArray(keysConfig)) {
        for (var i = 0; i < keysConfig.length; i++) {
            if (keysConfig[i].key && keysConfig[i].key === Ext.EventObject.TAB)
                return true;
        }
    } else if (Ext.isObject(keysConfig) && keysConfig.key && keysConfig.key === Ext.EventObject.TAB) {
        return true;
    }
    return false;
}

function explicitTabKeyHandler(key, event) {
    if (event.target.id) {
        var currentField = Ext.getCmp(event.target.id);
        var form = currentField.ownerCt;
        while (form && form.xtype !== 'pan-form' && form.ownerCt) {
            form = form.ownerCt;
        }
        var tabControllableFields = Pan.base.util.getAllChildItems(form, function (item) {
            return !item.hidden;
        });
        if (tabControllableFields.indexOf(currentField) > -1) {
            var currentFieldIndex = tabControllableFields.indexOf(currentField);
            var nextFieldIndex = currentFieldIndex === tabControllableFields.length - 1 ? 0 : currentFieldIndex + 1;
            for (var i = nextFieldIndex; i < tabControllableFields.length; i++) {
                if (i === currentFieldIndex) return false;
                if (!tabControllableFields[i].readOnly && !tabControllableFields[i].disabled) {
                    return tabControllableFields[i].focus();
                }
                if (i === tabControllableFields.length - 1) i = -1;
            }
        }
    }
}

Ext.reg('pan-form', Pan.base.container.FormPanel);
Pan.base.container.BasicForm = Ext.extend(Ext.form.BasicForm, {
    constructor: function (el, config) {
        Pan.base.container.BasicForm.superclass.constructor.apply(this, arguments);
        this.addEvents('afterinit');
    }, fireAfterInit: function () {
        if (this.isRecordLoaded) {
            this.formPanel.afterinitCompleted = true;
            this.fireEvent('afterinit', this);
        } else {
            this.readyToFireAfterInit = true;
        }
    }, loadRecord: function (record) {
        var rv = Pan.base.container.BasicForm.superclass.loadRecord.apply(this, arguments);
        this.isRecordLoaded = true;
        if (this.readyToFireAfterInit) {
            this.fireAfterInit();
        }
        return rv;
    }
});
Pan.base.container.TabPanel = Pan.base.util.cextend(Ext.ux.ButtonTabPanel, "isButtonTabPanel", {
    plain: true,
    frame: true,
    stateful: false,
    extraComponentConfig: undefined,
    deferredRender: false,
    fastRender: false,
    itemTpl: new Ext.XTemplate('<li class="{cls}" id="{id}">', '<tpl if="closable">', '<a class="x-tab-strip-close"></a>', '</tpl>', '<a class="x-tab-right" href="#">', '<em class="x-tab-left">', '<span class="x-tab-strip-inner {iconCls}">', '<tpl if="iconCls">', '<span class="x-tab-strip-icon"></span>', '</tpl>', '<span class="x-tab-strip-text">{text}</span>', '</span>', '</em>', '</a>', '</li>'),
    getTemplateArgs: function (item) {
        var result = Pan.base.container.TabPanel.superclass.getTemplateArgs.call(this, item);
        return Ext.applyIf(result, {closable: Ext.isDefined(item.closable) ? item.closable : false});
    },
    findTargets: function (e) {
        var rv = Pan.base.container.TabPanel.superclass.findTargets.apply(this, arguments);
        return Ext.applyIf({itemIcon: e.getTarget(".x-tab-strip-icon", this.strip)}, rv);
    },
    onStripMouseDown: function (e) {
        if (e.button !== 0) {
            return;
        }
        Pan.base.container.TabPanel.superclass.onStripMouseDown.apply(this, arguments);
        var t = this.findTargets(e);
        if (t.itemIcon) {
            t.item.fireEvent('itemiconclicked', t.item);
        }
    },
    initComponent: function () {
        Pan.base.container.TabPanel.superclass.initComponent.call(this);
        this.setLayout(new Pan.base.layout.TabCardLayout(Ext.apply({
            layoutOnCardChange: this.layoutOnTabChange,
            deferredRender: this.deferredRender,
            fastRender: this.fastRender
        }, this.layoutConfig)));
    },
    initTab: function (item, index) {
        Pan.base.container.TabPanel.superclass.initTab.apply(this, arguments);
        Ext.apply(item, {__tabIndex: index});
    },
    setInvalidMarking: function (tab, required) {
        var cssClass = 'x-form-invalid';
        if (required) {
            cssClass = 'x-form-required';
        }
        var tabEl = this.getTabEl(tab);
        if (tabEl) {
            Ext.get(tabEl).child('span.x-tab-strip-text').addClass(cssClass);
        }
    },
    clearInvalidMarking: function (tab) {
        var tabEl = this.getTabEl(tab);
        if (tabEl) {
            Ext.get(tabEl).child('span.x-tab-strip-text').removeClass('x-form-required');
            Ext.get(tabEl).child('span.x-tab-strip-text').removeClass('x-form-invalid');
        }
    },
    resetValidationMarking: function () {
        this.items.each(this.clearInvalidMarking, this);
    },
    getStateId: function () {
        var stateId = this.stateId || this.itemId || this.name;
        if (stateId) {
            return stateId;
        }
        return Pan.base.container.TabPanel.superclass.getStateId.call(this);
    },
    getState: function () {
        var o = {};
        o.activeTab = this.activeTab.__tabIndex;
        return o;
    },
    onRender: function (ct, position) {
        Pan.base.container.TabPanel.superclass.onRender.apply(this, arguments);
        if (this.extraComponentConfig) {
            this.extraComponentConfig = Ext.apply({width: 150, height: 35}, this.extraComponentConfig);
            var st = this[this.stripTarget];
            var extraComponentEl = st.insertSibling({
                tag: "div",
                style: "position: relative; z-index: 10; float: right; margin-top: -" + this.extraComponentConfig.height + "px; width: " + this.extraComponentConfig.width + "px;"
            }, 'after');
            Ext.create(Ext.apply({renderTo: extraComponentEl}, this.extraComponentConfig));
            extraComponentEl.insertSibling({tag: "div", style: "clear: right;"}, 'after');
        }
    },
    autoScrollTabs: function () {
        this.pos = this.tabPosition == 'bottom' ? this.footer : this.header;
        var count = this.items.length, ow = this.pos.dom.offsetWidth, tw = this.pos.dom.clientWidth,
            wrap = this.stripWrap, wd = wrap.dom, cw = wd.offsetWidth, pos = this.getScrollPos(),
            l = this.edge.getOffsetsTo(this.stripWrap)[0] + pos;
        if (Pan.base.json.path(this, "$.extraComponentConfig.width")) {
            l += this.extraComponentConfig.width;
        }
        if (!this.enableTabScroll || count < 1 || cw < 20) {
            return;
        }
        if (l <= tw) {
            wd.scrollLeft = 0;
            wrap.setWidth(tw);
            if (this.scrolling) {
                this.scrolling = false;
                this.pos.removeClass('x-tab-scrolling');
                this.scrollLeft.hide();
                this.scrollRight.hide();
                if (Ext.isAir || Ext.isWebKit) {
                    wd.style.marginLeft = '';
                    wd.style.marginRight = '';
                }
            }
        } else {
            if (!this.scrolling) {
                this.pos.addClass('x-tab-scrolling');
                if (Ext.isAir || Ext.isWebKit) {
                    wd.style.marginLeft = '18px';
                    wd.style.marginRight = '18px';
                }
            }
            tw -= wrap.getMargins('lr');
            wrap.setWidth(tw > 20 ? tw : 20);
            if (!this.scrolling) {
                if (!this.scrollLeft) {
                    this.createScrollers();
                } else {
                    this.scrollLeft.show();
                    this.scrollRight.show();
                }
            }
            this.scrolling = true;
            if (pos > (l - tw)) {
                wd.scrollLeft = l - tw;
            } else {
                this.scrollToTab(this.activeTab, false);
            }
            this.updateScrollButtons();
        }
    },
    createScrollers: function () {
        Pan.base.container.TabPanel.superclass.createScrollers.apply(this, arguments);
        if (this.extraComponentConfig) {
            this.scrollRight.setStyle("right", this.extraComponentConfig.width + "px");
        }
    },
    getScrollArea: function () {
        return Pan.base.container.TabPanel.superclass.getScrollArea.apply(this, arguments) - (this.extraComponentConfig ? this.extraComponentConfig.width : 0);
    }
});
Ext.reg('pan-tabpanel', Pan.base.container.TabPanel);
Pan.base.container.CardLayoutPanel = Ext.extend(Ext.Panel, {
    normalizeItems: function (items, html) {
        items = items || [];
        items.push({html: html || this.html || '', id: ''});
        return items;
    }, constructor: function (config) {
        Ext.apply(config, {layout: 'card', activeItem: -1, items: this.normalizeItems(config.items, config.html)});
        Pan.base.container.CardLayoutPanel.superclass.constructor.call(this, config);
    }, setItems: function (items) {
        this.removeAll();
        this.add(this.normalizeItems(items));
        this.doLayout();
    }, setEmptyItem: function () {
        var idx = this.items.length - 1;
        var l = this.getLayout();
        l.setActiveItem(idx);
    }
});
Ext.reg('pan-card-panel', Pan.base.container.CardLayoutPanel);
Pan.base.container.Window = Ext.extend(Ext.Window, {
    showHelp: undefined,
    shadow: 'frame',
    shadowOffset: 6,
    stateful: true,
    constrainHeader: true,
    closable: false,
    showLoadingIndication: true,
    maximizationPadding: [20, 20],
    width: Pan.base.Constants.minWindowWidth,
    minWidth: Pan.base.Constants.minWindowWidth,
    additionalTools: undefined,
    animationDuration: 0.5,
    initComponent: function () {
        var log = PanLogging.getLogger('base:container:Window');
        if (!Ext.isDefined(this.defaultButton) && Ext.isArray(this.buttons)) {
            for (var i = 0; i < this.buttons.length; i++) {
                var btn = this.buttons[i];
                if (Ext.isObject(btn) && btn.isDefaultButton) {
                    this.defaultButton = i;
                    if (!btn.cls) {
                        btn.cls = 'default-btn';
                    }
                    break;
                }
            }
        }
        Ext.apply(this, {stateId: this.itemId || this.name});
        if (!Ext.isEmpty(this.items)) {
            var winItems = !Ext.isArray(this.items) ? this.items : this.items[0];
            if (winItems.xtype == "pan-form" || winItems.xtype == "form" || winItems.form) {
                winItems.cls = winItems.cls || Pan.base.Constants.formThemes[0];
            }
            Ext.apply(winItems, {cls: winItems.cls || "darkblue-container"});
        }
        if (this.initialConfig && Ext.isDefined(this.initialConfig.width) && !Ext.isDefined(this.initialConfig.minwidth)) {
            this.minWidth = this.initialConfig.width;
        }
        Ext.apply(this, {minWidth: Math.max(this.minWidth, Pan.base.Constants.minWindowWidth)});
        Ext.apply(this, {width: Math.max(this.width, Pan.base.Constants.minWindowWidth)});
        Pan.base.container.Window.superclass.initComponent.call(this);
        if (this.width > Pan.base.Constants.maxWindowWidth || this.height > Pan.base.Constants.maxWindowHeight) {
            log.info("Maximum size limits exceeded:  " + this.width + "x" + this.height);
        }
    },
    onResize: function (adjWidth, adjHeight, rawWidth, rawHeight) {
        var rv = Pan.base.container.Window.superclass.onResize.apply(this, arguments);
        if (Ext.isDefined(this.boxMinWidth)) {
            if (this.getWidth() < this.boxMinWidth) {
                var autoWidth = this.autoWidth;
                this.autoWidth = false;
                this.setWidth(this.boxMinWidth);
                this.autoWidth = autoWidth;
            }
        }
    },
    initEvents: function () {
        Pan.base.container.Window.superclass.initEvents.apply(this, arguments);
        if (!this.closable) {
            var km = this.getKeyMap();
            km.on(27, this.onEsc, this);
            km.disable();
        }
    },
    applyState: function (state) {
        if (state) {
            var minWidth = this.minWidth;
            if (minWidth === Pan.base.Constants.minWindowWidth && this.width > minWidth) {
                minWidth = this.width;
            }
            if (state.width < minWidth) {
                state.width = minWidth;
            }
            if (state.height < this.minHeight) {
                state.height = this.minHeight;
            }
        }
        Pan.base.container.Window.superclass.applyState.apply(this, arguments);
    },
    getState: function () {
        return Ext.apply(Ext.Window.superclass.getState.call(this) || {}, this.getSize());
    },
    initTools: function () {
        if (this.showLoadingIndication) {
            this.initLoadingIndication();
        }
        if (this.showHelp) {
            this.addTool({
                id: 'help',
                qtip: Pan.base.htmlEncode(_T('Help')),
                handler: this.showHelp.createDelegate(this, [this.helpTopic])
            });
        }
        if (this.additionalTools) {
            if (Ext.isArray(this.additionalTools)) {
                Ext.each(this.additionalTools, function (tool) {
                    this.addTool(tool);
                }, this);
            } else {
                this.addTool(this.additionalTools);
            }
        }
        Pan.base.container.Window.superclass.initTools.apply(this, arguments);
    },
    fitContainer: function () {
        this.setPosition(0 + this.maximizationPadding[1], 0 + this.maximizationPadding[0]);
        var vs = this.container.getViewSize(false);
        this.setSize(vs.width - 2 * this.maximizationPadding[1], vs.height - 2 * this.maximizationPadding[0]);
    },
    alignTo: function (element, position, offsets) {
        var log = PanLogging.getLogger('base:container:Window');
        var rv = this;
        try {
            rv = Pan.base.container.Window.superclass.alignTo.apply(this, arguments);
        } catch (err) {
            log.error(err);
        }
        return rv;
    },
    close: function () {
        if (this.fireEvent('beforeclose', this) !== false) {
            if (this.hidden) {
                this.doClose();
            } else {
                this.hide(this.animateTarget, this.doClose, this);
            }
        }
    },
    syncShadow: function () {
        Pan.base.container.Window.superclass.syncShadow.apply(this, arguments);
        Pan.base.util.invokeLater(200, function () {
            this.doHeaderContrain();
            Pan.base.container.Window.superclass.syncShadow.apply(this, arguments);
        }, this, arguments);
    },
    doHeaderContrain: function () {
        var offsets = {bottom: this.el.shadowOffset};
        var wb = this.getBox();
        var xy = this.el.getConstrainToXY(this.container, true, offsets);
        if (xy && xy[1] < wb.y) {
            this.setPosition(wb.x, xy[1]);
        }
        var docBody = document.documentElement || document.body;
        if (docBody) {
            var docBodyWidth = Ext.fly(docBody).getWidth();
            if (docBodyWidth < wb.width) {
                var minWidth = this.minWidth;
                if (minWidth === Pan.base.Constants.minWindowWidth && this.width > minWidth) {
                    minWidth = this.width;
                }
                if (docBodyWidth >= minWidth) {
                    this.setWidth(docBodyWidth);
                }
            }
        }
    },
    center: function () {
        var xy = this.el.getAlignToXY(this.container, 'c-c');
        if (xy[0] < 0) {
            xy[0] = 0;
        }
        if (xy[1] < 0) {
            xy[1] = 0;
        }
        this.setPagePosition(xy[0], xy[1]);
        return this;
    },
    unghost: function (show, matchPosition) {
        if (!this.activeGhost) {
            return;
        }
        if (this.el.dom) {
            if (show !== false) {
                this.el.show();
                this.focus.defer(10, this);
                if (Ext.isMac && Ext.isGecko2) {
                    this.cascade(this.setAutoScroll);
                }
            }
            if (matchPosition !== false) {
                this.setPosition(this.activeGhost.getLeft(true), this.activeGhost.getTop(true));
            }
        }
        this.activeGhost.hide();
        this.activeGhost.remove();
        delete this.activeGhost;
    },
    show: function () {
        var rv = Pan.base.container.Window.superclass.show.apply(this, arguments);
        Ext.menu.MenuMgr.hideAll();
        return rv;
    },
    animShow: function () {
        this.proxy.show();
        this.proxy.setBox(this.animateTarget.getBox());
        this.proxy.setOpacity(0);
        var b = this.getBox();
        this.el.setStyle('display', 'none');
        this.proxy.shift(Ext.apply(b, {
            callback: this.afterShow.createDelegate(this, [true], false),
            scope: this,
            easing: 'easeNone',
            duration: this.animationDuration,
            opacity: 0.5
        }));
    },
    animHide: function () {
        this.proxy.setOpacity(0.5);
        this.proxy.show();
        var tb = this.getBox(false);
        this.proxy.setBox(tb);
        this.el.hide();
        this.proxy.shift(Ext.apply(this.animateTarget.getBox(), {
            callback: this.afterHide,
            scope: this,
            duration: this.animationDuration,
            easing: 'easeNone',
            opacity: 0
        }));
    }
});
Ext.reg('pan-window', Pan.base.container.Window);
Pan.base.container.Drawer = Ext.extend(drawer, {
    resizable: true, cls: 'x-pan-drawer', setAlignments: function () {
        switch (this.side) {
            case's-s':
                this.setWidth(this.win.el.getWidth() - 10);
                this.alignToParams = Ext.apply(this.alignToParams, {
                    alignTo: 'bl-bl',
                    alignToXY: [5, (Ext.isIE6) ? -2 : -7],
                    slideDirection: 't'
                });
                break;
            default:
                Pan.base.container.Drawer.superclass.setAlignments.apply(this, arguments);
                break;
        }
    }
});
Ext.reg('pan-drawer', Pan.base.container.Drawer);
Pan.base.container.EditorPanel = Ext.extend(Pan.base.container.Panel, {
    monitorValid: false,
    monitorPoll: 200,
    layout: 'fit',
    border: false,
    hideBorders: true,
    cls: 'editor-panel x-ignore-key-enter',
    constructor: function () {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.container.EditorPanel.superclass.constructor.apply(this, arguments);
    },
    initComponent: function () {
        this.addEvents('clientvalidation', 'afterinit');
        Pan.base.container.EditorPanel.superclass.initComponent.apply(this, arguments);
    },
    initEvents: function () {
        Pan.base.container.EditorPanel.superclass.initEvents.call(this);
        if (this.monitorValid) {
            this.startMonitoring();
        }
        this.afterinitCompleted = true;
        this.fireEvent('afterinit', this);
    },
    initEditor: function () {
        if (this.items.itemAt(0).initEditor) {
            this.items.itemAt(0).initEditor.apply(this.items.itemAt(0), arguments);
        }
    },
    setValue: function (value) {
        this.items.itemAt(0).setValue(value);
    },
    getValue: function () {
        return this.items.itemAt(0).getValue();
    },
    isValid: function () {
        var valid = true;
        var child = this.items.itemAt(0);
        if (child.isValid && !child.isValid()) {
            valid = false;
        }
        return valid;
    },
    validate: function () {
        return true;
    },
    markInvalid: function (msg) {
    },
    clearInvalid: function () {
    },
    getErrors: function (value) {
        var child = this.items.itemAt(0);
        var errors = [];
        if (child && child.getErrors && !(child.store)) {
            errors = child.getErrors();
        }
        return errors;
    },
    reset: function () {
        var child = this.items.itemAt(0);
        if (child.reset) {
            child.reset();
        }
    },
    startMonitoring: function () {
        if (!this.validTask) {
            this.validTask = new Ext.util.TaskRunner();
            this.validTask.start({run: this.bindHandler, interval: this.monitorPoll || 200, scope: this});
        }
    },
    stopMonitoring: function () {
        if (this.validTask) {
            this.validTask.stopAll();
            this.validTask = null;
        }
    },
    bindHandler: function () {
        var valid = this.isValid();
        if (this.fbar) {
            var fitems = this.fbar.items.items;
            for (var i = 0, len = fitems.length; i < len; i++) {
                var btn = fitems[i];
                if (btn.formBind === true && btn.disabled === valid) {
                    btn.setDisabled(!valid);
                }
            }
        }
        this.fireEvent('clientvalidation', this, valid);
    },
    beforeDestroy: function () {
        this.stopMonitoring();
        Pan.base.container.EditorPanel.superclass.beforeDestroy.call(this);
    }
});
Ext.reg('pan-editorpanel', Pan.base.container.EditorPanel);
Pan.base.container.EditorPanelMgr = function () {
    var editorPanels, active, attached = false, lastShow = new Date();

    function init() {
        editorPanels = {};
        active = new Ext.util.MixedCollection();
        Ext.getDoc().addKeyListener(27, function () {
            if (active.length > 0) {
                hideAll();
            }
        });
    }

    function hideAll(e) {
        if (active && active.length > 0) {
            var c = active.clone();
            c.each(function (m) {
                if (e) {
                    var grid = m.gridEditor.__grid;
                    if (grid.activeEditor) {
                        if (grid.isInActiveEditor(e)) {
                            return;
                        }
                    }
                }
                m.gridEditor.onBlur();
            });
            return true;
        }
        return false;
    }

    function onHide(m) {
        active.remove(m);
        if (active.length < 1) {
            Ext.getDoc().un("mousedown", onMouseDown);
            attached = false;
        }
    }

    function onShow(m) {
        var last = active.last();
        lastShow = new Date();
        active.add(m);
        if (!attached) {
            Ext.getDoc().on("mousedown", onMouseDown);
            attached = true;
        }
    }

    function onMouseDown(e) {
        if (lastShow.getElapsed() > 50 && active.length > 0 && !e.getTarget(".x-combo-list")) {
            hideAll(e);
        }
    }

    return {
        hideAll: function () {
            return hideAll();
        }, register: function (editorPanel) {
            if (!editorPanels) {
                init();
            }
            editorPanels[editorPanel.id] = editorPanel;
            editorPanel.on({show: onShow});
        }, unregister: function (editorPanel) {
            delete editorPanels[editorPanel.id];
            onHide(editorPanel);
            editorPanel.un("show", onShow);
        }
    };
}();
Pan.base.container.VrTabPanel = Ext.extend(Ext.ux.VrTabPanel, {
    plain: true, frame: true, deferredRender: false, fastRender: false, initComponent: function () {
        Pan.base.container.VrTabPanel.superclass.initComponent.call(this);
        this.setLayout(new Pan.base.layout.TabCardLayout(Ext.apply({
            layoutOnCardChange: this.layoutOnTabChange,
            deferredRender: this.deferredRender,
            fastRender: this.fastRender
        }, this.layoutConfig)));
    }, setActiveTab: function (item) {
        var rv = Pan.base.container.VrTabPanel.superclass.setActiveTab.apply(this, arguments);
        this.syncFloatingShadow();
        return rv;
    }, setInvalidMarking: function (tab, required) {
        var cssClass = 'x-form-invalid';
        if (required) {
            cssClass = 'x-form-required';
        }
        var tabEl = this.getTabEl(tab);
        if (tabEl) {
            Ext.get(tabEl).child('span.x-tab-strip-text').addClass(cssClass);
        }
    }, clearInvalidMarking: function (tab) {
        var tabEl = this.getTabEl(tab);
        if (tabEl) {
            Ext.get(tabEl).child('span.x-tab-strip-text').removeClass('x-form-required');
            Ext.get(tabEl).child('span.x-tab-strip-text').removeClass('x-form-invalid');
        }
    }, resetValidationMarking: function () {
        this.items.each(this.clearInvalidMarking, this);
    }
});
Ext.reg('pan-vrtabpanel', Pan.base.container.VrTabPanel);
Pan.base.container.CardContainer = Ext.extend(Pan.base.container.Container, {
    deferredCreate: true, initComponent: function () {
        this.defaults = this.defaults || {};
        Ext.applyIf(this.defaults, {formLabelWidth: this.formLabelWidth});
        if (this.deferredCreate) {
            if (!this.layout) {
                this.layout = 'fit';
            }
            this.firstTimeActivate = true;
        }
        Pan.base.container.CardContainer.superclass.initComponent.apply(this, arguments);
    }, createComponent: function (config, defaultType) {
        if (this.deferredCreate && this.firstTimeActivate && !this.itemConfig && !config.render) {
            this.itemConfig = config;
            return undefined;
        }
        return Pan.base.container.CardContainer.superclass.createComponent.apply(this, arguments);
    }, onBeforeAdd: function (item) {
        if (this.deferredCreate && !Ext.isDefined(item)) {
            return false;
        }
        return Pan.base.container.CardContainer.superclass.onBeforeAdd.apply(this, arguments);
    }, afterFirstActivate: function () {
        if (this.firstTimeActivate) {
            this.firstTimeActivate = false;
            if (this.itemConfig) {
                var item;
                var itemConfig = this.itemConfig;
                if (itemConfig.treePath && !itemConfig.render) {
                    item = Pan.create(itemConfig);
                } else if (!itemConfig.render) {
                    item = Ext.create(itemConfig);
                } else {
                    item = itemConfig;
                }
                this.add(item);
                if (this.__pdefaults && this.__pdefaults.__recordFormRecord) {
                    this.loadValues(this.__pdefaults.__recordFormRecord.data);
                }
                this.doLayout();
                this.doLayout();
            }
        }
    }, loadValues: function (values) {
        var field, id;
        for (id in values) {
            if (!Ext.isFunction(values[id]) && (field = this.findByItemId(id))) {
                if (Ext.FormPanel.prototype.isField(field)) {
                    var value = values[id];
                    if (Ext.isEmpty(value)) {
                        if (Ext.isDefined(field.value)) {
                            value = field.value;
                        }
                    }
                    field.setValue(value);
                    if (this.trackResetOnLoad) {
                        field.originalValue = field.getValue();
                    }
                    field.initValueChanged();
                }
            }
        }
    }, fireEvent: function (event) {
        if (this.deferredCreate && event === 'activate') {
            this.afterFirstActivate();
        }
        Pan.base.container.CardContainer.superclass.fireEvent.apply(this, arguments);
    }
});
Ext.reg('pan-cardcontainer', Pan.base.container.CardContainer);
Pan.base.container.FirstLevelTabPanel = Ext.extend(Pan.base.container.TabPanel, {
    cls: 'firstlevel',
    stateful: true,
    stateEvents: ['tabchange'],
    helpRootPath: undefined,
    getHelpTopic: function () {
        return this.getActiveTab().helpTopic;
    },
    getHelpRootPath: function () {
        return this.helpRootPath;
    }
});
Ext.reg('firstleveltabpanel', Pan.base.container.FirstLevelTabPanel);
Pan.base.container.ButtonTabPanel = Ext.extend(Ext.ux.ButtonTabPanel, {
    plain: true,
    frame: true,
    stateful: false,
    onRender: function (ct, position) {
        Ext.ux.ButtonTabPanel.superclass.onRender.apply(this, arguments);
        var buttons = this.button;
        for (var x = 0; x < buttons.length; x++) {
            var obj = {};
            obj['tag'] = 'li';
            obj['class'] = 'buttontab';
            var butEl = this.edge.insertSibling(obj);
            new Ext.Button(Ext.apply({renderTo: butEl}, this.button[x]));
        }
    }
});
Ext.reg('pan-buttontabpanel', Pan.base.container.ButtonTabPanel);
Pan.base.container.Explorer = Ext.extend(Pan.base.container.Container, {
    ADD_ENTRY_TITLE: "+", initComponent: function () {
        var data = [];
        this.cardItems = this.cardItems.slice(0);
        this.cardItems.push({title: this.ADD_ENTRY_TITLE, xtype: 'pan-container'});
        var record = this.__pdefaults.__recordForm.getRecord();
        var fields = this.__pdefaults.__fields;
        for (var i = 0; i < this.itemIds.length; i++) {
            var hasData = this.hasData(record, fields.get(this.itemIds[i]));
            data.push({title: this.cardItems[i].title, index: i, visible: hasData || i === 0, itemId: this.itemIds[i]});
        }
        data.push({title: this.ADD_ENTRY_TITLE, index: this.itemIds.length, visible: true});
        Ext.applyIf(this, {
            layout: 'border', style: 'background-color: transparent', items: [{
                xtype: 'pan-grid',
                itemId: 'selectionPanel',
                region: 'west',
                collapseMode: 'mini',
                split: true,
                width: 150,
                border: false,
                stripeRows: false,
                layout: 'fit',
                cls: 'x-explorer-selection-panel',
                supportFastRender: false,
                hideHeaders: true,
                hasGridFilter: false,
                singleSelect: true,
                ADD_ENTRY_TITLE: this.ADD_ENTRY_TITLE,
                supportsColumnActions: function (rowIndex, columnIndex, e) {
                    var record = this.store.getAt(rowIndex);
                    var title = record.get("title");
                    if (title === this.ADD_ENTRY_TITLE || record.get("index") == 0) {
                        return false;
                    }
                    return Pan.base.grid.GridPanel.prototype.supportsColumnActions.apply(this, arguments);
                },
                store: {
                    ztype: Pan.base.autorender.GridRecordStore,
                    zconfig: {
                        localStore: true,
                        idProperty: 'title',
                        fields: [{
                            name: 'index',
                            uiHint: {columnConfig: {hidden: true, hideable: false}}
                        }, {name: 'visible', uiHint: {columnConfig: {hidden: true, hideable: false}}}, {
                            name: 'itemId',
                            uiHint: {columnConfig: {hidden: true, hideable: false}}
                        }, {
                            name: 'title',
                            uiHint: {
                                columnConfig: {
                                    columnActionsMode: 'button',
                                    columnActions: [{
                                        iconCls: 'x-tab-close',
                                        useMiniCellSelection: true,
                                        handler: function (grid, config, event) {
                                            var scope = config.action.scope;
                                            var record = config.record;
                                            record.set("visible", false);
                                            scope.filterSelections();
                                            scope.selectFirstRecord();
                                            var field = scope.__pdefaults.__fields.get(config.record.get("itemId"));
                                            scope.markSkipSaveField(scope.__pdefaults.__recordForm.editRecord, field, true);
                                        },
                                        scope: this
                                    }]
                                }
                            }
                        }],
                        data: data
                    }
                }
            }, {
                xtype: 'pan-panel',
                padding: 8,
                itemId: 'contentPanel',
                region: 'center',
                layout: 'card',
                items: this.cardItems,
                activeItem: Ext.isDefined(this.activeItem) ? this.activeItem : 0,
                scope: this,
                setInvalidMarking: function (tab, required) {
                    var grid = this.scope.getSelectionPanel();
                    var store = grid.store;
                    var title = tab.title;
                    var index = store.indexOfId(title);
                    if (index >= 0) {
                        store.getAt(index).error = {"title": ""};
                        grid.view.refresh();
                    }
                },
                resetValidationMarking: function (tab) {
                    var grid = this.scope.getSelectionPanel();
                    var store = grid.store;
                    var hadError = false;
                    store.each(function (r) {
                        if (r.error) {
                            hadError = true;
                        }
                        delete r.error;
                    }, this);
                    if (hadError) {
                        grid.view.refresh();
                    }
                }
            }]
        });
        delete this.activeItem;
        Pan.base.container.Explorer.superclass.initComponent.apply(this, arguments);
        this.getSelectionPanel().getSelectionModel().handleMouseDown = Pan.base.util.createExtension(this.handleMouseDown, this.getSelectionPanel().getSelectionModel().handleMouseDown, this);
        this.filterSelections();
        Pan.base.util.invokeLater(1, this.selectFirstRecord, this, []);
    }, handleMouseDown: function (grid, rowIndex, e) {
        if (e.button !== 0) {
            return;
        }
        var store = grid.store;
        var record = store.getAt(rowIndex);
        var t = record.get("title");
        var index = record.get("index");
        if (t === this.ADD_ENTRY_TITLE) {
            var menu = [];
            for (var i = 0; i < this.itemIds.length; i++) {
                var title = this.cardItems[i].title;
                if (store.indexOfId(title) < 0) {
                    menu.push({
                        text: title, index: i, xtype: 'menuitem', scope: this, handler: function (menu, event) {
                            var record = this.getSelectionPanel().store.getById(menu.text);
                            record.set("visible", true);
                            this.filterSelections();
                            this.selectRecord(record);
                            var field = this.__pdefaults.__fields.get(record.get("itemId"));
                            this.markSkipSaveField(this.__pdefaults.__recordForm.editRecord, field, false);
                        }
                    });
                }
            }
            if (menu.length > 0) {
                this.addEntryMenu = Ext.create({xtype: 'menu', cls: 'blue', items: menu});
                this.addEntryMenu.render();
                var xy = this.addEntryMenu.el.getAlignToXY(Ext.fly(grid.el.select(".x-grid3-row-last").elements[0]), "tl-bl");
                this.addEntryMenu.showAt(xy);
            }
        } else {
            this.selectRecord(record);
            arguments.callee.superFunction.apply(this.getSelectionPanel().getSelectionModel(), arguments);
        }
    }, selectFirstRecord: function () {
        var firstRecord = this.getSelectionPanel().store.getAt(0);
        if (firstRecord && firstRecord.get("title") !== this.ADD_ENTRY_TITLE) {
            this.selectRecord(firstRecord);
        } else {
            this.findByItemId("contentPanel").getLayout().setActiveItem(this.cardItems.length - 1);
        }
    }, getSelectionPanel: function () {
        return this.findByItemId("selectionPanel");
    }, hasData: function (record, field) {
        var value = record.get(field.name);
        if (value !== "" && value !== undefined && record.json) {
            if (field.accessor(record.json) !== undefined) {
                return true;
            }
        }
        if (field && field.children) {
            for (var i = 0; i < field.children.length; i++) {
                if (this.hasData(record, field.children[i])) {
                    return true;
                }
            }
        }
        return false;
    }, markSkipSaveField: function (record, field, skip) {
        record.__skipSaveFields = record.__skipSaveFields || new Ext.util.MixedCollection();
        this.markSkipSaveFieldImp(record.__skipSaveFields, field, skip);
    }, markSkipSaveFieldImp: function (skipSaveFields, field, skip) {
        if (skip) {
            if (!skipSaveFields.containsKey(field.name)) {
                skipSaveFields.add(field.name, field.attrPath);
            }
        } else {
            if (skipSaveFields.containsKey(field.name)) {
                skipSaveFields.removeKey(field.name);
            }
        }
        if (field && field.children) {
            for (var i = 0; i < field.children.length; i++) {
                this.markSkipSaveFieldImp(skipSaveFields, field.children[i], skip);
            }
        }
    }, selectRecord: function (record) {
        var index = record.get("index");
        this.findByItemId("contentPanel").getLayout().setActiveItem(index);
        this.getSelectionPanel().getSelectionModel().selectRecords([record]);
    }, filterSelections: function () {
        var selectionPanel = this.getSelectionPanel();
        var store = selectionPanel.store;
        store.filterBy(this.selectionEntryFilter, this);
        this.setVisibilityForAddEntry();
    }, selectionEntryFilter: function (r) {
        return r.get("visible");
    }, setVisibilityForAddEntry: function () {
        var selectionPanel = this.getSelectionPanel();
        var store = selectionPanel.store;
        var r = store.getById(this.ADD_ENTRY_TITLE);
        var currentlyVisible = r.get("visible");
        var futureVisible = store.snapshot.length > store.data.length + (currentlyVisible ? 0 : 1);
        if (futureVisible !== currentlyVisible) {
            r.set("visible", futureVisible);
            store.filterBy(this.selectionEntryFilter, this);
        }
    }
});
Ext.reg('pan-explorer', Pan.base.container.Explorer);
Pan.base.container.Carousel = Ext.extend(Pan.base.container.Container, {
    initComponent: function () {
        this.addEvents('activate');
        this.navigateLeft = this.navigate.createDelegate(this, [-1]);
        this.navigateRight = this.navigate.createDelegate(this, [1]);
        Ext.apply(this, {
            sequence: 0,
            cls: 'x-carousel',
            layout: 'border',
            items: [{
                xtype: 'pan-button',
                iconCls: 'icon-left-btn',
                text: '',
                disabled: true,
                region: 'west',
                itemId: 'leftButton',
                handler: this.navigateLeft
            }, {
                xtype: 'pan-panel',
                region: 'center',
                border: false,
                layout: 'card',
                itemId: 'content',
                activeItem: 0,
                bbar: {itemId: 'circleBar', buttonAlign: 'center', internalDefaults: {}}
            }, {
                xtype: 'pan-button',
                iconCls: 'icon-right-btn',
                text: '',
                disabled: true,
                region: 'east',
                itemId: 'rightButton',
                handler: this.navigateRight
            }]
        });
        Pan.base.container.Carousel.superclass.initComponent.apply(this, arguments);
        this.contentPane = this.findByItemId("content");
        this.circleBar = this.contentPane.bottomToolbar;
        this.leftButton = this.findByItemId("leftButton");
        this.rightButton = this.findByItemId("rightButton");
    }, onDestroy: function () {
        if (this.keyMap) {
            this.keyMap.disable();
        }
        Pan.base.container.Carousel.superclass.onDestroy.apply(this, arguments);
    }, afterRender: function () {
        Pan.base.container.Carousel.superclass.afterRender.apply(this, arguments);
        if (this.keyMapComponent) {
            this.keyMap = new Ext.KeyMap(this.keyMapComponent.getEl(), [{
                key: [Ext.EventObject.LEFT],
                fn: this.navigateLeft
            }, {key: [Ext.EventObject.RIGHT], fn: this.navigateRight}]);
        }
    }, nextId: function () {
        return "id_" + this.sequence++;
    }, addToContent: function (item) {
        this.contentPane.add(Ext.apply(item, {itemId: this.nextId()}));
    }, getItemAt: function (index) {
        return this.getContents().get(index);
    }, getActiveItem: function () {
        var index = this.getActiveItemIndex();
        if (!Ext.isNumber(index)) {
            index = 0;
        }
        return this.getItemAt(index);
    }, setActiveItemIndex: function (index) {
        this.contentPane.layout.setActiveItem(index);
        this.fireEvent('activate', this, this.contentPane.getComponent(index));
    }, getActiveItemIndex: function () {
        return this.contentPane.layout.activeItem ? this.getContents().indexOf(this.contentPane.findByItemId(this.contentPane.layout.activeItem.itemId)) : undefined;
    }, onCircleClick: function () {
        this.scope.setActiveItemIndex(this.c.index);
        this.scope.redraw();
    }, navigate: function (dir) {
        if (this.contentPane.layout.activeItem) {
            var index = this.getActiveItemIndex() + dir;
            var activeItem = this.contentPane.getComponent(index);
            if (activeItem) {
                this.setActiveItemIndex(index);
                this.redraw();
            }
        }
        if (this.keyMapComponent) {
            this.keyMapComponent.focus();
        }
    }, redraw: function () {
        var activeIndex = this.getActiveItemIndex();
        if ((!Ext.isNumber(activeIndex) && this.getContents().length > 0) || (Ext.isNumber(activeIndex) && activeIndex >= this.getContents().length)) {
            activeIndex = 0;
            this.setActiveItemIndex(activeIndex);
        }
        this.circleBar.removeAll();
        if (this.getContents().length > 10) {
            if (Ext.isNumber(activeIndex)) {
                this.circleBar.add({xtype: 'tbtext', text: '' + (activeIndex + 1) + ' / ' + this.getContents().length});
            }
        } else if (this.getContents().length > 1) {
            for (var i = 0; i < this.getContents().length; i++) {
                var active = (activeIndex === i);
                var autoElobj = {
                    tag: 'div',
                    style: active ? '' : 'cursor: pointer;',
                    'class': active ? 'active-circle' : 'inactive-circle'
                };
                this.circleBar.add({
                    xtype: 'pan-boxcomponent',
                    autoEl: autoElobj,
                    index: i,
                    listeners: {
                        render: function (c) {
                            var el = this.mon(c.getEl(), "click", this.onCircleClick, {scope: this, c: c});
                        }, scope: this
                    }
                });
            }
        }
        if (Ext.isNumber(activeIndex)) {
            this.leftButton.setDisabled(activeIndex === 0);
            this.rightButton.setDisabled(activeIndex === this.getContents().length - 1);
        } else {
            this.leftButton.setDisabled(true);
            this.rightButton.setDisabled(true);
        }
        this.doLayout();
    }, getContents: function () {
        return this.contentPane.items;
    }, removeContent: function (item) {
        this.contentPane.remove(item, true);
    }, removeAllContent: function () {
        this.contentPane.removeAll(true);
    }
});
Ext.reg('pan-carousel', Pan.base.container.Carousel);
Ext.namespace('Pan.base.util');
Pan.base.util.LoadMaskMgr = Ext.apply(new Ext.util.MixedCollection(), {
    register: function (id1) {
        for (var i = 0, s; (s = arguments[i]); i++) {
            this.add(s);
        }
    }, unregister: function (id1) {
        for (var i = 0, s; (s = arguments[i]); i++) {
            this.remove(this.lookup(s));
        }
    }, lookup: function (id) {
        return Ext.isObject(id) ? id : this.get(id);
    }, getKey: function (o) {
        return o.el.id;
    }
});
Ext.namespace('Pan.base.util');
Pan.base.util.TaskRunner = function (interval) {
    Pan.base.util.TaskRunner.superclass.constructor.call(this, interval);
};
Ext.extend(Pan.base.util.TaskRunner, Ext.util.TaskRunner);
Pan.TaskMgr = new Pan.base.util.TaskRunner();
Pan.base.util.History = (function () {
    var iframe, hiddenField;
    var ready = false;
    var currentToken;

    function getHash() {
        var href = top.location.href, i = href.indexOf("#");
        return i >= 0 ? href.substr(i + 1) : null;
    }

    function doSave() {
        hiddenField.value = currentToken;
    }

    function handleStateChange(token) {
        currentToken = token;
        Pan.base.util.History.fireEvent('change', token);
    }

    function updateIFrame(token) {
        var html = ['<html><body><div id="state">', Ext.util.Format.htmlEncode(token), '</div></body></html>'].join('');
        try {
            var doc = iframe.contentWindow.document;
            doc.open();
            doc.write(html);
            doc.close();
            return true;
        } catch (e) {
            return false;
        }
    }

    function checkIFrame() {
        if (!iframe.contentWindow || !iframe.contentWindow.document) {
            setTimeout(checkIFrame, 10);
            return;
        }
        var doc = iframe.contentWindow.document;
        var elem = doc.getElementById("state");
        var token = elem ? elem.innerText : null;
        var hash = getHash();
        setInterval(function () {
            doc = iframe.contentWindow.document;
            elem = doc.getElementById("state");
            var newtoken = elem ? elem.innerText : null;
            var newHash = getHash();
            if (newtoken !== token) {
                token = newtoken;
                handleStateChange(token);
                top.location.hash = token;
                hash = token;
                doSave();
            } else if (newHash !== hash) {
                hash = newHash;
                updateIFrame(newHash);
            }
        }, 50);
        ready = true;
        Pan.base.util.History.fireEvent('ready', Pan.base.util.History);
    }

    function startUp() {
        currentToken = hiddenField.value ? hiddenField.value : getHash();
        if (Ext.isIE6 || Ext.isIE7) {
            checkIFrame();
        } else {
            var hash = getHash();
            setInterval(function () {
                var newHash = getHash();
                if (newHash !== hash) {
                    hash = newHash;
                    handleStateChange(hash);
                    doSave();
                }
            }, 50);
            ready = true;
            Pan.base.util.History.fireEvent('ready', Pan.base.util.History);
        }
    }

    return {
        fieldId: 'x-history-field', iframeId: 'x-history-frame', events: {}, init: function (onReady, scope) {
            if (ready) {
                Ext.callback(onReady, scope, [this]);
                return;
            }
            if (!Ext.isReady) {
                Ext.onReady(function () {
                    Pan.base.util.History.init(onReady, scope);
                });
                return;
            }
            hiddenField = Ext.getDom(Pan.base.util.History.fieldId);
            if (Ext.isIE6 || Ext.isIE7) {
                iframe = Ext.getDom(Pan.base.util.History.iframeId);
            }
            this.addEvents('ready', 'change');
            if (onReady) {
                this.on('ready', onReady, scope, {single: true});
            }
            startUp();
        }, add: function (token, preventDup) {
            if (preventDup !== false) {
                if (this.getToken() == token) {
                    return true;
                }
            }
            if (Ext.isIE6 || Ext.isIE7) {
                return updateIFrame(token);
            } else {
                top.location.hash = token;
                return true;
            }
        }, back: function () {
            history.go(-1);
        }, forward: function () {
            history.go(1);
        }, getToken: function () {
            return ready ? currentToken : getHash();
        }
    };
})();
Ext.apply(Pan.base.util.History, new Ext.util.Observable());
Ext.ns('Pan.base.autorender.layout');
Pan.base.autorender.layout.LayoutConfigConstants = (function () {
    return {leftAnchorSize: 3};
})();
Ext.ns('Pan.base.autorender.layout');
Pan.base.autorender.layout.RFColumnLayoutConfig = (function () {
    return function (items, recordForm) {
        var columnCount = recordForm.columnCount || 2;
        var i, colIndex;
        var columnItems = [];
        for (i = 0; i < columnCount; i++) {
            var columnItem = {
                xtype: 'pan-container',
                layout: 'form',
                layoutConfig: {trackLabels: Ext.isDefined(recordForm.trackLabels) ? recordForm.trackLabels : true},
                items: []
            };
            if (!recordForm.noLastColumnAnchor || (i < columnCount - 1)) {
                Ext.apply(columnItem, {defaults: {anchor: "-" + Pan.base.autorender.layout.LayoutConfigConstants.leftAnchorSize}});
            }
            var formLabelAlign = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelAlign)) ? recordForm.__field.uiHint.formLabelAlign : Ext.isDefined(recordForm.formLabelAlign) ? recordForm.formLabelAlign : recordForm.labelAlign;
            if (Ext.isDefined(formLabelAlign)) {
                columnItem.defaults = columnItem.defaults || {};
                Ext.applyIf(columnItem.defaults, {formLabelAlign: formLabelAlign});
                Ext.applyIf(columnItem.defaults, {labelAlign: formLabelAlign});
            }
            var formLabelWidth = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelWidth)) ? recordForm.__field.uiHint.formLabelWidth : Ext.isDefined(recordForm.formLabelWidth) ? recordForm.formLabelWidth : recordForm.labelWidth;
            if (Ext.isDefined(formLabelWidth)) {
                columnItem.defaults = columnItem.defaults || {};
                Ext.applyIf(columnItem, {formLabelWidth: formLabelWidth});
                Ext.applyIf(columnItem.defaults, {formLabelWidth: formLabelWidth});
                Ext.applyIf(columnItem, {labelWidth: formLabelWidth});
                Ext.applyIf(columnItem.defaults, {labelWidth: formLabelWidth});
            }
            if (Ext.isArray(recordForm.columnWidth)) {
                Ext.applyIf(columnItem, {columnWidth: recordForm.columnWidth[i]});
            }
            columnItems.push(columnItem);
        }
        for (i = 0, colIndex = 0; i < items.length; i++) {
            columnItems[colIndex++].items.push(items[i]);
            colIndex = colIndex === columnCount ? 0 : colIndex;
        }
        return {
            xtype: 'pan-container',
            layout: 'column',
            anchor: '100%',
            border: false,
            monitorValid: true,
            autoHeight: true,
            defaults: {columnWidth: 1 / columnCount},
            items: columnItems
        };
    };
})();
Ext.ns('Pan.base.autorender.layout');
Pan.base.autorender.layout.RFTableLayoutConfigCreate = function (config) {
    return {
        xtype: 'pan-container',
        layout: 'grid',
        autoHeight: true,
        layoutConfig: {columns: config.columnCount, tableAttrs: {style: {width: '100%'}}},
        monitorValid: true,
        items: config.newItems,
        rfPostLayoutConfig: function (items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var c = item.items.items[0];
                if (!c.getLayout) {
                    if (!c.fieldLabel || c.hideLabel || c.labelAlign === 'top') {
                        Ext.applyIf(c, {style: {}});
                        Ext.applyIf(c.style, {'margin-left': "" + Pan.base.autorender.layout.LayoutConfigConstants.leftAnchorSize});
                    }
                }
                Ext.copyTo(item, c, "vflex,colIndex,rowIndex,rowspan,colspan,cellId,cellCls,hideLabels,labelAlign,labelPad,labelSeparator,labelWidth");
            }
        }
    };
};
Pan.base.autorender.layout.RFTableLayoutConfig = (function () {
    return function (items, recordForm) {
        var columnCount = recordForm.columnCount || 1;
        var colRow = [], i = 0;
        for (i = 0; i < columnCount; i++) {
            colRow[i] = [];
        }
        var maxRow = 0, item, colIndex, rowIndex, c = 0, r = 0;
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (items.length > 1 && item.dim) {
                rowIndex = items[i].dim[1];
                colIndex = items[i].dim[0];
            }
            else {
                rowIndex = r;
                colIndex = c;
            }
            colRow[colIndex][rowIndex] = items[i];
            if (rowIndex > maxRow) {
                maxRow = rowIndex;
            }
            c++;
            if (c === columnCount) {
                r++;
                c = 0;
            }
        }
        var newItems = [];
        var colspan, rowspan;
        for (r = 0; r <= maxRow; r++) {
            for (c = 0; c < colRow.length; c++) {
                var childAnchorDefault = (colRow.length === 1) ? "0" : ("-" + Pan.base.autorender.layout.LayoutConfigConstants.leftAnchorSize);
                item = colRow[c][r];
                if (item) {
                    if (items.length > 1 && item.dim) {
                        colIndex = item.dim[0];
                        rowIndex = item.dim[1];
                        colspan = item.dim[2] === undefined ? 1 : item.dim[2];
                        rowspan = item.dim[3] === undefined ? 1 : item.dim[3];
                    }
                    else {
                        colIndex = c;
                        rowIndex = r;
                        colspan = 1;
                        rowspan = 1;
                    }
                    var newItem = {
                        xtype: 'pan-container',
                        layout: 'form',
                        items: item,
                        colIndex: colIndex,
                        rowIndex: rowIndex,
                        colspan: colspan,
                        rowspan: rowspan,
                        layoutConfig: {trackLabels: Ext.isDefined(recordForm.trackLabels) ? recordForm.trackLabels : true},
                        defaults: {anchor: childAnchorDefault}
                    };
                    var copyToList = "vflex,colIndex,rowIndex,rowspan,colspan,cellId,cellCls,hideLabels,labelAlign,labelPad,labelSeparator,labelWidth";
                    var itemField = recordForm.__pdefaults && recordForm.__pdefaults.__fields.get(item.itemId);
                    var itemUIHint = itemField && itemField.uiHint;
                    if (itemUIHint) {
                        newItem = Ext.copyTo(newItem, itemUIHint, copyToList);
                    }
                    newItem = Ext.copyTo(newItem, item, copyToList);
                    var formLabelAlign = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelAlign)) ? recordForm.__field.uiHint.formLabelAlign : Ext.isDefined(recordForm.formLabelAlign) ? recordForm.formLabelAlign : recordForm.labelAlign;
                    if (Ext.isDefined(formLabelAlign) && !Ext.isDefined(newItem.labelAlign)) {
                        newItem.defaults = newItem.defaults || {};
                        Ext.applyIf(newItem.defaults, {formLabelAlign: formLabelAlign});
                        Ext.applyIf(newItem.defaults, {labelAlign: formLabelAlign});
                    }
                    var formLabelWidth = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelWidth)) ? recordForm.__field.uiHint.formLabelWidth : Ext.isDefined(recordForm.formLabelWidth) ? recordForm.formLabelWidth : recordForm.labelWidth;
                    if (Ext.isDefined(formLabelWidth) && !Ext.isDefined(newItem.labelWidth)) {
                        Ext.applyIf(newItem, {formLabelWidth: formLabelWidth});
                        Ext.applyIf(newItem.defaults, {formLabelWidth: formLabelWidth});
                        Ext.applyIf(newItem, {labelWidth: formLabelWidth});
                        Ext.applyIf(newItem.defaults, {labelWidth: formLabelWidth});
                    }
                    newItems.push(newItem);
                }
            }
        }
        return Pan.base.autorender.layout.RFTableLayoutConfigCreate({newItems: newItems, columnCount: columnCount});
    };
})();
Ext.ns('Pan.base.autorender.layout');
Pan.base.autorender.layout.SimpleLayoutConfig = (function () {
    return function (items, recordForm) {
        function rowspan(matrix, x, y) {
            var i = x;
            while (--i >= 0) {
                var item = matrix[i][y];
                if (Ext.isObject(item)) {
                    var rs = item.rowspan || 1;
                    item.rowspan = rs + 1;
                    return;
                }
            }
            throw("Unsupported layout matrix rowspan with x=" + x + " y=" + y);
        }

        function colspan(matrix, x, y) {
            var j = y;
            while (--j >= 0) {
                var item = matrix[x][j];
                if (Ext.isObject(item)) {
                    var cs = item.colspan || 1;
                    item.colspan = cs + 1;
                    return;
                }
            }
        }

        function findItem(id, items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.itemId == id) {
                    return item;
                }
            }
            return null;
        }

        var matrix = items;
        if (recordForm && recordForm.rfLayoutMap) {
            matrix = Pan.base.clone(recordForm.rfLayoutMap);
        }
        var x, y, row, item;
        for (x = 0; x < matrix.length; x++) {
            row = matrix[x];
            for (y = 0; y < row.length; y++) {
                item = row[y];
                if (Ext.isString(item)) {
                    if (item == '-') {
                        colspan(matrix, x, y);
                    }
                    else if (item == '|') {
                        rowspan(matrix, x, y);
                    }
                    else if (item == '+') {
                        row[y] = {xtype: 'box', vflex: true};
                    }
                    else if (item == ' ') {
                        row[y] = {xtype: 'box'};
                    }
                    else {
                        var it = findItem(item, items);
                        if (it) {
                            row[y] = it;
                        }
                    }
                }
                else if (Ext.isNumber(item)) {
                    row[y] = {xtype: 'box', width: item};
                }
            }
        }
        var columnCount = matrix[0].length;
        var newItems = [];
        for (x = 0; x < matrix.length; x++) {
            row = matrix[x];
            for (y = 0; y < row.length; y++) {
                if (Ext.isObject(row[y])) {
                    var childAnchorDefault = (row.length === 1) ? "0" : ("-" + Pan.base.autorender.layout.LayoutConfigConstants.leftAnchorSize);
                    row[y].rowIndex = x;
                    row[y].colIndex = y;
                    item = row[y];
                    var newItem = {
                        xtype: 'pan-container',
                        layout: 'form',
                        items: item,
                        layoutConfig: {trackLabels: Ext.isDefined(recordForm.trackLabels) ? recordForm.trackLabels : true},
                        defaults: {anchor: childAnchorDefault}
                    };
                    var copyToList = "vflex,colIndex,rowIndex,rowspan,colspan,cellId,cellCls,hideLabels,labelAlign,labelPad,labelSeparator,labelWidth";
                    var itemField = recordForm.__pdefaults && recordForm.__pdefaults.__fields.get(item.itemId);
                    var itemUIHint = itemField && itemField.uiHint;
                    if (itemUIHint) {
                        newItem = Ext.copyTo(newItem, itemUIHint, copyToList);
                    }
                    newItem = Ext.copyTo(newItem, item, copyToList);
                    var formLabelAlign = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelAlign)) ? recordForm.__field.uiHint.formLabelAlign : Ext.isDefined(recordForm.formLabelAlign) ? recordForm.formLabelAlign : recordForm.labelAlign;
                    if (Ext.isDefined(formLabelAlign)) {
                        newItem.defaults = newItem.defaults || {};
                        Ext.applyIf(newItem.defaults, {formLabelAlign: formLabelAlign});
                        Ext.applyIf(newItem.defaults, {labelAlign: formLabelAlign});
                    }
                    var formLabelWidth = (recordForm.__field && recordForm.__field.uiHint && Ext.isDefined(recordForm.__field.uiHint.formLabelWidth)) ? recordForm.__field.uiHint.formLabelWidth : Ext.isDefined(recordForm.formLabelWidth) ? recordForm.formLabelWidth : recordForm.labelWidth;
                    if (Ext.isDefined(formLabelWidth) && !Ext.isDefined(newItem.labelWidth)) {
                        Ext.applyIf(newItem, {formLabelWidth: formLabelWidth});
                        Ext.applyIf(newItem.defaults, {formLabelWidth: formLabelWidth});
                        Ext.applyIf(newItem, {labelWidth: formLabelWidth});
                        Ext.applyIf(newItem.defaults, {labelWidth: formLabelWidth});
                    }
                    newItems.push(newItem);
                }
            }
        }
        return Pan.base.autorender.layout.RFTableLayoutConfigCreate({newItems: newItems, columnCount: columnCount});
    };
})();
Ext.ns('Pan.base.autorender');
Pan.base.autorender.SaveError = Ext.extend(Error, {
    constructor: function (errorConfig) {
        Pan.base.autorender.SaveError.superclass.constructor.call(this);
        Ext.apply(this, errorConfig);
        var field = this.field;
        if (field && this.saveRecovery || this.saveRecovery) {
            var fieldName = (field.uiHint && field.uiHint.fieldLabel) || field.attrName;
            var saveRecovery = this.saveRecovery || field.saveRecovery;
            if (Ext.isString(this.saveRecovery) && Ext.isObject(field.saveRecovery)) {
                saveRecovery = field.saveRecovery[this.saveRecovery];
            }
            if (Ext.isFunction(saveRecovery)) {
                Ext.apply(this, {saveRecovery: saveRecovery.createDelegate(this, [this])});
                Ext.applyIf(this, {
                    msg: _T("Invalid data found for field {fieldName}: {data}", {
                        fieldName: fieldName,
                        data: (this.data ? ": " + this.data : "")
                    })
                });
            }
        }
    },
    saveRecovery: Ext.emptyFn,
    recoveryDetail: _T("You may save again after recovery.") + "<br>" + _T("Do you wish to recover?")
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.AutoRenderContainer = Ext.extend(Pan.base.container.Container, {
    initComponent: function () {
        var items = this.items || [];
        for (var i = 0; i < this.__field.childrenNames.length; i++) {
            items.push({itemId: this.__field.childrenNames[i]});
        }
        Ext.applyIf(this, {
            layout: 'form',
            items: items,
            layoutConfig: {trackLabels: true},
            defaults: {anchor: "100%"}
        });
        Pan.base.autorender.AutoRenderContainer.superclass.initComponent.apply(this, arguments);
    }
});
Ext.reg("pan-autorendercontainer", Pan.base.autorender.AutoRenderContainer);
Pan.base.autorender.GridDataReader = Pan.base.util.cextend(Ext.ux.grid.livegrid.JsonReader, "isLiveGrid", {
    realize: function (rs, data) {
        if (Ext.isArray(rs)) {
            for (var i = rs.length - 1; i >= 0; i--) {
                if (Ext.isArray(data)) {
                    this.realize(rs.splice(i, 1).shift(), data.splice(i, 1).shift());
                }
                else {
                    this.realize(rs.splice(i, 1).shift(), data);
                }
            }
        }
        else {
            if (Ext.isArray(data) && data.length == 1) {
                data = data.shift();
            }
            if (!this.isData(data)) {
                throw new Ext.data.DataReader.Error('realize', rs);
            }
            rs.phantom = false;
            rs._phid = rs.id;
            rs.id = this.getId(data);
            rs.data = this.extractValues(data, rs.fields.items, rs.fields.length);
            rs.commit();
        }
    }, update: function (rs, data) {
        if (Ext.isArray(rs)) {
            for (var i = rs.length - 1; i >= 0; i--) {
                if (Ext.isArray(data)) {
                    this.update(rs.splice(i, 1).shift(), data.splice(i, 1).shift());
                }
                else {
                    this.update(rs.splice(i, 1).shift(), data);
                }
            }
        }
        else {
            if (Ext.isArray(data) && data.length == 1) {
                data = data.shift();
            }
            if (this.isData(data)) {
                rs.data = this.extractValues(data, rs.fields.items, rs.fields.length);
            }
            rs.commit();
        }
    }, extractValues: function (data, items, len) {
        data = this.recordBinder.readRecord(data, items, len);
        var f, values = {};
        for (var j = 0; j < len; j++) {
            f = items[j];
            var v = this.ef[j](data);
            values[f.name] = f.convert((v !== undefined) ? v : ((f.allowBlank === false) ? "" : f.defaultValue), data);
        }
        return values;
    }, rebuildExtractors: function () {
        delete this.ef;
        this.buildExtractors();
    }, createAccessor: function (expr) {
        var fields = this.recordType.prototype.fields;
        var field = fields.get(expr);
        if (field && field.accessor) {
            return field.accessor;
        } else {
            return Pan.base.PanDecode.createAccessor(expr);
        }
    }
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GridRecordIconMenu = Ext.extend(Ext.ux.menu.IconMenu, {
    onRender: function () {
        var hd = this.panel.header;
        if (!hd) {
            return;
        }
        hd.addClass('x-panel-icon');
        hd.applyStyles({position: 'relative'});
        this.icon = hd.insertFirst({
            tag: 'div',
            id: Ext.id(),
            style: this.style,
            cls: this.iconCls,
            qtip: Pan.base.htmlEncode(this.qtip || this.tooltip || '')
        }, 'first');
        var img = hd.down('img');
        if (img) {
            this.icon.alignTo(img, 'tl-tl');
            img.removeClass(this.panel.iconCls || this.iconCls);
            img.set({src: Ext.BLANK_IMAGE_URL});
            if (img.hasClass('x-panel-inline-icon')) {
                img.setStyle({width: '2px'});
            }
        }
        this.icon.on({
            scope: this, dblclick: function () {
                if (this.dblClickClose) {
                    this.hideMenu();
                    this.closeHandler();
                }
            }, click: {
                scope: this, delay: 200, fn: function (e, t) {
                    if (this.menu && !this.menu.isVisible() && !this.ignoreNextClick) {
                        this.showMenu();
                    }
                }
            }
        });
        this.panel.setIconClass = this.setIconClass.createDelegate(this);
        var padding = this.icon.getWidth() + 4 + 'px' + ' !important';
        Ext.util.CSS.createStyleSheet('.x-im-header{padding-left:' + padding + ';}');
        hd.addClass('x-im-header');
    }
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.valueChangedPrototype = {
    testValueChangedElementEvents: ['change', false, 'keyup', false], initValueChanged: function () {
        this.__valueChanged = false;
        var i;
        if (this.rendered && !this.__listeningToTestValueChangedElementEvents) {
            this.__listeningToTestValueChangedElementEvents = true;
            if (this.testValueChangedElementEvents) {
                for (i = 0; i < this.testValueChangedElementEvents.length; i++) {
                    this.mon(this.el, this.testValueChangedElementEvents[i++], (this.testValueChangedElementEvents[i] ? this.testValueChangedWithVerify : this.testValueChangedWithoutVerify), this);
                }
            }
        }
        if (!this.__listeningToTestValueChangedEvents) {
            this.__listeningToTestValueChangedEvents = true;
            if (this.testValueChangedEvents) {
                for (i = 0; i < this.testValueChangedEvents.length; i++) {
                    this.addListener(this.testValueChangedEvents[i++], (this.testValueChangedEvents[i] ? this.testValueChangedWithVerify : this.testValueChangedWithoutVerify), this);
                }
            }
        }
    }, testValueChangedWithoutVerify: function () {
        this.__isFieldDirty = true;
        this.__valueChanged = true;
    }, testValueChangedWithVerify: function () {
        this.__isFieldDirty = this.__isFieldDirty || this.isDirty();
        this.__valueChanged = this.__valueChanged || this.isDirty();
    }, hasValueChanged: function () {
        return this.__valueChanged;
    }, isFieldDirty: function () {
        return this.__isFieldDirty;
    }
};
Pan.base.autorender.GridRecordField = Ext.extend(Pan.base.container.Container, Ext.apply({
    getName: function () {
        return this.rendered && this.el.dom.name ? this.el.dom.name : this.name || this.id || '';
    }, getRecord: function () {
        return this.__pdefaults && this.__pdefaults.__recordFormRecord;
    }, getRecordFields: function () {
        return this.__pdefaults && this.__pdefaults.__fields;
    }, reset: function () {
    }, setValue: function () {
    }, getValue: function () {
    }, isValid: function () {
        return true;
    }, validate: function () {
        return true;
    }, markInvalid: function () {
    }, clearInvalid: function () {
    }
}, Pan.base.autorender.valueChangedPrototype));
Ext.reg("pan-recordfield", Pan.base.autorender.GridRecordField);
Pan.base.autorender.ComponentCommonInfo = Ext.extend(Object, {
    constructor: function (fieldData, field) {
        this.__field = field;
        this.__fieldData = fieldData;
    }, getFieldData: function () {
        return this.__fieldData;
    }, getField: function () {
        return this.__field;
    }, getRecord: function () {
        return this.__pdefaults && this.__pdefaults.__recordFormRecord;
    }, getRecordFields: function () {
        return this.__pdefaults && this.__pdefaults.__fields;
    }, isChildOfStarField: function () {
        return this.__field && this.__field.attrPath && this.__field.attrPath.indexOf("*") > 0;
    }
});
Ext.Container.prototype.applyDefaults = Pan.base.util.createExtension(function (c) {
    c = arguments.callee.superFunction.apply(this, arguments);
    if (!c.render) {
        var c__pdefaults = c.__pdefaults || this.__pdefaults;
        if (c.__pdefaults && this.__pdefaults && c.__pdefaults !== this.__pdefaults) {
            c__pdefaults = Ext.apply({}, c.__pdefaults, this.__pdefaults);
        }
        if (c__pdefaults) {
            c = Ext.apply({}, c);
            c.__pdefaults = c__pdefaults;
            var fields = c.__pdefaults.__fields;
            var data;
            if (fields && (c.fieldName || c.itemId || c.name)) {
                var fieldName = c.fieldName || c.itemId || c.name;
                var field = fields.get(fieldName);
                var builder = c.builder;
                if (field) {
                    if (field.uiHint) {
                        Ext.applyIf(c, field.uiHint);
                        var recordFormRecord = c.__pdefaults.__recordFormRecord;
                        if (recordFormRecord) {
                            data = jsonPath(recordFormRecord.json, field.attrPath);
                            data = data ? data[0] : undefined;
                        }
                        Ext.applyIf(c, new Pan.base.autorender.ComponentCommonInfo(data, field));
                        builder = c.builder;
                    }
                    if (!builder) {
                        if (field.isCollection) {
                            builder = 'EditorGridBuilder';
                        } else if (field.children) {
                            builder = 'ContainerBuilder';
                        }
                    }
                }
                {
                    if (Ext.isString(builder)) {
                        builder = Pan.base.autorender.builder.BuilderMgr.get(builder);
                    }
                    if (Ext.isFunction(builder)) {
                        builder.call(this, c, {field: field, data: data, fields: fields});
                    }
                    if (c.association || c.avail) {
                        c.plugins = Pan.base.util.integrateArray(c.plugins, {ptype: "association"});
                    }
                    if (c.showHelpString) {
                        var helpString = c.showHelpString === true ? c.helpstring : c.showHelpString;
                        if (Ext.isFunction(helpString)) {
                            helpString = helpString();
                        }
                        c.plugins = Pan.base.util.integrateArray(c.plugins, new Ext.ux.FieldHelp(helpString, undefined, c.wrapHelpString));
                    }
                    if (Ext.isFunction(c.fieldLabel)) {
                        c.fieldLabel = c.fieldLabel();
                    }
                    if (!c.hasOwnProperty('fieldLabelPlugin') && c.__pdefaults.fieldLabelPlugin) {
                        c.fieldLabelPlugin = c.__pdefaults.fieldLabelPlugin;
                    }
                    if (c.fieldLabelPlugin) {
                        c.plugins = Pan.base.util.integrateArray(c.plugins, {ptype: c.fieldLabelPlugin});
                    }
                }
                if (field) {
                    var allowBlankValidation = Ext.isDefined(c.allowBlankValidation) ? c.allowBlankValidation : Ext.isDefined(c.__pdefaults.__allowBlankValidation) ? c.__pdefaults.__allowBlankValidation : true;
                    if (!allowBlankValidation) {
                        if (c.allowBlank === false) {
                            c.allowBlank = true;
                        }
                    }
                    c.emptyText = Pan.base.genEmptyText(c, field);
                    if (!c.regexText) {
                        if (c.regex) {
                            c.regexText = _T("The value in this field does not fit the validation pattern:") + " " + c.regex.source;
                        }
                    }
                    if (!c.xtype) {
                        c.xtype = c.uitype || Pan.appframework.schema.PanType.getType2XTypeMap()[field.type.type] || 'pan-textfield';
                    }
                }
            }
        }
    }
    return c;
}, Ext.Container.prototype.applyDefaults);
Ext.Container.prototype.initComponent = Pan.base.util.createExtension(function () {
    if (Ext.isFunction(this.rfLayoutConfig)) {
        this.items = Ext.applyIf({anchor: "100% 100%"}, this.rfLayoutConfig.call(this, this.items, this.rfLayoutConfigParam || this));
    }
    var rv = arguments.callee.superFunction.apply(this, arguments);
    if (Ext.isFunction(this.postInitComponent)) {
        this.postInitComponent.call(this, this);
    }
    return rv;
}, Ext.Container.prototype.initComponent);
Ext.Container.prototype.add = Pan.base.util.createExtension(function () {
    var doPostLayoutConfig = false;
    if (!this.nthTime) {
        this.nthTime = true;
        if (Ext.isFunction(this.rfPostLayoutConfig)) {
            doPostLayoutConfig = true;
        }
    }
    var rv = arguments.callee.superFunction.apply(this, arguments);
    if (doPostLayoutConfig) {
        this.rfPostLayoutConfig.call(this, this.items.items);
    }
    return rv;
}, Ext.Container.prototype.add);
Ext.Component.prototype.findParentByInstanceof = function (inst) {
    return this.findParentBy(function (p) {
        return p instanceof inst;
    });
};
Ext.Container.prototype.findByItemId = function (itemId) {
    if (this.fieldName === itemId || this.itemId === itemId || this.name === itemId) {
        return this;
    }
    var m = null, ct = this;
    this.cascade(function (c) {
        if (ct != c) {
            if (c.findByItemId && c.findByItemId !== Ext.Container.prototype.findByItemId) {
                var x = c.findByItemId(itemId);
                if (x) {
                    m = x;
                    return false;
                }
            } else if (c.fieldName === itemId || c.itemId === itemId || c.name === itemId) {
                m = c;
                return false;
            }
        }
    });
    return m || null;
};
Ext.Container.prototype.syncFloatingShadow = function () {
    var ownerCt = this;
    while (ownerCt) {
        if (ownerCt.floating && Ext.isFunction(ownerCt.syncShadow)) {
            ownerCt.syncShadow();
            break;
        }
        ownerCt = ownerCt.ownerCt;
    }
};
Ext.Panel.prototype.initLoadingIndication = function () {
    this.cls = this.cls || "";
    this.cls += " " + Pan.base.Constants.loadMaskDisplayerClass;
    this.setLoadingIndication = function (stateOn) {
        stateOn ? this.tools.loading.show() : this.tools.loading.hide();
    }.createDelegate(this);
    this.setLoadingIndicationTooltip = function (tooltip) {
        this.tools.loading.dom.qtip = tooltip;
    }.createDelegate(this);
    this.addTool({id: 'loading', hidden: true});
};
Ext.FormPanel.prototype.isField = Pan.base.util.createExtension(function (c) {
    if (Ext.isBoolean(c.isExtFormField)) {
        return c.isExtFormField;
    } else {
        return arguments.callee.superFunction.apply(this, arguments);
    }
}, Ext.FormPanel.prototype.isField);
Ext.form.Field.prototype.requiredFieldClass = 'x-form-required';
Ext.form.Field.prototype.setValue = Pan.base.util.createExtension(function () {
    arguments.callee.superFunction.apply(this, arguments);
    if (this.testValueChangedWithVerify) {
        this.testValueChangedWithVerify();
    }
}, Ext.form.Field.prototype.setValue);
Ext.form.Field.prototype.protect = function () {
    this.addClass("x-protect-background");
    this.disable();
};
Ext.form.Field.prototype.unprotect = function () {
    this.removeClass("x-protect-background");
    if (!this.readOnly) {
        this.enable();
    }
};
Ext.form.Field.prototype.initComponent = Pan.base.util.createExtension(function () {
    if (this.__pdefaults && this.__pdefaults.__readOnly) {
        this.disabled = true;
    }
    arguments.callee.superFunction.apply(this, arguments);
}, Ext.form.Field.prototype.initComponent);
Ext.form.FieldSet.prototype.initComponent = Pan.base.util.createExtension(function () {
    if (this.__pdefaults && this.__pdefaults.__readOnly) {
        this.disabled = true;
    }
    arguments.callee.superFunction.apply(this, arguments);
}, Ext.form.FieldSet.prototype.initComponent);
Ext.form.Field.prototype.markInvalid = Pan.base.util.createExtension(function (msg) {
    if (this.rendered && !this.preventMark) {
        if (msg && msg === this.blankText) {
            this.el.addClass(this.requiredFieldClass);
        } else {
            this.el.removeClass(this.requiredFieldClass);
        }
    }
    msg = Pan.base.htmlEncode(msg);
    arguments.callee.superFunction.apply(this, arguments);
}, Ext.form.Field.prototype.markInvalid);
Ext.form.Field.prototype.clearInvalid = Pan.base.util.createExtension(function () {
    if (this.rendered && !this.preventMark) {
        this.el.removeClass(this.requiredFieldClass);
    }
    arguments.callee.superFunction.apply(this, arguments);
}, Ext.form.Field.prototype.clearInvalid);
Ext.form.Field.prototype.afterRender = Pan.base.util.createExtension(function () {
    arguments.callee.superFunction.apply(this, arguments);
    this.initValueChanged();
}, Ext.form.Field.prototype.afterRender);
Ext.override(Ext.form.Field, Pan.base.autorender.valueChangedPrototype);
Ext.override(Ext.form.FieldSet, Pan.base.autorender.valueChangedPrototype);
Ext.TabPanel.prototype.initTab = Pan.base.util.createExtension(function (item, index) {
    if (Ext.isString(item.title)) {
        item.title = Pan.base.htmlEncode(item.title);
    }
    if (Ext.isString(item.tabTip)) {
        item.tabTip = Pan.base.htmlEncode(item.tabTip);
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.TabPanel.prototype.initTab);
Ext.TabPanel.prototype.onItemTitleChanged = Pan.base.util.createExtension(function (item) {
    if (Ext.isString(item.title)) {
        item.title = Pan.base.htmlEncode(item.title);
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.TabPanel.prototype.onItemTitleChanged);
Ext.ux.VrTabPanel.prototype.initTab = Pan.base.util.createExtension(function (item, index) {
    if (Ext.isString(item.title)) {
        item.title = Pan.base.htmlEncode(item.title);
    }
    if (Ext.isString(item.tabTip)) {
        item.tabTip = Pan.base.htmlEncode(item.tabTip);
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.ux.VrTabPanel.prototype.initTab);
Ext.ux.VrTabPanel.prototype.onItemTitleChanged = Pan.base.util.createExtension(function (item) {
    if (Ext.isString(item.title)) {
        item.title = Pan.base.htmlEncode(item.title);
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.ux.VrTabPanel.prototype.onItemTitleChanged);
Ext.grid.GridEditor.prototype.realign = Pan.base.util.createExtension(function (autoSize) {
    if (autoSize === true) {
        this.doAutoSize();
    }
    var voffset = this.parentEl.getBoundingClientRect().bottom - (this.boundEl.getTop() + Math.max(this.field.getHeight(), this.boundEl.getHeight()));
    if (voffset < 0) {
        this.offsets[1] = voffset;
    } else {
        this.offsets[1] = 0;
    }
    this.el.alignTo(this.boundEl, this.alignment, this.offsets);
}, Ext.grid.GridEditor.prototype.realign);
Ext.grid.GridEditor.prototype.completeEdit = Pan.base.util.createExtension(function (remainVisible) {
    if (!this.editing) {
        return;
    }
    if (this.field.assertValue) {
        this.field.assertValue();
    }
    var v = this.getValue();
    if (this.field.validateAllCells !== true) {
        if (!this.field.isValid()) {
            if (this.revertInvalid !== false) {
                this.cancelEdit(remainVisible);
            }
            return;
        }
    }
    if (String(v) === String(this.startValue) && this.ignoreNoChange) {
        this.hideEdit(remainVisible);
        return;
    }
    if (this.fireEvent("beforecomplete", this, v, this.startValue) !== false) {
        v = this.getValue();
        if (this.updateEl && this.boundEl) {
            this.boundEl.update(v);
        }
        this.hideEdit(remainVisible);
        this.fireEvent("complete", this, v, this.startValue);
    }
}, Ext.grid.GridEditor.prototype.completeEdit);
Ext.util.Observable.prototype.hasEvent = function (eventName) {
    return this.events[eventName.toLowerCase()];
};
Ext.data.Connection.prototype.doFormUpload = Pan.base.util.createExtension(function () {
    var serverTokenGen = Pan.base.serverTokenGen(Pan.st);
    return function (o, ps, url) {
        if (Ext.isIE) {
            this.debugUploads = true;
        }
        var form = o.form;
        var hiddens = this.__hiddens = [];
        var items = serverTokenGen();
        var hd;
        Ext.iterate(items, function (k, v) {
            hd = document.createElement('input');
            Ext.fly(hd).set({type: 'hidden', value: v, name: k});
            form.insertBefore(hd, form.firstChild);
            hiddens.push(hd);
        });
        var result;
        try {
            result = arguments.callee.superFunction.apply(this, arguments);
        } catch (e) {
        }
        Ext.each(this.__hiddens, function (h) {
            Ext.removeNode(h);
        });
        delete this.__hiddens;
        return result;
    };
}(), Ext.data.Connection.prototype.doFormUpload);
Ext.Element.prototype.getStyleSize = Pan.base.util.createExtension(function () {
    if (this.dom) {
        return arguments.callee.superFunction.apply(this, arguments);
    }
    return {width: 0, height: 0};
}, Ext.Element.prototype.getStyleSize);
Ext.Element.prototype.getRegion = Pan.base.util.createExtension(function () {
    if (this.dom) {
        return arguments.callee.superFunction.apply(this, arguments);
    }
    return false;
}, Ext.Element.prototype.getRegion);
(function () {
    Ext.Component.prototype.isAvail = function () {
        return this.isAvailable !== false;
    };
    Ext.Component.prototype.setIsAvail = function (isAvailable, availHide, config) {
        if (this.el && this.el.dom) {
            config = config || {};
            if (isAvailable) {
                delete this.isAvailable;
            } else {
                this.isAvailable = false;
            }
            if (availHide === true) {
                var parentHeightArray = undefined;
                if (this.isVisible() !== isAvailable) {
                    parentHeightArray = [];
                    this.findParentBy(function (p) {
                        if (p && p.doLayout && p.getId) {
                            parentHeightArray.unshift([p.getId(), p.getHeight()]);
                        }
                    });
                    if (!isAvailable && !config.initialAvail && this.testValueChangedWithoutVerify)
                        this.testValueChangedWithoutVerify();
                }
                var currentlyVisible = this.isVisible();
                this.setVisible(isAvailable);
                if (Ext.isChrome || Ext.isSafari) {
                    var el = this.getVisibilityEl();
                    if (el) {
                        el.setStyle({display: ""});
                    }
                }
                if (Ext.isChrome || Ext.isSafari || Ext.isGecko) {
                    if (this.doLayout && currentlyVisible != isAvailable) {
                        this.doLayout();
                    }
                }
                if (parentHeightArray) {
                    var layoutParent = undefined;
                    for (var i = 0; i < parentHeightArray.length; i++) {
                        var parentHeight = parentHeightArray[i];
                        if (parentHeight[1] !== Ext.getCmp(parentHeight[0]).getHeight()) {
                            layoutParent = Ext.getCmp(parentHeightArray[(i > 0) ? i - 1 : 0][0]);
                            break;
                        }
                    }
                    if (layoutParent) {
                        layoutParent.doLayout();
                    }
                }
            } else {
                if (this.setTooltip) {
                    if (isAvailable) {
                        if (this.__availDisableTooltip) {
                            delete this.__availDisableTooltip;
                            this.setTooltip(this.tooltip);
                        }
                    } else if (config.availDisableReason && !this.tooltip) {
                        this.__availDisableTooltip = config.availDisableReason;
                        this.setTooltip(this.__availDisableTooltip);
                    }
                }
                this.setDisabled(!isAvailable);
            }
        }
    };
    Ext.Component.prototype.initComponent = Pan.base.util.createExtension(function () {
        if (Ext.isString(this.html)) {
            if (this.__pdefaults && this.__pdefaults.uiConfigSourceUntrustworthy) {
                this.html = Pan.base.htmlEncode(this.html);
            }
        }
        return arguments.callee.superFunction.apply(this, arguments);
    }, Ext.Component.prototype.initComponent);
    Ext.Component.prototype.setLabelText = function (label) {
        if (this.label && this.label.update) {
            this.label.update(label);
        }
    };
})();
Ext.util.MixedCollection.prototype.clone = function () {
    var r = new Ext.util.MixedCollection();
    var k = this.keys, it = this.items;
    r.suspendEvents(false);
    for (var i = 0, len = it.length; i < len; i++) {
        r.add(k[i], it[i]);
    }
    r.resumeEvents();
    r.getKey = this.getKey;
    return r;
};
Ext.util.MixedCollection.prototype.add = function (key, o) {
    if (arguments.length == 1) {
        o = arguments[0];
        key = this.getKey(o);
    }
    if (typeof key != 'undefined' && key !== null) {
        var old = this.map[key];
        if (typeof old != 'undefined') {
            return this.replace(key, o);
        }
        this.map[key] = o;
    }
    this.length++;
    this.items.push(o);
    this.keys.push(key);
    if (!this.eventsSuspended || this.eventQueue) {
        this.fireEvent('add', this.length - 1, o, key);
    }
    return o;
};
Ext.util.MixedCollection.prototype.filterBy = function (fn, scope) {
    var r = new Ext.util.MixedCollection();
    r.getKey = this.getKey;
    var k = this.keys, it = this.items;
    r.suspendEvents(false);
    for (var i = 0, len = it.length; i < len; i++) {
        if (fn.call(scope || this, it[i], k[i], i)) {
            r.add(k[i], it[i]);
        }
    }
    r.resumeEvents();
    return r;
};
Ext.util.MixedCollection.prototype.removeAt = function (index) {
    if (index < this.length && index >= 0) {
        this.length--;
        var o = this.items[index];
        this.items.splice(index, 1);
        var key = this.keys[index];
        if (typeof key != 'undefined') {
            delete this.map[key];
        }
        this.keys.splice(index, 1);
        if (!this.eventsSuspended || this.eventQueue) {
            this.fireEvent('remove', o, key);
        }
        return o;
    }
    return false;
};
Ext.Ajax.timeout = 1800000;
Ext.override(Ext.direct.RemotingProvider, {
    callWithServerToken: function () {
        var serverTokenGen = Pan.base.serverTokenGen(Pan.st);
        return function (c, m, args, data, hs, scope, me) {
            var t = new Ext.Direct.Transaction({
                provider: me,
                args: args,
                action: c,
                method: m.name,
                data: data,
                cb: scope && Ext.isFunction(hs) ? hs.createDelegate(scope) : hs
            });
            var serverToken = serverTokenGen(t.tid);
            data.unshift(serverToken['___token']);
            if (me.fireEvent('beforecall', me, t) !== false) {
                Ext.Direct.addTransaction(t);
                me.queueTransaction(t);
                me.fireEvent('call', me, t);
            }
        };
    }(), doCall: function (c, m, args) {
        var data = null, hs = args[m.len], scope = args[m.len + 1];
        if (m.len !== 0) {
            data = args.slice(0, m.len);
        }
        if (!data) {
            data = [];
        } else {
            data = data.slice(0);
        }
        this.callWithServerToken(c, m, args, data, hs, scope, this);
    }
});
Ext.direct.RemotingProvider.prototype.doCallback = Pan.base.util.createExtension(function () {
    var log = PanLogging.getLogger('framework:GridRecordField');
    try {
        arguments.callee.superFunction.apply(this, arguments);
    } catch (e) {
        if (Pan.test && typeof Pan.test.QaAutoUtils == 'undefined') {
            throw e;
        } else {
            log.error(e);
            if (e.stack) {
                log.error(e.stack);
            }
        }
    }
}, Ext.direct.RemotingProvider.prototype.doCallback);
Ext.Direct.hasTransaction = function () {
    for (var m in this.transactions) {
        if (this.transactions.hasOwnProperty(m)) {
            return true;
        }
    }
    return false;
};
Ext.layout.FormLayout.prototype.getTemplateArgs = Pan.base.util.createExtension(function (field) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    rv.label = Pan.base.genLabel(field, rv.label);
    if (field && field.__pdefaults && field.__pdefaults.uiConfigSourceUntrustworthy) {
        rv.label = Pan.base.htmlEncode(rv.label);
    }
    if (field.labelAction) {
        rv.label += Pan.base.renderer.RendererCommon.createActionImage(field.labelAction, {component: field});
    }
    if (field.fieldLabelPlugin) {
        rv.label += '<span id="' + field.id + '-label" class="x-hide-display">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>';
    }
    return rv;
}, Ext.layout.FormLayout.prototype.getTemplateArgs);
Ext.layout.FormLayout.prototype.renderItem = Pan.base.util.createExtension(function (c, position, target) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    var helpTip = Pan.base.genHelpTip(c, true);
    if (helpTip) {
        c.el.insertHtml('afterEnd', helpTip, true);
        c.addClass('x-form-item-with-help');
    }
    return rv;
}, Ext.layout.FormLayout.prototype.renderItem);
Ext.override(Ext.ux.ToggleSlide, {
    moveHandle: function (on, callback) {
        var to = on ? this.rightside : -this.rightside;
        var curX = this.handle.getX();
        this.handle.setX(curX + to);
        this.onHandleMove();
        if (callback) {
            callback();
        }
    }
});
Ext.override(Ext.data.Record, {
    isValid: function () {
        return true;
    }
});
Ext.Element.prototype.setOverflow = function (v, axis) {
    axis = axis ? axis.toString().toUpperCase() : '';
    var overflowProp = 'overflow';
    if (axis == 'X' || axis == 'Y') {
        overflowProp += axis;
    }
    if (v == 'auto' && Ext.isMac && Ext.isGecko2) {
        this.dom.style[overflowProp] = 'hidden';
        (function () {
            this.dom.style[overflowProp] = 'auto';
        }).defer(1, this);
    } else {
        this.dom.style[overflowProp] = v;
    }
};
Ext.override(Ext.Container, {
    setAutoScroll: function () {
        if (this.rendered && Ext.isDefined(this.autoScroll)) {
            var el = this.body || this.el;
            if (el) {
                if (Ext.isBoolean(this.autoScroll)) {
                    el.setOverflow(this.autoScroll ? 'auto' : 'hidden');
                } else {
                    el.setOverflow('auto', this.autoScroll);
                    var axis = this.autoScroll ? this.autoScroll.toString().toUpperCase() : '';
                    if (axis == 'X') {
                        el.setOverflow('hidden', 'y');
                    } else if (axis == 'Y') {
                        el.setOverflow('hidden', 'x');
                    }
                }
            }
            return this;
        } else {
            return Ext.Container.superclass.setAutoScroll.apply(this, arguments);
        }
    }
});
Ext.menu.Item.prototype.setTooltip = function (tooltip, initial) {
    if (this.rendered) {
        if (!initial) {
            this.clearTip();
        }
        if (Ext.isObject(tooltip)) {
            Ext.QuickTips.register(Ext.apply({target: this.el.id}, tooltip));
            this.tooltip = tooltip;
        } else {
            this.el.dom['qtip'] = tooltip;
        }
    } else {
        this.tooltip = tooltip;
    }
    return this;
};
Ext.menu.Item.prototype.clearTip = function () {
    if (Ext.isObject(this.tooltip)) {
        Ext.QuickTips.unregister(this.el);
    }
};
delete Pan.st;
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GridRecordForm = Ext.extend(Pan.base.container.FormPanel, {
    record: undefined,
    recordBinder: undefined,
    editRecord: undefined,
    autoHide: true,
    cancelIconCls: 'icon-cancel',
    cancelText: _T('Cancel'),
    columnCount: 1,
    defaultFormConfig: {border: false, frame: true, labelWidth: 100, layoutConfig: {trackLabels: true}},
    defaultWindowConfig: {border: false, width: 480, autoHeight: true, modal: true, showLoadingIndication: true},
    focusDefer: 200,
    okIconCls: 'icon-ok',
    okText: _T('OK'),
    showButtons: true,
    afterUpdateRecord: Ext.emptyFn,
    afterUpdateFailure: Ext.emptyFn,
    submitInProgress: false,
    formTheme: Pan.base.Constants.formThemes[0],
    protectionChanged: false,
    processAdd: function (c) {
        if (this.isField(c)) {
            this.form.add.apply(this.form, this.findBy(this.isField));
        } else {
            Pan.base.autorender.GridRecordForm.superclass.processAdd.apply(this, arguments);
        }
    },
    initComponent: function () {
        if (this.recordFormOverride) {
            this.recordForm = Ext.apply({}, this.recordFormOverride, this.recordForm);
            this.windowConfig = Ext.apply({}, this.recordFormOverride.windowConfig, this.windowConfig);
        }
        Ext.apply(this, {loadMask: Ext.isDefined(this.loadMask) ? this.loadMask : true});
        this.__pdefaults = Ext.applyIf({
            __saveImmediately: this.recordForm.saveImmediately ? this.onOK.createDelegate(this) : null,
            __renameable: this.recordForm.renameable,
            __allowBlankValidation: Ext.isDefined(this.recordForm.allowBlankValidation) ? this.recordForm.allowBlankValidation : true
        }, this.__pdefaults);
        Ext.applyIf(this.__pdefaults, this.recordForm.additionalPdefaults);
        this.setupRecord();
        Ext.applyIf(this.__pdefaults, {
            __fields: this.fields,
            __fieldsByPath: this.store.fieldsByPath,
            __rbaPath: this.rbaPath,
            __treePath: this.treePath,
            __configStates: this.configStates,
            __recordForm: this,
            __topStore: this.store
        });
        Ext.apply(this.__pdefaults, {
            __dataExtractor: function (fieldName, callChain, args) {
                var item = this.getForm().findField(fieldName);
                if (item) {
                    if (callChain === undefined) {
                        callChain = "getValue";
                    } else if (callChain === "") {
                        return item;
                    }
                    return Pan.callChain(item, callChain, args);
                } else if (this.dataExtractor) {
                    return this.dataExtractor(fieldName, callChain, args);
                }
            }.createDelegate(this)
        });
        var windowConfig = Ext.apply({}, this.windowConfig, this.defaultWindowConfig);
        if (windowConfig.autoScroll === true || windowConfig.autoScroll === 'y') {
            this.bodyStyle = 'overflow-y: auto';
        } else {
            this.recordFormAutoHeight = windowConfig.autoHeight;
            Ext.apply(this.__pdefaults, {__recordFormAutoHeight: this.recordFormAutoHeight});
        }
        this.createShellConfig();
        this.createFormConfig();
        if (this.isInWindow) {
            this.addListener({
                'afterlayout': {
                    fn: function () {
                        if (this.windowConfig.loadMask) {
                            this.windowConfig.loadMask.hide();
                            this.windowConfig.loadMask.destroy();
                            this.removeListener('afterlayout', arguments.callee, this);
                            if (this.umt) {
                                this.umt.cancel();
                            }
                        }
                    }
                }, scope: this
            });
        }
        Pan.base.autorender.GridRecordForm.superclass.initComponent.apply(this, arguments);
        this.loadRecord();
    },
    setupRecord: function () {
        if (!this.editRecord && this.record) {
            var record = this.record;
            if (Ext.isArray(record)) {
                record = record[0];
            }
            this.editRecord = record.store.beginEdit(record, {
                readOnly: this.recordForm && this.recordForm.readOnly,
                additionalInput: this.recordForm && this.recordForm.additionalInput
            });
            this.__pdefaults = this.__pdefaults || {};
            Ext.applyIf(this.__pdefaults, {__fields: this.fields || this.editRecord.fields});
            Ext.apply(this.__pdefaults, {__recordFormRecord: this.editRecord});
        }
    },
    loadRecord: function () {
        if (this.editRecord) {
            this.ensureData(this.editRecord, function (rec) {
                var basicForm = this.getForm();
                if (this.showWindowAfterLoadRecord) {
                    basicForm.loadRecord(rec);
                }
                if (this.isInWindow) {
                    if (!this.window) {
                        this.window = this.createWindow();
                    }
                    this.window.show();
                } else {
                    this.form.fireAfterInit();
                }
                var recordDetail = Pan.appframework.PanAppInterface.getRecordDetail(rec);
                if (this.recordForm.isProtected || recordDetail.isRecordProtected) {
                    this.protect();
                }
                if (this.window) {
                    recordDetail = Pan.appframework.PanAppInterface.getRecordDetail(this.record || this.editRecord);
                    var title = this.window.initialConfig.title || this.window.title;
                    if (recordDetail.recordTitle) {
                        title = title || "";
                        title += " - " + recordDetail.recordTitle;
                    }
                    var readOnly = this.readOnly || !Pan.appframework.PanAppInterface.hasEditPermission(this.__pdefaults.__rbaPath, this.editRecord);
                    if (readOnly) {
                        title = title || "";
                        if (!this.recordForm.ignoreHasEditPermissionResult)
                            title += " (" + _T("Read Only") + ")";
                    }
                    this.window.setTitle(title);
                }
                if (!this.showWindowAfterLoadRecord) {
                    basicForm.loadRecord(rec);
                }
                this.initValueChanged();
                if (this.recordForm.recordFormPostLoadChangeCallback) {
                    this.recordForm.recordFormPostLoadChangeCallback(this);
                }
                if (!this.window || this.window.autoHeight) {
                    this.syncFloatingShadow();
                } else {
                    this.window.doLayout();
                }
                if (this.isInWindow && this.windowConfig.centerWindowAfterLoadRecord) {
                    Pan.base.util.invokeLater(10, function () {
                        this.window.center();
                    }, this);
                }
                if (this.el) {
                    this.mon(this.el, "mouseover", this.mouseOver, this);
                }
            }, this);
        }
    },
    currentHelpTipCmpEl: null,
    currentHelpTipNode: null,
    mouseOver: function (event, target) {
        if (target && target.className && Ext.isFunction(target.className.indexOf) && target.className.indexOf('x-form-item-label-help') < 0) {
            var helpTipCmpEl = Ext.fly(target).findParent('.x-form-item-with-help', 10, true);
            if (helpTipCmpEl !== this.currentHelpTipCmpEl) {
                if (this.currentHelpTipNode) {
                    this.currentHelpTipNode.className += " x-hide-display";
                    this.currentHelpTipCmpEl = null;
                    this.currentHelpTipNode = null;
                }
                if (helpTipCmpEl && helpTipCmpEl.dom.parentNode) {
                    var helpTipNode = Ext.fly(helpTipCmpEl.dom.parentNode).select(".x-form-item-label-help.x-hide-display");
                    if (helpTipNode && helpTipNode.elements && helpTipNode.elements.length > 0) {
                        helpTipNode = helpTipNode.elements[0];
                        helpTipNode.className = helpTipNode.className.replace('x-hide-display', '');
                        this.currentHelpTipCmpEl = helpTipCmpEl;
                        this.currentHelpTipNode = helpTipNode;
                    }
                }
            }
        }
    },
    createFormConfig: function () {
        this.rfLayoutConfig = this.rfLayoutConfig || (this.recordForm && this.recordForm.rfLayoutConfig) || (this.recordFormAutoHeight ? Pan.base.autorender.layout.RFColumnLayoutConfig : Pan.base.autorender.layout.RFTableLayoutConfig);
        this.rfLayoutConfigParam = this.rfLayoutConfigParam || this.recordForm;
        var fields = this.store.recordType.prototype.fields.items;
        if (Ext.isDefined(this.recordForm.readOnly)) {
            this.readOnly = this.recordForm.readOnly;
            this.__pdefaults.__readOnly = this.readOnly;
        } else if (Ext.isFunction(this.recordForm.isReadOnly)) {
            this.readOnly = this.recordForm.isReadOnly();
            this.__pdefaults.__readOnly = this.readOnly;
        } else {
            this.readOnly = false;
            if (this.__pdefaults.__recordFormRecord) {
                this.readOnly = !Pan.appframework.PanAppInterface.hasEditPermission(this.__pdefaults.__rbaPath, this.__pdefaults.__recordFormRecord);
                this.__pdefaults.__readOnly = this.readOnly;
            }
        }
        var items = [], index, o;
        if (this.recordForm) {
            Ext.apply(this, this.recordForm.formConfig);
            for (index = 0; index < this.recordForm.items.length; index++) {
                o = Ext.apply({}, this.recordForm.items[index]);
                items.push(o);
            }
        } else {
            for (index = 0; index < fields.length; index++) {
                var f = fields[index];
                o = Ext.apply({}, {itemId: f.name});
                items.push(o);
            }
        }
        this.items = items;
        var foundTheme = false;
        this.cls = this.cls || "";
        if (this.recordForm.cls) {
            this.cls += " " + this.recordForm.cls;
        }
        for (var i = 0; i < Pan.base.Constants.formThemes.length; i++) {
            if (this.cls.indexOf(Pan.base.Constants.formThemes[i]) >= 0) {
                foundTheme = true;
            }
        }
        if (!foundTheme) {
            this.cls += ' ' + this.formTheme;
        }
        if (this.additionalCls) {
            this.cls += ' ' + this.additionalCls;
        }
    },
    setProgress: function (value, hide) {
        var progressBar = this.fbar.findByItemId("progressbar");
        if (progressBar) {
            progressBar.setVisible(!hide);
            progressBar.setValue(value);
        }
    },
    createShellConfig: function () {
        if (this.showButtons) {
            if (!this.buttons) {
                var buttons = [];
                Ext.apply(this, {buttons: buttons, buttonAlign: 'left'});
                buttons.push(Ext.create({
                    hidden: true,
                    itemId: "progressbar",
                    'xtype': 'pan-progress',
                    width: 100,
                    height: 20
                }));
                if (this.recordForm.customButtons) {
                    var bShowOnlyCustomButtons = Ext.isDefined(this.recordForm.showOnlyCustomButtons) && this.recordForm.showOnlyCustomButtons;
                    if (bShowOnlyCustomButtons) {
                        buttons.push("->");
                    }
                    for (var i = 0; i < this.recordForm.customButtons.length; i++) {
                        var btn = this.recordForm.customButtons[i];
                        buttons.push(Pan.createAction(btn, btn.scope || this));
                    }
                    if (bShowOnlyCustomButtons) {
                        return;
                    }
                }
                buttons.push("->", {
                    xtype: 'pan-button',
                    cls: 'default-btn',
                    hidden: this.recordForm.hideOK || this.hideOK,
                    text: this.recordForm.okText || this.okText,
                    iconCls: this.okIconCls,
                    listeners: {scope: this, click: this.onOK, delay: 100},
                    formBind: true,
                    id: this.id + this.okText
                }, {
                    xtype: 'pan-button',
                    hidden: this.recordForm.hideCancel || this.hideCancel,
                    text: this.recordForm.cancelText || this.cancelText,
                    iconCls: this.cancelIconCls,
                    scope: this,
                    handler: this.onCancel,
                    id: this.id + this.cancelText
                }, "-", "-");
                Ext.applyIf(this, {
                    keys: [{key: [10, 13], scope: this, stopEvent: false, fn: this.onOK}, {
                        key: [27],
                        scope: this,
                        stopEvent: false,
                        fn: this.onCancel
                    }]
                });
            }
        }
        Ext.applyIf(this, this.defaultFormConfig);
    },
    onDestroy: function () {
        if (this.window) {
            if (this.store) {
                this.store.removeListener("receivednotification", this.onReceivedNotification, this);
            }
            Pan.base.WindowFocusInfo.remove();
            this.window.destroy();
            this.window = null;
        }
        if (this.el) {
            this.el.removeListener("mouseover", this.mouseOver, this);
        }
        Pan.base.autorender.GridRecordForm.superclass.onDestroy.apply(this, arguments);
    },
    onOK: function (key, event) {
        if (event && event.getTarget) {
            var target = event.getTarget();
            if (target.type == "textarea" || this.ignoreKey(target)) {
                return;
            }
        }
        var showConfirmationOnOK = this.recordForm.showConfirmationOnOK;
        if (Ext.isFunction(showConfirmationOnOK)) {
            var scope = this.scope || this;
            showConfirmationOnOK.call(scope, this, this.onOKImp.createDelegate(this, [key, event]), this.onCancel.createDelegate(this, [key, event]));
        } else {
            this.onOKImp(key, event);
        }
    },
    onOKImp: function (key, event) {
        var log = PanLogging.getLogger('base:GridRecordForm');
        if (this.submitInProgress) {
            return;
        }
        var r = this.editRecord;
        if (r && !r.phantom) {
            if (!r.store.getById(r.id)) {
                Pan.Msg.alert(_T('Error'), _T('This item no longer exists and may have been deleted by another user.'));
                return;
            }
        }
        this.submitInProgress = true;
        if (this.recordForm.ignoreValidationResult || this.isValid()) {
            var okCallback = this.recordForm.okCallback || this.okCallback;
            if (Ext.isFunction(okCallback)) {
                var scope = this.scope || this;
                if (!okCallback.call(scope, this)) {
                    this.submitInProgress = false;
                    return;
                }
            }
            this.saveMask = new Pan.base.widgets.LoadMask(this.getEl(), {msg: _T('Saving...')});
            this.saveMask.show();
            try {
                var updateRecord = this.recordForm.updateRecord || this.updateRecord;
                updateRecord.call(this, (function (success) {
                    this.submitInProgress = false;
                    this.saveMask.hide();
                    this.saveMask.destroy();
                    if (success) {
                        if (this.autoHide && this.isInWindow) {
                            this.window.close();
                            Pan.base.WindowFocusInfo.clear();
                        }
                        var afterUpdateRecord = this.recordForm.afterUpdateRecord || this.afterUpdateRecord;
                        afterUpdateRecord.call(this, this.editRecord);
                    } else {
                        var afterUpdateFailure = this.recordForm.afterUpdateFailure || this.afterUpdateFailure;
                        afterUpdateFailure.call(this, this.editRecord);
                    }
                    return success;
                }.createDelegate(this)));
            } catch (error) {
                this.submitInProgress = false;
                this.saveMask.hide();
                this.saveMask.destroy();
                if (error instanceof Pan.base.autorender.SaveError) {
                    Pan.Msg.confirm(_T("Save Error"), error.msg + "<br>" + error.recoveryDetail, function (answer) {
                        if (answer === "yes") {
                            error.saveRecovery();
                        }
                    }, this);
                } else {
                    log.error(error);
                }
            }
        } else {
            this.submitInProgress = false;
        }
    },
    onCancel: function (key, event) {
        if (event && this.ignoreKey(event.target)) {
            return;
        }
        var scope = this.scope || this;
        var cancelCallback = this.recordForm.cancelCallback || this.cancelCallback;
        if (Ext.isFunction(cancelCallback)) {
            if (!cancelCallback.call(scope, this)) {
                return;
            }
        }
        if (this.editRecord) {
            this.editRecord.store.cancelEdit(this.editRecord);
        }
        var postCancelCallback = this.recordForm.postCancelCallback || this.postCancelCallback;
        if (Ext.isFunction(postCancelCallback)) {
            if (!postCancelCallback.call(scope, this)) {
                return;
            }
        }
        if (this.autoHide && this.isInWindow && this.window) {
            this.window.close();
        }
    },
    ignoreKey: function (target) {
        while (target) {
            if (target.className && (target.className.indexOf("x-ignore-key-enter") >= 0 || target.className.indexOf("x-cell-editable") >= 0 || target.className.indexOf("x-grid3-focus") >= 0)) {
                return true;
            }
            target = target.parentNode;
        }
        return false;
    },
    bindHandler: function () {
        if (!this.recordForm.ignoreValidationResult) {
            var valid = this.isValid();
            if (this.fbar) {
                var fitems = this.fbar.items.items;
                for (var i = 0, len = fitems.length; i < len; i++) {
                    var btn = fitems[i];
                    if (btn.formBind === true && btn.disabled === valid) {
                        btn.setDisabled(!valid);
                    }
                }
            }
            this.fireEvent('clientvalidation', this, valid);
        }
    },
    isValid: function () {
        var valid = true;
        if (valid) {
            var components = this.findBy(function (c) {
                return c.resetValidationMarking !== undefined;
            });
            if (components) {
                for (var i = 0; i < components.length; i++) {
                    var comp = components[i];
                    comp.resetValidationMarking();
                }
            }
            var me = this;
            var changedFields = [];
            var skipSaveFields = this.editRecord && this.editRecord.__skipSaveFields;
            this.form.items.each(function (f) {
                if (f.hasValueChanged) {
                    var changedValue = f.hasValueChanged();
                    if (changedValue) {
                        if (me.__pdefaults.__saveImmediately || me.__pdefaults.__topStore.includeFieldPathsInSave || me.store.includeFieldPathsInSave) {
                            f.initValueChanged();
                            changedFields.push(Ext.isObject(changedValue) ? changedValue : f);
                        } else {
                            if (me.editRecord) {
                                delete me.editRecord.isCompletelyEmpty;
                            }
                        }
                    }
                }
                if (!f.ignoreValidationResult) {
                    if (f.__field && skipSaveFields && skipSaveFields.containsKey(f.__field.name)) {
                        return;
                    }
                    if (!f.isValid(true)) {
                        var continueChecking = false;
                        var ownerCt = f;
                        while (ownerCt && ownerCt.ownerCt && ownerCt.ownerCt !== me) {
                            if (!f.rendered && ownerCt.ownerCt.layout.deferredRender && ownerCt.ownerCt.layout.fastRender) {
                                return;
                            }
                            var inNonActiveRadioCard = ownerCt.ownerCt.layout.type === 'radiocard' && ownerCt.ownerCt.layout.activeItem !== ownerCt;
                            if (inNonActiveRadioCard) {
                                return;
                            }
                            if (ownerCt.ownerCt.checkbox && !ownerCt.ownerCt.checkbox.dom.checked) {
                                return;
                            }
                            if (!ownerCt.isAvail()) {
                                return;
                            }
                            if (ownerCt.ownerCt.setInvalidMarking && f.el) {
                                ownerCt.ownerCt.setInvalidMarking(ownerCt, f.el.hasClass(f.requiredFieldClass));
                                continueChecking = true;
                            }
                            ownerCt = ownerCt.ownerCt;
                        }
                        valid = false;
                        return continueChecking;
                    }
                }
            });
            if (changedFields.length > 0) {
                for (var j = 0; j < changedFields.length; j++) {
                    var changedField = changedFields[j];
                    if (changedField.__field) {
                        if (me.store.includeFieldPathsInSave) {
                            me.store.markFieldAsChanged(changedField.__field);
                        }
                        if (me.__pdefaults.__topStore.includeFieldPathsInSave) {
                            me.__pdefaults.__topStore.markFieldAsChanged(changedField.__field);
                        }
                    }
                    if (me.__pdefaults.__saveImmediately) {
                        me.store.additionalInput = me.store.additionalInput || {};
                        Ext.apply(me.store.additionalInput, {"fieldPath": changedField.attrPath});
                        me.__pdefaults.__saveImmediately();
                    }
                }
            }
        }
        if (valid && this.__pdefaults.__recordFormRecord && this.recordForm.ignoreHasEditPermissionResult != true) {
            valid = Pan.appframework.PanAppInterface.hasEditPermission(this.__pdefaults.__rbaPath, this.__pdefaults.__recordFormRecord);
        }
        if (valid && !this.protectionChanged) {
            if (this.isProtected()) {
                valid = false;
            }
        }
        return valid;
    },
    createWindow: function () {
        if (!this.window) {
            if (this.store.hasEvent("receivednotification")) {
                this.store.addListener("receivednotification", this.onReceivedNotification, this);
            }
            if (Ext.isDefined(this.isCheckAutoRefreshAfterWrite)) {
                this.store.setCheckAutoRefreshAfterWrite(this.isCheckAutoRefreshAfterWrite);
            }
            var cmp = this;
            for (var i = 0; i < 3; i++) {
                if (cmp.items && cmp.items.length === 1) {
                    cmp = cmp.items.get(0);
                    if (cmp.layout && cmp.layout.type === 'tabcard') {
                        this.addClass('darkblue-container');
                        break;
                    }
                }
            }
            if (!Ext.isDefined(this.defaultButton) && Ext.isArray(this.buttons)) {
                for (var j = 0; j < this.buttons.length; j++) {
                    var btn = this.buttons[j];
                    if (Ext.isObject(btn)) {
                        if (btn.isDefaultButton) {
                            this.defaultButton = btn.id;
                            if (!btn.cls) {
                                btn.cls = 'default-btn';
                            }
                            break;
                        } else if (btn.cls && btn.cls.indexOf('default-btn') >= 0) {
                            this.defaultButton = btn.id;
                            break;
                        }
                    }
                }
            }
            var config = Ext.apply({
                gridRecordForm: this,
                xtype: 'pan-window',
                title: this.title,
                iconCls: this.iconCls,
                itemId: this.initialConfig.treePath ? this.initialConfig.treePath + "-window" : undefined,
                defaultButton: this.defaultButton,
                items: this,
                listeners: {
                    beforeshow: {
                        scope: this, fn: function () {
                            this.startMonitoring();
                        }
                    }, show: {
                        scope: this, delay: this.focusDefer, fn: function () {
                            this.setupTabIndex();
                            var lastFocusId = this.id + this.cancelText;
                            var result = Ext.fly(lastFocusId);
                            if (result) {
                                result = result.select('.x-btn-text');
                            }
                            if (result && result.elements && result.elements[0]) {
                                lastFocusId = result.elements[0].id;
                            }
                            Pan.base.WindowFocusInfo.startRecording(this.el.id, lastFocusId);
                            var basicForm = this.getForm();
                            basicForm.items.itemAt(0).focus();
                            if (!this.recordForm.ignoreValidationResult) {
                                basicForm.isValid();
                            }
                            this.form.fireAfterInit();
                            if (this.window.autoHeight) {
                                this.syncFloatingShadow();
                            }
                        }
                    }, hide: {
                        scope: this, fn: function () {
                            this.stopMonitoring();
                        }
                    }
                },
                closeAction: 'recordFormCancel',
                recordFormCancel: function () {
                    this.gridRecordForm.onCancel();
                },
                additionalTools: {
                    id: 'receivednotification',
                    hidden: true,
                    qtip: Pan.base.htmlEncode(_T("This object has been changed by another user.  If you save this object, the other user's change will be overwritten."))
                }
            }, this.windowConfig, this.defaultWindowConfig);
            if (Ext.isFunction(config.title)) {
                config.title = config.title.call(this, this.editRecord);
            }
            if (config.autoHeight === false) {
                Ext.applyIf(config, {layout: 'fit'});
            }
            this.window = Ext.ComponentMgr.create(config);
        }
        return this.window;
    },
    onReceivedNotification: function (store, objectNames) {
        if (this.window && this.window.tools.receivednotification) {
            if (Ext.isArray(objectNames)) {
                var nameIdProperty = store.storeInputs && store.storeInputs.nameIdProperty;
                if (nameIdProperty) {
                    var name = this.getRecord().get(nameIdProperty);
                    for (var i = 0; i < objectNames.length; i++) {
                        if (objectNames[i] === name) {
                            this.window.tools.receivednotification.show();
                        }
                    }
                }
            }
        }
    },
    protect: function () {
        this.el.addClass('x-protect');
        if (this.window) {
            this.window.el.addClass('x-protect');
        }
        this.protectionChanged = true;
    },
    unprotect: function () {
        this.el.removeClass('x-protect');
        if (this.window) {
            this.window.el.removeClass('x-protect');
        }
        this.protectionChanged = true;
    },
    isProtected: function () {
        return this.el && this.el.hasClass('x-protect');
    },
    updateRecord: function (delegate) {
        var r = this.editRecord;
        var values = this.getValue();
        r.store.endEdit(r, {
            values: values,
            action: this.recordForm.action || this.action,
            cbDelegate: delegate,
            additionalInput: this.recordForm && this.recordForm.additionalInput
        });
        if (!delegate) {
            this.afterUpdateRecord(r);
        }
    },
    ensureData: function (record, callback, scope) {
        if (this.recordForm && this.recordForm.actions) {
            var afterDataReceived = function (result) {
                var results = (result['@status'] == 'success') ? (result.result && result.result.entry) || result : false;
                if (results) {
                    var callbackPackage = this;
                    record.data[callbackPackage.action.field] = results;
                    callbackPackage.callback.call(callbackPackage.scope, callbackPackage.record);
                }
            };
            for (var i = 0; i < this.recordForm.actions.length; i++) {
                var action = this.recordForm.actions[i].action;
                var rv = this.recordBinder.getRemoteCommand(action, record);
                if (rv) {
                    this.recordBinder.directFnOverride({'arguments': [action, rv.commands]}, afterDataReceived, {
                        action: this.recordForm.actions[i],
                        record: record,
                        callback: callback,
                        scope: this
                    }, {superFunction: rv.directFn, scope: rv.directFn.directCfg.action});
                }
            }
        } else {
            callback.call(scope, record);
        }
    },
    supportPruneDataIfNotAvail: false,
    extractFormValues: function (fields, basicForm, r) {
        var values = {};
        var value;
        if (this.configStates && !Ext.isEmpty(this.configStates.supportPruneDataIfNotAvail)) {
            this.supportPruneDataIfNotAvail = this.configStates.supportPruneDataIfNotAvail;
        }
        for (var i = 0, n = fields.items.length; i < n; i++) {
            var field = fields.itemAt(i);
            var item = basicForm.findField(field.name);
            if (item) {
                if (this.supportPruneDataIfNotAvail && !item.isAvail() && !item.isVisible()) {
                    value = undefined;
                } else {
                    value = undefined;
                    if (item.extractFormValue) {
                        value = item.extractFormValue(item);
                    } else {
                        value = item.getValue();
                    }
                    if (item.customSave && Ext.isObject(value)) {
                        value.isCustomSave = true;
                    }
                }
                values[field.name] = value;
                if (r) {
                    r.data[field.name] = value;
                }
            }
        }
        return values;
    },
    getValue: function () {
        var r = this.editRecord;
        var fields = r.fields;
        var basicForm = this.getForm();
        return this.extractFormValues(fields, basicForm, r);
    },
    initValueChanged: function () {
        var basicForm = this.getForm();
        basicForm.items.each(function (f) {
            if (f.initValueChanged) {
                f.initValueChanged();
            } else {
            }
        });
        this.protectionChanged = false;
    },
    getRecord: function () {
        return this.record;
    },
    setupTabIndex: function () {
        var base = Pan.appframework.PanAppInterface.getWindowCount() - 1;
        if (base < 0) {
            base = 0;
        }
        base = base * 100;
        var selected = this.el.select("*[type],textarea");
        for (var i = 0; i < selected.elements.length; i++) {
            selected.elements[i].setAttribute('tabIndex', i + 1 + base);
        }
    }
});
Ext.reg('pan-gridrecordform', Pan.base.autorender.GridRecordForm);
Pan.base.autorender.GridRecordForm.showRecordForm = function (config, caller1) {
    config.windowConfig = config.windowConfig || {};
    config.windowConfig.loadMask = new Pan.base.widgets.LoadMask((caller1 && (caller1.el || caller1.parentEl)) || Ext.getBody(), config.windowConfig.loadMask || {msg: _T('Loading...')});
    config.windowConfig.loadMask.show();
    config.umt = new Ext.util.DelayedTask(function () {
        config.windowConfig.loadMask.hide();
        config.windowConfig.loadMask.destroy();
    });
    config.umt.delay(30000);
    Pan.base.util.invokeLater(1, function () {
        var log = PanLogging.getLogger('base:autorender:GridRecordForm');
        try {
            return new Pan.base.autorender.GridRecordForm(config);
        } catch (err) {
            log.error(err);
            config.windowConfig.loadMask.hide();
            config.windowConfig.loadMask.destroy();
        }
        return null;
    }, caller1);
};
Pan.base.WindowFocusInfo = function () {
    var focusStack = [];
    var isRecording = false;
    new Ext.KeyNav(Ext.getDoc(), {
        "tab": function (e) {
            var focusInfo = Pan.base.WindowFocusInfo.get();
            if (focusInfo) {
                var el;
                if (e.shiftKey && e.getTarget().id === focusInfo.firstFocusId) {
                    el = Ext.get(focusInfo.lastFocusId);
                    if (el) {
                        el.focus(100);
                        return false;
                    }
                } else if (!e.shiftKey && e.getTarget().id === focusInfo.lastFocusId) {
                    el = Ext.get(focusInfo.firstFocusId);
                    if (el) {
                        el.focus(100);
                        return false;
                    }
                }
                var found = false;
                var t = e.getTarget();
                while (t.parentNode) {
                    if (t.id === focusInfo.rootId) {
                        found = true;
                        break;
                    }
                    t = t.parentNode;
                }
                if (!found) {
                    if (e.shiftKey) {
                        el = Ext.get(focusInfo.lastFocusId);
                        if (el) {
                            el.focus(100);
                            return false;
                        }
                    } else {
                        el = Ext.get(focusInfo.firstFocusId);
                        if (el) {
                            el.focus(100);
                            return false;
                        }
                    }
                }
            }
            return true;
        }, scope: this
    });
    return {
        startRecording: function (rootId, lastFocusId) {
            focusStack.push({rootId: rootId, lastFocusId: lastFocusId});
            isRecording = true;
        }, isRecording: function () {
            return isRecording;
        }, record: function (firstFocusId) {
            if (this.isRecording && focusStack.length > 0) {
                isRecording = false;
                focusStack[focusStack.length - 1].firstFocusId = firstFocusId;
            }
        }, remove: function () {
            focusStack.pop();
        }, clear: function () {
            focusStack = [];
        }, get: function () {
            var index = focusStack.length - 1;
            if (index >= 0) {
                return focusStack[index];
            }
            return null;
        }
    };
}();
Ext.form.Field.prototype.onFocus = Pan.base.util.createExtension(function (e, dom) {
    if (dom) {
        if (Pan.base.WindowFocusInfo.isRecording()) {
            Pan.base.WindowFocusInfo.record(dom.id);
        }
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.form.Field.prototype.onFocus);
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GridRecordBinder = Ext.extend(Object, {
    store: undefined,
    getId: Ext.emptyFn,
    getNameId: Ext.emptyFn,
    setNameId: Ext.emptyFn,
    nameIdField: undefined,
    constructor: function (config) {
        Pan.base.autorender.GridRecordBinder.superclass.constructor.call(this, config);
        this.merge(this, config);
    },
    initialize: function () {
        var fields = this.store.fields;
        for (var i = 0, n = fields.items.length; i < n; i++) {
            var field = fields.itemAt(i);
            if (!field.children && field.childrenNames) {
                field.children = [];
                for (var j = 0; j < field.childrenNames.length; j++) {
                    field.children[j] = fields.get(field.childrenNames[j]);
                }
            }
            this.createOverride("convert", field, field.convert, this, this.readField, {fields: fields});
            var mapping = field.mapping || field.name;
            field.mutator = field.mutator || this.createMutator(mapping);
            var map = (field.mapping !== undefined && field.mapping !== null) ? field.mapping : field.name;
            field.accessor = field.accessor || this.createAccessor(map);
            var idProperty = (this.store.storeInputs && this.store.storeInputs.nameIdProperty) ? this.store.storeInputs.nameIdProperty : "id";
            if (field.name == idProperty) {
                this.nameIdField = field;
                var accessor = field.accessor;
                this.getNameId = function (rec) {
                    var r = accessor(rec);
                    return (r === undefined || r === '') ? null : r;
                };
                var mutator = field.mutator;
                this.setNameId = function (rec, val) {
                    mutator(rec, val);
                };
            }
        }
    },
    merge: function (a, b) {
        for (var item in b) {
            if (b.hasOwnProperty(item)) {
                if (a[item]) {
                    var typeofA = typeof a[item];
                    if (typeofA === typeof b[item]) {
                        if (typeofA === 'object') {
                            a[item] = Ext.apply({}, a[item]);
                            this.merge(a[item], b[item]);
                            continue;
                        }
                    }
                }
                a[item] = b[item];
            }
        }
        return a;
    },
    createOverride: function (methodName, originalObject, originalMethod, newObject, newMethod, config) {
        originalObject[methodName] = newMethod.createDelegate(newObject, {
            scope: originalObject,
            superFunction: originalMethod,
            config: config
        }, true);
    },
    createMutator: function (expr) {
        return Pan.base.PanDecode.createMutator(expr);
    },
    createAccessor: function (expr) {
        return Pan.base.PanDecode.createAccessor(expr);
    },
    readField: function (v, record, config) {
        var field = config.scope;
        if (field.dataMap) {
            var dataMapConfig = Ext.apply({
                '__v': v,
                '__record': record,
                '__recordInfo': record['@__recordInfo'],
                '__field': field,
                '__fields': config.config.fields
            }, field.dataMapArguments);
            if (Ext.isFunction(field.dataMap)) {
                v = field.dataMap.call(field.scope || this, dataMapConfig);
            } else {
                v = Pan.base.Evaluation.evaluate(field.dataMap, dataMapConfig);
            }
        }
        v = config.superFunction.call(field, v, record);
        return v;
    },
    writeField: function (record, name, value, values, additionalInput) {
        var field = record.fields.get(name);
        var useMutator = false;
        var defaultSaveMap;
        var saveMapIsUserDefined = field.initialFieldConfig && field.initialFieldConfig.saveMap;
        if (!saveMapIsUserDefined) {
            defaultSaveMap = additionalInput && additionalInput.__defaultSaveMap;
        }
        if (defaultSaveMap || (field && field.hasOwnProperty("saveMap") && field.saveMap !== "default")) {
            var saveMap = saveMapIsUserDefined ? (field.saveMap || defaultSaveMap) : (defaultSaveMap || field.saveMap);
            if (saveMap && saveMap != "") {
                var saveMapConfig = {
                    '__v': value,
                    '__record': record.json,
                    '__values': values,
                    '__name': name,
                    '__mapping': field.mapping || name,
                    '__recordInfo': record.json['@__recordInfo'],
                    '__field': field,
                    '__fields': record.fields,
                    '__fieldsByPath': this.store.fieldsByPath,
                    '__additionalInput': additionalInput,
                    '__store': record.store,
                    '__storeRecord': record
                };
                if (Ext.isFunction(saveMap)) {
                    var useDefault = saveMap.call(field.scope || this, saveMapConfig);
                    if (useDefault === "default") {
                        useMutator = true;
                    }
                } else {
                    Pan.base.Evaluation.evaluate(saveMap, saveMapConfig);
                }
                if (field.type.rconvert) {
                    value = field.accessor(record.json);
                    useMutator = true;
                }
            }
        } else {
            useMutator = true;
        }
        if (field && useMutator) {
            if (field.type.rconvert) {
                value = field.type.rconvert(value);
            }
            field.mutator(record.json, value);
        }
        return record;
    },
    preProcessResults: function (action, trans, result, res, rs) {
        var results;
        var notSuccessData = this.getFailedData(result).results;
        if (action == "read") {
            var rootField = this.store.fields.get("$");
            var successStructure = this.getSuccessData(result, rootField && rootField.rootJSONName);
            var successData = successStructure.results;
            if (notSuccessData || !successData) {
                this.reportStatus(notSuccessData ? notSuccessData : {
                    error: {
                        title: _T("Error"),
                        message: _T("Unable to read data")
                    }
                });
            } else {
                this.store.__extraInfo = successStructure.extraInfo;
                this.store.__ptpl = successStructure.ptpl;
                if (Ext.isNumber(successStructure.prefilterTotalCount)) {
                    this.store.__prefilterTotalCount = successStructure.prefilterTotalCount;
                } else {
                    delete this.store.__prefilterTotalCount;
                }
                var data = this.extractResults(successData, trans.request.arg.storeInputs, trans.request.arg.processedCommands);
                if (data && this.store.root) {
                    results = {};
                    Pan.base.PanDecode.setValue(results, this.store.root, data);
                    Pan.base.PanDecode.setValue(results, this.store.totalProperty || 'total', successStructure['total']);
                } else {
                    results = data;
                }
            }
        } else {
            if (notSuccessData) {
                if (result['@rename']) {
                    rs.newData[this.nameIdField.name] = rs.data[this.nameIdField.name];
                    rs.newJson[this.nameIdField.attrName] = rs.json[this.nameIdField.attrName];
                    rs.data = rs.newData;
                    rs.json = rs.newJson;
                    delete rs.newJson;
                    delete rs.newData;
                }
                this.reportStatus(notSuccessData);
                results = false;
            } else {
                if (action == "destroy") {
                    results = true;
                } else {
                    var resultObject = this.getSuccessData(result).results;
                    if (resultObject && resultObject.name) {
                        this.setNameId(rs.newJson, resultObject.name);
                    }
                    rs.json = rs.newJson;
                    results = rs.json;
                    delete rs.newJson;
                    delete rs.newData;
                    this.setId(results);
                    if (result['@refreshRecordAttribute']) {
                        for (var key in result['@refreshRecordAttribute']) {
                            if (result['@refreshRecordAttribute'].hasOwnProperty(key)) {
                                rs.json[key] = result['@refreshRecordAttribute'][key];
                            }
                        }
                    }
                }
            }
        }
        return results;
    },
    readRecord: function (data) {
        return data;
    },
    writeRecord: function (record, originalNameId) {
        var json = record.subpathJson || record.json;
        if (record.store && record.store.writeRecordWrap) {
            var writeRecordWrap = Pan.base.Evaluation.evaluate(record.store.writeRecordWrap, {
                '__record': record,
                '__recordInfo': record['@__recordInfo'],
                '__fields': record.store.fields
            });
            var newJson = {};
            newJson[writeRecordWrap] = json;
            json = newJson;
        }
        return json2xml(json, null);
    },
    reportStatus: function (notSuccess) {
        this.store.reportStatus(notSuccess);
    },
    getDataProxyAPI: function () {
        return this.dataProxyAPI;
    },
    getRemoteCommand: function (action, rs, additionalInput) {
        var log = PanLogging.getLogger('base:autorender:GridRecordBinder');
        var input = {}, i, j, n;
        var extraData = {};
        if (Ext.isArray(rs)) {
            var ids = [];
            for (i = 0; i < rs.length; i++) {
                ids.push(this.getNameId(rs[i].json));
            }
            Ext.apply(input, {__id: ids, __recordInfo: rs[0].json['@__recordInfo']});
        } else if (rs) {
            if (!(rs.newJson || rs.json)) {
            } else {
                var newJson = rs.newJson || rs.json;
                var originalJson = rs.json || rs.newJson;
                var originalId = this.getNameId(originalJson) || "";
                var newId = this.getNameId(newJson);
                if (!newId || newId == originalId) {
                    newId = undefined;
                }
                var data = rs.toBeCommitted ? rs.toBeCommitted.data : undefined;
                var oldData = rs.toBeCommitted ? rs.toBeCommitted.oldData : undefined;
                Ext.apply(input, {
                    __record: originalJson,
                    __id: originalId,
                    __recordInfo: originalJson['@__recordInfo'],
                    __data: data,
                    __oldData: oldData,
                    __newId: newId,
                    __newRecordInfo: newJson['@__recordInfo'],
                    __newRecord: newJson,
                    isWithinATemplate: this.store.isWithinATemplate,
                    getTemplate: this.store.getTemplate
                });
                if (rs.toBeCommitted && rs.toBeCommitted.extra) {
                    extraData['extra'] = rs.toBeCommitted.extra;
                }
            }
        }
        if (additionalInput) {
            Ext.applyIf(input, additionalInput);
        }
        Ext.applyIf(input, {__store: this.store});
        var directFn = this.getDataProxyAPI().api[action];
        if (directFn) {
            var commands, processedCommands;
            var commandParts = this[action + 'CommandParts'];
            if (commandParts && commandParts.length > 0) {
                processedCommands = this.processCommands(commandParts[0], input);
                if (processedCommands) {
                    commands = [processedCommands.length];
                    var commandPartsLength = commandParts.length;
                    var args;
                    for (i = 0, n = processedCommands.length; i < n; i++) {
                        var commandInput = Ext.applyIf(processedCommands[i], input);
                        if (commandInput["argumentsAreJSON"]) {
                            args = {};
                            for (j = 1; j < commandPartsLength; j++) {
                                args[commandParts[j]] = commandInput[commandParts[j]];
                            }
                            Ext.applyIf(args, extraData);
                        } else {
                            args = [];
                            args.push(commandParts[0]);
                            for (j = 1; j < commandPartsLength; j++) {
                                var arg = commandInput[commandParts[j]];
                                args.push(arg);
                            }
                        }
                        commands[i] = args;
                    }
                } else {
                    throw"in GridRecordBinder::getRemoteCommand: Empty processedCommand";
                }
            }
            return {action: action, directFn: directFn, commands: commands, processedCommands: processedCommands};
        } else {
            log.warn("Unable to find API for " + action);
        }
        return undefined;
    },
    getSuccessData: function (result, path) {
        var results;
        var total;
        if (Ext.isString(result) && result[0] === "<") {
            result = result.replace(/\n */g, "");
            var dom = jQuery.parseXML(result);
            var node = $("response", dom);
            if (node) {
                result = Pan.base.dom2array(node.get(0));
            }
        }
        if (!result) {
            results = false;
        } else if (result['@status']) {
            if (result['@status'] == 'success') {
                if (result.result) {
                    path = path || 'entry';
                    var pathArr = path.split('.');
                    if (pathArr.length > 1) {
                        results = Pan.callChain(result.result, path);
                        if (!results) {
                            results = [];
                        }
                    } else {
                        if (result.result[path]) {
                            if (path === 'entry') {
                                results = result.result[path];
                            } else {
                                results = [result.result[path]];
                            }
                        } else {
                            results = result;
                        }
                    }
                }
            } else {
                results = false;
            }
            if (this.store.totalProperty && result.result) {
                total = result.result[this.store.totalProperty];
            }
        } else {
            path = path || "result";
            results = Pan.base.PanDecode.panValue(result, '$[*][?(@.@status=="success")]' + (path ? "." + path : ""));
        }
        return {
            extraInfo: result && result.result && result.result.__extraInfo,
            ptpl: result && result.result && result.result.__ptpl,
            prefilterTotalCount: result && result.result && result.result['@prefilter-total-count'],
            total: total || (results && results.length),
            results: results
        };
    },
    getFailedData: function (result, path) {
        var results;
        if (!result) {
            results = true;
        } else if (result['@status']) {
            results = result['@status'] == 'success' ? false : result;
        } else {
            results = Pan.base.PanDecode.panValue(result, '$[*][?(@.@status!="success")]' + (path ? "." + path : ""));
        }
        return {results: results};
    },
    extractResults: function (successData, storeInputs, processedCommands) {
        var log = PanLogging.getLogger('base:autorender:GridRecordBinder');
        var path = storeInputs && storeInputs.resultObjectType;
        var results = [];
        if (!Ext.isArray(successData)) {
            log.info("GridRecordBinder::extractResults no data");
        } else if (successData.length === 1 && Ext.isArray(successData[0]) && successData[0].length > 0) {
            if (successData[0][0]['@__recordInfo']) {
                successData = successData[0];
            }
        }
        for (var i = 0; i < successData.length; i++) {
            var item = successData[i];
            if (Ext.isArray(item) || item[path]) {
                if (item[path]) {
                    item = item[path];
                }
                if (item['entry']) {
                    item = item['entry'];
                }
                if (Ext.isArray(item)) {
                    for (var j = 0; j < item.length; j++) {
                        if (Ext.isArray(item[j])) {
                            item[j] = {};
                        }
                        item[j]['@__recordInfo'] = item[j]['@__recordInfo'] || {};
                        Ext.apply(item[j]['@__recordInfo'], processedCommands[i]);
                        this.setId(item[j]);
                    }
                    results = results.concat(item);
                }
            } else {
                item['@__recordInfo'] = item['@__recordInfo'] ? Ext.util.JSON.decode(successData[i]['@__recordInfo']) : {};
                if (this.isData(item)) {
                    this.setId(item);
                }
                results.push(item);
            }
        }
        return results;
    },
    isData: function (data) {
        return (data && Ext.isObject(data) && !Ext.isEmpty(this.getId(data))) ? true : false;
    },
    setId: function (recordJSON) {
        if (recordJSON) {
            if (recordJSON['@__recordInfo'] === undefined) {
                recordJSON['@__recordInfo'] = {};
            }
            recordJSON['@__recordInfo'].id = this.getId(recordJSON);
        }
    },
    processCommands: function (command, additionalArgumentInputs) {
        var commandTemplate = this.preprocess(this.commandXPathTemplate[command], additionalArgumentInputs);
        return jsonPath(commandTemplate, "$[?(Ext.util.JSON.decode(@.condition) != false)]", undefined);
    },
    preprocess: function (o, additionalArgumentInputs) {
        var argumentHash = this.preprocessArguments(this.store.storeInputs, additionalArgumentInputs);
        var copyOfO = Pan.base.clone(o);
        Pan.base.Evaluation.visitAndEvaluate(copyOfO, argumentHash);
        return copyOfO;
    },
    preprocessArguments: function (args, additionalArgumentInputs) {
        var copyOfArgs = Pan.base.clone(args);
        if (additionalArgumentInputs) {
            Ext.apply(copyOfArgs, additionalArgumentInputs);
        }
        for (var m in args) {
            copyOfArgs[m] = Pan.base.Evaluation.evaluate(copyOfArgs[m], copyOfArgs);
        }
        return copyOfArgs;
    }
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GridRecordStore = Pan.base.util.cextend(Ext.ux.grid.livegrid.Store, "isLiveGrid", {
    __cloneable__: false,
    recordBinder: undefined,
    liveGridStoreSize: 1000000,
    isCheckAutoRefreshAfterWrite: true,
    isStoreLoaded: false,
    useSerializationToClone: true,
    autoDestroy: true,
    supportLocalPaging: false,
    pagingSnapshot: undefined,
    localPagingParams: undefined,
    includeFieldPathsInSave: true,
    useFilters: false,
    constructor: function (config) {
        this.addEvents('localPagingChanged', 'afterload', 'receivednotification', 'bulkremove');
        config = config || {};
        this.initialConfig = Ext.apply({}, config);
        config.bufferSize = (config.storeInputs && config.storeInputs.bufferSize) || this.liveGridStoreSize;
        if (config.storeInputs && Ext.isDefined(config.storeInputs.useSerializationToClone)) {
            config.useSerializationToClone = config.storeInputs.useSerializationToClone;
        }
        config.batchTransactions = false;
        this.recordBinderOverride = Ext.apply({}, this.recordBinderOverrideConfig);
        if (config.recordBinderOverride) {
            Ext.apply(this.recordBinderOverride, config.recordBinderOverride);
            delete config.recordBinderOverride;
        }
        this.recordBinder = this.createRecordBinder(this.recordBinderOverride);
        var reader = (!Ext.isDefined(config.reader) && config.fields) ? new Pan.base.autorender.GridDataReader(Ext.copyTo({}, config, 'totalProperty,root,idProperty,isLiveGrid'), config.fields) : config.reader;
        reader.recordBinder = this.recordBinder;
        if (Ext.isDefined(config.localStore)) {
            this.localStore = config.localStore;
        }
        var proxy = config.proxy;
        if (!Ext.isDefined(proxy)) {
            if (this.recordBinder.directFnOverride) {
                proxy = new Pan.base.autorender.GridDirectProxy(Ext.apply({recordBinder: this.recordBinder}, this.recordBinder.getDataProxyAPI(), {
                    directFn: config.directFn,
                    api: config.api
                }));
            } else {
                proxy = new Ext.data.DirectProxy(Ext.copyTo({}, config, 'paramOrder,paramsAsHash,directFn,api'));
            }
        }
        Ext.apply(config, {
            proxy: proxy,
            reader: reader,
            writer: this.localStore ? undefined : new Ext.data.JsonWriter()
        });
        Pan.base.autorender.GridRecordStore.superclass.constructor.call(this, config);
        this.recordBinder.initialize();
        if (this.supportAutoRefresh) {
            Ext.applyIf(this, this.autoRefreshConfig);
            this.addListener({
                scope: this, beforeload: function () {
                    this.pollingInProgress = true;
                }, load: function () {
                    this.pollingInProgress = false;
                    this.autoRefresh();
                }, exception: function () {
                    this.pollingInProgress = false;
                    this.autoRefresh();
                }
            });
        }
    },
    enableUseFilter: function () {
        this.useFilters = true;
        if (this.filters) {
            return;
        }
        this.filters = new Ext.util.MixedCollection(false);
        this.addEvents('addfilter', 'updatefilter', 'deletefilter', 'clearfilter', 'onfilter');
        this.addListener('addfilter', this.addStoreFilter, this);
        this.addListener('updatefilter', this.updateStoreFilter, this);
        this.addListener('deletefilter', this.deleteStoreFilter, this);
        this.addListener('clearfilter', this.clearStoreFilter, this);
        this.on('update', function (store, record, type) {
            if (!record.phantom && type == 'edit' && store.data) {
                if (Ext.isFunction(store.__filterFn)) {
                    var recs = this.filterRecords(record);
                    if (recs.length == 0) {
                        var index = store.indexOf(record);
                        if (index > -1) {
                            store.data.removeAt(index);
                            store.fireEvent('datachanged', this);
                        }
                    } else if (store.indexOf(record) < 0 && store.snapshot && store.snapshot.indexOf(record) > 0) {
                        store.data.add(record);
                        store.fireEvent('datachanged', this);
                    }
                }
            }
        }, this);
    },
    addStoreFilter: function (filterfuncs) {
        this.addFilters(filterfuncs);
        this.onFilter();
    },
    updateStoreFilter: function (id, values, func, operator) {
        if (this.filters.containsKey(id)) {
            this.filters.removeKey(id);
        }
        this.filters.add({id: id, values: values, fn: func, opt: operator || '='});
        this.onFilter();
    },
    deleteStoreFilter: function (filterids) {
        this.deleteFilters(filterids);
        this.onFilter();
    },
    deleteFilters: function (filterids) {
        filterids = [].concat(filterids);
        for (var i = 0; i < filterids.length; i++) {
            if (Ext.isObject(filterids[i]) && Ext.isDefined(filterids[i]['id'])) {
                this.filters.removeKey(filterids[i]['id']);
            } else {
                this.filters.removeKey(filterids[i]);
            }
        }
    },
    addFilters: function (filterfuncs) {
        filterfuncs = [].concat(filterfuncs);
        for (var i = 0; i < filterfuncs.length; i++) {
            if (this.filters.containsKey(filterfuncs[i]['id'])) {
                this.filters.removeKey(filterfuncs[i]['id']);
            }
            this.filters.add(filterfuncs[i]);
        }
    },
    clearStoreFilter: function () {
        this.filters.clear();
        this.onFilter();
    },
    onFilter: function () {
        var filter;
        if (this.filters.length == 0) {
            filter = null;
            this.clearFilter();
        } else {
            filter = this.createMultipleFilterFn(this.filters.items);
            this.filterBy(filter);
        }
        this.__filterFn = filter;
        this.fireEvent('onfilter', this, this.__filterFn, this.filters ? this.filters.keys : null);
    },
    filterRecords: function (records) {
        if (Ext.isFunction(this.__filterFn)) {
            if (!Ext.isArray(records)) {
                records = [records];
            }
            var recs = [];
            for (var i = 0, len = records.length; i < len; i++) {
                if (this.__filterFn.call(this.grid, records[i], records[i].id)) {
                    recs.push(records[i]);
                }
            }
            records = recs;
        }
        return records;
    },
    clearFilters: function () {
        if (this.filters) {
            this.filters.clear();
        }
        delete this.__filterFn;
        this.__filterFn = null;
    },
    supportAutoRefresh: false,
    autoRefreshConfig: {
        autoRefreshData: [[10 * 1000, _T('10 Seconds')], [30 * 1000, _T('30 Seconds')], [60 * 1000, _T('60 Seconds')], [0, _T('Manual')]],
        autoRefreshTime: 0,
        autoRefresh: function (refreshTime) {
            if (Ext.isDefined(refreshTime)) {
                this.autoRefreshTime = refreshTime;
            }
            if (this.autoRefreshTime > 0) {
                if (!this.autoRefreshTask) {
                    this.autoRefreshTask = new Ext.util.DelayedTask(function () {
                        if (!this.pollingInProgress) {
                            if (Ext.isFunction(this[this.reloadMethod])) {
                                this[this.reloadMethod]();
                            } else {
                                this.reload();
                            }
                        }
                    }, this);
                }
                this.autoRefreshTask.delay(this.autoRefreshTime);
            } else {
                if (this.autoRefreshTask) {
                    this.autoRefreshTask.cancel();
                }
            }
        }
    },
    destroy: function () {
        if (this.autoRefreshTask) {
            this.autoRefreshTask.cancel();
            delete this.autoRefreshTask;
        }
        if (this.useFilters) {
            this.clearFilters();
            this.filters = null;
        }
        Pan.base.autorender.GridRecordStore.superclass.destroy.apply(this, arguments);
    },
    setCheckAutoRefreshAfterWrite: function (isCheckAutoRefreshAfterWrite) {
        this.isCheckAutoRefreshAfterWrite = isCheckAutoRefreshAfterWrite;
    },
    findInLeafFields: function (json1, json2) {
        var inBothFields = [];
        var inJson1Fields = [];
        var inJson2Fields = [];
        for (var i = 0; i < this.fields.items.length; i++) {
            var field = this.fields.items[i];
            var result = this.findInLeafField(field, json1, json2);
            if (Ext.isDefined(result[0])) {
                inJson1Fields.push(field);
                if (Ext.isDefined(result[1])) {
                    inJson2Fields.push(field);
                    inBothFields.push(field);
                }
            } else if (Ext.isDefined(result[1])) {
                inJson2Fields.push(field);
            }
        }
        return {inBothFields: inBothFields, inJson1Fields: inJson1Fields, inJson2Fields: inJson2Fields};
    },
    findInLeafField: function (field, json1, json2) {
        if (field.attrPath && (!field.children || field.supportsFindInLeafField === true || field.isNonleaf !== true)) {
            var v1, v2, value1, value2;
            var attrPath = field.attrPath;
            if (field.choiceParentAttr) {
                value1 = field.choiceParentAttr.getData(json1);
                if (value1) {
                    for (v1 in value1) {
                        if (value1.hasOwnProperty(v1)) {
                            break;
                        }
                    }
                }
                value2 = field.choiceParentAttr.getData(json2);
                if (value2) {
                    for (v2 in value2) {
                        if (value2.hasOwnProperty(v2)) {
                            break;
                        }
                    }
                }
            } else {
                value1 = jsonPath(json1, attrPath);
                if (value1) {
                    v1 = value1[0];
                }
                value2 = jsonPath(json2, attrPath);
                if (value2) {
                    v2 = value2[0];
                }
            }
            return [v1, v2];
        }
        return [];
    },
    createRecordBinder: function (config) {
        return new Pan.base.autorender.GridRecordBinder(Ext.apply({store: this}, config));
    },
    reportStatus: function () {
    },
    rebuildExtractors: function () {
        this.reader.rebuildExtractors();
    },
    getRealIndex: function (index) {
        return this.isLiveGrid ? this.bufferRange[0] + index : index;
    },
    copyRecordData: function (src, dst) {
        var srcConfig = dst.json[Pan.common.Constants.attrSrc];
        var ptplConfig = dst.json[Pan.common.Constants.attrPtpl];
        var recordInfo = dst.json['@__recordInfo'];
        dst.json = this.cloneJSON(src.json);
        dst.json[Pan.common.Constants.attrSrc] = srcConfig;
        dst.json[Pan.common.Constants.attrPtpl] = ptplConfig;
        dst.json['@__recordInfo'] = recordInfo;
        dst.data = Ext.apply({}, src.data);
    },
    cloneRecord: function (r) {
        var copy = r.copy();
        copy.json = this.cloneJSON(r.json);
        copy.fields = r.fields;
        copy.phantom = r.phantom;
        copy.store = r.store;
        return copy;
    },
    cloneJSON: function (originalRecordJson) {
        return Pan.base.clone(originalRecordJson);
    },
    move: function (record, whereTo, destinationRecord) {
        if (this.localStore) {
            if (record !== destinationRecord) {
                this.remove(record);
                var offset = (whereTo == 'after') ? 1 : 0;
                this.insert(this.indexOf(destinationRecord) + offset, record);
            }
            return;
        }
        var firstRecord = record, lastRecord = record;
        var i, min = Math.max(0, this.getCount() - 1), max = 0;
        if (Ext.isArray(record)) {
            for (i = 0; i < record.length; i++) {
                var index = this.indexOf(record[i]);
                if (index < min) {
                    min = index;
                    firstRecord = record[i];
                }
                if (index > max) {
                    max = index;
                    lastRecord = record[i];
                }
            }
        }
        switch (whereTo) {
            case'up':
                if (min == 0) {
                    whereTo = 'top';
                    destinationRecord = this.getAt(0);
                } else {
                    whereTo = 'before';
                    destinationRecord = this.getAt(min - 1);
                }
                break;
            case'down':
                if (max >= this.getCount() - 1) {
                    whereTo = 'bottom';
                    destinationRecord = this.getAt(this.getCount() - 1);
                } else {
                    whereTo = 'after';
                    destinationRecord = this.getAt(max + 1);
                }
                break;
            case'top':
                destinationRecord = this.getAt(0);
                break;
            case'bottom':
                destinationRecord = this.getAt(this.getCount() - 1);
                break;
            case'before':
                break;
            case'after':
                break;
            default:
                break;
        }
        if (Ext.isArray(record)) {
            for (i = 0; i < record.length; i++) {
                record[i].toBeCommitted = {
                    action: "move",
                    destinationRecord: destinationRecord,
                    whereTo: whereTo,
                    additionalInput: {
                        whereTo: whereTo,
                        destinationId: this.recordBinder.getNameId(destinationRecord.json)
                    }
                };
            }
        } else {
            record.toBeCommitted = {
                action: "move",
                destinationRecord: destinationRecord,
                whereTo: whereTo,
                additionalInput: {whereTo: whereTo, destinationId: this.recordBinder.getNameId(destinationRecord.json)}
            };
        }
        this.remove(record);
    },
    getEditRecordJSON: function (originalRecord, config) {
        return originalRecord.json;
    },
    beginEdit: function (originalRecord, config) {
        originalRecord.beginEdit();
        var r = originalRecord.copy();
        var originalRecordJson = this.getEditRecordJSON(originalRecord, config);
        if (originalRecordJson) {
            r.json = this.cloneJSON(originalRecordJson);
            if (config && config.additionalInput) {
                if (config.additionalInput.templateOverride && originalRecordJson[Pan.common.Constants.attrSrc] === Pan.common.Constants.srcTemplate) {
                    delete r.json[Pan.common.Constants.attrSrc];
                } else if (config.additionalInput.templateOverride && originalRecordJson[Pan.common.Constants.attrPtpl]) {
                    delete r.json[Pan.common.Constants.attrPtpl];
                } else if (config.additionalInput.dgOverride) {
                    delete r.json[Pan.common.Constants.attrLoc];
                    delete r.json[Pan.common.Constants.attrOverrides];
                    if (r.json['@__recordInfo'].permission === "readonly") {
                        r.json['@__recordInfo'].permission = "readwrite";
                    }
                    if (Pan.global.getLoc().type === "shared") {
                        r.json['@__recordInfo'].xpathId = "shared";
                    } else {
                        r.json['@__recordInfo'].vsysName = Pan.global.getLocVal();
                        r.json['@__recordInfo'].xpathId = "vsys";
                        if (Ext.isDefined(r.data.location) && r.data.location !== Pan.global.getLocVal()) {
                            r.data.location = Pan.global.getLocVal();
                        }
                    }
                }
            }
        } else {
            r.json = {};
        }
        r.json['@__recordInfo'] = r.json['@__recordInfo'] || {};
        Ext.applyIf(r.json['@__recordInfo'], {xpathId: ""});
        if (r.data) {
            for (var m in r.data) {
                if (r.data.hasOwnProperty(m)) {
                    if (m == '$' && (!r.data[m] || r.data[m] === originalRecordJson)) {
                        r.data[m] = r.json;
                    } else {
                        r.data[m] = this.cloneJSON(r.data[m]);
                    }
                }
            }
        }
        r.phantom = originalRecord.phantom;
        r.store = originalRecord.store;
        r.originalRecord = originalRecord;
        return r;
    },
    cancelEdit: function (r) {
        r.originalRecord.cancelEdit();
        delete r.originalRecord;
        this.rejectChanges();
    },
    hasFieldChanged: function (fieldName) {
        return this.additionalInput && this.additionalInput.fieldPaths && this.additionalInput.fieldPaths.containsKey(fieldName);
    },
    markFieldAsChanged: function (changedField) {
        this.additionalInput = this.additionalInput || {};
        this.additionalInput.fieldPaths = this.additionalInput.fieldPaths || new Ext.util.MixedCollection();
        if (!this.additionalInput.fieldPaths.containsKey(changedField.name)) {
            this.additionalInput.fieldPaths.add(changedField.name, changedField.attrPath);
        }
    },
    clearAllFieldChanges: function () {
        if (this.additionalInput && this.additionalInput.fieldPaths) {
            delete this.additionalInput.fieldPaths;
        }
    },
    willAlwaysWriteRecord: function (r, config) {
        return false;
    },
    willAlwaysWriteField: function (rec, field) {
        var alwaysWriteField = field.alwaysWriteField || field.children || !field.attrPath || !field.allowBlank || !this.includeFieldPathsInSave || (field.initialFieldConfig && Ext.isDefined(field.initialFieldConfig.defaultValue));
        return alwaysWriteField;
    },
    endEdit: function (r, config) {
        var additionalInput;
        if (this.additionalInput) {
            additionalInput = Ext.apply({}, this.additionalInput);
        }
        if (config && config.additionalInput) {
            additionalInput = additionalInput || {};
            Ext.apply(additionalInput, config.additionalInput);
        }
        var fieldPathsMixedCollection = additionalInput && additionalInput.fieldPaths;
        var values = config && config.values || r.data;
        var fields = r.fields;
        var fieldItems = fields.items;
        var writeFieldAdditionalInput;
        var i, n;
        for (i = 0, n = fieldItems.length; i < n; i++) {
            var field = fieldItems[i];
            if (values.hasOwnProperty(field.name)) {
                var alwaysWriteField = this.willAlwaysWriteField(r, field);
                var value = values[field.name];
                if (Ext.isObject(value)) {
                    if (value.isCustomSave) {
                        alwaysWriteField = true;
                        writeFieldAdditionalInput = {isCustomSave: true};
                        delete value.isCustomSave;
                    }
                    if (value.__defaultSaveMap) {
                        alwaysWriteField = true;
                        if (!writeFieldAdditionalInput) {
                            writeFieldAdditionalInput = {};
                        }
                        Ext.apply(writeFieldAdditionalInput, {__defaultSaveMap: value.__defaultSaveMap});
                        delete value.__defaultSaveMap;
                    }
                }
                if (!alwaysWriteField && (!fieldPathsMixedCollection || fieldPathsMixedCollection.indexOfKey(field.name) < 0)) {
                    continue;
                }
                this.recordBinder.writeField(r, field.name, value, values, writeFieldAdditionalInput);
                r.dirty = true;
            }
        }
        if (r.__skipSaveFields) {
            r.__skipSaveFields.eachKey(function (key) {
                var field = fields.get(key);
                field.mutator(r.json, undefined);
            });
        }
        if (!r.dirty) {
            if (r.isCompletelyEmpty || this.willAlwaysWriteRecord(r, config)) {
                r.dirty = true;
            }
        }
        if (this.localStore) {
            Ext.apply(r.originalRecord.data, r.data);
            if (r.phantom) {
                r.phantom = false;
                r.originalRecord.phantom = false;
            }
            r.originalRecord.dirty = true;
        } else {
            if (r.originalRecord.store !== this) {
                var newOriginalRecord = this.getById(r.originalRecord.id);
                if (newOriginalRecord) {
                    r.originalRecord = newOriginalRecord;
                }
            }
            var nameIdProperty = r.store.storeInputs && r.store.storeInputs.nameIdProperty;
            var nameField = fields.get(nameIdProperty);
            var newNameId = nameField && nameField.accessor(r.json);
            var newRecordInfo = Ext.apply({}, r.json['@__recordInfo'], this.initialRecordInfo);
            if (r.dirty || r.phantom) {
                r.originalRecord.dirty = true;
                delete r.json['@__recordInfo'];
                var attributeTrimMap = {};
                attributeTrimMap[Pan.common.Constants.attrSrc] = r.json[Pan.common.Constants.attrSrc];
                attributeTrimMap[Pan.common.Constants.attrOverrides] = r.json[Pan.common.Constants.attrOverrides];
                attributeTrimMap[Pan.common.Constants.attrLoc] = r.json[Pan.common.Constants.attrLoc];
                attributeTrimMap[Pan.common.Constants.attrPtpl] = r.json[Pan.common.Constants.attrPtpl];
                delete r.json[Pan.common.Constants.attrLoc];
                delete r.json[Pan.common.Constants.attrOverrides];
                delete r.json[Pan.common.Constants.attrSrc];
                delete r.json[Pan.common.Constants.attrPtpl];
                if (nameField) {
                    nameField.mutator(r.json, undefined);
                }
                if (additionalInput && additionalInput.subpath) {
                    var subpath = additionalInput.subpath;
                    var subpathJson = jsonPath(r.json, subpath) || undefined;
                    var parts = String(subpath).split(".");
                    var tmp = {};
                    tmp[parts[parts.length - 1]] = Ext.isArray(subpathJson) ? subpathJson[0] : {};
                    r.subpathJson = tmp;
                    additionalInput.subpath = subpath.substring(2).replace(/\./g, '\/');
                }
                if (additionalInput && additionalInput.fieldPath) {
                    additionalInput.fieldPath = additionalInput.fieldPath.substring(2).replace(/\./g, '\/');
                }
                if (fieldPathsMixedCollection) {
                    var fieldPaths = [];
                    for (i = 0; i < fieldPathsMixedCollection.items.length; i++) {
                        var item = fieldPathsMixedCollection.items[i];
                        if (item) {
                            fieldPaths.push(item.substring(2).replace(/\./g, '\/'));
                        }
                    }
                    additionalInput.fieldPaths = fieldPaths;
                }
                var newJson = r.json;
                var extra = newJson.EXTRA;
                if (Ext.isDefined(newJson.EXTRA)) {
                    delete newJson.EXTRA;
                }
                r.originalRecord.toBeCommitted = {
                    action: config && config.action,
                    additionalInput: additionalInput,
                    data: r.isCompletelyEmpty ? "" : this.recordBinder.writeRecord(r, nameField && nameField.accessor(r.originalRecord.json)),
                    extra: extra
                };
                if (extra) {
                    newJson.EXTRA = extra;
                }
                if (this.storeInputs && this.storeInputs.saveOldData && r.originalRecord.json) {
                    var oldDataRecordInfo = r.originalRecord.json['@__recordInfo'];
                    if (oldDataRecordInfo) {
                        delete r.originalRecord.json['@__recordInfo'];
                    }
                    Ext.applyIf(r.originalRecord.toBeCommitted, {oldData: this.recordBinder.writeRecord(r.originalRecord, nameField && nameField.accessor(r.originalRecord.json))});
                    if (oldDataRecordInfo) {
                        r.originalRecord.json['@__recordInfo'] = oldDataRecordInfo;
                    }
                }
                r.originalRecord.cbDelegate = config && config.cbDelegate;
                r.json['@__recordInfo'] = newRecordInfo;
                for (var attr in attributeTrimMap) {
                    if (attributeTrimMap.hasOwnProperty(attr)) {
                        r.json[attr] = attributeTrimMap[attr];
                    }
                }
                if (nameField) {
                    if (Ext.isString(newNameId)) {
                        newNameId = newNameId.trim();
                    }
                    nameField.mutator(r.json, newNameId);
                }
                r.originalRecord.newJson = this.cloneJSON(r.json);
                r.originalRecord.newData = r.data;
            }
        }
        if (!r.originalRecord.dirty) {
            if (config.cbDelegate) {
                config.cbDelegate.call(this, true, r.originalRecord);
            }
        }
        if (r.originalRecord.store !== this) {
            var oldStore = r.originalRecord.store;
            r.originalRecord.store = this;
            r.originalRecord.endEdit();
            r.originalRecord.store = oldStore;
        } else {
            r.originalRecord.endEdit();
        }
    },
    beginAdd: function (record) {
        var log = PanLogging.getLogger('base:autorender:GridRecordStore');
        var rec = new this.recordType();
        rec.store = this;
        if (record) {
            var nameIdProperty = (this.storeInputs && this.storeInputs.nameIdProperty) || this.idProperty;
            rec.fields.each(function (f) {
                if (f.name == nameIdProperty) {
                    rec.data[f.name] = "Copy of " + record.data[f.name];
                } else {
                    rec.data[f.name] = record.data[f.name];
                }
            });
            rec.json = Pan.base.clone(record.json);
            if (rec.json && rec.json[Pan.common.Constants.attrSrc] === Pan.common.Constants.srcTemplate) {
                delete rec.json[Pan.common.Constants.attrSrc];
            }
            if (rec.json && rec.json[Pan.common.Constants.attrPtpl]) {
                delete rec.json[Pan.common.Constants.attrPtpl];
            }
            rec.dirty = true;
        } else {
            var recordJson = {'@__recordInfo': {}};
            rec.fields.each(function (f) {
                var defaultValue = f.defaultValue;
                if (f.isFromSchema()) {
                    try {
                        defaultValue = f.convert(defaultValue, recordJson);
                    } catch (ex) {
                        log.warn(ex);
                    }
                }
                rec.data[f.name] = Ext.isDefined(f.overrideDefault) ? f.overrideDefault : defaultValue;
            });
        }
        rec.__newlyCreated = true;
        return rec;
    },
    getSnapshot: function () {
        return this.snapshot || this.data;
    },
    setValue: function (v, starField) {
        var records = [], r;
        if (Ext.isArray(v)) {
            for (var i = 0; i < v.length; i++) {
                r = this.createRecord(v[i], starField);
                r.phantom = false;
                records.push(r);
            }
        } else {
            r = this.createRecord(v, starField);
            r.phantom = false;
            records.push(r);
        }
        if (records.length > 0) {
            this.loadRecords({records: records}, {}, true);
        } else {
            this.removeAll();
        }
    },
    getValue: function (starField) {
        var fields = this.fields;
        var fieldItems = fields.items.slice(0);
        var results = [];
        this.getSnapshot().each(function (r) {
            results.push(this.getRecordValue(r, fieldItems, starField));
        }, this);
        return results;
    },
    getRecordValue: function (r, fieldItems, starField) {
        var values = r.data;
        var oldJson = r.json;
        r.json = {};
        var count = (starField.attrPath.match(/[*]/g) || []).length;
        var recordValueChildrenSaveLevel = this.recordValueChildrenSaveLevel();
        for (var i = 0, n = fieldItems.length; i < n; i++) {
            var field = fieldItems[i];
            if (values.hasOwnProperty(field.name)) {
                if (field.attrPath && (field.attrPath.match(/[*]/g) || []).length < count + recordValueChildrenSaveLevel) {
                    var value = values[field.name];
                    this.recordBinder.writeField(r, field.name, value, values);
                }
            }
        }
        var data = starField.accessor(r.json);
        r.json = oldJson;
        return data;
    },
    recordValueChildrenSaveLevel: function () {
        return 1;
    },
    createRecord: function (data, starField) {
        var fields = this.fields;
        var rdata = {};
        var id, v;
        var items = fields.items;
        if (!starField && items.length === 1 && items[0].name === 'id') {
            if (Ext.isObject(data)) {
                if (data['@name']) {
                    rdata[items[0].name] = data['@name'];
                }
            } else {
                rdata[items[0].name] = data;
            }
        } else {
            var value = {};
            starField.mutator(value, data);
            var count = fields.items.length;
            for (var i = 0; i < count; i++) {
                var child = fields.items[i];
                v = child.accessor(value);
                rdata[child.name] = child.convert((v !== undefined) ? v : child.defaultValue, value);
            }
        }
        if (this.prop_enforceIdProperty && this.idProperty) {
            id = rdata[this.idProperty];
        }
        var record = new this.recordType(rdata, id);
        record.json = data;
        return record;
    },
    doPermanentFilter: function (o) {
        if (Ext.isObject(o) && o.records && o.totalRecords) {
            if (this.permanentFilter || this.permanentFilterFn !== Ext.emptyFn || this.internalPermanentFilterFn !== Ext.emptyFn) {
                var filters = this.permanentFilter ? ((Ext.isArray(this.permanentFilter) && this.permanentFilter) || [this.permanentFilter]) : [];
                var length = o.records.length;
                for (var i = length - 1; i >= 0; i--) {
                    var r = o.records[i];
                    for (var k = 0; k < filters.length; k++) {
                        var filter = filters[k];
                        var rv = filter.call(this, r);
                        if (rv === false) {
                            o.records.splice(i, 1);
                            o.totalRecords--;
                            r = undefined;
                            break;
                        }
                    }
                    if (r && this.internalPermanentFilterFn !== Ext.emptyFn && this.internalPermanentFilterFn(r, i, length) === false) {
                        o.records.splice(i, 1);
                        o.totalRecords--;
                    } else if (r && this.permanentFilterFn !== Ext.emptyFn && this.permanentFilterFn(r, i, length) === false) {
                        o.records.splice(i, 1);
                        o.totalRecords--;
                    }
                }
            }
        }
        return o;
    },
    internalPermanentFilterFn: Ext.emptyFn,
    permanentFilterFn: Ext.emptyFn,
    createMultipleFilterFn: function (filters) {
        if (this.fieldOrBasedFilter) {
            return function (record, key, rIndex) {
                var isMatch = false;
                for (var i = 0, j = filters.length; i < j; i++) {
                    var filter = filters[i], fn = filter.fn, scope = filter.scope;
                    isMatch = isMatch || fn.call(scope, record, key, rIndex);
                }
                return isMatch;
            };
        } else {
            return Pan.base.autorender.GridRecordStore.superclass.createMultipleFilterFn.apply(this, arguments);
        }
    },
    doRecordQueryFilter: function (expression, filterFields) {
        var log = PanLogging.getLogger('base:autorender:GridRecordStore');
        var parseQueryResult;
        try {
            parseQueryResult = Pan.base.parseQuery(expression);
        } catch (err) {
            log.error(err);
            return;
        }
        var header2FieldMap = {};
        for (var i = 0; i < filterFields.length; i++) {
            var filterField = filterFields[i];
            header2FieldMap[filterField['header'].toLowerCase()] = filterField;
        }
        var filterFn = function () {
            var expressionTree = parseQueryResult;
            var map = header2FieldMap;
            return function (record, key) {
                return Pan.base.RecordQuery.evaluateRecord(expressionTree, record, map);
            };
        }();
        this.filterBy(filterFn, this);
    },
    doStringFilter: function (filterString, filterFields, anyMatch, caseSensitive, exactMatch) {
        var filters = [];
        for (var i = 0; i < filterFields.length; i++) {
            var filterField = filterFields[i];
            var filter = {};
            if (filterField.fn) {
                Ext.applyIf(filter, {fn: filterField.fn, scope: filterField.scope || this});
            } else {
                Ext.applyIf(filter, {
                    fn: this.createFilterFn(filterField.property, filterString, anyMatch, caseSensitive, exactMatch),
                    scope: filterField.scope || this
                });
            }
            filters.push(filter);
        }
        var originalValue = this.fieldOrBasedFilter;
        this.fieldOrBasedFilter = true;
        var fn = this.createMultipleFilterFn(filters);
        this.fieldOrBasedFilter = originalValue;
        if (this.useFilters) {
            this.filters.add({id: 'stringfilter', fn: fn, scope: this});
            fn = this.createMultipleFilterFn(this.filters.items);
        }
        return fn ? this.filterBy(fn) : this.clearFilter();
    },
    getTotalCount: function (prefilter) {
        if (prefilter) {
            return this.snapshot ? this.snapshot.getCount() : (this.isLiveGrid || !this.localStore) ? this.totalLength || 0 : this.data ? this.data.getCount() : 0;
        }
        return this.pagingSnapshot ? this.pagingSnapshot.getCount() : this.snapshot ? this.snapshot.getCount() : (this.isLiveGrid || !this.localStore) ? this.totalLength || 0 : this.data ? this.data.getCount() : 0;
    },
    doLocalPaging: function (config) {
        if (!this.data) {
            return;
        }
        var oldCount = this.pagingSnapshot && this.pagingSnapshot.getCount() || 0;
        var oldStart = this.localPagingParams && this.localPagingParams.start;
        var oldLimit = this.localPagingParams && this.localPagingParams.limit;
        if (config.resetSnapshot || !this.pagingSnapshot) {
            this.pagingSnapshot = this.data;
        }
        if (config.applySort) {
            this.applySort();
        }
        this.localPagingParams = Ext.applyIf({
            start: config.start,
            limit: config.limit
        }, config.params || this.localPagingParams);
        var start = this.localPagingParams.start, limit = this.localPagingParams.limit,
            count = this.pagingSnapshot.getCount();
        if (config.findIndexRecords) {
            var findIndexRecords = config.findIndexRecords;
            if (!Ext.isArray(findIndexRecords)) {
                findIndexRecords = [findIndexRecords];
            }
            for (var j = 0; j < findIndexRecords.length; j++) {
                var id = findIndexRecords[j].id;
                var record = this.pagingSnapshot.key(id);
                if (record) {
                    start = this.pagingSnapshot.indexOf(record);
                    break;
                }
            }
        }
        if (start >= this.pagingSnapshot.getCount()) {
            start = Math.max(0, this.pagingSnapshot.getCount() - 1);
        }
        start = Math.floor(start / limit) * limit;
        this.localPagingParams.start = start;
        var allData = this.pagingSnapshot;
        var data = new Ext.util.MixedCollection(allData.allowFunctions, allData.getKey);
        data.items = allData.items.slice(start, start + limit);
        data.keys = allData.keys.slice(start, start + limit);
        var len = data.length = data.items.length;
        var map = {};
        for (var i = 0; i < len; i++) {
            var item = data.items[i];
            map[data.getKey(item)] = item;
        }
        data.map = map;
        if (!this.snapshot) {
            this.snapshot = this.data.clone();
        }
        this.data = data;
        if (config.fireDataChanged) {
            this.fireEvent('datachanged', this);
        }
        if (start !== oldStart || limit !== oldLimit || count !== oldCount) {
            this.fireEvent('localPagingChanged', this, this.localPagingParams);
        }
    },
    add: function (records, skipFilter) {
        records = [].concat(records);
        if (records.length < 1) {
            return;
        }
        if (this.pagingSnapshot) {
            this.pagingSnapshot.addAll(records);
        }
        var afterFilterRecords = records;
        if (!skipFilter && this.useFilters) {
            afterFilterRecords = this.filterRecords(records);
        }
        for (var i = 0, len = records.length; i < len; i++) {
            records[i].join(this);
        }
        var index = this.data.length;
        this.data.addAll(afterFilterRecords);
        if (this.snapshot) {
            this.snapshot.addAll(records);
        }
        if (afterFilterRecords.length > 0) {
            this.fireEvent('add', this, afterFilterRecords, index);
        }
    },
    bulkRemove: function (record) {
        this.suspendEvents();
        this.remove.apply(this, arguments);
        this.resumeEvents();
        this.fireEvent('bulkremove', this, record);
        this.fireEvent('datachanged', this);
    },
    remove: function (record) {
        if (record && !Ext.isArray(record)) {
            if (this.pagingSnapshot) {
                this.pagingSnapshot.remove(record);
            }
        }
        Pan.base.autorender.GridRecordStore.superclass.remove.apply(this, arguments);
    },
    removeAll: function (silent) {
        if (this.pagingSnapshot) {
            this.pagingSnapshot.clear();
        }
        Pan.base.autorender.GridRecordStore.superclass.removeAll.apply(this, arguments);
    },
    insert: function (index, records, skipFilter) {
        records = [].concat(records);
        if (this.pagingSnapshot) {
            this.pagingSnapshot.addAll(records);
        }
        var afterFilterRecords = records;
        if (!skipFilter && this.useFilters) {
            afterFilterRecords = this.filterRecords(records);
        }
        for (var len = afterFilterRecords.length, i = len - 1; i >= 0; i--) {
            this.data.insert(index, afterFilterRecords[i]);
        }
        for (var j = 0, len2 = records.length; j < len2; j++) {
            records[j].join(this);
        }
        if (this.snapshot) {
            this.snapshot.addAll(records);
        }
        if (afterFilterRecords.length > 0) {
            this.fireEvent('add', this, afterFilterRecords, index);
        }
    },
    filterBy: function (fn, scope) {
        if (this.useFilters) {
            this.__filterFn = fn;
        }
        var oldDataItems = this.data && this.data.items;
        if (this.supportLocalPaging) {
            this.suspendEvents(true);
        }
        Pan.base.autorender.GridRecordStore.superclass.filterBy.apply(this, arguments);
        if (this.supportLocalPaging) {
            this.doLocalPaging({findIndexRecords: oldDataItems, resetSnapshot: true, fireDataChanged: false});
            this.resumeEvents();
        }
    },
    clearFilter: function (suppressEvent) {
        if (this.isFiltered()) {
            delete this.pagingSnapshot;
        }
        Pan.base.autorender.GridRecordStore.superclass.clearFilter.apply(this, arguments);
    },
    sort: function (fieldName, dir) {
        if (this.multiSortInfo && this.multiSortInfo.sorters && !Ext.isArray(fieldName)) {
            var forceMultiSort = false;
            var reverse = false;
            dir = dir || this.multiSortInfo.direction || "ASC";
            if (dir == this.multiSortInfo.direction) {
                reverse = true;
            }
            for (var i = 0; i < this.multiSortInfo.sorters.length; i++) {
                var f = this.multiSortInfo.sorters[i].field;
                if (f === fieldName) {
                    forceMultiSort = true;
                    break;
                }
            }
            if (forceMultiSort) {
                if (reverse) {
                    for (var j = 0; j < this.multiSortInfo.sorters.length; j++) {
                        var d = this.multiSortInfo.sorters[j].direction || "ASC";
                        this.multiSortInfo.sorters[j].direction = d.toggle("ASC", "DESC");
                    }
                }
                this.sortInfo = {field: fieldName, direction: dir};
                this.multiSort.call(this, this.multiSortInfo.sorters, dir);
                return;
            }
        }
        return Pan.base.autorender.GridRecordStore.superclass.sort.apply(this, arguments);
    },
    singleSort: function (fieldName, dir) {
        if (this.supportLocalPaging) {
            this.suspendEvents(true);
        }
        var field = this.fields.get(fieldName);
        if (!field) return false;
        var name = field.name, sortInfo = this.sortInfo || null;
        if (!dir) {
            if (sortInfo && sortInfo.field == name) {
                dir = (this.sortToggle[name] || 'ASC').toggle('ASC', 'DESC');
            } else {
                dir = field.sortDir;
            }
        }
        this.sortToggle[name] = dir;
        this.sortInfo = {field: name, direction: dir};
        this.hasMultiSort = false;
        if (this.remoteSort) {
            this.load(this.lastOptions);
        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
        if (this.supportLocalPaging) {
            this.doLocalPaging({fireDataChanged: false});
            this.resumeEvents();
        }
    },
    multiSort: function (sorters, direction) {
        if (this.supportLocalPaging) {
            this.suspendEvents(true);
        }
        Pan.base.autorender.GridRecordStore.superclass.multiSort.apply(this, arguments);
        if (this.supportLocalPaging) {
            this.doLocalPaging({fireDataChanged: false});
            this.resumeEvents();
        }
    },
    sortData: function () {
        if (this.pagingSnapshot) {
            var sortInfo = this.hasMultiSort ? this.multiSortInfo : this.sortInfo,
                direction = sortInfo.direction || "ASC", sorters = sortInfo.sorters, sortFns = [];
            if (!this.hasMultiSort) {
                sorters = [{direction: direction, field: sortInfo.field}];
            }
            for (var i = 0, j = sorters.length; i < j; i++) {
                sortFns.push(this.createSortFunction(sorters[i].field, sorters[i].direction));
            }
            if (sortFns.length == 0) {
                return;
            }
            var directionModifier = direction.toUpperCase() == "DESC" ? -1 : 1;
            var fn = function (r1, r2) {
                var result = sortFns[0].call(this, r1, r2);
                if (sortFns.length > 1) {
                    for (var i = 1, j = sortFns.length; i < j; i++) {
                        result = result || sortFns[i].call(this, r1, r2);
                    }
                }
                return directionModifier * result;
            };
            this.data.sort(direction, fn);
            if (this.snapshot && this.snapshot != this.data) {
                this.snapshot.sort(direction, fn);
            }
            this.pagingSnapshot.sort(direction, fn);
        } else {
            Pan.base.autorender.GridRecordStore.superclass.sortData.apply(this, arguments);
        }
    },
    onMetaChange: function (meta) {
        delete this.pagingSnapshot;
        Pan.base.autorender.GridRecordStore.superclass.onMetaChange.apply(this, arguments);
    },
    reload: function (options) {
        if (this.isLiveGrid && this.lastOptions && this.lastOptions.params) {
            delete this.lastOptions.params.start;
            delete this.lastOptions.params.limit;
        }
        Pan.base.autorender.GridRecordStore.superclass.reload.apply(this, arguments);
    },
    load: function (options) {
        if (this.supportLocalPaging && options && options.params && options.params.supportLocalPaging) {
            this.doLocalPaging({params: options.params, fireDataChanged: true});
        } else {
            Pan.base.autorender.GridRecordStore.superclass.load.apply(this, arguments);
        }
    },
    loadRecords: function (o, options, success) {
        var log = PanLogging.getLogger('base:autorender:GridRecordStore');
        o = this.doPermanentFilter(o);
        var oldDataItems = this.data && this.data.items;
        var snapshot = this.snapshot;
        var data = this.data;
        if (success && this.supportLocalPaging) {
            delete this.pagingSnapshot;
            this.suspendEvents(true);
            if (snapshot) {
                snapshot.suspendEvents(false);
            }
            if (data) {
                data.suspendEvents(false);
            }
        }
        Pan.base.autorender.GridRecordStore.superclass.loadRecords.call(this, o, options, success);
        if (!success) {
            log.warn("GridRecordStore::loadRecords Unable to load record");
        } else {
            if (this.__filterFn) {
                this.filterBy(this.__filterFn);
            }
            if (this.supportLocalPaging) {
                this.doLocalPaging({findIndexRecords: oldDataItems, fireDataChanged: false});
                if (data) {
                    data.resumeEvents();
                }
                if (snapshot) {
                    snapshot.resumeEvents();
                }
                this.resumeEvents();
            }
            this.isStoreLoaded = true;
            this.fireEvent('afterload', this);
        }
    },
    onUpdateRecords: function (success, rs, data) {
        var finishing = true;
        if (rs.cbDelegate) {
            finishing = rs.cbDelegate.apply(this, arguments);
            delete rs.cbDelegate;
        }
        if (finishing && !this.isDestroyed) {
            if (success === true) {
                Pan.base.autorender.GridRecordStore.superclass.onUpdateRecords.apply(this, arguments);
            } else {
                this.rejectChanges();
            }
            this.clearAllFieldChanges();
        }
        this.postWrite && this.postWrite(success, rs, data);
    },
    onCreateRecords: function (success, rs, data) {
        var finishing = true;
        if (rs.cbDelegate) {
            finishing = rs.cbDelegate.apply(this, arguments);
            delete rs.cbDelegate;
        }
        if (finishing && !this.isDestroyed) {
            if (success === true) {
                this.reader.realize(rs, data);
                this.add(rs);
                if (Ext.isNumber(this.totalLength)) {
                    this.totalLength += Ext.isArray(rs) ? rs.length : 1;
                }
                if (this.supportLocalPaging) {
                    this.doLocalPaging({findIndexRecords: rs, applySort: true, fireDataChanged: true});
                }
            } else {
                this.rejectChanges();
            }
            this.clearAllFieldChanges();
        }
        this.postWrite && this.postWrite(success, rs, data);
    },
    onDestroyRecords: function (success, rs, data) {
        this.postWrite && this.postWrite(success, rs, data);
        var action = "destroy";
        if (Ext.isArray(rs)) {
            action = (rs[0].toBeCommitted && rs[0].toBeCommitted.action) || action;
        } else {
            action = (rs.toBeCommitted && rs.toBeCommitted.action) || action;
        }
        if (success !== false && action === "move") {
            if (!Ext.isArray(rs)) {
                rs = [rs];
            }
            var destinationRecord = rs[0].toBeCommitted.destinationRecord;
            var whereTo = rs[0].toBeCommitted.whereTo;
            switch (whereTo) {
                case'top':
                case'before':
                    this.insert(this.indexOf(destinationRecord), rs);
                    break;
                case'bottom':
                case'after':
                    this.insert(this.indexOf(destinationRecord) + 1, rs);
                    break;
                default:
                    break;
            }
        } else {
            return Pan.base.autorender.GridRecordStore.superclass.onDestroyRecords.apply(this, arguments);
        }
    },
    handleException: function (e) {
        this.rejectChanges();
        this.reportStatus({error: {title: _T("Internal Error"), message: "Caught exception:\n" + e}});
        return Pan.base.autorender.GridRecordStore.superclass.handleException.apply(this, arguments);
    },
    postWrite: undefined
});
Pan.base.autorender.GridDirectProxy = Ext.extend(Ext.data.DirectProxy, {
    constructor: function (config) {
        this.initDataProxyAPI(config);
        Pan.base.autorender.GridDirectProxy.superclass.constructor.call(this, config);
        this.addListener('exception', this.handleException, this);
        this.addListener('loadexception', this.handleException, this);
    }, initDataProxyAPI: function (config) {
        if (config.directFn) {
            var directCfg1 = config.directFn.directCfg;
            config.directFn = config.recordBinder.directFnOverride.createDelegate(config.recordBinder, {
                scope: directCfg1.action,
                superFunction: config.directFn,
                directCfg: directCfg1
            }, true);
            config.directFn.directCfg = directCfg1;
        }
        if (config.api) {
            var argPrependMap = {};
            for (var action in config.api) {
                if (config.api.hasOwnProperty(action)) {
                    var method = undefined;
                    if (Ext.isString(config.api[action])) {
                        method = config.api[action];
                        var validFunctionName = /^[A-Z_][0-9A-Z_]*$/i;
                        if (validFunctionName.test(method)) {
                            config.api[action] = PanDirect.execute;
                        }
                    }
                    if (Ext.isFunction(config.api[action]) && config.api[action].directCfg) {
                        var directCfg = config.api[action].directCfg;
                        var scope = {
                            scope: directCfg.action,
                            superFunctionAction: action,
                            superFunction: config.api[action],
                            directCfg: directCfg
                        };
                        if (method) {
                            if (config['remoteClass']) {
                                method = config['remoteClass'] + "." + method;
                            }
                            if (config['plugin']) {
                                method = config['plugin'] + "." + method;
                            }
                            argPrependMap[action] = method;
                            Ext.apply(scope, {argPrepend: method, argPrependMap: argPrependMap});
                        }
                        config.api[action] = config.recordBinder.directFnOverride.createDelegate(config.recordBinder, scope, true);
                        config.api[action].directCfg = directCfg;
                    }
                }
            }
        }
    }, onRead: function (action, trans, result, res) {
        if (trans.request.scope.isDestroyed === true) {
            return;
        }
        result = this.recordBinder.preProcessResults(action, trans, result, res);
        Pan.base.autorender.GridDirectProxy.superclass.onRead.call(this, action, trans, result, res);
    }, onWrite: function (action, trans, result, res, rs) {
        var data = this.recordBinder.preProcessResults(action, trans, result, res, rs);
        if (!data) {
            trans.request.callback.call(trans.request.scope, result, res, false);
        } else {
            this.fireEvent("write", this, action, data, res, rs, trans.request.arg);
            trans.request.callback.call(trans.request.scope, data, res, true);
        }
        if (this.recordBinder.store.isCheckAutoRefreshAfterWrite) {
            if (result && result['@refresh']) {
                this.recordBinder.store.reload();
            }
        }
    }, handleException: function (dataProxy, type, action, options, response, mixed) {
        var log = PanLogging.getLogger('base:autorender:GridRecordStore');
        if (action) {
            if (action.code === Ext.Direct.exceptions.TRANSPORT) {
                var msg = Pan.base.Constants.transportErrorMsg;
                Pan.Msg.show({title: _T('Error'), msg: msg, buttons: Ext.MessageBox.OK, icon: Ext.MessageBox.ERROR});
                return;
            } else if (action.type === 'exception') {
                Pan.base.checkUnauthorized(action.message);
            }
        }
        if (mixed) {
            log.warn(mixed);
        }
    }
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GridRecordDialogEditor = Ext.extend(Ext.Component, {
    initComponent: function () {
        Pan.base.autorender.GridRecordDialogEditor.superclass.initComponent.call(this);
        this.addEvents("beforestartedit", "startedit", "beforecomplete", "complete", "canceledit");
    }, startEdit: function (el, value) {
        if (this.fireEvent("beforestartedit", this, this.el, value) !== false) {
            var config = Ext.applyIf({
                store: value.store,
                record: value ? value : this.store.beginAdd()
            }, this.initialConfig);
            if (this.recordFormConfig) {
                Ext.apply(config.recordForm, this.recordFormConfig);
            }
            if (config.recordForm.localStore || value.store.localStore) {
                Ext.apply(config, {
                    okCallback: function (recordForm) {
                        var updateRecord = recordForm.recordForm.updateRecord || recordForm.updateRecord;
                        updateRecord.call(this);
                        recordForm.onDestroy();
                        return false;
                    }, cancelCallback: function (recordForm) {
                        recordForm.onDestroy();
                        return true;
                    }
                });
            }
            this.field = Pan.base.autorender.GridRecordForm.showRecordForm(config, this);
            this.fireEvent("startedit", this.el, value);
        }
    }, setRecordFormOverride: function (recordFormConfig) {
        this.recordFormConfig = recordFormConfig;
    }, completeEdit: function () {
    }, cancelEdit: function () {
    }, setValue: function () {
    }, getValue: function () {
        return undefined;
    }
});
Ext.reg('GridRecordDialogEditor', Pan.base.autorender.GridRecordDialogEditor);
Ext.ns('Pan.base.autorender');
Pan.base.autorender.GroupingGridStore = Ext.extend(Pan.base.autorender.GridRecordStore, {
    allPossibleGroups: undefined,
    remoteGroup: false,
    groupOnSort: false,
    groupDir: 'ASC',
    constructor: function (config) {
        config = config || {};
        this.hasMultiSort = true;
        this.multiSortInfo = this.multiSortInfo || {sorters: []};
        var sorters = this.multiSortInfo.sorters, groupField = config.groupField || this.groupField,
            sortInfo = config.sortInfo || this.sortInfo, groupDir = config.groupDir || this.groupDir;
        if (groupField) {
            sorters.push({field: groupField, direction: groupDir});
        }
        if (sortInfo) {
            sorters.push(sortInfo);
        }
        Pan.base.autorender.GroupingGridStore.superclass.constructor.call(this, config);
        this.addEvents('groupchange');
        this.applyGroupField();
    },
    setValue: function (v, starField) {
        if (!starField) {
            this.loadData(v);
            return;
        }
        var records = [];
        for (var i = 0; i < v.length; i++) {
            var separatedRecordArray = this.getSeparatedRecordValues(v[i], starField);
            for (var j = 0; j < separatedRecordArray.length; j++) {
                records.push(this.createRecord(separatedRecordArray[j], starField));
            }
        }
        if (records.length > 0) {
            this.loadRecords({records: records}, {}, true);
        }
    },
    getValue: function (starField) {
        var fields = this.fields;
        var fieldItems = fields.items.slice(0);
        var resultsMap = {};
        var results = [];
        this.getSnapshot().each(function (r) {
            if (!starField) {
                var entry = {};
                fields.each(function (field) {
                    entry[field.name] = r.get(field.name);
                });
                results.push(entry);
                return;
            }
            var result = this.getCombinedRecordValue(r, fieldItems, starField, resultsMap);
            if (result) {
                resultsMap[result['@name']] = result;
                results.push(result);
            }
        }, this);
        return results;
    },
    getSeparatedRecordValues: function (rec, starField) {
        var rv = [];
        var parentOfGroupStar = this.__pdefaults.__fields.get(this.groupStarField.attrPath.substring(0, this.groupStarField.attrPath.length - 2));
        var groupRecArray = parentOfGroupStar.accessor(rec, starField.level);
        parentOfGroupStar.mutator(rec, undefined, false, starField.level);
        if (!Ext.isArray(groupRecArray)) {
            groupRecArray = [];
        }
        for (var i = 0; i < groupRecArray.length; i++) {
            var newRec = Pan.base.clone(rec);
            this.groupStarField.mutator(newRec, groupRecArray[i], false, this.starField.level);
            rv.push(newRec);
        }
        return rv;
    },
    getCombinedRecordValue: function (r, fieldItems, starField, resultsMap) {
        var rec = this.getRecordValue(r, fieldItems, starField);
        var groupRec = this.groupStarField.accessor(rec, starField.level);
        this.groupStarField.mutator(rec, undefined, false, starField.level);
        var originalRec = resultsMap[rec["@name"]];
        if (originalRec) {
            rec = originalRec;
        }
        var parentOfGroupStar = this.__pdefaults.__fields.get(this.groupStarField.attrPath.substring(0, this.groupStarField.attrPath.length - 2));
        var groupRecArray = parentOfGroupStar.accessor(rec, starField.level);
        if (!Ext.isArray(groupRecArray)) {
            groupRecArray = [];
            parentOfGroupStar.mutator(rec, groupRecArray, false, starField.level);
        }
        groupRecArray.push(groupRec);
        if (!originalRec) {
            return rec;
        }
    },
    recordValueChildrenSaveLevel: function () {
        return 2;
    },
    clearGrouping: function () {
        this.groupField = false;
        if (this.remoteGroup) {
            if (this.baseParams) {
                delete this.baseParams.groupBy;
                delete this.baseParams.groupDir;
            }
            var lo = this.lastOptions;
            if (lo && lo.params) {
                delete lo.params.groupBy;
                delete lo.params.groupDir;
            }
            this.reload();
        } else {
            this.sort();
            this.fireEvent('datachanged', this);
        }
    },
    groupBy: function (field, forceRegroup, direction) {
        direction = direction ? (String(direction).toUpperCase() == 'DESC' ? 'DESC' : 'ASC') : this.groupDir;
        if (this.groupField == field && this.groupDir == direction && !forceRegroup) {
            return;
        }
        var sorters = this.multiSortInfo.sorters;
        if (sorters.length > 0 && sorters[0].field == this.groupField) {
            sorters.shift();
        }
        this.groupField = field;
        this.groupDir = direction;
        this.applyGroupField();
        var fireGroupEvent = function () {
            this.fireEvent('groupchange', this, this.getGroupState());
        };
        if (this.groupOnSort) {
            this.sort(field, direction);
            fireGroupEvent.call(this);
            return;
        }
        if (this.remoteGroup) {
            this.on('load', fireGroupEvent, this, {single: true});
            this.reload();
        } else {
            this.sort(sorters);
            fireGroupEvent.call(this);
        }
    },
    sort: function (fieldName, dir) {
        if (this.remoteSort) {
            return Pan.base.autorender.GroupingGridStore.superclass.sort.call(this, fieldName, dir);
        }
        var sorters = [];
        if (Ext.isArray(arguments[0])) {
            sorters = arguments[0];
        } else if (fieldName == undefined) {
            sorters = [this.sortInfo];
        } else {
            var field = this.fields.get(fieldName);
            if (!field) return false;
            var name = field.name, sortInfo = this.sortInfo || null,
                sortToggle = this.sortToggle ? this.sortToggle[name] : null;
            if (!dir) {
                if (sortInfo && sortInfo.field == name) {
                    dir = (this.sortToggle[name] || 'ASC').toggle('ASC', 'DESC');
                } else {
                    dir = field.sortDir;
                }
            }
            this.sortToggle[name] = dir;
            this.sortInfo = {field: name, direction: dir};
            sorters = [this.sortInfo];
        }
        if (this.groupField) {
            sorters.unshift({direction: this.groupDir, field: this.groupField});
        }
        return this.multiSort.call(this, sorters, dir);
    },
    applyGroupField: function () {
        if (this.remoteGroup) {
            if (!this.baseParams) {
                this.baseParams = {};
            }
            Ext.apply(this.baseParams, {groupBy: this.groupField, groupDir: this.groupDir});
            var lo = this.lastOptions;
            if (lo && lo.params) {
                lo.params.groupDir = this.groupDir;
                delete lo.params.groupBy;
            }
        }
    },
    applyGrouping: function (alwaysFireChange) {
        if (this.groupField !== false) {
            this.groupBy(this.groupField, true, this.groupDir);
            return true;
        } else {
            if (alwaysFireChange === true) {
                this.fireEvent('datachanged', this);
            }
            return false;
        }
    },
    getGroupState: function () {
        return this.groupOnSort && this.groupField !== false ? (this.sortInfo ? this.sortInfo.field : undefined) : this.groupField;
    },
    getAllPossibleGroups: function () {
        return this.allPossibleGroups || {};
    },
    getMissingGroups: function () {
        var allGroups = Ext.apply({}, this.getAllPossibleGroups());
        this.each(function (record) {
            var groupFieldValue = record.get(this.groupField);
            if (allGroups[groupFieldValue]) {
                delete allGroups[groupFieldValue];
            }
        }, this);
        var rv = [];
        for (var key in allGroups) {
            if (allGroups.hasOwnProperty(key)) {
                rv.push(allGroups[key]);
            }
        }
        return rv;
    }
});
Ext.ns('Pan.base.autorender');
Pan.base.autorender.ObjectField = Ext.extend(Pan.base.autorender.GridRecordField, {
    reset: function () {
        this.setValue(this.getValue());
    }, setValue: function (v) {
        if (v) {
            var children = this.__field.children;
            if (children) {
                for (var i = 0; i < children.length; i++) {
                    var field = children[i];
                    var ui = this.findByItemId(field.name);
                    if (ui.setValue) {
                        ui.setValue(field.accessor(v, this.__field.level));
                    }
                }
            }
        }
    }, getValue: function () {
        var editRecord;
        var ownerCt = this;
        while (ownerCt.ownerCt) {
            ownerCt = ownerCt.ownerCt;
        }
        if (ownerCt.__editRecord) {
            editRecord = ownerCt.__editRecord;
        }
        var rv = {};
        var children = this.__field.children;
        if (children) {
            for (var i = 0; i < children.length; i++) {
                var field = children[i];
                var ui = this.findByItemId(field.name);
                if (ui.getValue) {
                    var value = ui.getValue();
                    field.mutator(rv, value, false, this.__field.level);
                    if (editRecord) {
                        editRecord.set(field.name, value);
                    }
                }
            }
        }
        return rv;
    }
});
Ext.reg("pan-objectfield", Pan.base.autorender.ObjectField);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.Builder = (function () {
    return function (comp) {
        return comp;
    };
})();
Pan.base.autorender.builder.BuilderMgr = (function () {
    var builderMap = {};
    return {
        registerBuilder: function (type, builder) {
            builderMap[type] = builder;
        }, get: function (type) {
            return builderMap[type];
        }
    };
})();
Pan.breg = Pan.base.autorender.builder.BuilderMgr.registerBuilder;
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.ContainerBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        if (config.field.childrenNames && !comp.items) {
            var items = [];
            for (var i = 0; i < config.field.childrenNames.length; i++) {
                if (!config.field.children[i]) {
                    continue;
                }
                var childConfig = {itemId: config.field.childrenNames[i]};
                if (config.field.children[i].uiHint && config.field.children[i].uiHint.dim) {
                    childConfig.dim = config.field.children[i].uiHint.dim;
                }
                items.push(childConfig);
            }
            Ext.applyIf(comp, {items: items});
        }
        if (comp.items) {
            Ext.applyIf(comp, {xtype: 'pan-container', defaults: {}});
        }
        else {
            Ext.applyIf(comp, {
                xtype: 'pan-recordfield', getValue: function () {
                    return {};
                }
            });
        }
        if (comp.items && !comp.layout) {
            var autoHeight = true;
            if (comp.__pdefaults && Ext.isDefined(comp.__pdefaults.__recordFormAutoHeight)) {
                autoHeight = comp.__pdefaults.__recordFormAutoHeight;
            }
            if (comp.withFieldSetHPadding) {
                comp.cls = comp.cls || '';
                comp.cls += ' x-container-with-fieldset-h-padding';
            }
            if (comp.withFieldSetVPadding) {
                comp.cls = comp.cls || '';
                comp.cls += ' x-container-with-fieldset-v-padding';
            }
            if (autoHeight) {
                Ext.applyIf(comp, {autoHeight: true, layoutConfig: {trackLabels: true}});
                Ext.applyIf(comp, {rfLayoutConfig: Pan.base.autorender.layout.RFTableLayoutConfig});
            }
            else {
                var vflex = true;
                if (Ext.isDefined(comp.vflex)) {
                    vflex = comp.vflex;
                }
                Ext.applyIf(comp, {
                    rfLayoutConfig: Pan.base.autorender.layout.RFTableLayoutConfig,
                    autoHeight: !vflex,
                    vflex: vflex
                });
            }
        }
        Ext.applyIf(comp.defaults, {anchor: '100%'});
        if (Ext.isDefined(config.field.uiHint) && comp.fieldLabel === config.field.uiHint.fieldLabelAutoGen) {
            comp.fieldLabel = '';
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("ContainerBuilder", Pan.base.autorender.builder.ContainerBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.FieldSetBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        var title = comp.fieldLabel;
        var autoHeightIsFromConfig = Ext.isDefined(comp.autoHeight);
        comp = arguments.callee.superFunction.apply(this, arguments);
        Ext.apply(comp, {xtype: 'pan-fieldset', fieldLabel: ''});
        var autoHeight = true;
        if (comp.vflex) {
            autoHeight = false;
        }
        if (!autoHeightIsFromConfig) {
            comp.autoHeight = autoHeight;
        }
        Ext.applyIf(comp, {title: title, rfLayoutConfig: Pan.base.autorender.layout.RFTableLayoutConfig});
        switch (config.field.type.type) {
            case'sequence':
                if (!comp.allowBlank) {
                    break;
                }
                Ext.applyIf(comp, {checkboxToggle: true});
                break;
            case'bool':
            case'reverseBool':
                Ext.applyIf(comp, {checkboxToggle: true});
                break;
            default:
                break;
        }
        return comp;
    }, Pan.base.autorender.builder.ContainerBuilder);
})();
Pan.breg("FieldSetBuilder", Pan.base.autorender.builder.FieldSetBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.TabBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        var items = comp.items;
        var deferredCreate = false;
        if (!items) {
            items = [];
            for (var i = 0; i < config.field.childrenNames.length; i++) {
                var cardContainer = config.field.children[i].uiHint;
                var dc = cardContainer.deferredCreate;
                if (!Ext.isDefined(dc)) {
                    dc = false;
                }
                var cardContainerConfig = {
                    xtype: 'pan-cardcontainer',
                    layout: 'fit',
                    deferredCreate: dc,
                    title: cardContainer.tabTitle || cardContainer.fieldLabel,
                    items: {
                        itemId: config.field.childrenNames[i], setIsAvail: function (isAvailable, availHide) {
                            Ext.Component.prototype.setIsAvail.apply(this, arguments);
                            if (availHide === true) {
                                var tabIndex = this.ownerCt.__tabIndex;
                                if (isAvailable) {
                                    this.ownerCt.ownerCt.unhideTabStripItem(tabIndex);
                                }
                                else {
                                    this.ownerCt.ownerCt.hideTabStripItem(tabIndex);
                                    if (this.ownerCt.ownerCt.getActiveTab().__tabIndex == tabIndex) {
                                        var index = tabIndex == 0 ? 1 : 0;
                                        if (Ext.isDefined(this.ownerCt.ownerCt.activateTabTitleAfterAvail)) {
                                            var activateTabTitleAfterAvail = this.ownerCt.ownerCt.activateTabTitleAfterAvail;
                                            if (Ext.isFunction(activateTabTitleAfterAvail)) {
                                                activateTabTitleAfterAvail = activateTabTitleAfterAvail.call(this);
                                            }
                                            for (var i = 0; i < this.ownerCt.ownerCt.items.getCount(); i++) {
                                                if (i !== tabIndex && (this.ownerCt.ownerCt.get(i).initialConfig.items.itemId === activateTabTitleAfterAvail || this.ownerCt.ownerCt.get(i).title === activateTabTitleAfterAvail)) {
                                                    index = i;
                                                    break;
                                                }
                                            }
                                        }
                                        this.ownerCt.ownerCt.setActiveTab(index);
                                        this.ownerCt.ownerCt.doLayout();
                                    }
                                }
                            }
                        }
                    }
                };
                if (dc) {
                    deferredCreate = true;
                    var origItems = cardContainerConfig.items;
                    cardContainerConfig.items = {layout: 'fit', xtype: 'pan-container', items: origItems};
                }
                items.push(cardContainerConfig);
            }
        }
        var autoHeight = true;
        if (comp.__pdefaults && Ext.isDefined(comp.__pdefaults.__recordFormAutoHeight)) {
            autoHeight = comp.__pdefaults.__recordFormAutoHeight;
        }
        Ext.applyIf(comp, {
            xtype: comp.vertical ? 'pan-vrtabpanel' : 'pan-tabpanel',
            items: items,
            autoHeight: autoHeight,
            vflex: !autoHeight,
            border: false,
            activeTab: Ext.isFunction(comp.getDefaultActiveTab) ? comp.getDefaultActiveTab(this.ownerCt) : 0,
            deferredRender: comp.__pdefaults && Ext.isDefined(comp.__pdefaults.tabBuilderDeferredRenderDefaultValue) ? comp.__pdefaults.tabBuilderDeferredRenderDefaultValue : true
        });
        if (deferredCreate) {
            Ext.apply(comp, {layoutOnTabChange: true});
        }
        if (config.field && comp.fieldLabel === config.field.uiHint.fieldLabelAutoGen) {
            comp.fieldLabel = '';
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("TabBuilder", Pan.base.autorender.builder.TabBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.RadioCardBuilder = (function () {
    var deferredCreateDefaultValue = false;
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        var radioItems = [];
        var cardItems = [];
        var children = config.field.children;
        var suffix = Pan.base.form.RadioCard.prototype.suffix;
        var groupName = config.field.name + "-group";
        var autoHeight = true;
        if (comp.vflex) {
            autoHeight = false;
        }
        var deferredCreate = Ext.isDefined(comp.deferredCreate) ? comp.deferredCreate : deferredCreateDefaultValue;
        Ext.each(children, function (child) {
            if (config.field.nodetype === undefined || (child.nodetype !== undefined && child.nodetype != "attr-req")) {
                var name = child.name;
                var available = true;
                if (child.uiHint && Ext.isFunction(child.uiHint.radioAvail)) {
                    available = child.uiHint.radioAvail(comp);
                }
                if (available) {
                    var inputValue = child.attrName || child.name;
                    var isDefaulValue = comp.__field && comp.__field.defaultValue && comp.__field.defaultValue === inputValue;
                    var boxLabel = config.field.uiHint && config.field.uiHint.useHelpStringAsDisplay ? child.uiHint.helpstring : (child.uiHint.boxLabel || child.uiHint.fieldLabel || child.uiHint.fieldLabelAutoGen);
                    if (comp.prependDefaultLabel && isDefaulValue) {
                        boxLabel = 'default (' + boxLabel + ')';
                    }
                    radioItems.push({
                        boxLabel: boxLabel,
                        inputValue: inputValue,
                        itemId: name,
                        name: groupName,
                        cardSelection: name + suffix
                    });
                    var cardItem = {
                        xtype: 'pan-container',
                        itemId: name + suffix,
                        items: {
                            itemId: name,
                            fieldLabel: child.uiHint.hideLabel === false ? child.uiHint.fieldLabel : '',
                            anchor: "100%"
                        }
                    };
                    var dc = Ext.isDefined(child.uiHint.deferredCreate) ? child.uiHint.deferredCreate : deferredCreate;
                    if (dc) {
                        Ext.apply(cardItem, {xtype: 'pan-cardcontainer', layout: 'fit', deferredCreate: true});
                    }
                    if (autoHeight) {
                        Ext.apply(cardItem, {layout: 'form', autoHeight: true});
                    }
                    else {
                        Ext.apply(cardItem, {layout: 'fit', autoHeight: false});
                    }
                    if (child.nodetype == "sequence") {
                        if (!child.initialFieldConfig || !child.initialFieldConfig.uiHint || !child.initialFieldConfig.uiHint.builder) {
                            Ext.applyIf(cardItem.items, {builder: "ContainerBuilder"});
                        }
                    }
                    if (comp.isAnEditor) {
                        Ext.apply(cardItem, {defaults: {formLabelAlign: 'top'}});
                    }
                    cardItems.push(cardItem);
                }
            }
        });
        if (comp.isAnEditor) {
            Ext.apply(comp, {frame: true, hideLabel: true});
        }
        Ext.applyIf(comp, {
            xtype: 'pan-radiocard',
            suffix: suffix,
            fieldLabel: config.field.uiHint.fieldLabel,
            radioItems: radioItems,
            cardItems: cardItems,
            formLabelWidth: this.formLabelWidth
        });
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("RadioCardBuilder", Pan.base.autorender.builder.RadioCardBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.getDefaultProxySelectionCommonName = function (metaField, field, oneValueFieldCommonName) {
    if (field.proxySelectionCommonName) {
        return field.proxySelectionCommonName;
    }
    if (oneValueFieldCommonName) {
        return oneValueFieldCommonName;
    }
    if (metaField.attrPath && field.attrPath) {
        if (field.attrPath.startsWith(metaField.attrPath + ".")) {
            return field.attrPath.substr(metaField.attrPath.length + 1);
        }
    }
    return field.attrName;
};
Pan.base.autorender.builder.combineProxySelectionFields = function (proxySelectionField, columnOrderFields, storeFieldsMap, storeFields, oneValueFieldCommonName, inlineEditing, ignoreUnionChildren) {
    proxySelectionField.uiHint = Ext.apply({}, proxySelectionField.uiHint);
    proxySelectionField.uiHint.columnConfig = Ext.apply({}, proxySelectionField.uiHint.columnConfig);
    Ext.applyIf(proxySelectionField.uiHint.columnConfig, {editor: {}});
    var mapping = {};
    for (var i = 0; i < proxySelectionField.children.length; i++) {
        var proxySelectionFieldChild = proxySelectionField.children[i];
        proxySelectionFieldChild.visit(function (field) {
            var fieldAvailable = true;
            if (field.uiHint && field.uiHint.columnConfig && field.uiHint.columnConfig.columnAvail) {
                fieldAvailable = field.uiHint.columnConfig.columnAvail();
            }
            if (!fieldAvailable) {
                return;
            }
            if (!field.children || field.isCollection || field.isTerminalForDisplay || ((field.nodetype === 'union' || field.nodetype === 'choice') && ignoreUnionChildren)) {
                if (field.includeTerminalChildrenForDisplay === false) {
                    return false;
                }
                var proxySelectionCommonName = Pan.base.autorender.builder.getDefaultProxySelectionCommonName(proxySelectionFieldChild, field, oneValueFieldCommonName);
                if (!mapping[proxySelectionCommonName]) {
                    var uiHint = Ext.apply({}, field.uiHint);
                    Ext.apply(uiHint, {
                        builder: undefined, allowBlank: true, columnConfig: Ext.applyIf({
                            renderer: function (v, meta, record, row, column, store, grid) {
                                grid = grid || meta.grid;
                                this.rendererGrid = grid;
                                var fields = grid.store.fields;
                                var realFieldName;
                                var namefield = fields.get("namefield");
                                if (namefield) {
                                    realFieldName = record.get("namefield");
                                    v = record.get("valuefield");
                                }
                                else {
                                    var proxyField = fields.get(this.dataIndex);
                                    var proxySelectionData = record.get(proxyField.proxySelectionFieldName);
                                    realFieldName = proxyField.proxyFieldMapping[proxySelectionData];
                                    if (realFieldName) {
                                        v = record.get(realFieldName);
                                    }
                                }
                                if (realFieldName) {
                                    var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                    var realColumn;
                                    if (realColumnIndex >= 0) {
                                        realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                    }
                                    if (realColumn && realColumn.renderer) {
                                        if (realColumn.doHTMLEncode !== false && Ext.isString(v)) {
                                            v = Pan.base.htmlEncode(v);
                                        }
                                        return realColumn.renderer.call(this, v, meta, record, row, realColumnIndex, store, grid);
                                    }
                                }
                                return v;
                            }, spanCellRenderer: function (v, meta, record, row, column, store, grid) {
                                grid = grid || this.rendererGrid;
                                var fields = grid.store.fields;
                                var realFieldName;
                                var namefield = fields.get("namefield");
                                if (namefield) {
                                    realFieldName = record.get("namefield");
                                }
                                else {
                                    var proxyField = fields.get(this.dataIndex);
                                    var proxySelectionData = record.get(proxyField.proxySelectionFieldName);
                                    realFieldName = proxyField.proxyFieldMapping[proxySelectionData];
                                }
                                if (realFieldName) {
                                    var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                    var realColumn;
                                    if (realColumnIndex >= 0) {
                                        realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                    }
                                    if (realColumn && realColumn.spanCellRenderer) {
                                        return realColumn.spanCellRenderer.call(this, v, meta, record, row, realColumnIndex, store, grid);
                                    }
                                }
                                return v;
                            }, getCellEditor: function (row) {
                                if (Ext.isDefined(row) && Ext.isDefined(this.rendererGrid)) {
                                    var grid = this.rendererGrid;
                                    var record = grid.store.getAt(row);
                                    var fields = grid.store.fields;
                                    var realFieldName;
                                    var namefield = fields.get("namefield");
                                    var v;
                                    if (namefield) {
                                        realFieldName = record.get("namefield");
                                        v = record.get("valuefield");
                                    }
                                    else {
                                        var proxyField = fields.get(this.dataIndex);
                                        var proxySelectionData = record.get(proxyField.proxySelectionFieldName);
                                        realFieldName = proxyField.proxyFieldMapping[proxySelectionData];
                                        if (realFieldName) {
                                            v = record.get(realFieldName);
                                        }
                                    }
                                    if (realFieldName) {
                                        var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                        var realColumn;
                                        if (realColumnIndex >= 0) {
                                            realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                        }
                                        if (realColumn && realColumn.getCellEditor) {
                                            return realColumn.getCellEditor.call(realColumn, 0);
                                        }
                                    }
                                }
                                return undefined;
                            }
                        }, field.uiHint.columnConfig)
                    });
                    if (!inlineEditing) {
                        Ext.apply(uiHint.columnConfig, {editor: {}});
                    }
                    mapping[proxySelectionCommonName] = {uiHint: uiHint};
                    mapping[proxySelectionCommonName]['proxyFieldMapping'] = {};
                }
                var proxyFieldMapping = mapping[proxySelectionCommonName]['proxyFieldMapping'];
                proxyFieldMapping[proxySelectionFieldChild.attrName] = field.name;
                var realField = storeFieldsMap[field.name] = Ext.apply({}, field.clone());
                realField.uiHint = Ext.apply({}, realField.uiHint);
                realField.uiHint.columnConfig = Ext.apply({}, realField.uiHint.columnConfig);
                Ext.applyIf(realField.uiHint.columnConfig, {hidden: true, hideable: false});
                if (!inlineEditing) {
                    Ext.applyIf(realField.uiHint.columnConfig, {editor: {}});
                }
                columnOrderFields.push(realField.name);
                if (field.isTerminalForDisplay && field.includeTerminalChildrenForDisplay) {
                    return true;
                }
                return false;
            }
        });
    }
    for (var commonName in mapping) {
        if (mapping.hasOwnProperty(commonName)) {
            var name = oneValueFieldCommonName || commonName;
            storeFields.push({
                name: name,
                proxySelectionFieldName: proxySelectionField.name,
                proxyFieldMapping: mapping[commonName]['proxyFieldMapping'],
                uiHint: mapping[commonName].uiHint,
                saveMap: ""
            });
            columnOrderFields.push(name);
        }
    }
};
Pan.base.autorender.builder.EditorGridBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        var storeFields, allFields, columnOrderFields, keyFieldName,
            height = comp.height || Pan.base.Constants.defaultEditorGridHeight;
        var starChild = config.field.children && config.field.children[0];
        if (!starChild) {
            return comp;
        }
        if (!comp.store) {
            storeFields = [];
            columnOrderFields = [];
            if (starChild.children) {
                var storeFieldsMap = {};
                starChild.visit(function (field) {
                    if (field.uiHint.isKeyField) {
                        keyFieldName = field.name;
                    }
                    storeFieldsMap[field.name] = field.clone();
                    if ((field.nodetype === 'union' || field.nodetype === 'choice') && comp.showUnionChildren) {
                        columnOrderFields.push(field.name);
                        Pan.base.autorender.builder.combineProxySelectionFields(field, columnOrderFields, storeFieldsMap, storeFields);
                        return false;
                    }
                    else if (!field.children || field.isCollection || field.nodetype === 'union' || field.nodetype === 'choice') {
                        columnOrderFields.push(field.name);
                        return false;
                    }
                }, this);
                starChild.visit(function (field) {
                    if (!storeFieldsMap[field.name]) {
                        storeFieldsMap[field.name] = field;
                    }
                }, this);
                allFields = storeFields.slice(0);
                for (var i = 0; i < config.fields.length; i++) {
                    var field = config.fields.items[i];
                    var mapfield = storeFieldsMap[field.name];
                    if (mapfield) {
                        storeFields.push(mapfield);
                        allFields.push(mapfield);
                    }
                    else {
                        allFields.push(field);
                    }
                }
            }
            else {
                storeFields.push(starChild.clone());
                allFields = storeFields.slice(0);
                keyFieldName = starChild.name;
                columnOrderFields.push(starChild.name);
            }
            var fieldsByPath = new Ext.util.MixedCollection(false, function (field) {
                return field.attrPath;
            });
            for (var k = 0; k < allFields.length; k++) {
                fieldsByPath.add(allFields[k]);
            }
            Ext.applyIf(comp, {
                useColumns: 'columnOrderFields',
                columnOrderFields: columnOrderFields,
                miniCellRowLines: false,
                store: {
                    ztype: comp.ztype || Pan.base.autorender.GridRecordStore,
                    zconfig: Ext.apply({
                        localStore: true,
                        fields: storeFields,
                        fieldsByPath: fieldsByPath,
                        idProperty: keyFieldName,
                        reader: Ext.extend(Ext.data.JsonReader, {
                            createAccessor: function () {
                                return Pan.base.PanDecode.createAccessor;
                            }
                        })
                    }, comp.zconfig)
                }
            });
        }
        if (config.field.maxCount == 1 && !Ext.isDefined(comp.ignoreSingleEntry)) {
            Ext.applyIf(comp, {xtype: 'pan-singleentry'});
        }
        else {
            if (comp.showBbar == false) {
                comp.bbar = '';
            }
            if (!Ext.isDefined(comp.bbar)) {
                comp.bbar = [{
                    atype: 'addRecordAction',
                    checkCount: true,
                    nontransferable: true
                }, {atype: 'deleteRecordAction'}];
                if (comp.useClone) {
                    comp.bbar.push("cloneRecordAction");
                }
                if (comp.isOrdered) {
                    comp.bbar.push("moveUpRecordAction", "moveDownRecordAction");
                    Ext.applyIf(comp, {enableDragDrop: true, ddGroup: config.field.name});
                }
                if (comp.drawer) {
                    comp.bbar.unshift(_T('browseAction'));
                }
            }
            if (Ext.isNumber(config.field.maxCount) && config.field.maxCount <= Pan.base.Constants.showGridFilterLimit) {
                Ext.applyIf(comp, {hasGridFilter: false});
            }
            if (comp.fieldLabel === comp.fieldLabelAutoGen) {
                Ext.apply(comp, {fieldLabel: ''});
            }
            if (comp.isAnEditor) {
                Ext.applyIf(comp, {frame: true, hasGridFilter: false});
                if (columnOrderFields.length <= 1) {
                    Ext.applyIf(comp, {hideHeaders: true});
                }
                height = Pan.base.Constants.defaultGridEditorHeight;
                if (config.caller && Ext.isNumber(config.caller.height)) {
                    if (height > (config.caller.height - 50)) {
                        height = config.caller.height - 50;
                    }
                }
            }
            if (starChild.multitypes) {
                Ext.applyIf(comp, {xtype: 'pan-multitypegrid', height: height});
            }
            else {
                Ext.applyIf(comp, {xtype: 'pan-editorgrid', height: height});
            }
            comp.style = comp.style || {};
            if (Ext.isObject(comp.style)) {
                Ext.applyIf(comp.style, {marginBottom: Pan.base.Constants.generatedGridMarginBottom});
            }
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("EditorGridBuilder", Pan.base.autorender.builder.EditorGridBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.PropertyGridBuilder = (function () {
    var mergeDefaults = function (field, values) {
        var choiceValue;
        if (field.children) {
            if (field.choiceParentAttr) {
                if (field.getData(values) === undefined) {
                    var o = field.choiceParentAttr.getData(values);
                    if (!Ext.isObject(o)) {
                        if (Ext.isDefined(o) && o !== "") {
                            choiceValue = o;
                        }
                        else {
                            choiceValue = field.defaultValue;
                        }
                    }
                    else {
                        for (var i = 0; i < field.children.length; i++) {
                            var child = field.children[i];
                            if (o[child.attrName]) {
                                choiceValue = child.attrName;
                                break;
                            }
                        }
                    }
                }
                if (choiceValue) {
                    field.setData(values, choiceValue);
                }
            }
            for (var j = 0; j < field.children.length; j++) {
                var childField = field.children[j];
                if (choiceValue) {
                    if (childField.attrName === choiceValue) {
                        mergeDefaults(childField, values);
                        break;
                    }
                }
                else {
                    if (!childField.choiceParentAttr && Ext.isDefined(childField.defaultValue) && childField.defaultValue !== "") {
                        if (childField.getData(values) === undefined) {
                            childField.setData(values, childField.defaultValue);
                        }
                    }
                    else {
                        mergeDefaults(childField, values);
                    }
                }
            }
        }
    };
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return null;
        }
        var isNotInline, valueField;
        var propertyRootField = Ext.isDefined(comp.propertyRootField) ? comp.propertyRootField : comp.itemId;
        if (comp.isMultiProperty) {
            Ext.applyIf(comp, {
                hideLabel: true,
                xtype: 'pan-multipropertygrid',
                columnConfig: Ext.applyIf({}, comp.titleColumnConfig)
            });
        }
        else if (propertyRootField) {
            var allFields = comp.__pdefaults.__fields;
            propertyRootField = allFields.get(propertyRootField);
            var storeFieldsMap = {};
            var storeFields = [], columnOrderFields = [];
            Pan.base.autorender.builder.combineProxySelectionFields(propertyRootField, columnOrderFields, storeFieldsMap, storeFields, "valuefield", Ext.isDefined(comp.inlineEditing) ? comp.inlineEditing : true, true);
            isNotInline = comp.isWidget || (Ext.isDefined(comp.inlineEditing) && !comp.inlineEditing);
            valueField = $.extend(true, storeFields[0], {
                uiHint: {
                    columnConfig: {sortable: false},
                    editable: true,
                    fieldLabel: _T("Values")
                }
            });
            if (!valueField.uiHint.columnConfig.renderer) {
                throw new Error("Renderer should be defined in combineProxySelectionFields");
            }
            valueField.uiHint.columnConfig.renderer = Pan.base.util.createExtension(function (dataValue, meta, record, row, column, store, grid) {
                var rv = arguments.callee.superFunction.apply(this, arguments);
                var realFieldName = grid.colModel.getRealFieldName(record, grid, this);
                if (realFieldName) {
                    var index = grid.colModel.findColumnIndex(realFieldName);
                    var col = grid.colModel.getColumnAt(index);
                    if (col.propertyRenderer) {
                        var gridStore = grid.store;
                        var values = grid.__pdefaults && grid.__pdefaults.__recordFormRecord && grid.__pdefaults.__recordFormRecord.json;
                        values = values ? Pan.base.clone(values) : {};
                        var rf = gridStore.fields.get(realFieldName);
                        mergeDefaults(rf, values);
                        var value = Pan.base.json.path(values, realFieldName);
                        var a = col.propertyRenderer(value, values, gridStore);
                        rv = [];
                        for (var i = 1; i < a.length; i += 2) {
                            rv.push(a[i]);
                        }
                    }
                    else {
                        if (!isNotInline) {
                            var realField = grid.store.fields.get(realFieldName);
                            var doEncoding = col.doHTMLEncode !== false && Ext.isString(dataValue) && dataValue != '&#160;';
                            var emptyText = Pan.base.genEmptyText(realField.uiHint, realField, doEncoding);
                            var defaultValue = doEncoding ? Pan.base.htmlEncode(realField.defaultValue) : realField.defaultValue;
                            if (defaultValue === dataValue && emptyText) {
                                rv = emptyText;
                                meta.css += ' ' + Pan.base.form.TextField.prototype.emptyClass;
                            }
                            else {
                                meta.css.replace(Pan.base.form.TextField.prototype.emptyClass, '');
                            }
                        }
                    }
                }
                return rv;
            }, valueField.uiHint.columnConfig.renderer);
            valueField.uiHint.columnConfig.renderer.onClick = function (grid, config) {
                var realFieldName = grid.colModel.getRealFieldName(config.record, grid, this);
                if (realFieldName) {
                    var index = grid.colModel.findColumnIndex(realFieldName);
                    var col = grid.colModel.getColumnAt(index);
                    if (col.renderer && col.renderer.onClick) {
                        col.renderer.onClick.apply(this, arguments);
                    }
                }
            };
            var fields = [{
                name: 'metafield',
                uiHint: {columnConfig: {hidden: true, hideable: false, renderer: Ext.emptyFn}}
            }, {name: 'namefield', uiHint: {columnConfig: {hidden: true, hideable: false, renderer: Ext.emptyFn}}}, {
                name: 'titlefield', uiHint: {
                    isKeyField: true, fieldLabel: _T('Name'), columnConfig: Ext.apply({
                        doHTMLEncode: false,
                        sortable: false,
                        renderer: function (v, meta, record, row, column, store, grid) {
                            var realFieldName = grid.colModel.getRealFieldName(record, grid, this);
                            if (realFieldName) {
                                var index = grid.colModel.findColumnIndex(realFieldName);
                                var col = grid.colModel.getColumnAt(index);
                                var source, value;
                                if (grid.__pdefaults && grid.__pdefaults.__recordFormRecord && grid.__pdefaults.__recordFormRecord.store && grid.__pdefaults.__recordFormRecord.store.__ptpl) {
                                    source = grid.__pdefaults.__recordFormRecord.store.__ptpl;
                                }
                                var values = grid.__pdefaults && grid.__pdefaults.__recordFormRecord && grid.__pdefaults.__recordFormRecord.json;
                                if (col.propertyRenderer) {
                                    var gridStore = grid.store;
                                    values = values ? Pan.base.clone(values) : {};
                                    var rf = gridStore.fields.get(realFieldName);
                                    mergeDefaults(rf, values);
                                    value = Pan.base.json.path(values, realFieldName);
                                    var a = col.propertyRenderer(value, values, gridStore);
                                    v = [];
                                    for (var i = 0; i < a.length; i += 2) {
                                        v.push(a[i]);
                                    }
                                }
                                else {
                                    var realField = grid.store.fields.get(realFieldName);
                                    if (realField) {
                                        v = Pan.base.genLabel(realField.uiHint, v);
                                    }
                                }
                            }
                            if (comp.translateTitle) {
                                v = _T(v);
                            }
                            return v;
                        }
                    }, comp.titleColumnConfig, {align: isNotInline ? "right" : undefined, editor: {}})
                }
            }, valueField];
            var data = [];
            for (var j = 0; j < columnOrderFields.length; j++) {
                var field = storeFieldsMap[columnOrderFields[j]];
                if (field) {
                    fields.push(field);
                    var rowData = {};
                    rowData['valuefield'] = field.defaultValue;
                    rowData['titlefield'] = field.uiHint && ((field.uiHint.columnConfig && field.uiHint.columnConfig.header) || field.uiHint.fieldLabel);
                    rowData['metafield'] = field;
                    rowData['namefield'] = field.name;
                    data.push(rowData);
                }
            }
            fields = Ext.data.Field.prototype.orderFields(fields);
            Ext.applyIf(comp, {
                miniCellRowLines: false,
                store: {
                    ztype: comp.ztype || Pan.base.propertygrid.PropertyStore,
                    zconfig: Ext.apply({
                        baseField: config.field,
                        localStore: true,
                        fields: fields,
                        data: data,
                        idProperty: 'namefield'
                    }, comp.zconfig)
                },
                deferRowRender: false,
                xtype: comp.useList ? 'pan-propertylist' : 'pan-propertygrid',
                hideLabel: true,
                hideHeaders: true,
                autoHeight: true,
                viewConfig: {markDirty: false}
            });
        }
        else if (!comp.store) {
            Ext.applyIf(comp, {
                height: 200,
                xtype: 'pan-propertygrid',
                miniCellRowLines: false,
                store: {ztype: Pan.base.propertygrid.PropertyStore, zconfig: {baseField: config.field}}
            });
        }
        comp.style = comp.style || {};
        if (isNotInline) {
            Ext.applyIf(valueField.uiHint.columnConfig, comp.useList ? {cls: "propertylist-value-col"} : {css: "color: #000; "});
            comp.cls += ' pan_widget';
            comp.stripeRows = false;
            comp.columnLines = false;
            comp.sm = new Ext.grid.CellSelectionModel({
                listeners: {
                    beforecellselect: function () {
                        return false;
                    }
                }
            });
        }
        if (Ext.isObject(comp.style)) {
            Ext.applyIf(comp.style, {marginBottom: Pan.base.Constants.generatedGridMarginBottom});
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("PropertyGridBuilder", Pan.base.autorender.builder.PropertyGridBuilder);
Pan.base.autorender.builder.PasswordBuilder = (function () {
    return Pan.base.util.createExtension(function (comp) {
        if (comp.xtype) {
            return;
        }
        Ext.apply(comp, {xtype: 'pan-passwordverify', autoHeight: true});
        if (comp.isAnEditor) {
            Ext.applyIf(comp, {cls: '', frame: true, labelAlign: 'top'});
        }
        return comp;
    }, Pan.base.autorender.builder.ContainerBuilder);
})();
Pan.breg("PasswordBuilder", Pan.base.autorender.builder.PasswordBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.GridRecordFormBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        var form = {};
        for (var m in comp) {
            if (comp.hasOwnProperty(m)) {
                form[m] = comp[m];
                delete comp[m];
            }
        }
        if (config.caller && config.caller.recordForm) {
            Ext.applyIf(form, config.caller.recordForm);
        } else {
            var recordFormField = form.recordFormField || config.field;
            if (!recordFormField) {
                if (config.caller && config.caller.getStarField) {
                    recordFormField = config.caller.getStarField();
                }
            }
            if (recordFormField) {
                Ext.applyIf(form, {
                    items: [{itemId: recordFormField.name}],
                    recordFormField: recordFormField,
                    recordFormTitle: config.recordFormTitle || (recordFormField.uiHint && recordFormField.uiHint.fieldLabel)
                });
            }
        }
        if (form) {
            if (!form.items) {
                form.items = form.fields;
            }
            if (form.items) {
                for (var i = 0; i < form.items.length; i++) {
                    var item = form.items[i];
                    if (item.config) {
                        var itemConfig = item.config;
                        delete item.config;
                        Ext.apply(item, itemConfig);
                    }
                    if (item.dataIndex) {
                        Ext.applyIf(item, {itemId: item.dataIndex});
                        delete item.dataIndex;
                    }
                    if (item.action) {
                        form.actions = form.actions || [];
                        form.actions.push({field: item.itemId, action: item.action});
                        delete item.action;
                    }
                }
                form.columnCount = form.columnCount || 1;
            }
        }
        return Ext.apply(comp, {
            isARecordEditor: true,
            dataExtractor: config.caller && config.caller.__pdefaults && config.caller.__pdefaults.__dataExtractor,
            store: form.store || config.store,
            recordBinder: (form.store && form.store.recordBinder) || (config.store && config.store.recordBinder),
            record: form.record || config.record,
            recordForm: form,
            scope: form.scope,
            okIconCls: undefined,
            cancelIconCls: undefined,
            windowConfig: Ext.apply({title: form.recordFormTitle, itemId: form.recordFormField.name}, form.windowConfig)
        });
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("GridRecordFormBuilder", Pan.base.autorender.builder.GridRecordFormBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.GroupingGridBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        var storeFields, columnOrderFields, keyFieldName, groupFieldName;
        if (!comp.store) {
            var starChild = config.field.children[0];
            storeFields = [];
            columnOrderFields = [];
            if (starChild && starChild.children) {
                for (var i = 0, n = starChild.children.length; i < n; i++) {
                    if (starChild.children[i].children) {
                        var nextLevelStarChild = starChild.children[i].children[0].children[0];
                        var isGrpField = comp.groupedField ? (nextLevelStarChild.name == comp.groupedField) && nextLevelStarChild.children : nextLevelStarChild.children;
                        if (isGrpField) {
                            var storeFieldsMap = {};
                            nextLevelStarChild.visit(function (field) {
                                storeFieldsMap[field.name] = field.clone();
                                if ((field.nodetype === 'union' || field.nodetype === 'choice') && comp.showUnionChildren) {
                                    columnOrderFields.push(field.name);
                                    Pan.base.autorender.builder.combineProxySelectionFields(field, columnOrderFields, storeFieldsMap, storeFields);
                                    return false;
                                }
                                else if (!field.children || field.isCollection || field.nodetype === 'union' || field.nodetype === 'choice') {
                                    columnOrderFields.push(field.name);
                                    return false;
                                }
                            }, this);
                            for (var j = 0; j < config.fields.length; j++) {
                                var field = config.fields.items[j];
                                var mapfield = storeFieldsMap[field.name];
                                if (mapfield) {
                                    storeFields.push(mapfield);
                                }
                            }
                        }
                        else {
                            storeFields.push(nextLevelStarChild.clone());
                        }
                    }
                    else {
                        storeFields.push(starChild.children[i].clone());
                        columnOrderFields.push(starChild.children[i].name);
                        keyFieldName = starChild.children[i].name;
                    }
                }
                Ext.applyIf(comp, {height: 300});
            }
            else {
                storeFields.push(starChild.clone());
                keyFieldName = starChild.name;
            }
            storeFields = Ext.data.Field.prototype.orderFields(storeFields);
            groupFieldName = comp.groupByAttribute ? comp.groupByAttribute : keyFieldName;
            Ext.applyIf(comp, {
                height: 200,
                xtype: 'pan-groupinggrid',
                useColumns: 'columnOrderFields',
                columnOrderFields: columnOrderFields,
                miniCellRowLines: false,
                store: {
                    ztype: Pan.base.autorender.GroupingGridStore,
                    zconfig: {
                        localStore: true,
                        fields: storeFields,
                        groupField: groupFieldName,
                        reader: Ext.extend(Ext.data.JsonReader, {
                            createAccessor: function () {
                                return Pan.base.PanDecode.createAccessor;
                            }
                        })
                    }
                }
            });
            comp.style = comp.style || {};
            if (Ext.isObject(comp.style)) {
                Ext.applyIf(comp.style, {marginBottom: Pan.base.Constants.generatedGridMarginBottom});
            }
        }
        if (comp.fieldLabel === comp.fieldLabelAutoGen) {
            Ext.apply(comp, {fieldLabel: ''});
        }
        if (!comp.bbar) {
            comp.bbar = [{atype: 'addGroupRecordAction', field: comp.groupedField}, {
                atype: 'addGroupAction',
                checkCount: true
            }, {atype: 'deleteGroupRecordAction'}];
            if (comp.isOrdered) {
                comp.bbar.push({atype: "moveUpRecordAction", doNotCheckSelection: true});
                comp.bbar.push({atype: "moveDownRecordAction", doNotCheckSelection: true});
                Ext.apply(comp.store.zconfig, {multiSort: false, multiSortInfo: undefined});
            }
            if (comp.drawer) {
                comp.bbar.push('browseAction');
            }
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("GroupingGridBuilder", Pan.base.autorender.builder.GroupingGridBuilder);
Pan.base.autorender.builder.ExplorerBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        var items = comp.items;
        var itemIds = [];
        if (!items) {
            items = [];
            for (var i = 0; i < config.field.childrenNames.length; i++) {
                var cardContainer = config.field.children[i].uiHint;
                var cardContainerConfig = {
                    xtype: 'pan-cardcontainer',
                    layout: 'fit',
                    deferredCreate: Ext.isDefined(cardContainer.deferredCreate) ? cardContainer.deferredCreate : true,
                    title: cardContainer.tabTitle || cardContainer.fieldLabel,
                    items: {itemId: config.field.childrenNames[i]}
                };
                var origItems = cardContainerConfig.items;
                cardContainerConfig.items = {layout: 'fit', xtype: 'pan-container', items: origItems};
                items.push(cardContainerConfig);
                itemIds.push(config.field.childrenNames[i]);
            }
        }
        var autoHeight = true;
        if (comp.__pdefaults && Ext.isDefined(comp.__pdefaults.__recordFormAutoHeight)) {
            autoHeight = comp.__pdefaults.__recordFormAutoHeight;
        }
        Ext.applyIf(comp, {
            xtype: 'pan-explorer',
            cardItems: items,
            itemIds: itemIds,
            autoHeight: autoHeight,
            vflex: !autoHeight,
            activeItem: 0
        });
        if (config.field && comp.fieldLabel === config.field.uiHint.fieldLabelAutoGen) {
            comp.fieldLabel = '';
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
})();
Pan.breg("ExplorerBuilder", Pan.base.autorender.builder.ExplorerBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.ObjectFieldBuilder = (function () {
    return Pan.base.util.createExtension(function (comp) {
        if (comp.xtype) {
            return;
        }
        if (comp.isAnEditor) {
            Ext.apply(comp, {frame: true});
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        Ext.apply(comp, {xtype: 'pan-objectfield'});
        return comp;
    }, Pan.base.autorender.builder.ContainerBuilder);
})();
Pan.breg("ObjectFieldBuilder", Pan.base.autorender.builder.ObjectFieldBuilder);
Ext.ns('Pan.base.autorender.builder');
Pan.base.autorender.builder.PanelBuilder = (function () {
    return Pan.base.util.createExtension(function (comp) {
        if (comp.xtype) {
            return;
        }
        var title = comp.fieldLabel;
        comp = arguments.callee.superFunction.apply(this, arguments);
        Ext.apply(comp, {xtype: 'pan-panel', fieldLabel: ''});
        Ext.applyIf(comp, {title: title, border: false});
        return comp;
    }, Pan.base.autorender.builder.ContainerBuilder);
})();
Pan.breg("PanelBuilder", Pan.base.autorender.builder.PanelBuilder);
Ext.namespace('Pan.base.form');
Pan.base.form.RadioCard = Ext.extend(Pan.base.container.Container, {
    largeSelectionCount: 3,
    useCheckBoxSelection: false,
    suffix: "-card",
    hideSelectionForSingleChoice: true,
    constructor: function () {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.form.RadioCard.superclass.constructor.apply(this, arguments);
    },
    initComponent: function () {
        var allSingleElementChildren = false;
        if (this.__field && this.__field.children) {
            allSingleElementChildren = true;
            for (var c = 0; c < this.__field.children.length; c++) {
                var child = this.__field.children[c];
                if (child.type === "password") {
                    allSingleElementChildren = false;
                    break;
                }
                if ((child.nodetype !== undefined && child.nodetype != "attr-req")) {
                    if (child.nodetype !== 'element') {
                        allSingleElementChildren = false;
                        break;
                    }
                }
            }
        }
        var realItemCount = this.initialConfig.radioItems.length;
        var isSingleChoice = realItemCount === 1 && !this.noneString;
        var singleLineLayout = this.singleLineLayout;
        if (Ext.isFunction(singleLineLayout)) {
            singleLineLayout = singleLineLayout.apply(this);
        }
        singleLineLayout = (singleLineLayout === undefined && allSingleElementChildren === true) ? true : singleLineLayout;
        if (singleLineLayout) {
            Ext.each(this.initialConfig.cardItems, function (cItem) {
                if (cItem.items) {
                    cItem.items.hideLabel = true;
                    cItem.items.fieldLabelPlugin = undefined;
                }
            });
            Ext.apply(this, {
                largeSelectionCount: 0,
                rfLayoutConfig: Pan.base.autorender.layout.RFColumnLayoutConfig,
                columnCount: isSingleChoice && this.hideSelectionForSingleChoice !== false ? 1 : 2
            });
        }
        if (this.noneString) {
            if (isSingleChoice && singleLineLayout) {
                var items = this.initialConfig.cardItems[0].items;
                this.initialConfig.cardItems[0].items = [];
                if (!Ext.isArray(items)) {
                    this.initialConfig.cardItems[0].items.push(items);
                }
                items = this.initialConfig.cardItems[0].items;
                for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
                    items[itemIndex].allowBlank = true;
                }
            } else {
                var noneStringStructure = {
                    boxLabel: this.noneString,
                    inputValue: undefined,
                    name: this.initialConfig.radioItems[0].name,
                    cardSelection: this.noneString + this.suffix
                };
                if (this.noneStringFirst) {
                    this.initialConfig.radioItems.unshift(noneStringStructure);
                } else {
                    this.initialConfig.radioItems.push(noneStringStructure);
                }
                this.initialConfig.cardItems.unshift({
                    xtype: 'pan-container',
                    itemId: this.noneString + this.suffix,
                    autoHeight: true
                });
            }
        }
        var selectionComponent, i;
        if (this.useCheckBoxSelection && this.initialConfig.radioItems.length <= 2) {
            selectionComponent = {
                xtype: 'pan-checkbox',
                itemId: this.initialConfig.itemId,
                listeners: {
                    'check': function (checkbox, checked) {
                        var card = this.findByItemId(checkbox.itemId + this.suffix);
                        var activeItem = checked ? 1 : 0;
                        if (card.layout.setActiveItem) {
                            card.layout.setActiveItem(activeItem);
                        } else {
                            card.activeItem = activeItem;
                        }
                    }, scope: this
                },
                getValue: function () {
                    if (this.radioCardForSequence) {
                        return Pan.base.form.Checkbox.prototype.getValue.call(this);
                    }
                    var v = Pan.base.form.Checkbox.prototype.getValue.apply(this, arguments);
                    return this.ownerCt.initialConfig.radioItems[!this.noneStringFirst && v ? 1 : 0].inputValue;
                },
                setValue: function (v) {
                    var boolValue = Ext.isBoolean(v) ? v : Ext.isObject(v) ? true : this.ownerCt.initialConfig.radioItems.length > 0 ? this.ownerCt.initialConfig.radioItems[1].inputValue == v : false;
                    return Pan.base.form.Checkbox.prototype.setValue.call(this, boolValue);
                }
            };
        } else if (this.initialConfig.radioItems.length >= this.largeSelectionCount) {
            var radioItems = this.initialConfig.radioItems;
            var comboItems = [];
            for (i = 0; i < radioItems.length; i++) {
                var item = radioItems[i];
                comboItems.push([item.inputValue || this.noneString, item.boxLabel, item.cardSelection]);
            }
            selectionComponent = {
                xtype: 'pan-combo',
                anchor: singleLineLayout ? "-" + Pan.base.autorender.layout.LayoutConfigConstants.leftAnchorSize : '100%',
                allowBlank: this.allowBlank,
                itemId: this.initialConfig.itemId,
                store: comboItems,
                listeners: {
                    'valuechange': function (combo, newValueDataExternal, newValueDataInternal) {
                        var record = combo.findRecord(combo.valueField, newValueDataInternal);
                        if (record) {
                            var card = this.findByItemId(combo.itemId + this.suffix);
                            var activeItem = record.data.field3;
                            if (card.layout.setActiveItem) {
                                card.layout.setActiveItem(activeItem);
                            } else {
                                card.activeItem = activeItem;
                            }
                        }
                    }, scope: this
                }
            };
        } else {
            selectionComponent = {
                xtype: 'pan-radiogroup',
                useFlowStyle: true,
                allowBlank: this.allowBlank,
                itemId: this.initialConfig.itemId,
                value: this.initialConfig.radioItems[0].inputValue,
                items: this.initialConfig.radioItems,
                listeners: {
                    'change': function (radiogroup, checked) {
                        if (checked) {
                            var card = this.findByItemId(radiogroup.itemId + this.suffix);
                            var activeItem = checked.cardSelection;
                            if (card.layout.setActiveItem) {
                                card.layout.setActiveItem(activeItem);
                            } else {
                                card.activeItem = activeItem;
                            }
                        }
                    }, scope: this
                }
            };
            if (this.hideLabel && !this.fieldLabel) {
                selectionComponent.hideLabel = true;
            } else {
                selectionComponent.cls = "x-form-radio-group-with-label";
            }
            if (isSingleChoice && this.hideSelectionForSingleChoice !== false) {
                this.fieldLabel = '';
            }
        }
        delete this.itemId;
        for (i = 0; i < this.initialConfig.cardItems.length; i++) {
            this.initialConfig.cardItems[i].radioCard = this;
            if (Ext.isDefined(this.formLabelWidth)) {
                this.initialConfig.cardItems[i].defaults = this.initialConfig.cardItems[i].defaults || {};
                Ext.applyIf(this.initialConfig.cardItems[i].defaults, {
                    formLabelWidth: this.formLabelWidth,
                    labelWidth: this.formLabelWidth
                });
                Ext.applyIf(this.initialConfig.cardItems[i], {labelWidth: this.formLabelWidth});
            }
        }
        var cards = {
            region: 'center',
            xtype: 'pan-container',
            anchor: '100%',
            layout: 'tabcard',
            layoutConfig: {type: 'radiocard', layoutOnCardChangeFirstTimeOnly: true},
            itemId: this.initialConfig.itemId + this.suffix,
            activeItem: 0,
            items: this.initialConfig.cardItems
        };
        Ext.apply(selectionComponent, {region: 'north', showHelpString: false});
        if (!singleLineLayout && (this.vflex || this.flex)) {
            Ext.apply(this, {
                layout: 'border',
                autoHeight: false,
                items: [{
                    region: 'north',
                    xtype: 'pan-container',
                    layout: 'form',
                    layoutConfig: {trackLabels: true},
                    fieldLabel: this.fieldLabel,
                    hideLabel: this.hideLabel,
                    items: selectionComponent
                }, cards]
            });
        } else {
            Ext.apply(this, {
                layout: 'form',
                autoHeight: true,
                layoutConfig: {trackLabels: true},
                items: [selectionComponent, cards]
            });
        }
        if (isSingleChoice && this.hideSelectionForSingleChoice !== false) {
            selectionComponent.hidden = true;
            if (!singleLineLayout) {
                delete this.fieldLabel;
            }
        } else {
            Ext.apply(selectionComponent, {fieldLabel: this.fieldLabel, hideLabel: this.hideLabel});
            delete this.fieldLabel;
        }
        if (this.helpTip) {
            Ext.apply(selectionComponent, {helpTip: this.helpTip});
            delete this.helpTip;
        }
        if (this.avail) {
            selectionComponent.avail = Pan.base.util.integrateArray(selectionComponent.avail, this.avail);
            delete this.avail;
        }
        if (this.association) {
            selectionComponent.association = Pan.base.util.integrateArray(selectionComponent.association, this.association);
            delete this.association;
        }
        Pan.base.form.RadioCard.superclass.initComponent.apply(this, arguments);
        if (this.initialConfig.selectionComponentListeners) {
            var listenerObj = this.initialConfig.selectionComponentListeners;
            for (var m in listenerObj) {
                if (listenerObj.hasOwnProperty(m)) {
                    this.getSelectionComponent().addListener(m, listenerObj[m], listenerObj['scope'] || this, listenerObj['options']);
                }
            }
        }
    },
    getSelectionComponent: function () {
        return this.findByItemId(this.initialConfig.itemId);
    },
    getSelection: function () {
        return this.getSelectionComponent().getValue();
    },
    reset: function () {
        this.getSelectionComponent().reset();
    },
    setValue: function (v) {
        if (!this.rendered) {
            return;
        }
        if (!v) {
            v = this.__field.defaultValue;
        }
        var name = this.__field.name;
        name = name.replace(/\.choice$/, "");
        var card;
        if (v) {
            card = this.findByItemId(name + "." + v + this.suffix);
        } else {
            card = this.findByItemId(this.noneString + this.suffix);
        }
        if (!card) {
            return;
        }
        var comp = card.get(0);
        if (comp) {
            var ownerCt = this;
            while (ownerCt.ownerCt) {
                ownerCt = ownerCt.ownerCt;
            }
            if (ownerCt.__editRecord) {
                comp.setValue(ownerCt.__editRecord.get(comp.__field.name));
            }
        }
        this.getSelectionComponent().setValue(v);
    },
    getValue: function () {
        var v = this.getSelection();
        var name = this.__field.name;
        name = name.replace(/\.choice$/, "");
        var card;
        if (v) {
            card = this.findByItemId(name + "." + v + this.suffix);
        } else {
            card = this.findByItemId(this.noneString + this.suffix);
        }
        var comp = card.get(0);
        if (comp) {
            var ownerCt = this;
            while (ownerCt.ownerCt) {
                ownerCt = ownerCt.ownerCt;
            }
            if (ownerCt.__editRecord) {
                ownerCt.__editRecord.set(comp.__field.name, comp.getValue());
            }
        }
        return v;
    }
});
Ext.reg('pan-radiocard', Pan.base.form.RadioCard);
Pan.base.form.Checkbox = Ext.extend(Ext.form.Checkbox, {
    associationEvent: 'check', testValueChangedEvents: ['check', false], constructor: function (config) {
        config = config || {};
        if (!config.hideBoxLabel) {
            if (config.fieldLabel && config.fieldLabel !== config.fieldLabelAutoGen) {
                Ext.applyIf(config, {boxLabel: config.fieldLabel});
            }
            var helpString = config.helpstring;
            if (helpString) {
                Ext.applyIf(config, {boxLabel: Pan.i18n(helpString)});
                delete config.helpstring;
            }
            if (!config.boxLabel) {
                config.boxLabel = config.fieldLabel;
            }
            config.fieldLabel = '';
            config.style = {'margin-left': "" + 0};
            config.labelStyle = 'padding-left: ' + 0;
        }
        Pan.base.form.Checkbox.superclass.constructor.call(this, config);
    }, stateEvents: ['check'], getState: function () {
        return {'check': this.getValue()};
    }, applyState: function (state) {
        this.setValue(state && state['check']);
    }, protect: function () {
        var el = this.getActionEl();
        el.addClass('x-protect-mask');
        el.mask();
    }, unprotect: function () {
        var el = this.getActionEl();
        el.removeClass('x-protect-mask');
        el.unmask();
    }, setBoxLabel: function (boxLabel) {
        this.boxLabel = boxLabel;
        if (this.rendered) {
            this.wrap.child('.x-form-cb-label').update(boxLabel);
        }
    }, initComponent: function () {
        Pan.base.form.Checkbox.superclass.initComponent.apply(this, arguments);
        if (this.tooltip) {
            this.addListener('afterrender', function () {
                Ext.QuickTips.register({target: this.getEl().parent().parent(), text: this.tooltip});
                this.addListener('beforedestroy', function () {
                    Ext.QuickTips.unregister(this.getEl().parent().parent());
                }, this);
            }, this);
        }
    }, initEvents: function () {
        Pan.base.form.Checkbox.superclass.initEvents.apply(this, arguments);
        if (this.label) {
            this.mon(this.label, {
                scope: this, click: function (event) {
                    event.stopEvent();
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
        }
    }
});
Ext.reg('pan-checkbox', Pan.base.form.Checkbox);
Pan.base.form.CheckboxGroup = Ext.extend(Ext.form.CheckboxGroup, {});
Ext.reg('pan-checkboxgroup', Pan.base.form.CheckboxGroup);
Pan.base.form.ComboBox = Ext.extend(Ext.form.ComboBox, {
    displayCount: Pan.base.Constants.defaultComboDisplayCount,
    associationEvent: 'valuechange',
    setValueToDisplay: true,
    selectOnFocus: true,
    expandOnInitEditor: false,
    selectOnLoadForNewRecord: undefined,
    testValueChangedEvents: ['valuechange', true],
    moreText: _T('Please filter for more entries'),
    disabledList: [],
    doHTMLEncode: true,
    addSelection: function (selection) {
        var value = selection;
        if (Ext.isArray(selection) && selection.length > 0) {
            value = selection[0];
        }
        if (Ext.isArray(this.fieldValue)) {
            this.fieldValue = [];
            if (value) {
                this.fieldValue.push(value);
            }
        }
        else {
            this.fieldValue = value;
        }
        this.populate(this.store);
    },
    initEditor: function () {
        if (this.alwaysReload) {
            this.store.removeAll();
            this.store.isStoreLoaded = false;
            this.lastQuery = null;
        }
        Ext.applyIf(this, {selectFirst: false});
        if (this.expandOnInitEditor || !this.remoteFilter) {
            this.onTriggerClick();
        }
    },
    initEvents: function () {
        Pan.base.form.ComboBox.superclass.initEvents.call(this);
        Ext.apply(this.keyNav, {
            doRelay: Pan.base.util.createExtension(function (e, h, hname) {
                if (hname == 'enter') {
                    this.scope.assertValue();
                }
                return arguments.callee.superFunction.apply(this, arguments);
            }, this.keyNav.doRelay)
        });
    },
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        config = Ext.apply({}, config);
        Ext.applyIf(config, {triggerAction: 'all', forceSelection: true});
        Pan.base.form.ComboBox.superclass.constructor.call(this, config);
    },
    isValid: function (preventMark) {
        if (this.disabled) {
            return true;
        }
        var restore = this.preventMark;
        this.preventMark = preventMark === true;
        var v = true;
        var r = this.findRecord(this.displayField || this.valueField, this.getRawValue());
        var newValue = this.processValue(this.getRawValue());
        if (!r) {
            v = this.validateValue(newValue);
        }
        this.preventMark = restore;
        return v;
    },
    validate: function () {
        var r = this.findRecord(this.displayField || this.valueField, this.getRawValue());
        var newValue = this.processValue(this.getRawValue());
        if (r || this.disabled || this.validateValue(newValue)) {
            this.clearInvalid();
            return true;
        }
        return false;
    },
    protect: function () {
        this.wrap.addClass("x-protect-background");
        this.disable();
    },
    unprotect: function () {
        this.wrap.removeClass("x-protect-background");
        if (!this.readOnly) {
            this.enable();
        }
    },
    getTemplate: function () {
        return new Ext.XTemplate('<tpl for=".">', '<tpl if="xindex <= ' + this.displayCount + '">', '<div {[this.getTooltip(values, parent, xindex, xcount, "' + this.valueField + '")]}', '{[this.getCls(values, parent, xindex, xcount, "' + this.valueField + '")]}', '>{[this.getListFieldValue(values, parent, xindex, xcount, "' + this.displayField + '")]}</div>', '</tpl></tpl>', this.getTplForEllipse(), {
            showMoreEllipse: function (values) {
                return this.scope.hasExceededDisplayCount(values);
            }, getListFieldValue: function () {
                var value = this.scope.getListFieldValue.apply(this, arguments);
                return this.scope.doHTMLEncode ? Ext.util.Format.htmlEncode(value) : value;
            }, getTooltip: function (values, parent, xindex, xcount, valueFieldName) {
                if (this.scope.helpTips && Ext.isDefined(this.scope.helpTips[values[valueFieldName]])) {
                    return 'ext:qtip="' + Pan.base.htmlEncode(this.scope.helpTips[values[valueFieldName]]) + '"';
                }
                if (this.scope.useHelpStringAsTooltip) {
                    return 'ext:qtip="' + Pan.base.htmlEncode(values['help-string']) + '"';
                }
                return "";
            }, getCls: function (values, parent, xindex, xcount, valueFieldName) {
                var disabledList = Ext.isFunction(this.scope.disabledList) ? this.scope.disabledList() : this.scope.disabledList;
                if (valueFieldName && disabledList.indexOf(values[valueFieldName]) > -1) {
                    return 'class="x-item-disabled x-combo-list-item"';
                }
                else {
                    return 'class="x-combo-list-item"';
                }
            }, scope: this
        });
    },
    getTplForEllipse: function () {
        return '<div <tpl if="this.showMoreEllipse(values) == false">style="display: none;"</tpl>><i>(' + this.moreText + ')</i></div>';
    },
    getListFieldValue: function (values, parent, xindex, xcount, fieldName) {
        return values[fieldName];
    },
    hasExceededDisplayCount: function (values) {
        return !!this.store.hasExceededDisplayCount || (values && values.length > this.displayCount);
    },
    initComponent: function () {
        this.addEvents('beforeselect', 'valuechange');
        if (this.postEditSplit) {
            this.postEditValue = this.editorGridPostEditValueSplitFn;
        }
        if (this.store && this.store.ztype) {
            var config = Ext.apply({
                autoLoad: false,
                record: this.getRecord(),
                __pdefaults: this.__pdefaults
            }, this.store.zconfig);
            this.store = new this.store.ztype(config);
        }
        if (this.mode === 'local' && this['enum']) {
            Ext.apply(this, {store: this['enum']});
        }
        if (this.store.fields) {
            for (var i = 0, n = this.store.fields.items.length; i < n; i++) {
                var field = this.store.fields.itemAt(i);
                if (field.uiHint) {
                    if (!this.valueField && field.uiHint.isKeyField) {
                        this.valueField = field.name;
                    }
                    if (!this.displayField && field.uiHint.isDisplayField) {
                        this.displayField = field.name;
                    }
                }
            }
        }
        this.store.autoSave = false;
        Pan.base.form.ComboBox.superclass.initComponent.call(this);
        if (this.mode === 'local') {
            this.addNoneValueToStore();
        }
        else {
            this.store.addListener("load", function () {
                this.loadDisplayValue();
                this.store.clearFilter();
                if (this.remoteFilter && !Ext.isEmpty(this.lastQuery)) {
                    var anyMatch = true, caseSensitive = false, exactMatch = false;
                    var filterFields = [{property: 'display'}];
                    this.store.doStringFilter(this.lastQuery, filterFields, anyMatch, caseSensitive, exactMatch);
                }
                else {
                    this.store.filter(this.displayField, this.lastQuery);
                }
                this.addNoneValueToStore();
                if (this.getRecord && this.getRecord() && this.getRecord().phantom && Ext.isString(this.selectOnLoadForNewRecord) && Ext.isEmpty(this.getValue())) {
                    var rindex = 0;
                    this.store.each(function (r) {
                        if (!r.isNone) {
                            if (this.selectOnLoadForNewRecord === "" || this.selectOnLoadForNewRecord === r.data[this.valueField]) {
                                this.onSelect(r, rindex);
                                return false;
                            }
                        }
                        rindex++;
                    }, this);
                }
            }, this);
        }
    },
    loadDisplayValue: function () {
        var v = this.getValue();
        var text = v;
        if (this.valueField) {
            var r = this.findRecord(this.valueField, v);
            if (r) {
                text = r.data[this.displayField];
            }
            else if (Ext.isDefined(this.valueNotFoundText)) {
                text = this.valueNotFoundText;
            }
        }
        if (this.lastSelectionText !== text && v !== text) {
            this.lastSelectionText = text;
            if (this.hiddenField) {
                this.hiddenField.value = Ext.value(v, '');
            }
            if (this.emptyText && this.el && !Ext.isEmpty(v)) {
                this.el.removeClass(this.emptyClass);
            }
            this.value = v;
            if (this.rendered) {
                this.el.dom.value = (Ext.isEmpty(text) ? '' : text);
            }
            this.applyEmptyText();
            this.autoSize();
            this.value = v;
        }
    },
    addNoneValueToStore: function () {
        if (this.noneString) {
            var foundNone, i;
            var items = this.store.data && this.store.data.items;
            if (items) {
                var valueField = this.valueField;
                var lowerCaseNone = this.noneString.toLowerCase();
                for (i = 0; i < items.length; i++) {
                    var v = items[i].get(valueField);
                    if (String(v).toLowerCase() == lowerCaseNone) {
                        foundNone = v;
                        break;
                    }
                }
            }
            if (!foundNone) {
                var noneData = {};
                for (i = 0; i < Math.min(this.store.fields.items.length, 2); i++) {
                    noneData[this.store.fields.items[i].name] = this.noneString;
                }
                var r = new this.store.recordType(noneData);
                r.isNone = true;
                this.store.insert(0, r);
            }
            else {
                this.noneString = foundNone;
            }
        }
    },
    needToRemoteQuery: function () {
        return this.remoteFilter || (this.mode === 'remote' && !this.store.isStoreLoaded);
    },
    doQuery: function (query) {
        if (this.alwaysReload) {
            this.store.removeAll();
            this.store.isStoreLoaded = false;
            this.lastQuery = null;
        }
        if (this.needToRemoteQuery()) {
            this.store.baseParams = this.store.baseParams || {};
            this.store.baseParams.useCache = true;
            Pan.base.form.ComboBox.superclass.doQuery.apply(this, arguments);
            delete this.store.baseParams.useCache;
        }
        else {
            this.expand();
            this.store.clearFilter();
            this.store.filter(this.displayField, query, true);
            this.restrictHeight();
        }
    },
    applyPermanentFilter: function (allQuery) {
        var resetValue = false;
        if (allQuery == undefined) {
            this.allQuery = '';
        }
        else {
            this.allQuery = allQuery;
            resetValue = true;
        }
        this.initList();
        this.store.clearFilter();
        this.store.filter(this.displayField, allQuery, true);
        this.restrictHeight();
        if (resetValue) {
            var index = this.store.find(this.valueField, this.getValue());
            if (index < 0) {
                if (this.store.getCount() > 0) {
                    this.setValue(this.store.getAt(0).get(this.valueField));
                }
                else {
                    this.clearValueEx(true);
                }
            }
        }
    },
    populate: function () {
        if (!this.store.isStoreLoaded && this.preloadStore) {
            this.store.reload();
        }
        var v = this.fieldValue;
        if (Ext.isArray(this.fieldValue) && this.fieldValue.length > 0) {
            v = this.fieldValue[0];
        }
        if (v !== undefined && !Ext.isString(v) && !Ext.isNumber(v)) {
            v = undefined;
        }
        if (!v) {
            if (this.noneString) {
                v = this.noneString;
            }
            else if (!this.allowBlank && this.selectFirst !== false) {
                var items = this.store.data && this.store.data.items;
                if (items && items.length > 0) {
                    v = items[0].get(this.valueField);
                }
            }
        }
        else if (this.valueField) {
            var r = this.findRecord(this.valueField, v);
            if (!r && this.forceSelection !== false && this.selectFirst === true) {
                r = this.store.getAt(0);
                if (r) {
                    v = r.get(this.valueField);
                }
            }
        }
        var startValue = this.value;
        if (this.setValueToDisplay) {
            Pan.base.form.ComboBox.superclass.setValue.call(this, v);
        }
        else {
            this.lastSelectionText = v;
            if (this.hiddenField) {
                this.hiddenField.value = Ext.value(v, '');
            }
            Ext.form.ComboBox.superclass.setValue.call(this, v);
        }
        if (String(v) !== String(startValue)) {
            this.fireEvent('valuechange', this, (v === this.noneString ? undefined : v), v, startValue);
        }
    },
    editorGridPostEditValueSplitFn: (function () {
        var addToRecord = function (store, idValue) {
            var rec;
            if (store.beginAdd) {
                rec = store.beginAdd();
            }
            rec.data[store.idProperty] = idValue;
            store.add(rec);
        };
        var addRecords = function (store, names) {
            var added = false;
            var a = names.split(/[;,\t\r\n]/);
            var addList = [], i, s;
            for (i = 0; i < a.length; i++) {
                s = a[i].trim();
                if (s) {
                    addList.push(s);
                }
            }
            if (addList.length > 1) {
                for (i = 0; i < addList.length; i++) {
                    s = addList[i];
                    addToRecord(store, s);
                    added = true;
                }
            }
            return added;
        };
        return function (value, _originalValue, r) {
            if (addRecords(r.store, value)) {
                r.store.remove(r);
            }
        };
    }()),
    assertValue: function () {
        var val = this.getRawValue();
        var a = [];
        if (this.postEditSplit) {
            a = val.split(/[ ;,\t\r\n]/);
        }
        if (!this.postEditSplit || a.length <= 1) {
            return Pan.base.form.ComboBox.superclass.assertValue.apply(this, arguments);
        }
        this.setValue(val);
    },
    setValue: function (v) {
        this.fieldValue = v;
        if (this.fieldValueIsArray === undefined) {
            this.fieldValueIsArray = Ext.isArray(v);
        }
        this.populate(this.store);
    },
    getValue: function () {
        var value = Pan.base.form.ComboBox.superclass.getValue.apply(this, arguments);
        if (this.fieldValueIsArray) {
            return [value];
        }
        else {
            if (value === this.noneString) {
                value = undefined;
            }
            return value;
        }
    },
    getErrors: function (value) {
        value = value || this.processValue(this.getRawValue());
        if (!this.forceSelection) {
            if (!this.hideTrigger && !this.store.isStoreLoaded) {
                if (!this.allowBlank && (!Ext.isDefined(value) || value.length < 1 || value === this.emptyText)) {
                    return [this.blankText];
                }
                else {
                    return [];
                }
            }
            var rec = this.findRecord(this.valueField, value) || this.findRecord(this.displayField, value);
            if (rec) {
                return [];
            }
        }
        if (!Ext.isDefined(value) || value.length < 1 || value === this.emptyText) {
            if (this.allowBlank) {
                return [];
            }
        }
        return Pan.base.form.ComboBox.superclass.getErrors.apply(this, arguments);
    },
    validateValue: function () {
        if (!this.forceSelection) {
            var val = this.getRawValue(), rec = this.findRecord(this.displayField, val);
            if (rec || (this.allowBlank && this.store.getCount() <= 0 && val === this.noneString)) {
                return true;
            }
        }
        return Pan.base.form.ComboBox.superclass.validateValue.apply(this, arguments);
    },
    clearValueEx: function (validate, clearValue, resetToDefault) {
        if (resetToDefault && clearValue) {
            this.setValue(this.__field.defaultValue);
        }
        else if (clearValue) {
            this.fieldValue = undefined;
            if (this.noneString) {
                this.setValue(this.noneString);
            }
            else {
                this.clearValue();
            }
        }
        if (validate) {
            this.validateValue();
        }
        if (this.store.isStoreLoaded) {
            this.store.isStoreLoaded = false;
            if (this.preloadStore) {
                this.store.removeAll();
                this.lastQuery = null;
            }
            else {
                this.store.reload();
            }
        }
    },
    initList: function () {
        if (!this.list) {
            if (!this.tpl) {
                this.tpl = this.getTemplate();
            }
            Pan.base.form.ComboBox.superclass.initList.apply(this, arguments);
            var disableMenuActions = this.disableMenuActions;
            if (Ext.isFunction(this.disableMenuActions)) {
                disableMenuActions = this.disableMenuActions();
            }
            if (!disableMenuActions && !this.title && this.menuActions) {
                var cls = 'x-combo-list';
                this.title = _T("hasstuff");
                this.header = this.list.createChild({cls: cls + '-hd'});
                var buttons = [{xtype: 'label', text: this.buttonLabel ? _T(this.buttonLabel) : _T('New')}];
                for (var i = 0; i < this.menuActions.length; i++) {
                    var config = Ext.apply({
                        xtype: 'pan-linkbutton',
                        replaceSelection: true,
                        editorComponent: this
                    }, this.menuActions[i]);
                    buttons.push(config);
                }
                this.customComponent = Ext.create({
                    xtype: 'pan-container',
                    items: buttons,
                    renderTo: this.header,
                    layout: 'toolbar'
                });
                this.customComponent.ownerCt = this;
                if (this.title) {
                    this.assetHeight += this.header.getHeight();
                }
            }
        }
        var ownerCt = this;
        while (ownerCt.parentOwner || ownerCt.ownerCt) {
            if (ownerCt.itemId) {
                this.list.set({'itemId': ownerCt.itemId + '-list'});
                break;
            }
            ownerCt = ownerCt.parentOwner || ownerCt.ownerCt;
        }
    },
    onLoad: function () {
        if (!this.hasFocus) {
            return;
        }
        if (this.store.getCount() <= 0 && !this.listEmptyText && this.title) {
            this.expand();
            this.restrictHeight();
        }
        else {
            Pan.base.form.ComboBox.superclass.onLoad.apply(this, arguments);
        }
    },
    listeners: {
        beforeselect: function (combo, record, index) {
            if (combo && combo.view && Ext.get(combo.view.getNode(index)).hasClass('x-item-disabled')) {
                return false;
            }
            else {
                return true;
            }
        }
    },
    onDestroy: function () {
        Ext.destroy(this.customComponent);
        Pan.base.form.ComboBox.superclass.onDestroy.apply(this, arguments);
    }
});
Ext.reg('pan-combo', Pan.base.form.ComboBox);
Pan.base.form.IconComboBox = Ext.extend(Pan.base.form.ComboBox, {
    constructor: function (config) {
        Pan.base.form.IconComboBox.superclass.constructor.call(this, config);
        this.iconClsMap = config.iconClsMap || [];
    }, initComponent: function () {
        Pan.base.form.IconComboBox.superclass.initComponent.call(this);
        this.on({
            render: {
                scope: this, fn: function () {
                    var wrap = this.el.up('div.x-form-field-wrap');
                    this.wrap.applyStyles({position: 'relative'});
                    this.el.addClass('x-icon-combo-input');
                    this.itemIcon = Ext.DomHelper.append(wrap, {
                        tag: 'div',
                        style: 'position:absolute',
                        cls: 'x-icon-combo-icon'
                    });
                }
            }
        });
    }, getTemplate: function () {
        var tpl = new Ext.XTemplate('<tpl for="."><div class="x-icon-combo-icon icon-tag {[this.getIconClass(values)]}"></div><div class="x-combo-list-item x-icon-combo-item">' + '{' + this.displayField + ':htmlEncode}</div></tpl>', {
            scope: this, getIconClass: function (values) {
                for (var i = 0, len = this.scope.iconClsMap.length; i < len; i++) {
                    if (this.scope.iconClsMap[i][0] == values[this.scope.valueField])
                        return this.scope.iconClsMap[i][1];
                }
                return values[this.scope.valueField];
            }
        });
        return tpl;
    }, setIconCls: function () {
        if (!this.getValue()) {
            this.el.removeClass('x-icon-combo-input');
            this.itemIcon.className = 'x-icon-combo-icon';
            return;
        }
        var rec = this.store.query(this.valueField, this.getValue()).itemAt(0);
        if (rec) {
            if (this.getIconCls(rec)) {
                this.itemIcon.className = 'x-icon-combo-icon ' + this.getIconCls(rec);
                this.el.addClass('x-icon-combo-input');
            } else {
                this.itemIcon.className = 'x-icon-combo-icon';
            }
        }
    }, getIconCls: function (rec) {
        return this.getFieldIconCls(rec.get(this.valueField));
    }, getFieldIconCls: function (valueField) {
        for (var i = 0, len = this.iconClsMap.length; i < len; i++) {
            if (this.iconClsMap[i][0] == valueField)
                return this.iconClsMap[i][1];
        }
        return '';
    }, setValue: function (value) {
        Pan.base.form.IconComboBox.superclass.setValue.call(this, value);
        this.setIconCls();
    }
});
Ext.reg('pan-iconcombo', Pan.base.form.IconComboBox);
Ext.ns("Pan.base.form");
Pan.base.form.SortedComboBox = Ext.extend(Pan.base.form.ComboBox, {
    initComponent: function () {
        if (this.store.data && this.store.data.items.sort) {
            Pan.base.util.naturalSortObjectArray(this.store.data.items, this.sortProperty ? 'data.' + this.sortProperty : 'data.text');
        }
        Pan.base.form.SortedComboBox.superclass.initComponent.call(this);
    }
});
Ext.reg('sorted-combobox', Pan.base.form.SortedComboBox);
Pan.base.form.DefaultComboBoxHelper = function (e) {
    return {
        updateDefaultBeforeEditHandler: function (e) {
            var editor = e.grid.getColumnModel().getCellEditor(e.column, e.row);
            if (this.getDefaultDetailText && e.column == this.actionColumn) {
                var defaultDisplayText = Pan.base.form.DefaultComboBoxHelper.getModifiedDefaultText('default', this.getDefaultDetailText(e.record.data));
                var reloadData = [];
                editor.field.store.each(function (item) {
                    if (item.data.id == 'default') {
                        item.data['displayText'] = defaultDisplayText;
                    }
                    reloadData.push([item.data.id, item.data['displayText']]);
                    return true;
                }, this);
                editor.field.store.removeAll();
                editor.field.store.loadData(reloadData);
            }
            return true;
        }, getModifiedDefaultText: function (origDefault, detailText) {
            if (detailText.length) {
                return origDefault + ' (' + detailText + ')';
            }
            return origDefault;
        }
    };
}();
Pan.base.form.DefaultComboBox = Ext.extend(Pan.base.form.ComboBox, {
    valueField: 'id',
    displayField: 'displayText',
    mode: 'local',
    editable: false,
    selectOnFocus: true,
    lazyInit: false,
    lazyRender: false
});
Ext.reg('pan-defaultcombo', Pan.base.form.DefaultComboBox);
Pan.base.form.Radio = Ext.extend(Ext.form.Radio, {
    initComponent: function () {
        if (this.tooltip) {
            this.addListener('afterrender', function () {
                Ext.QuickTips.register({target: this.getEl().parent().parent(), text: this.tooltip});
                this.addListener('beforedestroy', function () {
                    Ext.QuickTips.unregister(this.getEl().parent().parent());
                }, this);
            }, this);
        }
        Pan.base.form.Radio.superclass.initComponent.apply(this, arguments);
    }, stateEvents: ['check'], getState: function () {
        return {'check': this.checked};
    }, applyState: function (state) {
        this.setValue(state && state['check']);
    }
});
Ext.reg('pan-radio', Pan.base.form.Radio);
Pan.base.form.RadioGroup = Ext.extend(Ext.form.RadioGroup, {
    useFlowStyle: false,
    flowSpacing: 10,
    defaultType: 'pan-radio',
    testValueChangedEvents: ['change', true],
    stateEvents: ['change'],
    getState: function () {
        return {value: this.getValue()};
    },
    applyState: function (state) {
        this.setValue(state['value']);
    },
    afterRender: function () {
        this.eachItem(function (item) {
            item.on('check', this.fireChecked, this);
            item.inGroup = true;
        });
        Pan.base.form.RadioGroup.superclass.afterRender.call(this);
    },
    getValue: function () {
        var o = Pan.base.form.RadioGroup.superclass.getValue.call(this);
        if (Ext.isDefined(o) && o !== null) {
            return o ? o.inputValue : o;
        } else if (this.buffered && this.value && this.value.length > 0) {
            return this.value[0];
        } else {
            return o;
        }
    },
    setValue: function (v) {
        if (this.noneString && !v) {
            v = undefined;
        } else if (this.items && this.items.length === 1 && !v && !this.isVisible()) {
            v = this.value;
        }
        return Pan.base.form.RadioGroup.superclass.setValue.call(this, v);
    },
    setValueForItem: function (val) {
        if (val !== undefined) {
            val = String(val).split(',')[0];
        }
        if (!this.allowBlank) {
            var needToSelectValue = false;
            this.eachItem(function (item) {
                if (!needToSelectValue && val == item.inputValue) {
                    needToSelectValue = true;
                }
            });
            if (!needToSelectValue) {
                return;
            }
        }
        this.eachItem(function (item) {
            item.setValue(val == item.inputValue);
        });
    },
    onRender: function (ct, position) {
        if (!this.el && this.useFlowStyle && !this.isAnEditor) {
            var panelCfg = {
                autoEl: {id: this.id},
                cls: this.groupCls,
                layout: 'toolbar',
                renderTo: ct,
                bufferResize: false
            };
            var cols = [];
            for (var i = 0, len = this.items.length; i < len; i++) {
                var item = Ext.applyIf({xtype: 'pan-radio'}, this.items[i]);
                if (item.fieldLabel) {
                    item.hideLabel = false;
                }
                cols.push(item);
                cols.push({xtype: 'tbspacer', width: this.flowSpacing});
            }
            Ext.apply(panelCfg, {items: cols});
            this.panel = new Ext.Container(panelCfg);
            this.panel.ownerCt = this;
            this.el = this.panel.getEl();
            var fields = this.panel.findBy(function (c) {
                return c.isFormField;
            }, this);
            this.items = new Ext.util.MixedCollection();
            this.items.addAll(fields);
            return Ext.form.CheckboxGroup.superclass.onRender.apply(this, arguments);
        } else {
            return Pan.base.form.RadioGroup.superclass.onRender.apply(this, arguments);
        }
    },
    protect: function () {
        var el = this.el;
        el.addClass('x-protect-mask');
        el.mask();
    },
    unprotect: function () {
        var el = this.el;
        el.removeClass('x-protect-mask');
        el.unmask();
    },
    fireChecked: function () {
        if (this.initValueInProgress) {
            this.bufferChecked();
        } else {
            Pan.base.form.RadioGroup.superclass.fireChecked.apply(this, arguments);
        }
    },
    initValue: function () {
        this.initValueInProgress = true;
        try {
            Pan.base.form.RadioGroup.superclass.initValue.apply(this, arguments);
        } catch (e) {
            console.log('exception caught in RadioGroup.js');
        }
        delete this.initValueInProgress;
    }
});
Ext.reg('pan-radiogroup', Pan.base.form.RadioGroup);
Ext.layout.ToolbarLayout.prototype.addComponentToMenu = Ext.layout.ToolbarLayout.prototype.addComponentToMenu.createSequence(function (menu, component) {
    var createMenuItem = function (cmp) {
        var config = Ext.apply({}, cmp.initialConfig), group = Ext.id();
        Ext.copyTo(config, cmp, ['iconCls', 'icon', 'itemId', 'disabled', 'handler', 'scope', 'menu']);
        Ext.apply(config, {text: cmp.overflowText || cmp.text});
        Ext.apply(config, {
            group: group,
            checked: cmp.getValue(),
            text: cmp.boxLabel,
            listeners: {
                checkchange: function (item, checked) {
                    cmp.setValue(checked);
                }
            }
        });
        delete config.ownerCt;
        delete config.xtype;
        delete config.id;
        return config;
    };
    if (Ext.isFunction(component.isXType)) {
        if (component.isXType('radio')) {
            menu.add(createMenuItem(component));
        }
    }
});
Pan.base.form.TextField = Ext.extend(Ext.form.TextField, {
    multivalueSeparator: ',', isConstantValue: false, initComponent: function () {
        if (this.isConstantValue) {
            Ext.apply(this, {readOnly: true});
        }
        Pan.base.form.TextField.superclass.initComponent.apply(this, arguments);
    }, afterRender: function () {
        Pan.base.form.TextField.superclass.afterRender.apply(this, arguments);
        if (this.isConstantValue) {
            Pan.base.form.TextField.superclass.setValue.call(this, this.value);
        }
    }, getErrors: function (value) {
        value = value || this.processValue(this.getRawValue());
        if (!Ext.isDefined(value) || value.length < 1 || value === this.emptyText) {
            if (this.allowBlank) {
                return [];
            }
        }
        if (this.minLength === this.maxLength && (value.length < this.minLength || value.length > this.maxLength)) {
            return [_T('The length for this field must be exactly {len}', {len: this.minLength})];
        }
        return Pan.base.form.TextField.superclass.getErrors.apply(this, arguments);
    }, setValue: function (v) {
        if (this.isConstantValue) {
            return;
        }
        if (this.multivalue && (v instanceof Array)) {
            v = v.join(this.multivalueSeparator);
        }
        return Pan.base.form.TextField.superclass.setValue.call(this, v);
    }, getValue: function () {
        var tfvalue = Pan.base.form.TextField.superclass.getValue.call(this);
        if (tfvalue == '' || !Ext.isDefined(tfvalue)) {
            return undefined;
        }
        else if (this.multivalue) {
            var superValue = tfvalue.split(this.multivalueSeparator);
            var newList = [];
            for (var i = 0; i < superValue.length; i++) {
                var trimmed = Ext.util.Format.trim(superValue[i]);
                if (trimmed) {
                    newList.push(trimmed);
                }
            }
            return newList;
        }
        else {
            return tfvalue;
        }
    }
});
Ext.reg('pan-textfield', Pan.base.form.TextField);
Pan.base.form.TextArea = Ext.extend(Ext.form.TextArea, {
    multivalue: false, style: {overflow: 'auto'}, setValue: function (v) {
        if (this.multivalue && (v instanceof Array)) {
            v = v.join("\n");
        }
        return Pan.base.form.TextArea.superclass.setValue.call(this, v);
    }, getValue: function () {
        var superValue = Pan.base.form.TextArea.superclass.getValue.call(this);
        if (this.multivalue && Ext.isString(superValue)) {
            superValue = superValue.split(new RegExp("([\n])+"));
            var newList = [];
            for (var i = 0; i < superValue.length; i++) {
                var trimmed = Ext.util.Format.trim(superValue[i]);
                if (trimmed) {
                    newList.push(trimmed);
                }
            }
            if (newList.length > 0) {
                superValue = newList;
            }
        }
        return superValue;
    }
});
Ext.reg('pan-textarea', Pan.base.form.TextArea);
Ext.ns('Pan.base.form');
Pan.base.form.PanTextAreaWithDrawerField = Ext.extend(Pan.base.container.Container, {
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.form.PanTextAreaWithDrawerField.superclass.constructor.call(this, config);
    }, initComponent: function () {
        var textArea = {
            region: 'center',
            xtype: 'pan-textarea',
            itemId: 'panTextAndButton_' + this.__field.attrName,
            drawer: this.drawer,
            allowBlank: this.allowBlank
        };
        if (!this.vflex) {
            Ext.apply(this, {height: (this.height || 100) + 30});
        }
        else {
            Ext.apply(textArea, {vflex: true, autoHeight: false});
        }
        Ext.apply(this, {
            layout: 'border',
            fieldLabel: this.__field.uiHint.fieldLabel,
            items: [textArea, {
                xtype: 'pan-container',
                autoHeight: true,
                vflex: false,
                region: 'south',
                items: [Ext.applyIf({
                    xtype: 'pan-button',
                    iconCls: 'icon-add',
                    text: _T('Add Match Criteria')
                }, this.buttonCfg)]
            }]
        });
        Pan.base.form.PanTextAreaWithDrawerField.superclass.initComponent.apply(this, arguments);
        this.text = this.findByItemId('panTextAndButton_' + this.__field.attrName);
    }, setValue: function (v) {
        this.text.setValue(v);
        return this;
    }, getValue: function () {
        return this.text.getValue();
    }, isValid: function () {
        return this.text.validate();
    }, reset: function () {
    }, getSelectedText: function () {
        var dom = this.text.el.dom;
        var selected = (dom.value).substring(this.getSelectionStart(), this.getSelectionEnd());
        return selected;
    }, getSelectionStart: function () {
        this.text.focus();
        var input = this.text.getEl().dom;
        if (input.setSelectionRange) {
            return input.selectionStart;
        }
        else if (document.selection) {
            var pos, textRange = document.selection.createRange().duplicate();
            if (textRange.text.length > 0) {
                pos = input.value.indexOf(textRange.text);
            }
            else {
                pos = 0;
            }
            return pos;
        }
        return 0;
    }, getSelectionEnd: function () {
        this.text.focus();
        var input = this.text.getEl().dom;
        if (input.setSelectionRange) {
            return input.selectionEnd;
        }
        else if (document.selection) {
            var selectedRange = document.selection.createRange().duplicate();
            if (selectedRange.text.length > 0) {
                selectedRange.moveStart("character", -input.value.length);
            }
            return selectedRange.text.length;
        }
        return 0;
    }, getCaretPos: function () {
        this.text.focus();
        var input = this.text.getEl().dom;
        var pos = 0;
        if (input.createTextRange && document.selection) {
            var r = document.selection.createRange();
            var re = input.createTextRange();
            var rc = re.duplicate();
            re.moveToBookmark(r.getBookmark());
            rc.setEndPoint('EndToStart', re);
            pos = rc.text.length;
        }
        else if (input.setSelectionRange) {
            pos = input.selectionEnd;
        }
        return pos;
    }, insertText: function (textField, insertedVal, op) {
        if (textField === undefined) {
            return;
        }
        var currentStr = textField.getValue();
        if (currentStr === undefined || currentStr === '') {
            currentStr = insertedVal;
        }
        else {
            var pos = textField.getCaretPos();
            var startPos = textField.getSelectionStart();
            var endPos = textField.getSelectionEnd();
            if (startPos === endPos) {
                if (pos > 1) {
                    currentStr = String.format('{0} {1} {2} {3}', currentStr.substring(0, pos), op, insertedVal, currentStr.substring(pos));
                }
                else {
                    currentStr = String.format('{0} {1} {2}', insertedVal, op, currentStr);
                }
            }
            else if (startPos !== endPos) {
                var startStr = currentStr.substring(0, startPos).trim();
                if (!Ext.isEmpty(startStr)) {
                    var lastOrPosition = startStr.lastIndexOf("or");
                    var lastAndPosition = startStr.lastIndexOf("and");
                    var lastOpPosition = -1;
                    if (lastAndPosition > lastOrPosition)
                        lastOpPosition = lastAndPosition; else
                        lastOpPosition = lastOrPosition;
                    var startStrEndWithOp = (startStr.length - lastOpPosition) <= 3;
                    if (startStrEndWithOp) {
                        currentStr = String.format('{0} {1} {2} ({3}) {4}', startStr, insertedVal, op, currentStr.substring(startPos, endPos), currentStr.substring(endPos));
                    }
                    else {
                        currentStr = String.format('{0} {1} {2} ({3}) {4}', startStr, op, insertedVal, currentStr.substring(startPos, endPos), currentStr.substring(endPos));
                    }
                }
                else {
                    currentStr = String.format('{0} {1} ({2}) {3}', insertedVal, op, currentStr.substring(startPos, endPos), currentStr.substring(endPos));
                }
            }
        }
        textField.setValue(currentStr);
    }
});
Ext.reg("pan-textarea-drawer", Pan.base.form.PanTextAreaWithDrawerField);
Pan.base.form.SelectionBox = Ext.extend(Pan.base.form.ComboBox, {
    setValue: function (v) {
        if (v === null || v === undefined) {
            return;
        }
        Pan.base.form.SelectionBox.superclass.setValue.call(this, v);
    }, constructor: function (config) {
        config = config || {};
        Ext.applyIf(config, {editable: false, forceSelection: true});
        if (config.value === undefined && Ext.isArray(config.store) && config.store.length > 0) {
            config.value = Ext.isArray(config.store[0]) ? config.store[0][0] : config.store[0];
        }
        Pan.base.form.SelectionBox.superclass.constructor.call(this, config);
    }
});
Ext.reg('pan-selectbox', Pan.base.form.SelectionBox);
Pan.base.form.DirectSelectionBox = Ext.extend(Pan.base.form.SelectionBox, {
    constructor: function (config) {
        var jsonReader = config.jsonReader;
        if (!jsonReader) {
            jsonReader = new Ext.data.JsonReader({
                root: 'completions',
                fields: [{name: 'type', mapping: '@type', type: 'string'}, {
                    name: 'help-string',
                    mapping: '@help-string',
                    type: 'string'
                }, {name: 'value', mapping: '@value', type: 'string'}]
            });
        }
        var storeConfig = Pan.base.util.selectiveApply(['paramsAsHash', 'paramOrder', 'api', 'directFn', 'storeId', 'autoLoad', 'reader', 'createFilterFn'], {
            autoDestroy: true,
            autoLoad: true,
            reader: jsonReader
        }, config);
        var store = new Ext.data.DirectStore(storeConfig);
        Ext.applyIf(config, {
            autoSelect: true,
            editable: false,
            typeAhead: false,
            store: store,
            triggerAction: 'all',
            displayField: config.displayField || 'value',
            tpl: config.appendHelpString === true ? '<tpl for="."><div class="x-combo-list-item">{value:htmlEncode} ({help-string:htmlEncode})</div></tpl>' : undefined,
            valueField: config.valueField || 'value'
        });
        Pan.base.form.DirectSelectionBox.superclass.constructor.call(this, config);
    }
});
Ext.reg('pan-directselectbox', Pan.base.form.DirectSelectionBox);
Pan.base.form.SelectBox = function (config) {
    this.searchResetDelay = 1000;
    config = config || {};
    config = Ext.apply(config || {}, {
        editable: false,
        forceSelection: true,
        rowHeight: false,
        lastSearchTerm: false,
        triggerAction: 'all'
    });
    Pan.base.form.SelectBox.superclass.constructor.call(this, config);
    this.lastSelectedIndex = this.selectedIndex || 0;
};
Ext.extend(Pan.base.form.SelectBox, Ext.form.ComboBox, {
    lazyInit: false, initEvents: function () {
        Pan.base.form.SelectBox.superclass.initEvents.apply(this, arguments);
        this.mon(this.el, 'keydown', this.keySearch, this, true);
        this.cshTask = new Ext.util.DelayedTask(this.clearSearchHistory, this);
    }, keySearch: function (e) {
        var raw = e.getKey();
        var key = String.fromCharCode(raw);
        var startIndex = 0;
        if (!this.store.getCount()) {
            return;
        }
        switch (raw) {
            case Ext.EventObject.HOME:
                e.stopEvent();
                this.selectFirst();
                return;
            case Ext.EventObject.END:
                e.stopEvent();
                this.selectLast();
                return;
            case Ext.EventObject.PAGEDOWN:
                this.selectNextPage();
                e.stopEvent();
                return;
            case Ext.EventObject.PAGEUP:
                this.selectPrevPage();
                e.stopEvent();
                return;
        }
        if ((e.hasModifier() && !e.shiftKey) || e.isNavKeyPress() || e.isSpecialKey()) {
            return;
        }
        if (this.lastSearchTerm == key) {
            startIndex = this.lastSelectedIndex;
        }
        this.search(this.displayField, key, startIndex);
        this.cshTask.delay(this.searchResetDelay);
    }, onRender: function () {
        this.store.on('load', this.calcRowsPerPage, this);
        Pan.base.form.SelectBox.superclass.onRender.apply(this, arguments);
        if (this.mode == 'local') {
            this.calcRowsPerPage();
        }
    }, onSelect: function (record, index, skipCollapse) {
        if (this.fireEvent('beforeselect', this, record, index) !== false) {
            this.setValue(record.data[this.valueField || this.displayField]);
            if (!skipCollapse) {
                this.collapse();
            }
            this.lastSelectedIndex = index + 1;
            this.fireEvent('select', this, record, index);
        }
    }, render: function () {
        Pan.base.form.SelectBox.superclass.render.apply(this, arguments);
        if (Ext.isSafari) {
            this.el.swallowEvent('mousedown', true);
        }
        this.el.unselectable();
        this.innerList.unselectable();
        this.trigger.unselectable();
        this.innerList.on('mouseup', function (e, target) {
            if (target.id && target.id == this.innerList.id) {
                return;
            }
            this.onViewClick();
        }, this);
        this.innerList.on('mouseover', function (e, target) {
            if (target.id && target.id == this.innerList.id) {
                return;
            }
            this.lastSelectedIndex = this.view.getSelectedIndexes()[0] + 1;
            this.cshTask.delay(this.searchResetDelay);
        }, this);
        this.trigger.un('click', this.onTriggerClick, this);
        this.trigger.on('mousedown', function (e) {
            e.preventDefault();
            this.onTriggerClick();
        }, this);
        this.on('collapse', function () {
            Ext.getDoc().un('mouseup', this.collapseIf, this);
        }, this, true);
        this.on('expand', function () {
            Ext.getDoc().on('mouseup', this.collapseIf, this);
        }, this, true);
    }, clearSearchHistory: function () {
        this.lastSelectedIndex = 0;
        this.lastSearchTerm = false;
    }, selectFirst: function () {
        this.focusAndSelect(this.store.data.first());
    }, selectLast: function () {
        this.focusAndSelect(this.store.data.last());
    }, selectPrevPage: function () {
        if (!this.rowHeight) {
            return;
        }
        var index = Math.max(this.selectedIndex - this.rowsPerPage, 0);
        this.focusAndSelect(this.store.getAt(index));
    }, selectNextPage: function () {
        if (!this.rowHeight) {
            return;
        }
        var index = Math.min(this.selectedIndex + this.rowsPerPage, this.store.getCount() - 1);
        this.focusAndSelect(this.store.getAt(index));
    }, search: function (property, value, start, anyMatch, caseSensitive) {
        property = property || this.displayField;
        this.lastSearchTerm = value;
        var index = this.store.find.call(this.store, property, value, start, anyMatch, caseSensitive);
        if (index !== -1) {
            this.focusAndSelect(index);
        }
    }, focusAndSelect: function (record) {
        var index = typeof record === 'number' ? record : this.store.indexOf(record);
        this.select(index, this.isExpanded());
        this.onSelect(this.store.getAt(record), index, this.isExpanded());
    }, calcRowsPerPage: function () {
        if (this.store.getCount()) {
            this.rowHeight = Ext.fly(this.view.getNode(0)).getHeight();
            this.rowsPerPage = this.maxHeight / this.rowHeight;
        }
        else {
            this.rowHeight = false;
        }
    }
});
Ext.reg('selectbox', Pan.base.form.SelectBox);
Pan.base.form.CustomTimePeriodCombo = Ext.extend(Pan.base.form.SelectionBox, {
    setSingleDateTimeDisplay: function (singleDateTime) {
        if (singleDateTime.split(this.dateTimeSeparator).length === 2) {
            this.validStartEnd = true;
            this.setValue('custom');
        }
        this.setValue(singleDateTime);
    }, setStartEndDisplay: function (start, end) {
        this.setValue('custom');
        this.setValue(start.format(this.dateTimeFmtstr) + this.dateTimeSeparator + end.format(this.dateTimeFmtstr));
    }, setStartEnd: function (start, end) {
        var str;
        if (!Ext.isDate(start)) {
            str = start;
            start = Date.parseDate(str, Pan.base.Constants.datetimeFmtstr);
            if (!start)
                start = Date.parseDate(str, Pan.base.Constants.dateFmtstr);
        }
        if (!Ext.isDate(end)) {
            str = end;
            end = Date.parseDate(str, Pan.base.Constants.datetimeFmtstr);
            if (!end)
                end = Date.parseDate(str, Pan.base.Constants.dateFmtstr);
        }
        if (Ext.isDate(start) && Ext.isDate(end) && end > start) {
            this.start.setValue(start);
            this.end.setValue(end);
            this.setStartEndDisplay(start, end);
            return true;
        }
        return false;
    }, isCustomDateTime: function () {
        return Pan.base.Constants.predefinedTimePeriods.indexOf(this.getValue()) == -1;
    }, getStart: function (fmtstr) {
        var start = null;
        var components = this.getValue().split(this.dateTimeSeparator);
        if (components && components[0]) {
            start = Date.parseDate(components[0], this.dateTimeFmtstr);
        }
        if (fmtstr && start) {
            return start.format(fmtstr);
        }
        return start;
    }, getEnd: function (fmtstr) {
        var end = null;
        var components = this.getValue().split(this.dateTimeSeparator);
        if (components && components[1]) {
            end = Date.parseDate(components[1], this.dateTimeFmtstr);
        }
        if (fmtstr && end) {
            return end.format(fmtstr);
        }
        return end;
    }, constructor: function (config) {
        config = config || {};
        Ext.applyIf(config, {
            hasCustom: true,
            mode: 'local',
            displayField: 'display',
            valueField: 'value',
            allowBlank: false,
            validStartEnd: false,
            dateFmtstr: 'Y/m/d',
            timeFmtstr: 'h:i a',
            dateTimeFmtstr: 'Y/m/d h:ia',
            dateTimeSeparator: ' - '
        });
        Pan.base.form.CustomTimePeriodCombo.superclass.constructor.call(this, config);
    }, removeValidScheduledTimePeriodsFilter: function () {
        this.store.loadData(this.prepareUnfilteredData());
    }, addValidScheduledTimePeriodsFilter: function () {
        var oldval = this.getValue();
        var ok = false;
        Ext.each(Pan.base.Constants.validScheduledTimePeriods, function (validvalue) {
            if (oldval == validvalue || _TC(oldval) == _TC(validvalue)) {
                ok = true;
            }
        });
        if (!ok) {
            this.setValue(Pan.base.Constants.validScheduledTimePeriods[0]);
        }
        this.store.loadData(this.prepareFilteredData());
    }, prepareUnfilteredData: function () {
        var data = [];
        Ext.each(this.data || Pan.base.Constants.predefinedTimePeriods, function (val) {
            data.push([val, _TC(val)]);
        });
        if (this.hasCustom) {
            data.push(['custom', _T('Custom')]);
        }
        return data;
    }, prepareFilteredData: function () {
        var data = [];
        Ext.each(this.data || Pan.base.Constants.validScheduledTimePeriods, function (val) {
            data.push([val, _TC(val)]);
        });
        return data;
    }, initComponent: function () {
        var self = this;
        var start = new Ext.ux.form.DateTime({
            timeWidth: 80,
            fieldLabel: _T('Start Date'),
            anchor: '-18',
            timeFormat: this.timeFmtstr,
            timeConfig: {allowBlank: false},
            dateFormat: this.dateFmtstr,
            dateConfig: {allowBlank: false}
        });
        var end = new Ext.ux.form.DateTime({
            timeWidth: 80,
            fieldLabel: _T('End Date'),
            width: 180,
            anchor: '-18',
            timeFormat: this.timeFmtstr,
            timeConfig: {allowBlank: false},
            dateFormat: this.dateFmtstr,
            dateConfig: {allowBlank: false}
        });
        var checkTimeDialogOkState = function () {
            if (!start.isValid()) {
                Pan.base.msg.warn(_T('start date is invalid'));
                return false;
            }
            if (!end.isValid()) {
                Pan.base.msg.warn(_T('end date is invalid'));
                return false;
            }
            if (start.getValue() >= end.getValue()) {
                Pan.base.msg.warn(_T('End Date must be later than Start Date'));
                return false;
            }
            return true;
        };
        var setTimeDialog = new Pan.base.container.Window({
            width: 300,
            height: 135,
            layout: 'fit',
            title: _T('Time Range'),
            modal: true,
            border: false,
            closable: false,
            items: new Pan.base.container.FormPanel({
                xtype: 'pan-form',
                labelWidth: 70,
                frame: false,
                defaults: {border: false},
                bodyStyle: 'padding:5px 5px 0',
                items: [start, end]
            }),
            buttons: [{
                text: _T('OK'), handler: function () {
                    if (checkTimeDialogOkState()) {
                        self.setStartEndDisplay(start.getValue(), end.getValue());
                        self.validStartEnd = true;
                        setTimeDialog.hide();
                    }
                }
            }, {
                text: _T('Cancel'), isDefaultButton: true, handler: function () {
                    self.validStartEnd = false;
                    setTimeDialog.hide();
                }
            }]
        });
        var store = new Ext.data.ArrayStore({fields: ['value', 'display'], data: this.prepareUnfilteredData()});
        Ext.apply(this, {
            store: store, start: start, end: end, listeners: {
                change: function (record, newValue, oldValue) {
                    if (newValue == 'custom') {
                        self.setValue(oldValue);
                    }
                }, select: function (combo, record, idx) {
                    if (record.get('value') == 'custom') {
                        var mystart = null;
                        var myend = null;
                        if (arguments[0].startValue != null) {
                            var components = arguments[0].startValue.split(this.dateTimeSeparator);
                            if (components && components[0] && components[1]) {
                                mystart = Date.parseDate(components[0], this.dateTimeFmtstr);
                                myend = Date.parseDate(components[1], this.dateTimeFmtstr);
                            }
                        }
                        if (mystart != null & myend != null) {
                            start.setValue(mystart);
                            end.setValue(myend);
                        }
                        setTimeDialog.show();
                    } else {
                        try {
                            setTimeDialog.hide();
                        } catch (e) {
                        }
                    }
                }
            }
        });
        Ext.applyIf(this, {width: 235, editable: false, forceSelection: false});
        Pan.base.form.CustomTimePeriodCombo.superclass.initComponent.apply(this, arguments);
    }
});
Ext.reg('pan-customtimecombo', Pan.base.form.CustomTimePeriodCombo);
Pan.base.form.NumberField = Ext.extend(Ext.form.NumberField, {});
Ext.reg('pan-numberfield', Pan.base.form.NumberField);
Pan.base.form.CompositeField = Ext.extend(Ext.form.CompositeField, {});
Ext.reg('pan-compositefield', Pan.base.form.CompositeField);
Pan.base.form.PanTimeField = Ext.extend(Ext.form.TimeField, {
    testValueChangedEvents: ['valuechange', true], initEvents: function () {
        Pan.base.form.PanTimeField.superclass.initEvents.call(this);
        Ext.apply(this.keyNav, {
            doRelay: Pan.base.util.createExtension(function (e, h, hname) {
                if (hname == 'enter') {
                    this.scope.assertValue();
                }
                return arguments.callee.superFunction.apply(this, arguments);
            }, this.keyNav.doRelay)
        });
    }
});
Ext.reg('pan-timefield', Pan.base.form.PanTimeField);
Pan.base.form.DisplayField = Ext.extend(Ext.form.DisplayField, {
    showMoreEllipse: false, showMoreText: _T("Show All"), showToolTip: false, initComponent: function () {
        Pan.base.form.DisplayField.superclass.initComponent.apply(this, arguments);
        if (this.showMoreEllipse) {
            this.addListener('afterrender', this.showEllipseAndMoreText);
            if (this.showToolTip) {
                this.addListener('beforedestroy', function () {
                    Ext.QuickTips.unregister(this.getEl());
                }, this);
            }
        }
    }, showEllipseAndMoreText: function (me) {
        var newValue = me.getValue(), textMetrics = Ext.util.TextMetrics.createInstance(me.el),
            tWidth = textMetrics.getWidth(newValue), moreTextWidth = textMetrics.getWidth(this.showMoreText);
        if (me.getWidth() < tWidth) {
            me.addClass("x-displayfield-ellipsis");
            me.wrapEl = me.el.wrap({tag: 'div', cls: 'x-displayfield-more-wrap'});
            me.button = me.wrapEl.createChild({tag: 'a', html: this.showMoreText, cls: 'x-displayfield-btn-more'});
            me.button.addClassOnOver('x-displayfield-btn-more-over').on('click', function (e) {
                e.stopEvent();
                if (this.disabled) {
                    return;
                }
                this.showMoreEllipseClick(newValue, e.getTarget());
            }, this);
            if (this.showToolTip) {
                Ext.QuickTips.register({target: me.el, text: newValue});
            }
        } else {
            if (this.showToolTip) {
                Ext.QuickTips.unregister(me.el);
            }
        }
        this.on('change', this.showEllipseAndMoreText);
    }, setValue: function (v) {
        this.setRawValue(v);
        if (this.showMoreEllipse) {
            this.fireEvent('change', this, v);
        }
        return this;
    }, showMoreEllipseClick: function (v, eventTarget) {
        if (!this.displayfieldWrapTextWindow) {
            this.displayfieldWrapTextWindow = Ext.create({
                xtype: "menu",
                items: {
                    xtype: 'pan-textarea',
                    itemId: 'displayFieldWrapData',
                    autoScroll: true,
                    readOnly: true,
                    width: 250,
                    height: 70
                }
            });
            this.displayfieldWrapTextArea = this.displayfieldWrapTextWindow.findByItemId("displayFieldWrapData");
        }
        this.displayfieldWrapTextArea.setValue(v);
        if (!this.displayfieldWrapTextWindow.el) {
            this.displayfieldWrapTextWindow.render();
        }
        var xy = this.displayfieldWrapTextWindow.el.getAlignToXY(eventTarget, 'c-c');
        this.displayfieldWrapTextWindow.showAt(xy);
        this.displayfieldWrapTextArea.focus(false, 300);
    }
});
Ext.reg('pan-displayfield', Pan.base.form.DisplayField);
Pan.base.form.CompletionComboBox = Ext.extend(Pan.base.form.SelectBox, {});
Ext.reg('completioncombo', Pan.base.form.CompletionComboBox);
Pan.base.form.SearchInfoField = Ext.extend(Pan.base.form.TextField, {
    cls: 'pan-grid-filter x-ignore-key-enter',
    defaultAutoCreate: {tag: "input", type: "text", size: "16", autocomplete: "off"},
    hideSearchInfo: false,
    autoSize: Ext.emptyFn,
    monitorTab: true,
    deferHeight: true,
    actionMode: 'wrap',
    defaultSearchInfoWidth: 78,
    defaultMagnifierWidth: 16,
    initComponent: function () {
        if (!this.hideSearchInfo) {
            this.style = this.style || {};
            Ext.applyIf(this.style, {"border-right": "none"});
        }
        Pan.base.form.SearchInfoField.superclass.initComponent.apply(this, arguments);
        if (this.enableTrigger) {
            this.addEvents('expand', 'collapse');
        }
    },
    bindStore: function (store) {
        if (store) {
            store = Ext.StoreMgr.lookup(store);
            store.addListener({scope: this, datachanged: this.onStoreDataChanged});
            store.addListener({scope: this, add: this.onStoreDataChanged});
            store.addListener({scope: this, remove: this.onStoreDataChanged});
        }
    },
    onStoreDataChanged: function (store) {
        this.searchInfo.dom.value = Pan.base.getStoreFilterCountString(store);
    },
    onResize: function (w, h) {
        Pan.base.form.SearchInfoField.superclass.onResize.call(this, w, h);
        var tw = this.getAdditionalWidth();
        if (Ext.isNumber(w)) {
            this.el.setWidth(w - tw);
        }
        var ww = this.el.getWidth() + tw;
        this.wrap.setWidth(ww);
        if (this.enableTrigger && this.list && this.innerList) {
            var lw = Math.max(ww, this.minListWidth);
            this.list.setWidth(lw);
            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));
        }
    },
    getAdditionalWidth: function () {
        var tw = this.searchInfo.getWidth();
        if (!this.hideSearchInfo && tw === 0) {
            tw = this.defaultSearchInfoWidth;
        }
        if (this.enableTrigger) {
            tw += this.trigger.getWidth();
        }
        var magnifierWidth = this.magnifier.getWidth();
        if (magnifierWidth === 0) {
            magnifierWidth = this.defaultMagnifierWidth;
        }
        return tw + magnifierWidth;
    },
    alignErrorIcon: function () {
        if (this.wrap) {
            this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
        }
    },
    onRender: function (ct, position) {
        this.doc = Ext.isIE ? Ext.getBody() : Ext.getDoc();
        Pan.base.form.SearchInfoField.superclass.onRender.apply(this, arguments);
        this.wrap = this.el.wrap({cls: 'x-form-field-wrap x-form-field-trigger-wrap'});
        this.magnifier = this.wrap.createChild({
            tag: 'img',
            src: "/images/icons/magnifier.png",
            style: 'vertical-align:-5px;'
        }, this.el);
        this.searchInfo = this.wrap.createChild(this.searchInfoConfig || {
            tag: "input",
            type: 'text',
            autocomplete: 'off',
            style: 'width: ' + this.defaultSearchInfoWidth + 'px;',
            cls: " x-form-text x-form-field  x-form-search-info " + (this.searchInfoClass ? this.searchInfoClass : "")
        });
        this.initSearchInfo();
        if (this.enableTrigger) {
            this.trigger = this.wrap.createChild(this.triggerConfig || {
                tag: "img",
                src: Ext.BLANK_IMAGE_URL,
                cls: "x-form-trigger " + this.triggerClass
            });
            this.initTrigger();
            this.on('focus', this.initList, this, {single: true});
        }
        if (!this.width) {
            this.wrap.setWidth(this.el.getWidth() + this.searchInfo.getWidth());
        }
        this.resizeEl = this.positionEl = this.wrap;
    },
    getWidth: function () {
        return (this.el.getWidth() + this.searchInfo.getWidth());
    },
    updateEditState: function () {
        if (this.rendered) {
            this.searchInfo.setDisplayed(!this.hideSearchInfo);
            this.onResize(this.width || this.wrap.getWidth());
        }
    },
    setHideSearchInfo: function (hideSearchInfo) {
        if (hideSearchInfo != this.hideSearchInfo) {
            this.hideSearchInfo = hideSearchInfo;
            this.updateEditState();
        }
    },
    afterRender: function (ct) {
        Pan.base.form.SearchInfoField.superclass.afterRender.call(this);
        this.updateEditState();
    },
    initSearchInfo: function () {
        this.tooltipWrap = this.searchInfo.wrap({tag: 'span', cls: 'x-form-search-info-span'});
        this.tooltipWrapMask = this.tooltipWrap.mask();
        this.tooltipWrapMask.addClass('x-form-search-info-mask');
        if (this.parent.store) {
            this.onStoreDataChanged(this.parent.store);
        }
        this.bindStore(this.parent.store);
        this.searchInfoTooltip = new Pan.base.component.ToolTip({
            minWidth: 80,
            target: [this.magnifier, this.tooltipWrapMask],
            trackMouse: true,
            mouseOffset: [-30, 0],
            renderTo: document.body,
            listeners: {
                beforeshow: function (tip) {
                    tip.body.dom.innerHTML = Pan.base.getStoreFilterCountTip(this.parent.store, this.parent.selModel, this.parent.getResultCount);
                }, scope: this
            }
        });
    },
    onDestroy: function () {
        if (this.parent) {
            if (this.searchInfoTooltip) {
                this.searchInfoTooltip.destroy();
                delete this.searchInfoTooltip;
            }
            if (this.parent.store) {
                this.parent.store.removeListener('remove', this, this.onStoreDataChanged);
                this.parent.store.removeListener('add', this, this.onStoreDataChanged);
                this.parent.store.removeListener('datachanged', this, this.onStoreDataChanged);
            }
            delete this.parent;
        }
        if (this.enableTrigger) {
            Ext.destroy(this.trigger);
            if (this.mimicing) {
                this.doc.un('mousedown', this.mimicBlur, this);
            }
        }
        Ext.destroy(this.searchInfo, this.magnifier, this.tooltipWrap, this.tooltipWrapMask, this.wrap);
        delete this.doc;
        Pan.base.form.SearchInfoField.superclass.onDestroy.call(this);
    },
    checkTab: function (me, e) {
        if (e.getKey() == e.TAB) {
            this.triggerBlur();
        }
    },
    onBlur: Ext.emptyFn,
    mimicBlur: function (e) {
        if (!this.isDestroyed && !this.wrap.contains(e.target) && this.validateBlur(e)) {
            this.triggerBlur();
        }
    },
    triggerBlur: function () {
        this.mimicing = false;
        this.doc.un('mousedown', this.mimicBlur, this);
        if (this.monitorTab && this.el) {
            this.un('specialkey', this.checkTab, this);
        }
        Pan.base.form.SearchInfoField.superclass.onBlur.call(this);
        if (this.wrap) {
            this.wrap.removeClass(this.wrapFocusClass);
        }
    },
    beforeBlur: Ext.emptyFn,
    validateBlur: function () {
        return true;
    },
    selectedClass: 'x-combo-selected',
    triggerClass: 'x-form-arrow-trigger',
    listClass: '',
    listEmptyText: '',
    listAlign: 'tl-bl?',
    maxListHeight: 300,
    minListHeight: 90,
    minListWidth: 70,
    wrapFocusClass: 'x-trigger-wrap-focus',
    defaultTriggerWidth: 17,
    hideTrigger: false,
    shadow: 'sides',
    enableTrigger: false,
    editable: true,
    readOnly: false,
    mimicing: false,
    getListParent: function () {
        return document.body;
    },
    initList: function () {
        if (!this.list) {
            var cls = 'x-combo-list', listParent = Ext.getDom(this.getListParent() || Ext.getBody()),
                zindex = parseInt(Ext.fly(listParent).getStyle('z-index'), 10);
            if (!zindex) {
                zindex = this.getParentZIndex();
            }
            this.list = new Ext.Layer({
                parentEl: listParent,
                shadow: this.shadow,
                cls: [cls, this.listClass].join(' '),
                constrain: false,
                zindex: (zindex || 12000) + 5
            });
            var lw = this.listWidth || Math.max(this.wrap.getWidth() - this.magnifier.getWidth(), this.minListWidth);
            this.list.setSize(lw, 0);
            this.list.swallowEvent('mousewheel');
            this.assetHeight = 0;
            this.innerList = this.list.createChild({cls: cls + '-inner'});
            this.innerList.setWidth(lw - this.list.getFrameWidth('lr'));
            var store = new Ext.data.ArrayStore({id: 0, fields: ['id', 'displayText'], data: []});
            this.view = new Ext.DataView({
                applyTo: this.innerList,
                tpl: '<tpl for="."><div style="white-space:normal !important; word-wrap: break-word;" class="' + cls + '-item">{displayText}</div></tpl>',
                autoHeight: true,
                singleSelect: true,
                overClass: 'x-view-over',
                selectedClass: this.selectedClass,
                itemSelector: this.itemSelector || '.' + cls + '-item',
                store: store,
                valueField: 'id',
                displayField: 'displayText'
            });
        }
    },
    restrictHeight: function () {
        this.innerList.dom.style.height = '';
        var inner = this.innerList.dom, pad = this.list.getFrameWidth('tb') + this.assetHeight,
            h = Math.max(inner.clientHeight, inner.offsetHeight, inner.scrollHeight),
            ha = this.getPosition()[1] - Ext.getBody().getScroll().top,
            hb = Ext.lib.Dom.getViewHeight() - ha - this.getSize().height,
            space = Math.max(ha, hb, this.minHeight || 0) - this.list.shadowOffset - pad - 5;
        h = Math.min(h, space, this.maxListHeight);
        this.innerList.setHeight(h);
        this.list.setHeight(h + pad);
        this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));
    },
    initTrigger: function () {
        this.mon(this.trigger, 'click', this.onTriggerClick, this, {preventDefault: true});
        this.trigger.addClassOnOver('x-form-trigger-over');
        this.trigger.addClassOnClick('x-form-trigger-click');
    },
    isExpanded: function () {
        return this.list && this.list.isVisible();
    },
    onTriggerClick: function () {
        if (this.readOnly || this.disabled) {
            return;
        }
        if (this.isExpanded()) {
            this.collapse();
        } else {
            this.onFocus();
            this.onLoad();
        }
        this.el.focus();
    },
    collapse: function () {
        if (!this.isExpanded()) {
            return;
        }
        this.list.hide();
        Ext.getDoc().un('mousewheel', this.collapseIf, this);
        Ext.getDoc().un('mousedown', this.collapseIf, this);
        this.fireEvent('collapse', this);
    },
    collapseIf: function (e) {
        if (!this.isDestroyed && !e.within(this.wrap) && !e.within(this.list)) {
            this.collapse();
        }
    },
    onLoad: function () {
        var value = this.getValue();
        if (Ext.isEmpty(value)) {
            this.collapse();
        } else {
            this.view.store.loadData([[1, value]]);
            this.expand();
            this.restrictHeight();
        }
    },
    expand: function () {
        if (this.isExpanded() || !this.hasFocus) {
            return;
        }
        this.list.alignTo.apply(this.list, [this.el].concat(this.listAlign));
        var listParent = Ext.getDom(this.getListParent() || Ext.getBody()),
            zindex = parseInt(Ext.fly(listParent).getStyle('z-index'), 10);
        if (!zindex) {
            zindex = this.getParentZIndex();
        }
        if (zindex) {
            this.list.setZIndex(zindex + 5);
        }
        this.list.show();
        if (Ext.isGecko2) {
            this.innerList.setOverflow('auto');
        }
        this.mon(Ext.getDoc(), {scope: this, mousewheel: this.collapseIf, mousedown: this.collapseIf});
        this.fireEvent('expand', this);
    },
    onFocus: function () {
        Pan.base.form.SearchInfoField.superclass.onFocus.call(this);
        if (this.enableTrigger) {
            if (!this.mimicing) {
                this.wrap.addClass(this.wrapFocusClass);
                this.mimicing = true;
                this.doc.on('mousedown', this.mimicBlur, this, {delay: 10});
                if (this.monitorTab) {
                    this.on('specialkey', this.checkTab, this);
                }
            }
        }
    },
    getTriggerWidth: function () {
        var tw = 0;
        Ext.each(this.triggers, function (t, index) {
            var triggerIndex = 'Trigger' + (index + 1), w = t.getWidth();
            if (w === 0 && !this['hidden' + triggerIndex]) {
                tw += this.defaultTriggerWidth;
            } else {
                tw += w;
            }
        }, this);
        return tw;
    },
    getParentZIndex: function () {
        var zindex;
        if (this.ownerCt) {
            this.findParentBy(function (ct) {
                zindex = parseInt(ct.getPositionEl().getStyle('z-index'), 10);
                return !!zindex;
            });
        }
        return zindex;
    }
});
Ext.reg('pan-searchinfofield', Pan.base.form.SearchInfoField);
Pan.base.form.SearchField = Ext.extend(Ext.form.TwinTriggerField, {
    cls: 'x-ignore-key-enter',
    constructor: function (cfg) {
        this.addEvents("clearsearch", "executesearch");
        Pan.base.form.SearchField.superclass.constructor.call(this, Ext.apply(cfg, {}));
    },
    initComponent: function () {
        Pan.base.form.SearchField.superclass.initComponent.call(this);
        this.on('specialkey', function (f, e) {
            if (e.getKey() == e.ENTER) {
                e.stopEvent();
                this.onTrigger2Click();
            }
        }, this);
    },
    validationEvent: false,
    validateOnBlur: false,
    trigger1Class: 'x-form-clear-trigger',
    trigger2Class: 'x-form-search-trigger',
    hideTrigger1: true,
    hasSearch: false,
    onTrigger1Click: function () {
        if (this.hasSearch) {
            this.fireEvent('clearsearch', this);
            this.el.dom.value = '';
            this.triggers[0].hide();
            this.hasSearch = false;
        }
    },
    onTrigger2Click: function () {
        var v = this.getRawValue();
        if (v.length < 1) {
            this.onTrigger1Click();
            return;
        }
        this.fireEvent('executesearch', this);
        this.hasSearch = true;
        this.triggers[0].show();
    }
});
Ext.reg('pan-searchfield', Pan.base.form.SearchField);
Pan.base.form.DateField = Ext.extend(Ext.form.DateField, {testValueChangedEvents: ['select', true]});
Ext.reg('pan-datefield', Pan.base.form.DateField);
Pan.base.form.DateTimeField = Ext.extend(Ext.form.CompositeField, {
    initComponent: function () {
        Ext.apply(this, {
            xtype: 'compositefield',
            items: [{xtype: 'datefield', format: 'Y/m/d', allowBlank: false, width: 100}, {
                xtype: 'timefield',
                format: 'H:i:s',
                allowBlank: false,
                flex: 1
            }]
        });
        Pan.base.form.DateTimeField.superclass.initComponent.apply(this, arguments);
    }, getValue: function () {
        var d = this.items.get(0).getValue();
        var t = this.items.get(1).getValue();
        if (d && d.format) {
            d = d.format('Y/m/d');
        }
        if (d && t) {
            return d + ' ' + t;
        } else {
            return '';
        }
    }
});
Ext.reg('pan-datetime', Pan.base.form.DateTimeField);
Pan.base.form.FileUploadField = Ext.extend(Pan.base.form.TextField, {
    buttonText: _T('Browse') + '...',
    buttonOffset: 3,
    readOnly: true,
    autoSize: Ext.emptyFn,
    testValueChangedEvents: ['fileselected', false],
    initComponent: function () {
        Pan.base.form.FileUploadField.superclass.initComponent.call(this);
        this.addEvents('fileselected');
    },
    onRender: function (ct, position) {
        Pan.base.form.FileUploadField.superclass.onRender.call(this, ct, position);
        this.wrap = this.el.wrap({cls: 'x-form-field-wrap x-form-file-wrap'});
        this.el.addClass('x-form-file-text');
        this.el.dom.removeAttribute('name');
        this.createFileInput();
        var btnCfg = Ext.applyIf(this.buttonCfg || {}, {text: this.buttonText});
        this.button = new Pan.base.button.LinkButton(Ext.apply(btnCfg, {
            renderTo: this.wrap,
            cls: 'x-form-file-btn' + (btnCfg.cls ? ' ' + btnCfg.cls : '') + (btnCfg.iconCls ? ' x-btn-icon' : '')
        }));
        if (this.button.tooltip) {
            if (Ext.isObject(this.button.tooltip)) {
                Ext.QuickTips.register(Ext.apply({target: this.fileInput}, this.button.tooltip));
            } else {
                this.fileInput.dom[this.button.tooltipType] = this.button.tooltip;
            }
        }
        this.addFileListener();
    },
    getFileInputId: function () {
        return this.id + '-file';
    },
    onResize: function (w, h) {
        Pan.base.form.FileUploadField.superclass.onResize.call(this, w, h);
        this.wrap.setWidth(w);
        w = this.wrap.getWidth() - this.button.getEl().getWidth() - this.buttonOffset;
        this.el.setWidth(w);
    },
    preFocus: Ext.emptyFn,
    getResizeEl: function () {
        return this.wrap;
    },
    getPositionEl: function () {
        return this.wrap;
    },
    alignErrorIcon: function () {
        this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
    },
    protect: function () {
        Pan.base.form.FileUploadField.superclass.protect.call(this);
        this.button.setDisabled(true);
        this.button.btnEl.addClass('x-protect-mask');
        this.button.btnEl.mask();
        this.fileInput.setStyle("display", "none");
    },
    unprotect: function () {
        Pan.base.form.FileUploadField.superclass.unprotect.call(this);
        this.button.setDisabled(false);
        this.button.btnEl.removeClass('x-protect-mask');
        this.button.btnEl.unmask();
        this.fileInput.setStyle("display", "inline");
    },
    createFileInput: function () {
        this.fileInput = this.wrap.createChild({
            id: this.getFileInputId(),
            name: this.name || this.getId(),
            cls: 'x-form-file',
            tag: 'input',
            type: 'file',
            size: 1
        });
    },
    addFileListener: function () {
        var self = this;
        this.fileInput.on({
            change: function () {
                var v = self.fileInput.dom.value;
                if (v) {
                    this.setValue(v);
                    this.fireEvent('fileselected', this, v);
                }
            }, mouseover: function () {
                self.button.addClass(['x-btn-over', 'x-btn-focus']);
            }, mouseout: function () {
                self.button.removeClass(['x-btn-over', 'x-btn-focus', 'x-btn-click']);
            }, mousedown: function () {
                self.button.addClass('x-btn-click');
            }, mouseup: function () {
                self.button.removeClass(['x-btn-over', 'x-btn-focus', 'x-btn-click']);
            }, scope: this
        });
    },
    reset: function () {
        this.fileInput.removeAllListeners();
        this.fileInput.remove();
        this.createFileInput();
        this.addFileListener();
        Pan.base.form.FileUploadField.superclass.reset.call(this);
    },
    disable: function (silent) {
        this.fileInput.dom.disabled = true;
        this.button.disable(silent);
        Pan.base.form.FileUploadField.superclass.disable.call(this, arguments);
    },
    enable: function () {
        this.fileInput.dom.disabled = false;
        this.button.enable();
        Pan.base.form.FileUploadField.superclass.enable.call(this, arguments);
    }
});
Ext.reg('fileuploadfield', Pan.base.form.FileUploadField);
Pan.base.form.PasswordVerify = Ext.extend(Pan.base.container.Container, {
    associationEvent: ['blur'],
    password: undefined,
    confirmPassword: undefined,
    phash: undefined,
    defaultValue: '********',
    mustHaveValidPwd: false,
    layout: 'form',
    blankText: _T('This field is required'),
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Ext.applyIf(this, Pan.base.autorender.valueChangedPrototype);
        Pan.base.form.PasswordVerify.superclass.constructor.call(this, config);
    },
    setDisabled: function (v) {
        this.password.setDisabled(v);
        this.confirmPassword.setDisabled(v);
    },
    getLayoutItems: function () {
        if (this.singleLineLayout) {
            var labelWidth = this.ownerCt.initialConfig.labelWidth || this.initialConfig.labelWidth || 100;
            this.password.labelWidth = labelWidth;
            this.confirmPassword.labelWidth = labelWidth;
            return {
                xtype: 'pan-container',
                layout: 'form',
                flex: true,
                fieldLabel: '',
                rfLayoutConfig: Pan.base.autorender.layout.RFTableLayoutConfig,
                columnCount: 2,
                items: [this.password, this.confirmPassword]
            };
        } else {
            return [this.password, this.confirmPassword];
        }
    },
    initComponent: function () {
        this.__field = this.__field || {};
        this.__field.uiHint = this.__field.uiHint || {};
        if (Pan.base.json.path(this, "$.__field.defaultValue")) {
            this.defaultValue = this.__field.defaultValue;
        }
        var commonConfig = {
            xtype: "pan-textfield",
            inputType: this.inputType || 'password',
            maxLength: this.__field.uiHint.maxLength || this.maxLength || Number.MAX_VALUE,
            minLength: this.__field.uiHint.minLength || this.minLength || Pan.global.getMinPasswordLength(),
            vtype: this.__field.uiHint.vtype || this.vtype || null,
            regex: this.__field.uiHint.regex || this.regex || null,
            allowBlank: this.__field.uiHint.allowBlank || this.allowBlank,
            validator: this.__field.uiHint.validator || null,
            helpTip: this.helpTip || null,
            helpstring: this.helpstring || null,
            disabled: this.__pdefaults ? this.__pdefaults.__readOnly : false,
            isExtFormField: false
        };
        this.password = new Pan.base.form.TextField(Ext.applyIf({
            fieldLabel: this.__field.uiHint.passwordLabel || this.__field.uiHint.fieldLabel || this.fieldLabel || _T("Password"),
            itemId: 'pwd1_' + this.itemId
        }, commonConfig));
        this.confirmPassword = new Pan.base.form.TextField(Ext.applyIf({
            fieldLabel: this.__field.uiHint.cpFieldLabel || this.cpFieldLabel || _T("Confirm") + " " + (this.__field.uiHint.fieldLabel || this.fieldLabel || _T("Password")),
            itemId: 'pwd2_' + this.itemId
        }, commonConfig));
        Ext.apply(this, {
            layout: 'form',
            fieldLabel: '',
            labelWidth: this.ownerCt.initialConfig.labelWidth || this.initialConfig.labelWidth || 100,
            defaults: {anchor: '100%'},
            items: this.getLayoutItems()
        });
        Pan.base.form.PasswordVerify.superclass.initComponent.apply(this, arguments);
        this.relayEvents(this.password, ['blur']);
        this.relayEvents(this.confirmPassword, ['blur']);
    },
    getValue: function () {
        var value = this.password.getValue();
        if (value === this.defaultValue)
            value = this.phash;
        return value;
    },
    setValue: function (valueString) {
        if (!Ext.isDefined(this.phash))
            this.phash = valueString;
        this.value = valueString;
        if (Ext.isEmpty(valueString)) {
            this.defaultValue = '';
        }
        this.reset();
    },
    hasDefaultValue: function () {
        if (this.isAnEditor) {
            return this.confirmPassword.getValue() === this.value && this.password.getValue() === this.value;
        }
        return this.confirmPassword.getValue() === this.defaultValue && this.password.getValue() === this.defaultValue;
    },
    hasNullValue: function () {
        return (this.confirmPassword.getValue() === undefined && this.password.getValue() === undefined) || (this.confirmPassword.getValue() === '' && this.password.getValue() === '');
    },
    enforceValue: function (mustHavePassword) {
        this.mustHaveValidPwd = mustHavePassword;
        return this.isValid();
    },
    isValid: function () {
        if (this.phash && !this.__valueChanged && this.hasDefaultValue()) {
            this.confirmPassword.clearInvalid();
            this.password.clearInvalid();
            return true;
        }
        if (this.mustHaveValidPwd && (this.hasDefaultValue() || this.hasNullValue())) {
            this.confirmPassword.setValue('');
            this.password.setValue('');
            this.password.selectText();
            this.password.markInvalid(this.password.fieldLabel + ' ' + _T('and') + ' ' + this.confirmPassword.fieldLabel + ' ' + _T('are not set'));
            return false;
        }
        var match = this.confirmPassword.getValue() == this.password.getValue();
        if (!match) {
            this.password.markInvalid(this.password.fieldLabel + ' ' + _T('and') + ' ' + this.confirmPassword.fieldLabel + ' ' + _T('do not match'));
            return false;
        }
        var isValid = this.password.validate() && this.confirmPassword.validate();
        if (!isValid) {
            return false;
        }
        this.__valueChanged = this.password.__valueChanged;
        return true;
    },
    getErrors: function () {
        var errors = [];
        var value = this.password.getValue();
        if (!this.allowBlank && (value === null || !Ext.isDefined(value) || value.length < 1)) {
            errors.push(this.blankText);
        }
        return errors;
    },
    reset: function () {
        this.confirmPassword.setValue(this.isAnEditor ? this.value : this.defaultValue);
        this.password.setValue(this.isAnEditor ? this.value : this.defaultValue);
    }
});
Ext.reg('pan-passwordverify', Pan.base.form.PasswordVerify);
Pan.base.form.PasswordVerifyRenderer = function (value, meta, rec) {
    if (value) {
        return '********';
    } else {
        return '';
    }
};
Pan.base.form.FieldSet = Ext.extend(Ext.form.FieldSet, {
    associationEvent: 'check',
    testValueChangedEvents: ['check', true],
    labelFieldPluginEvent: 'afterrender',
    checkboxAction: "disable",
    initComponent: function () {
        this.addEvents('check');
        this.layoutConfig = this.layoutConfig || {};
        Ext.applyIf(this.layoutConfig, {trackLabels: true});
        Ext.applyIf(this, {isExtFormField: !!this.checkboxToggle});
        if (Ext.isIE && this.checkboxAction === "disable") {
            Ext.apply(this, {
                listeners: {
                    'afterlayout': function (c) {
                        this.onCheckClick();
                    }, scope: this
                }
            });
        }
        if (this.fieldLabelPlugin) {
            this.title += '<span id="' + this.getId() + '-label" class="x-hide-display">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>';
        }
        return Pan.base.form.FieldSet.superclass.initComponent.apply(this, arguments);
    },
    initValue: function () {
        if (this.value !== undefined) {
            this.setValue(this.value);
        }
    },
    afterRender: function () {
        Pan.base.form.FieldSet.superclass.afterRender.call(this);
        this.initValue();
    },
    afterCollapse: function (anim) {
        Pan.base.form.FieldSet.superclass.afterCollapse.apply(this, arguments);
        this.syncFloatingShadow();
    },
    afterExpand: function (anim) {
        Pan.base.form.FieldSet.superclass.afterExpand.apply(this, arguments);
        this.syncFloatingShadow();
    },
    onRender: function (ct, position) {
        Pan.base.form.FieldSet.superclass.onRender.apply(this, arguments);
        if (this.checkbox && this.checkboxAction !== "hide") {
            this.checkbox.dom.checked = !this.collapsed;
        }
        if (this.checkboxInitState !== undefined) {
            this.checkbox.dom.checked = this.checkboxInitState;
            this.onCheckClick();
        }
        if (this.checkbox) {
            this.mon(this.checkbox, 'click', function () {
                this.testValueChangedWithoutVerify();
            }, this);
        }
    },
    onCheckClick: function () {
        if (this.checkboxAction === "disable" && this.checkbox) {
            this.checkbox.dom.checked ? this.body.unmask() : this.body.mask();
            this.fireEvent('check', this, this.checkbox.dom.checked);
        } else if (this.checkboxAction === "hide") {
            Pan.base.form.FieldSet.superclass.onCheckClick.call(this);
            this.fireEvent('check', this, this.checkbox.dom.checked);
        }
    },
    onDisable: function () {
        if (this.rendered && this.maskDisabled) {
            this.body.mask();
        }
        if (this.strictReadOnly === true) {
            Pan.base.form.FieldSet.superclass.onDisable.call(this);
        } else {
            Ext.Panel.superclass.onDisable.call(this);
        }
    },
    onEnable: function () {
        if (this.rendered && this.maskDisabled) {
            this.body.unmask();
        }
        if (this.strictReadOnly === true) {
            Pan.base.form.FieldSet.superclass.onEnable.call(this);
        } else {
            Ext.Panel.superclass.onEnable.call(this);
        }
    },
    protect: function () {
        this.addClass("x-protect-mask");
        this.disable();
    },
    unprotect: function () {
        this.removeClass("x-protect-mask");
        if (!this.readOnly) {
            this.enable();
        }
    },
    setValue: function (value) {
        if (this.isExtFormField) {
            this.value = value;
            if (this.checkbox) {
                this.checkbox.dom.checked = value;
                this.onCheckClick();
            }
        }
    },
    getValue: function () {
        if (!this.rendered) {
            if (this.value === "") {
                return false;
            } else {
                return this.value;
            }
        }
        if (this.checkbox) {
            return this.checkbox.dom.checked;
        }
        if (this.isExtFormField) {
            return true;
        }
    },
    isDirty: function () {
        if (this.disabled || !this.rendered) {
            return false;
        }
        return this.getValue() !== this.value;
    },
    isValid: function () {
        return true;
    },
    validate: function () {
        return true;
    },
    markInvalid: function (msg) {
    },
    clearInvalid: function () {
    },
    stateEvents: ['check'],
    getState: function () {
        return {'check': this.checkbox && this.checkbox.dom.checked};
    },
    applyState: function (state) {
        if (this.checkbox) {
            this.checkbox.dom.checked = (state && state['check']);
            this.onCheckClick();
        } else {
            this.checkboxInitState = (state && state['check']);
        }
    }
});
Ext.reg('pan-fieldset', Pan.base.form.FieldSet);
Pan.base.form.ToggleField = Ext.extend(Ext.ux.form.ToggleSlideField, {
    ctCls: 'x-pan-toggle-slide', initComponent: function () {
        Pan.base.form.ToggleField.superclass.initComponent.call(this);
    }, initEvents: function () {
        Pan.base.form.ToggleField.superclass.initEvents.call(this);
    }, onRender: function (ct, position) {
        Pan.base.form.ToggleField.superclass.onRender.call(this, ct, position);
        this.toggle.el.un('mouseup', this.toggle.onMouseUp, this.toggle);
        this.toggle.el.on('mouseup', this.onMouseUp, this);
    }, getValue: function () {
        return this.toggle.getValue();
    }, setValue: function (value) {
        Pan.base.form.ToggleField.superclass.setValue.apply(this, arguments);
        if (this.toggle.state !== value) {
            this.toggle.toggle();
        }
    }, onMouseUp: function () {
        if (this.isAvailable !== false) {
            if (!this.toggle.dragging) {
                this.toggle.toggle();
            }
            var recordForm = this;
            while (recordForm.ownerCt) {
                if (recordForm.onOK) {
                    recordForm.onOK(this.toggle);
                    break;
                }
                recordForm = recordForm.ownerCt;
            }
        }
    }
});
Ext.reg('pan-togglefield', Pan.base.form.ToggleField);
Pan.base.form.TimeField = Ext.extend(Pan.base.autorender.GridRecordField, {
    showMinutes: true, initComponent: function () {
        var config = this.initialConfig;
        Ext.apply(this, {
            xtype: 'compositefield',
            fieldLabel: config.fieldLabel || ' ',
            labelWidth: config.labelWidth || 100,
            hideLabel: config.hideLabel || false,
            msgTarget: 'side',
            defaults: {allowDecimals: false},
            items: [{
                xtype: 'pan-numberfield',
                maxValue: config.daysMaxValue,
                width: config.daysWidth || 55,
                allowBlank: config.allowBlank,
                enableKeyEvents: true
            }, {xtype: 'label', text: ' ' + _T('Days') + '  ', width: 40}, {
                xtype: 'pan-numberfield',
                minValue: 0,
                maxValue: 23,
                width: config.hoursWidth || 30,
                allowBlank: config.allowBlank,
                enableKeyEvents: true
            }, {xtype: 'label', text: ' ' + _T('Hours') + '  ', width: 40}]
        });
        if (this.showMinutes) {
            this.items.push({
                xtype: 'pan-numberfield',
                minValue: 0,
                maxValue: 59,
                maxLength: 2,
                width: config.minutesWidth || 30
            }, {xtype: 'label', text: ' ' + _T('Minutes'), width: 50, flex: 1});
        }
        Pan.base.form.TimeField.superclass.initComponent.apply(this, arguments);
        this.relayEvents(this.items.items[0], ['keyup']);
        this.relayEvents(this.items.items[2], ['keyup']);
        this.on("keyup", function () {
            if (this.allowBlank)
                return;
            var item0Val = this.items.items[0].getValue();
            var item2Val = this.items.items[2].getValue();
            if ((item0Val && item0Val !== '') || (item2Val && item2Val !== '')) {
                this.items.items[0].allowBlank = true;
                this.items.items[2].allowBlank = true;
            }
            else {
                this.items.items[0].allowBlank = false;
                this.items.items[2].allowBlank = false;
            }
            this.items.items[0].validate();
            this.items.items[2].validate();
            this.isValid();
        }, this, {buffer: 100});
    }, markInvalid: function (msg) {
        this.items.items[0].markInvalid(msg);
        this.items.items[2].markInvalid(msg);
    }, clearInvalid: function () {
        this.items.items[0].clearInvalid();
        this.items.items[2].clearInvalid();
    }, isValid: function () {
        var error = this.getErrors(this.getValue())[0];
        if (error == undefined) {
            return true;
        }
        else {
            this.markInvalid(error);
            return false;
        }
    }, getErrors: function (value) {
        var rv = [];
        if (!this.allowBlank) {
            var v = this.items.items[0].getValue().toString() || this.items.items[2].getValue().toString();
            if (v.length < 1 || v === Pan.base.form.TextField.prototype.emptyText) {
                rv.push(Pan.base.form.TextField.prototype.blankText);
                this.items.items[0].allowBlank = false;
                this.items.items[2].allowBlank = false;
            }
            else {
                this.items.items[0].allowBlank = true;
                this.items.items[2].allowBlank = true;
                this.items.items[0].clearInvalid();
                this.items.items[2].clearInvalid();
            }
        }
        if (rv.length <= 0 && (value > this.maxValue || value < this.minValue)) {
            rv.push(this.helpText || '');
        }
        if (this.lessThanItemId) {
            var lessThanItem = this.ownerCt.findByItemId(this.lessThanItemId);
            if (lessThanItem && (lessThanItem.getXType() == 'pan-time') && (value > lessThanItem.getValue())) {
                rv.push(this.lessThanHelpText || '');
            }
        }
        return rv;
    }, getValue: function () {
        var d = this.items.get(0).getValue();
        var h = this.items.get(2).getValue();
        var total = 0;
        if (d && d > 0)
            total += d * 1440;
        if (h && h > 0)
            total += h * 60;
        if (this.showMinutes) {
            var m = this.items.get(4).getValue();
            if (m && m > 0)
                total += m;
        }
        return total;
    }, setValue: function (value) {
        var v = parseInt(value, 10);
        if (v && v > 0) {
            var d = parseInt(v / 1440, 10);
            this.items.get(0).setValue(d);
            var h = parseInt((v - d * 1440) / 60, 10);
            this.items.get(2).setValue(h);
            if (this.showMinutes) {
                var m = v - d * 1440 - h * 60;
                this.items.get(4).setValue(m);
            }
        }
    }
});
Ext.reg('pan-time', Pan.base.form.TimeField);
Pan.base.form.MergeEditor = Ext.extend(Ext.BoxComponent, {
    grow: false,
    autoFormat: true,
    readOnly: true,
    initComponent: function () {
        this.listeners = this.listeners || {};
        Ext.applyIf(this.listeners, {
            'render': function (target) {
                target.el.dom.innerHTML = "";
                target.editor = CodeMirror.ComparisonView(target.el.dom, {
                    value: this.value || "",
                    origLeft: null,
                    orig: this.orig || "",
                    lineNumbers: true,
                    mode1: "text/html",
                    mode: {name: 'xml', alignCDATA: true},
                    highlightDifferences: true,
                    connect: null,
                    collapseIdentical: true,
                    readOnly: this.readOnly,
                    mergeEditor: target
                });
                target.autoFormatAll();
            }
        });
        Pan.base.form.MergeEditor.superclass.initComponent.apply(this, arguments);
    },
    autoFormatAll: function () {
        var editor = this.editor.edit;
        editor.autoFormatRange({line: editor.firstLine(), ch: 0}, {
            line: editor.lastLine(),
            ch: editor.getLine(editor.lastLine()).length
        });
        editor.setSelection({line: editor.firstLine(), ch: 0});
        editor = this.editor.right.orig;
        editor.autoFormatRange({line: editor.firstLine(), ch: 0}, {
            line: editor.lastLine(),
            ch: editor.getLine(editor.lastLine()).length
        });
        editor.setSelection({line: editor.firstLine(), ch: 0});
    },
    onResize: function (adjWidth, adjHeight, rawWidth, rawHeight) {
        if (this.editor) {
        }
    },
    getValue: function () {
        return this.value || {};
    },
    setValue: function (v) {
        this.value = v;
        if (this.editor) {
            var editor = this.editor.edit;
            editor.setValue(v && v.value || "");
            editor = this.editor.right.orig;
            editor.setValue(v && v.orig || "");
            if (this.autoFormat) {
                this.autoFormatAll();
            }
        }
    },
    setOption: function () {
        if (this.editor) {
            this.editor.setOption.apply(this.editor, arguments);
        }
    },
    replaceSelection: function () {
        this.editor.replaceSelection.apply(this.editor, arguments);
    }
});
Ext.reg('pan-mergeeditor', Pan.base.form.MergeEditor);
(function () {
    "use strict";
    var Pos = CodeMirror.Pos;
    var svgNS = "http://www.w3.org/2000/svg";

    function DiffView(mv, type) {
        this.mv = mv;
        this.type = type;
        this.classes = type == "left" ? {
            chunk: "CodeMirror-merge-l-chunk",
            start: "CodeMirror-merge-l-chunk-start",
            end: "CodeMirror-merge-l-chunk-end",
            insert: "CodeMirror-merge-l-inserted",
            del: "CodeMirror-merge-l-deleted",
            connect: "CodeMirror-merge-l-connect"
        } : {
            chunk: "CodeMirror-merge-r-chunk",
            start: "CodeMirror-merge-r-chunk-start",
            end: "CodeMirror-merge-r-chunk-end",
            insert: "CodeMirror-merge-r-inserted",
            del: "CodeMirror-merge-r-deleted",
            connect: "CodeMirror-merge-r-connect"
        };
    }

    DiffView.prototype = {
        constructor: DiffView, init: function (pane, orig, options) {
            this.edit = this.mv.edit;
            this.orig = CodeMirror(pane, copyObj({value: orig, readOnly: true}, copyObj(options)));
            this.diff = getDiff(asString(orig), asString(options.value));
            this.diffOutOfDate = false;
            this.showDifferences = options.showDifferences !== false;
            this.forceUpdate = registerUpdate(this);
            setScrollLock(this, true, false);
            registerScroll(this);
        }, setShowDifferences: function (val) {
            val = val !== false;
            if (val != this.showDifferences) {
                this.showDifferences = val;
                this.forceUpdate("full");
            }
        }
    };

    function registerUpdate(dv) {
        var edit = {from: 0, to: 0, marked: []};
        var orig = {from: 0, to: 0, marked: []};
        var debounceChange;

        function update(mode) {
            if (mode == "full") {
                if (dv.svg) clear(dv.svg);
                clear(dv.copyButtons);
                clearMarks(dv.edit, edit.marked, dv.classes);
                clearMarks(dv.orig, orig.marked, dv.classes);
                edit.from = edit.to = orig.from = orig.to = 0;
            }
            if (dv.diffOutOfDate) {
                dv.diff = getDiff(dv.orig.getValue(), dv.edit.getValue());
                dv.diffOutOfDate = false;
                CodeMirror.signal(dv.edit, "updateDiff", dv.diff);
            }
            if (dv.showDifferences) {
                updateMarks(dv.edit, dv.diff, edit, DIFF_INSERT, dv.classes);
                updateMarks(dv.orig, dv.diff, orig, DIFF_DELETE, dv.classes);
            }
            drawConnectors(dv);
        }

        function set(slow) {
            clearTimeout(debounceChange);
            debounceChange = setTimeout(update, slow == true ? 250 : 100);
        }

        function change() {
            if (!dv.diffOutOfDate) {
                dv.diffOutOfDate = true;
                edit.from = edit.to = orig.from = orig.to = 0;
            }
            set(true);
        }

        dv.edit.on("change", change);
        dv.orig.on("change", change);
        dv.edit.on("markerAdded", set);
        dv.edit.on("markerCleared", set);
        dv.orig.on("markerAdded", set);
        dv.orig.on("markerCleared", set);
        dv.edit.on("viewportChange", set);
        dv.orig.on("viewportChange", set);
        update();
        return update;
    }

    function registerScroll(dv) {
        dv.edit.on("scroll", function () {
            syncScroll(dv, DIFF_INSERT) && drawConnectors(dv);
        });
        dv.orig.on("scroll", function () {
            syncScroll(dv, DIFF_DELETE) && drawConnectors(dv);
        });
    }

    function syncScroll(dv, type) {
        if (dv.diffOutOfDate) return false;
        if (!dv.lockScroll) return true;
        var editor, other, now = +new Date;
        if (type == DIFF_INSERT) {
            editor = dv.edit;
            other = dv.orig;
        }
        else {
            editor = dv.orig;
            other = dv.edit;
        }
        if (editor.state.scrollSetBy == dv && (editor.state.scrollSetAt || 0) + 50 > now) return false;
        var sInfo = editor.getScrollInfo(), halfScreen = .5 * sInfo.clientHeight, midY = sInfo.top + halfScreen;
        var mid = editor.lineAtHeight(midY, "local");
        var around = chunkBoundariesAround(dv.diff, mid, type == DIFF_INSERT);
        var off = getOffsets(editor, type == DIFF_INSERT ? around.edit : around.orig);
        var offOther = getOffsets(other, type == DIFF_INSERT ? around.orig : around.edit);
        var ratio = (midY - off.top) / (off.bot - off.top);
        var targetPos = (offOther.top - halfScreen) + ratio * (offOther.bot - offOther.top);
        var botDist, mix;
        if (targetPos > sInfo.top && (mix = sInfo.top / halfScreen) < 1) {
            targetPos = targetPos * mix + sInfo.top * (1 - mix);
        } else if ((botDist = sInfo.height - sInfo.clientHeight - sInfo.top) < halfScreen) {
            var otherInfo = other.getScrollInfo();
            var botDistOther = otherInfo.height - otherInfo.clientHeight - targetPos;
            if (botDistOther > botDist && (mix = botDist / halfScreen) < 1)
                targetPos = targetPos * mix + (otherInfo.height - otherInfo.clientHeight - botDist) * (1 - mix);
        }
        other.scrollTo(sInfo.left, targetPos);
        other.state.scrollSetAt = now;
        other.state.scrollSetBy = dv;
        return true;
    }

    function getOffsets(editor, around) {
        var bot = around.after;
        if (bot == null) bot = editor.lastLine() + 1;
        return {top: editor.heightAtLine(around.before || 0, "local"), bot: editor.heightAtLine(bot, "local")};
    }

    function setScrollLock(dv, val, action) {
        dv.lockScroll = val;
        if (val && action != false) syncScroll(dv, DIFF_INSERT) && drawConnectors(dv);
        dv.lockButton.innerHTML = val ? "\u21db\u21da" : "\u21db&nbsp;&nbsp;\u21da";
    }

    function clearMarks(editor, arr, classes) {
        for (var i = 0; i < arr.length; ++i) {
            var mark = arr[i];
            if (mark instanceof CodeMirror.TextMarker) {
                mark.clear();
            } else {
                editor.removeLineClass(mark, "background", classes.chunk);
                editor.removeLineClass(mark, "background", classes.start);
                editor.removeLineClass(mark, "background", classes.end);
            }
        }
        arr.length = 0;
    }

    function updateMarks(editor, diff, state, type, classes) {
        var vp = editor.getViewport();
        editor.operation(function () {
            if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
                clearMarks(editor, state.marked, classes);
                markChanges(editor, diff, type, state.marked, vp.from, vp.to, classes);
                state.from = vp.from;
                state.to = vp.to;
            } else {
                if (vp.from < state.from) {
                    markChanges(editor, diff, type, state.marked, vp.from, state.from, classes);
                    state.from = vp.from;
                }
                if (vp.to > state.to) {
                    markChanges(editor, diff, type, state.marked, state.to, vp.to, classes);
                    state.to = vp.to;
                }
            }
        });
    }

    function markChanges(editor, diff, type, marks, from, to, classes) {
        var pos = Pos(0, 0);
        var top = Pos(from, 0), bot = editor.clipPos(Pos(to - 1));
        var cls = type == DIFF_DELETE ? classes.del : classes.insert;

        function markChunk(start, end) {
            var bfrom = Math.max(from, start), bto = Math.min(to, end);
            for (var i = bfrom; i < bto; ++i) {
                var line = editor.addLineClass(i, "background", classes.chunk);
                if (i == start) editor.addLineClass(line, "background", classes.start);
                if (i == end - 1) editor.addLineClass(line, "background", classes.end);
                marks.push(line);
            }
            if (start == end && bfrom == end && bto == end) {
                if (bfrom)
                    marks.push(editor.addLineClass(bfrom - 1, "background", classes.end)); else
                    marks.push(editor.addLineClass(bfrom, "background", classes.start));
            }
        }

        var chunkStart = 0;
        for (var i = 0; i < diff.length; ++i) {
            var part = diff[i], tp = part[0], str = part[1];
            if (tp == DIFF_EQUAL) {
                var cleanFrom = pos.line + (startOfLineClean(diff, i) ? 0 : 1);
                moveOver(pos, str);
                var cleanTo = pos.line + (endOfLineClean(diff, i) ? 1 : 0);
                if (cleanTo > cleanFrom) {
                    if (i) markChunk(chunkStart, cleanFrom);
                    chunkStart = cleanTo;
                }
            } else {
                if (tp == type) {
                    var end = moveOver(pos, str, true);
                    var a = posMax(top, pos), b = posMin(bot, end);
                    if (!posEq(a, b))
                        marks.push(editor.markText(a, b, {className: cls}));
                    pos = end;
                }
            }
        }
        if (chunkStart <= pos.line) markChunk(chunkStart, pos.line + 1);
    }

    function drawConnectors(dv) {
        if (!dv.showDifferences) return;
        if (dv.svg) {
            clear(dv.svg);
            var w = dv.gap.offsetWidth;
            attrs(dv.svg, "width", w, "height", dv.gap.offsetHeight);
        }
        clear(dv.copyButtons);
        var flip = dv.type == "left";
        var vpEdit = dv.edit.getViewport(), vpOrig = dv.orig.getViewport();
        var sTopEdit = dv.edit.getScrollInfo().top, sTopOrig = dv.orig.getScrollInfo().top;
        iterateChunks(dv.diff, function (topOrig, botOrig, topEdit, botEdit) {
            if (topEdit > vpEdit.to || botEdit < vpEdit.from || topOrig > vpOrig.to || botOrig < vpOrig.from)
                return;
            var topLpx = dv.orig.heightAtLine(topOrig, "local") - sTopOrig, top = topLpx;
            if (dv.svg) {
                var topRpx = dv.edit.heightAtLine(topEdit, "local") - sTopEdit;
                if (flip) {
                    var tmp = topLpx;
                    topLpx = topRpx;
                    topRpx = tmp;
                }
                var botLpx = dv.orig.heightAtLine(botOrig, "local") - sTopOrig;
                var botRpx = dv.edit.heightAtLine(botEdit, "local") - sTopEdit;
                if (flip) {
                    tmp = botLpx;
                    botLpx = botRpx;
                    botRpx = tmp;
                }
                var curveTop = " C " + w / 2 + " " + topRpx + " " + w / 2 + " " + topLpx + " " + (w + 2) + " " + topLpx;
                var curveBot = " C " + w / 2 + " " + botLpx + " " + w / 2 + " " + botRpx + " -1 " + botRpx;
                attrs(dv.svg.appendChild(document.createElementNS(svgNS, "path")), "d", "M -1 " + topRpx + curveTop + " L " + (w + 2) + " " + botLpx + curveBot + " z", "class", dv.classes.connect);
            }
            var copy = dv.copyButtons.appendChild(elt("div", dv.type == "left" ? "\u21dd" : "\u21dc", "CodeMirror-merge-copy"));
            copy.title = dv.edit.options.mergeEditor.getValue().lineMetaMap && dv.edit.options.mergeEditor.getValue().lineMetaMap[topEdit];
            copy.chunk = {topEdit: topEdit, botEdit: botEdit, topOrig: topOrig, botOrig: botOrig};
            copy.style.top = top + "px";
        });
    }

    function copyChunk(dv, chunk) {
    }

    var ComparisonView = CodeMirror.ComparisonView = function (node, options) {
        if (!(this instanceof ComparisonView)) return new ComparisonView(node, options);
        var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;
        var hasLeft = origLeft != null, hasRight = origRight != null;
        var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
        var wrap = [], left = this.left = null, right = this.right = null;
        if (hasLeft) {
            left = this.left = new DiffView(this, "left");
            var leftPane = elt("div", null, "CodeMirror-merge-pane");
            wrap.push(leftPane);
            wrap.push(buildGap(left));
        }
        var editPane = elt("div", null, "CodeMirror-merge-pane");
        wrap.push(editPane);
        if (hasRight) {
            right = this.right = new DiffView(this, "right");
            wrap.push(buildGap(right));
            var rightPane = elt("div", null, "CodeMirror-merge-pane");
            wrap.push(rightPane);
        }
        (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";
        wrap.push(elt("div", null, null, "height: 0; clear: both;"));
        var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
        this.edit = CodeMirror(editPane, copyObj(options));
        if (left) left.init(leftPane, origLeft, options);
        if (right) right.init(rightPane, origRight, options);
        var onResize = function () {
            if (left) drawConnectors(left);
            if (right) drawConnectors(right);
        };
        CodeMirror.on(window, "resize", onResize);
        var resizeInterval = setInterval(function () {
            for (var p = wrapElt.parentNode; p && p != document.body; p = p.parentNode) {
            }
            if (!p) {
                clearInterval(resizeInterval);
                CodeMirror.off(window, "resize", onResize);
            }
        }, 5000);
    };

    function buildGap(dv) {
        var lock = dv.lockButton = elt("div", null, "CodeMirror-merge-scrolllock");
        lock.title = "Toggle locked scrolling";
        var lockWrap = elt("div", [lock], "CodeMirror-merge-scrolllock-wrap");
        CodeMirror.on(lock, "click", function () {
            setScrollLock(dv, !dv.lockScroll);
        });
        dv.copyButtons = elt("div", null, "CodeMirror-merge-copybuttons-" + dv.type);
        CodeMirror.on(dv.copyButtons, "click", function (e) {
            var node = e.target || e.srcElement;
            if (node.chunk) copyChunk(dv, node.chunk);
        });
        var gapElts = [dv.copyButtons, lockWrap];
        var svg = document.createElementNS && document.createElementNS(svgNS, "svg");
        if (svg && !svg.createSVGRect) svg = null;
        dv.svg = svg;
        if (svg) gapElts.push(svg);
        return dv.gap = elt("div", gapElts, "CodeMirror-merge-gap");
    }

    ComparisonView.prototype = {
        constuctor: ComparisonView, editor: function () {
            return this.edit;
        }, rightOriginal: function () {
            return this.right && this.right.orig;
        }, leftOriginal: function () {
            return this.left && this.left.orig;
        }, setShowDifferences: function (val) {
            if (this.right) this.right.setShowDifferences(val);
            if (this.left) this.left.setShowDifferences(val);
        }, rightChunks: function () {
            return this.right && getChunks(this.right.diff);
        }, leftChunks: function () {
            return this.left && getChunks(this.left.diff);
        }
    };

    function asString(obj) {
        if (typeof obj == "string") return obj; else return obj.getValue();
    }

    var dmp = new diff_match_patch();

    function getDiff(a, b) {
        var diff = dmp.diff_main(a, b);
        dmp.diff_cleanupSemantic(diff);
        for (var i = 0; i < diff.length; ++i) {
            var part = diff[i];
            if (!part[1]) {
                diff.splice(i--, 1);
            } else if (i && diff[i - 1][0] == part[0]) {
                diff.splice(i--, 1);
                diff[i][1] += part[1];
            }
        }
        return diff;
    }

    function iterateChunks(diff, f) {
        var startEdit = 0, startOrig = 0;
        var edit = Pos(0, 0), orig = Pos(0, 0);
        for (var i = 0; i < diff.length; ++i) {
            var part = diff[i], tp = part[0];
            if (tp == DIFF_EQUAL) {
                var startOff = startOfLineClean(diff, i) ? 0 : 1;
                var cleanFromEdit = edit.line + startOff, cleanFromOrig = orig.line + startOff;
                moveOver(edit, part[1], null, orig);
                var endOff = endOfLineClean(diff, i) ? 1 : 0;
                var cleanToEdit = edit.line + endOff, cleanToOrig = orig.line + endOff;
                if (cleanToEdit > cleanFromEdit) {
                    if (i) f(startOrig, cleanFromOrig, startEdit, cleanFromEdit);
                    startEdit = cleanToEdit;
                    startOrig = cleanToOrig;
                }
            } else {
                moveOver(tp == DIFF_INSERT ? edit : orig, part[1]);
            }
        }
        if (startEdit <= edit.line || startOrig <= orig.line)
            f(startOrig, orig.line + 1, startEdit, edit.line + 1);
    }

    function getChunks(diff) {
        var collect = [];
        iterateChunks(diff, function (topOrig, botOrig, topEdit, botEdit) {
            collect.push({origFrom: topOrig, origTo: botOrig, editFrom: topEdit, editTo: botEdit});
        });
        return collect;
    }

    function endOfLineClean(diff, i) {
        if (i == diff.length - 1) return true;
        var next = diff[i + 1][1];
        if (next.length == 1 || next.charCodeAt(0) != 10) return false;
        if (i == diff.length - 2) return true;
        next = diff[i + 2][1];
        return next.length > 1 && next.charCodeAt(0) == 10;
    }

    function startOfLineClean(diff, i) {
        if (i == 0) return true;
        var last = diff[i - 1][1];
        if (last.charCodeAt(last.length - 1) != 10) return false;
        if (i == 1) return true;
        last = diff[i - 2][1];
        return last.charCodeAt(last.length - 1) == 10;
    }

    function chunkBoundariesAround(diff, n, nInEdit) {
        var beforeE, afterE, beforeO, afterO;
        iterateChunks(diff, function (fromOrig, toOrig, fromEdit, toEdit) {
            var fromLocal = nInEdit ? fromEdit : fromOrig;
            var toLocal = nInEdit ? toEdit : toOrig;
            if (afterE == null) {
                if (fromLocal > n) {
                    afterE = fromEdit;
                    afterO = fromOrig;
                }
                else if (toLocal > n) {
                    afterE = toEdit;
                    afterO = toOrig;
                }
            }
            if (toLocal <= n) {
                beforeE = toEdit;
                beforeO = toOrig;
            }
            else if (fromLocal <= n) {
                beforeE = fromEdit;
                beforeO = fromOrig;
            }
        });
        return {edit: {before: beforeE, after: afterE}, orig: {before: beforeO, after: afterO}};
    }

    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) e.className = className;
        if (style) e.style.cssText = style;
        if (typeof content == "string") e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
    }

    function clear(node) {
        for (var count = node.childNodes.length; count > 0; --count)
            node.removeChild(node.firstChild);
    }

    function attrs(elt) {
        for (var i = 1; i < arguments.length; i += 2)
            elt.setAttribute(arguments[i], arguments[i + 1]);
    }

    function copyObj(obj, target) {
        if (!target) target = {};
        for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
        return target;
    }

    function moveOver(pos, str, copy, other) {
        var out = copy ? Pos(pos.line, pos.ch) : pos, at = 0;
        for (; ;) {
            var nl = str.indexOf("\n", at);
            if (nl == -1) break;
            ++out.line;
            if (other) ++other.line;
            at = nl + 1;
        }
        out.ch = (at ? 0 : out.ch) + (str.length - at);
        if (other) other.ch = (at ? 0 : other.ch) + (str.length - at);
        return out;
    }

    function posMin(a, b) {
        return (a.line - b.line || a.ch - b.ch) < 0 ? a : b;
    }

    function posMax(a, b) {
        return (a.line - b.line || a.ch - b.ch) > 0 ? a : b;
    }

    function posEq(a, b) {
        return a.line == b.line && a.ch == b.ch;
    }
})();
Pan.base.form.XMLEditor = Ext.extend(Pan.base.form.TextArea, {
    grow: false,
    autoFormat: false,
    readOnly: false,
    initComponent: function () {
        this.listeners = this.listeners || {};
        Ext.applyIf(this.listeners, {
            'render': function (textarea) {
                textarea.editor = CodeMirror.fromTextArea(textarea.el.dom, {
                    content: textarea.getValue(),
                    autoMatchParens: true,
                    lineNumbers: true,
                    foldGutter: true,
                    gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
                    mode: {name: 'xml', alignCDATA: true},
                    readOnly: textarea.readOnly
                });
            }
        });
        Pan.base.form.XMLEditor.superclass.initComponent.apply(this, arguments);
    },
    onResize: function () {
        if (this.editor) {
            this.editor.refresh();
        }
    },
    getValue: function () {
        if (this.editor) {
            return this.editor.getValue();
        }
    },
    setValue: function (v) {
        if (this.editor) {
            this.editor.setValue(v || "");
            if (this.autoFormat) {
                this.editor.execCommand("selectAll");
                this.autoFormatSelection();
                var range = this.getSelectedRange();
                this.editor.setCursor(range.to);
            }
        }
    },
    setOption: function () {
        if (this.editor) {
            this.editor.setOption.apply(this.editor, arguments);
        }
    },
    getSelectedRange: function () {
        return {from: this.editor.getCursor(true), to: this.editor.getCursor(false)};
    },
    autoFormatSelection: function () {
        var range = this.getSelectedRange();
        this.editor.autoFormatRange(range.from, range.to);
    },
    commentSelection: function (isComment) {
        var range = this.getSelectedRange();
        this.editor.commentRange(isComment, range.from, range.to);
    },
    replaceSelection: function () {
        this.editor.replaceSelection.apply(this.editor, arguments);
    }
});
Ext.reg('pan-xmleditor', Pan.base.form.XMLEditor);
Pan.base.form.CodeMirror = Ext.extend(Ext.form.TextArea, {
    mode: 'javascript', initComponent: function () {
        Pan.base.form.CodeMirror.superclass.initComponent.apply(this, arguments);
        this.on({
            resize: function (ta, width, height) {
                var el = Ext.select('.' + this.id, true);
                if (el) {
                    width -= 35;
                    el.elements.forEach(function (e) {
                        e.setSize(width, height);
                    });
                }
            }, render: function () {
                var me = this;
                me.codeEditor = CodeMirror.fromTextArea(me.el.dom, {
                    lineNumbers: true,
                    content: me.getValue(),
                    mode: me.mode,
                    autoMatchParent: true,
                    foldGutter: true,
                    gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"]
                });
            }
        });
    }, setMode: function (mode) {
        if (this.codeEditor) {
            this.codeEditor.setOption('mode', mode);
            this.setValue(this.getValue());
        }
    }, getValue: function () {
        if (this.codeEditor) {
            return this.codeEditor.getValue();
        }
        return this.initialConfig.value;
    }, setValue: function (v) {
        if (this.codeEditor) {
            this.codeEditor.setValue(v || "");
            this.codeEditor.execCommand("selectAll");
            this.autoFormatSelection();
            var range = this.getSelectedRange();
            this.codeEditor.setCursor(range.to);
        }
    }, validate: function () {
        this.getValue();
        Pan.base.form.CodeMirror.superclass.validate.apply(this, arguments);
    }, onResize: function (adjWidth, adjHeight, rawWidth, rawHeight) {
        if (this.codeEditor) {
            this.codeEditor.refresh();
        }
    }, setOption: function () {
        if (this.codeEditor) {
            this.codeEditor.setOption.apply(this.codeEditor, arguments);
        }
    }, getSelectedRange: function () {
        return {from: this.codeEditor.getCursor(true), to: this.codeEditor.getCursor(false)};
    }, autoFormatSelection: function () {
        var range = this.getSelectedRange();
        this.codeEditor.autoFormatRange(range.from, range.to);
    }, commentSelection: function (isComment) {
        var range = this.getSelectedRange();
        this.codeEditor.commentRange(isComment, range.from, range.to);
    }, replaceSelection: function () {
        this.codeEditor.replaceSelection.apply(this.codeEditor, arguments);
    }
});
Ext.reg('pan-codemirror', Pan.base.form.CodeMirror);
Pan.base.form.HtmlEditor = Ext.extend(Ext.form.HtmlEditor, {
    base64Conversion: false, constructor: function (config) {
        config = config || {};
        if (config.base64Conversion) {
            Ext.applyIf(config, {base64Conversion: config.base64Conversion});
        }
        Pan.base.form.HtmlEditor.superclass.constructor.call(this, config);
    }, setValue: function (v) {
        if (this.base64Conversion) {
            v = Base64.decode(v);
        }
        return Pan.base.form.HtmlEditor.superclass.setValue.call(this, v);
    }, getValue: function () {
        var superValue = Pan.base.form.HtmlEditor.superclass.getValue.call(this);
        if (this.base64Conversion) {
            superValue = Base64.encode(superValue);
        }
        return superValue;
    }, fixKeys: function () {
        if (Ext.isWebKit) {
            return function (e) {
                var k = e.getKey(), doc = this.getDoc(), r;
                if (k == e.TAB) {
                    e.stopEvent();
                    r = doc.selection.createRange();
                    if (r) {
                        r.collapse(true);
                        r.pasteHTML('&nbsp;&nbsp;&nbsp;&nbsp;');
                        this.deferFocus();
                    }
                } else if (k == e.ENTER) {
                    r = doc.selection.createRange();
                    if (r) {
                        var target = r.parentElement();
                        if (!target || target.tagName.toLowerCase() != 'li') {
                            e.stopEvent();
                            r.pasteHTML('<br />');
                            r.collapse(false);
                            r.select();
                        }
                    }
                }
            };
        }
        return Pan.base.form.HtmlEditor.superclass.fixKeys.apply(this, arguments);
    }
});
Ext.reg('pan-htmleditor', Pan.base.form.HtmlEditor);
Pan.base.form.Label = Ext.extend(Ext.form.Label, {
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.form.Label.superclass.constructor.call(this, config);
    }, setValue: function (value) {
        this.setText(value);
    }
});
Ext.reg('pan-label', Pan.base.form.Label);
Pan.base.form.GridStack = Ext.extend(Ext.BoxComponent, {
    resizeLaterAnimateDelay: 100, animate: true, stateful: true, initComponent: function () {
        Ext.apply(this, {
            paddingComponents: [],
            options: {
                resizable: {handles: 'n, ne, nw, e, se, s, sw, w'},
                animate: this.animate,
                handle: '.x-panel-header'
            },
            autoEl: {tag: 'div', cls: 'grid-stack', height: 300},
            listeners: {
                restore: function () {
                    var parentWindow = this.findParentByType('pan-window');
                    if (parentWindow) {
                        parentWindow.focus();
                    }
                }
            }
        });
        Pan.base.form.GridStack.superclass.initComponent.apply(this, arguments);
    }, getGridStack: function () {
        if (!this.$gridstack) {
            var $gridstack = $('#' + this.id);
            if ($gridstack.length) {
                this.$gridstack = $gridstack;
            }
        }
        return this.$gridstack;
    }, getGridStackInstance: function () {
        var $gridstack = this.getGridStack();
        return $gridstack && $gridstack.data('gridstack');
    }, onFitSize: function () {
        Ext.each(this.getComponents(), function (item) {
            var parent = item.el.parent('.grid-stack-item-content');
            if (parent) {
                var size = parent.getSize(), curSize = item.getSize();
                if (size.width !== curSize.width || size.height !== curSize.height) {
                    item.setSize(parent.getSize());
                }
            }
        });
    }, onRender: function (ct, position) {
        Pan.base.form.GridStack.superclass.onRender.apply(this, arguments);
        var $gridstack = this.getGridStack();
        if ($gridstack && !$gridstack.data('gridstack')) {
            var delay = this.animate ? this.resizeLaterAnimateDelay : 10;
            var handler = _.throttle(_.bind(this.onFitSize, this), delay, {leading: false});
            $gridstack.gridstack(this.options).on('change', _.debounce(_.bind(this.saveState, this), 300)).on('transitionend resizestop', handler);
            this.on('resize', handler, this, {delay: delay});
        }
        if (!Ext.isEmpty(this.paddingComponents)) {
            Ext.each(this.paddingComponents, function (args) {
                this.addComponent.apply(this, args);
            }, this);
            this.paddingComponents = null;
        }
    }, getState: function () {
        var widgets;
        if (this.rendered) {
            widgets = _.reduce(this.getComponents(), function (nodes, panel) {
                var el = panel.container.parent('.grid-stack-item').dom;
                var node = el && $(el).data('_gridstack_node');
                if (node) {
                    nodes.push({
                        x: node.x,
                        y: node.y,
                        width: node.width,
                        height: node.height,
                        state: Ext.applyIf({
                            dim: [node.x, node.y, node.width, node.height],
                            title: panel.title
                        }, panel.componentConfig)
                    });
                }
                return nodes;
            }, []);
            widgets = _.map(GridStackUI.Utils.sort(widgets), function (widget) {
                return widget.state;
            });
        }
        else {
            widgets = _.map(this.paddingComponents, function (args) {
                return args[0];
            });
        }
        return {name: this.name, widgets: widgets};
    }, applyState: function (state) {
        state = state || {};
        if (state.name) {
            this.name = state.name;
        }
        this.clear();
        if (!Ext.isEmpty(state.widgets) && Ext.isArray(state.widgets)) {
            Ext.each(state.widgets, this.addViewer, this);
        }
    }, addComponent: function (config, createFunction) {
        if (!this.rendered) {
            this.paddingComponents.push([config, createFunction]);
            return;
        }
        var newWidgetID = this.newWidgetID();
        var styles = "";
        if (Ext.isNumber(config.horizontalMargin) && config.horizontalMargin >= 0) {
            var horizontalMargin = config.horizontalMargin;
            styles = "left:" + horizontalMargin + "px;right:" + horizontalMargin + "px;";
        }
        this.getGridStackInstance().addWidget('<div class="grid-stack-item"><div id="' + newWidgetID + '" class="grid-stack-item-content" style="' + styles + '"></div></div>', config.dim[0], config.dim[1], config.dim[2], config.dim[3], true);
        var widget = Ext.get(newWidgetID);
        var componentConfig = Ext.apply({}, config);
        var title = componentConfig.title || '&#160;';
        delete componentConfig.title;
        var widgetProperty = Ext.apply({}, {
            renderTo: newWidgetID,
            componentConfig: componentConfig,
            xtype: 'pan-panel',
            parentGridStack: this,
            cls: 'pan-widget-root',
            layout: 'fit',
            width: widget.getWidth(),
            height: widget.getHeight(),
            padding: 12,
            items: createFunction ? createFunction(componentConfig) : componentConfig,
            listeners: {
                destroy: function (panel) {
                    var grid = panel.parentGridStack.getGridStackInstance();
                    if (grid) {
                        grid.removeWidget(panel.container.parent('.grid-stack-item').dom);
                    }
                    this.parentGridStack = null;
                }
            }
        });
        if (config.hideHeader !== true) {
            Ext.apply(widgetProperty, {title: title, tools: this.getWidgetTools(config, this)});
        }
        if (Ext.isNumber(config.padding) && config.padding >= 0) {
            Ext.apply(widgetProperty, {padding: config.padding});
        }
        if (Ext.isNumber(config.verticalMargin) && config.verticalMargin >= 0) {
            this.getGridStackInstance().verticalMargin(config.verticalMargin);
        }
        return Ext.create(widgetProperty);
    }, addViewer: function (config) {
        this.addComponent(config, config.treePath ? Pan.create : undefined);
    }, clear: function () {
        var gridstack = this.getGridStackInstance();
        if (gridstack) {
            gridstack.removeAll();
        }
    }, newWidgetID: function () {
        return 'pan-widget-' + (++Pan.base.form.GridStack.AUTO_ID);
    }, getComponents: function () {
        var a = [];
        var elements = this.el.select('.pan-widget-root').elements;
        for (var i = 0; i < elements.length; i++) {
            var cmp = Ext.getCmp(elements[i].id);
            a.push(cmp);
        }
        return a;
    }, beforeDestroy: function () {
        Ext.each(this.getComponents(), function (cmp) {
            cmp.destroy();
        });
        this.getGridStackInstance().destroy();
        this.getGridStack().off('resizestop transitionend').remove();
        this.$gridstack = undefined;
        Pan.base.form.GridStack.superclass.beforeDestroy.apply(this, arguments);
    }, maximizeWidget: function (event, toolEl, panel) {
        var window = Ext.create({
            xtype: 'pan-containerwindow',
            parentSizeContainer: this.ownerCt,
            restoreToContainer: panel,
            parentContainer: this,
            animate: this.animate
        });
        panel.parentGridStack.fireEvent("maximize");
        window.show();
    }, disable: function () {
        var gridstack = this.getGridStackInstance();
        if (gridstack) {
            gridstack.disable();
        }
    }, getWidgetTools: function (config, gridstack) {
        var tools = [];
        if (Ext.isDefined(config['gear'])) {
            var gearProperty = Ext.apply({id: 'gear'}, config['gear']);
            tools.push(gearProperty);
        }
        if (!(config['maximizable'] === false)) {
            tools.push({
                id: 'maximize',
                qtip: 'maximize panel',
                handler: gridstack.maximizeWidget.createDelegate(gridstack)
            });
        }
        if (!(config['closeable'] === false)) {
            tools.push({
                id: 'close', qtip: 'close panel', handler: function (event, toolEl, panel) {
                    Ext.QuickTips.getQuickTip().hide();
                    panel.destroy();
                }
            });
        }
        return tools;
    }
});
Ext.reg('pan-gridstack', Pan.base.form.GridStack);
Pan.base.form.GridStack.AUTO_ID = 1000;
Pan.base.form.ContainerWindow = Ext.extend(Pan.base.container.Window, {
    animationDelay: 500, initComponent: function () {
        var box = this.parentSizeContainer.getBox();
        Ext.apply(this, {
            draggable: false,
            closable: false,
            resizable: false,
            maximizationPadding: [0, 0],
            animationDelay: this.animate ? this.animationDelay : 0
        });
        Ext.apply(this, {
            title: this.restoreToContainer.title || '&#160;',
            layout: 'fit',
            animateTarget: this.animate ? this.restoreToContainer.getEl() : undefined,
            x: box.x + this.maximizationPadding[1],
            y: box.y + this.maximizationPadding[0],
            width: box.width - 2 * this.maximizationPadding[1],
            height: box.height - 2 * this.maximizationPadding[0]
        });
        Ext.applyIf(this, {tools: [{id: 'restore', handler: this.restore}]});
        this.parentContainer.addListener("hide", this.hide, this);
        this.parentContainer.addListener("show", this.show, this);
        this.restoreToContainer.addListener("beforedestroy", this.close, this);
        this.parentSizeContainer.addListener("resize", this.fitContainer, this);
        this.parentSizeContainer.addListener("move", this.fitContainer, this);
        this.on('show', this.moveComponent, this, {single: true});
        Pan.base.form.ContainerWindow.superclass.initComponent.apply(this, arguments);
    }, moveComponent: function () {
        var innerComponent = this.restoreToContainer.remove(this.restoreToContainer.getComponent(0), false);
        this.restoreToContainer.doLayout();
        this.add(innerComponent);
        this.doLayout();
    }, fitContainer: function () {
        Pan.base.util.invokeLater(100, function () {
            var box = this.parentSizeContainer.getBox();
            this.setPosition(box.x + this.maximizationPadding[1], box.y + this.maximizationPadding[0]);
            this.setSize(box.width - 2 * this.maximizationPadding[1], box.height - 2 * this.maximizationPadding[0]);
        }, this, []);
    }, onDestroy: function () {
        this.parentContainer.removeListener("hide", this.hide, this);
        this.parentContainer.removeListener("show", this.show, this);
        this.restoreToContainer.removeListener("beforedestroy", this.close, this);
        this.parentSizeContainer.removeListener("resize", this.fitContainer, this);
        this.parentSizeContainer.removeListener("move", this.fitContainer, this);
        Pan.base.form.ContainerWindow.superclass.onDestroy.apply(this, arguments);
    }, restore: function (event, toolEl, w) {
        var innerComponent = w.remove(w.getComponent(0), false);
        w.close();
        Pan.base.util.invokeLater(0, function (w, innerComponent) {
            w.restoreToContainer.add(innerComponent);
            w.restoreToContainer.doLayout();
        }, this, [w, innerComponent]);
        w.restoreToContainer.parentGridStack.fireEvent("restore");
    }
});
Ext.reg('pan-containerwindow', Pan.base.form.ContainerWindow);
Ext.namespace('Pan.base.button');
Pan.base.button.processAType = function (config, button) {
    if (config.atype) {
        var makeHandler = function (o, action) {
            o.handler = Pan.base.util.createExtension(function (element, event) {
                var component;
                if (this.componentItemId) {
                    var ownerCt = this;
                    while (ownerCt.parentOwner || ownerCt.ownerCt) {
                        if (ownerCt.itemId === this.componentItemId) {
                            component = ownerCt;
                            break;
                        }
                        ownerCt = ownerCt.parentOwner || ownerCt.ownerCt;
                    }
                    if (!component) {
                        component = ownerCt.findByItemId(this.componentItemId);
                    }
                    if (!component) {
                        if (this.editorComponent) {
                            ownerCt = this.editorComponent;
                            while (ownerCt.parentOwner || ownerCt.ownerCt) {
                                if (ownerCt.itemId === this.componentItemId) {
                                    component = ownerCt;
                                    break;
                                }
                                ownerCt = ownerCt.parentOwner || ownerCt.ownerCt;
                            }
                        }
                    }
                }
                var config = {};
                if (component) {
                    config = {component: component, event: event, action: action};
                }
                arguments.callee.superFunction.call(this.scope || this, this, config, event);
            }, o.handler, this);
        };
        config = Pan.createAction(config, button);
        if (config.handler) {
            makeHandler.call(button, config, config);
        } else if (config.initialConfig && config.initialConfig.handler) {
            makeHandler.call(button, config.initialConfig, config);
        }
    }
    return config;
};
Pan.base.button.Button = Ext.extend(Ext.Button, {
    constructor: function (config) {
        config = Pan.base.button.processAType(config, this);
        Pan.base.button.Button.superclass.constructor.call(this, config);
    }, initComponent: function () {
        Pan.base.button.Button.superclass.initComponent.apply(this, arguments);
        if (this.menu) {
            this.menu.ownerCt = this;
        }
    }, onMenuHide: function (e) {
        var ownerCt = this.menu.ownerCt;
        Pan.base.button.Button.superclass.onMenuHide.call(this, e);
        if (ownerCt == this) {
            this.menu.ownerCt = ownerCt;
        }
    }, onDestroy: function () {
        Pan.base.button.Button.superclass.onDestroy.apply(this, arguments);
        if (this.menu) {
            delete this.menu.ownerCt;
        }
    }, focus: function () {
        if (this.btnEl) {
            Pan.base.button.Button.superclass.focus.apply(this, arguments);
        }
    }
});
Ext.reg('pan-button', Pan.base.button.Button);
Pan.base.button.LinkButton = Ext.extend(Pan.base.button.Button, {
    initComponent: function () {
        this.cls += " link-btn";
        Pan.base.button.LinkButton.superclass.initComponent.apply(this, arguments);
    }
});
Ext.reg('pan-linkbutton', Pan.base.button.LinkButton);
Pan.base.button.HttpLinkButton = Ext.extend(Ext.LinkButton, {
    dialogHeight: 500, dialogWidth: 800, constructor: function (config) {
        Pan.base.button.HttpLinkButton.superclass.constructor.call(this, config);
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
    }, initComponent: function () {
        if (this.showModalDialog) {
            this.template = new Ext.Template('<table id="{4}" cellspacing="0" class="x-btn {3}"><tbody class="{1}">', '<tr><td class="x-btn-tl"><i> </i></td><td class="x-btn-tc"></td><td class="x-btn-tr"><i> </i></td></tr>', '<tr><td class="x-btn-ml"><i> </i></td><td class="x-btn-mc"><em class="{2}" unselectable="on"><a style="display:block" class="x-btn-text">{0}</a></em></td><td class="x-btn-mr"><i> </i></td></tr>', '<tr><td class="x-btn-bl"><i> </i></td><td class="x-btn-bc"></td><td class="x-btn-br"><i> </i></td></tr>', '</tbody></table>').compile();
        }
        this.cls += " link-btn";
        Pan.base.button.HttpLinkButton.superclass.initComponent.apply(this, arguments);
    }, onClick: function (e) {
        if (this.showModalDialog) {
            this.modalWin();
        } else {
            Pan.base.button.HttpLinkButton.superclass.onClick.apply(this, arguments);
        }
    }, modalWin: function () {
        if (window.showModalDialog) {
            window.showModalDialog(this.showModalDialog, this.args, "dialogWidth:" + this.dialogWidth + "px;dialogHeight:" + this.dialogHeight + "px");
        } else {
            window.open(this.showModalDialog, this.args, 'height=' + this.dialogHeight + ',width=' + this.dialogWidth + ',toolbar=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=no,modal=yes');
        }
    }, setValue: function (value) {
        if (value && value.text) {
            this.setText(Pan.base.htmlEncode(value.text));
        }
        if (value && (value.href || value.baseParams || value.params)) {
            this.href = value.href || this.href;
            this.baseParams = value.baseParams || this.baseParams;
            if (value.params && Ext.isString(value.params)) {
                this.href += value.params;
            } else {
                this.params = value.params || this.params;
            }
            if (this.rendered) {
                this.el.dom.getElementsByTagName("a")[0].href = this.getHref();
            }
        }
    }, getValue: function () {
        return this.getText();
    }
});
Ext.reg('pan-httplinkbutton', Pan.base.button.HttpLinkButton);
Pan.base.button.LinkButtonField = Ext.extend(Pan.base.button.LinkButton, {
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        var newConfig = Ext.apply({}, config);
        newConfig.cls = newConfig.cls || "";
        newConfig.cls += " x-link-button-field";
        Pan.base.button.LinkButtonField.superclass.constructor.call(this, newConfig);
    }, setValue: function (value) {
        this.setText(value);
    }, getValue: function () {
        return this.getText();
    }
});
Ext.reg('pan-linkbuttonfield', Pan.base.button.LinkButtonField);
Ext.ns('Pan.base.button');
Pan.base.button.LinkButtonDrawer = Ext.extend(Pan.base.autorender.GridRecordField, {
    allowEmpty: true, preventMark: false, requiredFieldClass: 'x-form-invalid', constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.button.LinkButtonDrawer.superclass.constructor.call(this, config);
    }, initComponent: function () {
        Ext.apply(this, {
            layout: 'fit',
            fieldLabel: this.__field.uiHint.fieldLabel,
            items: [Ext.applyIf({
                xtype: 'pan-linkbuttonfield',
                iconCls: '',
                text: this.text,
                atype: 'browseAction',
                sameHeight: true,
                hideLabel: true
            }, this.buttonCfg)]
        });
        Pan.base.button.LinkButtonDrawer.superclass.initComponent.apply(this, arguments);
    }, getValue: function () {
        if (!this.record) {
            this.record = [];
        }
        return this.record;
    }, setValue: function (record) {
        this.record = record || [];
        this.items.items[0].setText(this.text + " (" + this.record.length + ")");
        return this;
    }, isValid: function () {
        var includeGroups = this.__field.name === "$.all.entry.*.user-groups.member" ? this.__pdefaults.__dataExtractor("$.all.entry.*.include-user-groups-info") : this.__pdefaults.__dataExtractor("$.selected-zone.entry.*.include-user-groups-info");
        if (this.allowEmpty || !includeGroups) {
            this.clearInvalid();
            return true;
        } else {
            if (Ext.isEmpty(this.record)) {
                this.markInvalid('test test');
                return false;
            }
        }
        this.clearInvalid();
        return true;
    }, markInvalid: function (msg) {
        if (this.rendered && !this.preventMark) {
            this.el.addClass(this.requiredFieldClass);
        }
    }, clearInvalid: function () {
        if (this.rendered && !this.preventMark) {
            this.el.removeClass(this.requiredFieldClass);
        }
    }
});
Ext.reg("pan-linkbutton-drawer", Pan.base.button.LinkButtonDrawer);
Pan.base.button.LeftRightTriggerButton = Ext.extend(Pan.base.form.Label, {
    deferHeight: true,
    actionMode: 'wrap',
    defaultTriggerStyle: 'vertical-align: middle; cursor: pointer;',
    initComponent: function () {
        Pan.base.button.LeftRightTriggerButton.superclass.initComponent.apply(this, arguments);
    },
    onRender: function (ct, position) {
        Pan.base.button.LeftRightTriggerButton.superclass.onRender.apply(this, arguments);
        this.wrap = this.el.wrap({cls: 'pan-leftright-trigger-wrap'});
        if (this.leftButtonConfig) {
            var leftButtonStyle = this.defaultTriggerStyle + (this.leftButtonConfig.style ? this.leftButtonConfig.style : '');
            var leftButtonConfig = Ext.applyIf({style: leftButtonStyle}, this.leftButtonConfig);
            if (leftButtonConfig.tooltip) {
                Ext.apply(leftButtonConfig, {'ext:qtip': Pan.base.htmlEncode(leftButtonConfig.tooltip)});
                delete leftButtonConfig.tooltip;
            }
            var leftButtonHandler = this.leftButtonConfig.handler;
            delete leftButtonConfig.handler;
            var leftButtonScope = this.leftButtonConfig.scope;
            delete leftButtonConfig.scope;
            this.leftButton = this.wrap.createChild(leftButtonConfig, this.el);
            if (leftButtonHandler) {
                this.mon(this.leftButton, 'click', function (e) {
                    leftButtonHandler.call(leftButtonScope || this, this, e);
                }, this);
            }
        }
        if (this.rightButtonConfig) {
            var rightButtonStyle = this.defaultTriggerStyle + (this.rightButtonConfig.style ? this.rightButtonConfig.style : '');
            var rightButtonConfig = Ext.applyIf({style: rightButtonStyle}, this.rightButtonConfig);
            if (rightButtonConfig.tooltip) {
                Ext.apply(rightButtonConfig, {'ext:qtip': Pan.base.htmlEncode(rightButtonConfig.tooltip)});
                delete rightButtonConfig.tooltip;
            }
            var rightButtonHandler = this.rightButtonConfig.handler;
            delete rightButtonConfig.handler;
            var rightButtonScope = this.rightButtonConfig.scope;
            delete rightButtonConfig.scope;
            this.rightButton = this.wrap.createChild(rightButtonConfig);
            if (rightButtonHandler) {
                this.mon(this.rightButton, 'click', function (e) {
                    rightButtonHandler.call(rightButtonScope || this, this, e);
                }, this);
            }
        }
        this.resizeEl = this.positionEl = this.wrap;
    },
    onDestroy: function () {
        if (this.leftButton) {
            Ext.destroy(this.leftButton);
        }
        if (this.rightButton) {
            Ext.destroy(this.rightButton);
        }
        Ext.destroy(this.wrap);
        Pan.base.button.LeftRightTriggerButton.superclass.onDestroy.call(this);
    }
});
Ext.reg('pan-Leftrighttriggerbutton', Pan.base.button.LeftRightTriggerButton);
Ext.namespace('Pan.base.data');
Pan.base.data.ErrorReader = Ext.extend(Ext.data.XmlReader, {
    readRecords: function (doc) {
        this.xmlData = doc;
        var root = doc.documentElement || doc;
        var q = Ext.DomQuery;
        var records = [];
        var status = q.selectValue('@status', root);
        var success = (status == "success");
        if (!success) {
            var recordType = this.recordType;
            var ns = q.select('line', root);
            for (var i = 0, len = ns.length; i < len; i++) {
                var n = ns[i];
                var values = {};
                values['line'] = Pan.base.getText(n);
                var record = new recordType(values, i);
                record.node = n;
                records[records.length] = record;
            }
        }
        return {success: success, records: records, totalRecords: records.length};
    }
});
Pan.base.data.HttpProxy = Ext.extend(Ext.data.HttpProxy, {});
Ext.ns('Pan.base.data');
Pan.base.data.LogStore = Ext.extend(Ext.data.Store, {
    reloadMethod: 'completeReload',
    autoDestroy: true,
    queryidInvalidMessages: {"No such query job": true, "query job cleared": true, "query job expired": true},
    queryEnqueuedResponseMessages: {"query job enqueued with jobid": true},
    beforeloadHandler: function (store, options) {
        options.params || (options.params = {});
        var query = '';
        var userQuery = this.logviewer.getUserQueryValue();
        if (this.logviewer && this.logviewer.appendImplicitFitler)
            userQuery += this.logviewer.appendImplicitFitler();
        if (userQuery) {
            userQuery = Ext.util.Format.trim(userQuery);
        }
        if (userQuery) {
            if (query) {
                query += ' AND ' + userQuery;
            } else {
                query = userQuery;
            }
        }
        Ext.apply(options.params, {query: query});
    },
    constructor: function (config) {
        this.addEvents('pollingInProgress', 'blockChange');
        Ext.applyIf(this, Pan.base.autorender.GridRecordStore.prototype.autoRefreshConfig);
        Pan.base.data.LogStore.superclass.constructor.apply(this, arguments);
        this.responseText = null;
        this.block = 0;
        this.totalCountInCurrentBlock = 0;
        this.hasNextPage = false;
        this.anchors = {};
        this.counts = {};
        this.currentTask = null;
        this.nextTask = null;
        var self = this;
        this.on({
            'beforeload': {fn: this.beforeloadHandler, scope: this}, 'pollingInProgress': {
                fn: function (store, finished) {
                    if (self.logviewer && self.logviewer.highlightLogViewerActions) {
                        self.logviewer.highlightLogViewerActions(store.highlightactions);
                    }
                    if (finished && store.resolvehostname) {
                        Pan.acc.whois.resolveLogViewerHostnames.defer(1000);
                    }
                    if (finished) {
                        Pan.acc.threatNameResolve.resolveLogViewerThreatNamesBulk.defer(1000);
                    }
                }, scope: this
            }
        });
    },
    destroy: function () {
        if (this.autoRefreshTask) {
            this.autoRefreshTask.cancel();
            delete this.autoRefreshTask;
        }
        Pan.base.data.LogStore.superclass.destroy.apply(this, arguments);
    },
    loadRecords: function (o, options, success) {
        if (o && o.anchor) {
            this.anchor = o.anchor;
        }
        return Pan.base.data.LogStore.superclass.loadRecords.call(this, o, options, success);
    },
    readActionHandler: function (options) {
        var self = this;
        if (options.params.identifier && options.params.identifier == 'viewerTab') {
            if (Pan.common.PanConfigStates.prototype.isShowingVsysComboOnTop()) {
                options.params.vsys = Pan.monitor.vsysScope();
            } else {
                options.params.vsys = '';
            }
        } else {
            options.params.vsys = Pan.monitor.vsysScope();
        }
        options.params.queryid = this.queryid;
        if (!options.params.isSameBlock) {
            this.setTotalCountInCurrentBlock(0);
        }
        this.enqueueTask(options, function (xmlData, tran) {
            self.processResult(xmlData, options);
        });
    },
    execute: function (action, rs, options, batch) {
        if (!Ext.data.Api.isAction(action)) {
            throw new Ext.data.Api.Error('execute', action);
        }
        options = Ext.applyIf(options || {}, {params: {}});
        if (batch !== undefined) {
            this.addToBatch(batch);
        }
        var doRequest = true;
        if (action === 'read') {
            doRequest = this.fireEvent('beforeload', this, options);
            Ext.applyIf(options.params, this.baseParams);
        }
        else {
            if (this.writer.listful === true && this.restful !== true) {
                rs = (Ext.isArray(rs)) ? rs : [rs];
            }
            else if (Ext.isArray(rs) && rs.length == 1) {
                rs = rs.shift();
            }
            if ((doRequest = this.fireEvent('beforewrite', this, action, rs, options)) !== false) {
                this.writer.apply(options.params, this.baseParams, action, rs);
            }
        }
        if (doRequest !== false) {
            if (this.writer && this.proxy.url && !this.proxy.restful && !Ext.data.Api.hasUniqueUrl(this.proxy, action)) {
                options.params.xaction = action;
            }
            if (action === 'read') {
                this.readActionHandler(options);
            } else {
                this.proxy.request(Ext.data.Api.actions[action], rs, options.params, this.reader, this.createCallback(action, rs, batch), this, options);
            }
        }
        return doRequest;
    },
    stopPolling: function () {
        if (this.currentTask && this.currentTask.queryid) {
            PanDirect.run('PanDirect.stopQuery', [this.currentTask.queryid]);
            this.currentTask = null;
        }
        if (this.nextTask) {
            this.currentTask = this.nextTask;
            this.nextTask = null;
            this.runTask();
        } else {
            this.pollingInProgress = false;
            this.fireEvent('pollingInProgress', this, !this.pollingInProgress);
        }
        if (!this.pollingInProgress) {
            this.autoRefresh();
        }
    },
    runTask: function () {
        if (this.currentTask) {
            this.pollingInProgress = true;
            this.fireEvent('pollingInProgress', this, !this.pollingInProgress);
            if (this.currentTask.options.params.queryid) {
                delete this.currentTask.options.params['start-respawn'];
            }
            PanDirect.run('MonitorDirect.enqueueLogRequest', [this.currentTask.options.params], this.currentTask.callback);
        }
    },
    enqueueCountOnlyTask: function (options) {
        var self = this;
        var countonlyOption = Pan.base.clone(options);
        countonlyOption.params = countonlyOption.params || {};
        countonlyOption.params['countonly'] = true;
        countonlyOption.params['start'] = 0;
        countonlyOption.params['anchor'] = this.anchor;
        countonlyOption.params['vsys'] = Pan.monitor.vsysScope();
        this.enqueueTask(countonlyOption, function (xmlData, tran) {
            self.processCount(xmlData, countonlyOption);
        });
    },
    enqueueExpiredTask: function (options) {
        this.currentTask = null;
        var self = this;
        options.params = options.params || {};
        options.params['start-respawn'] = Math.floor(options.params['start'] / (options.params['limit'] * 10)) * options.params['limit'] * 10;
        delete options.params['queryid'];
        delete options.params['isSameBlock'];
        this.enqueueTask(options, function (xmlData, tran) {
            self.processResult(xmlData, options);
        });
    },
    enqueueTask: function (options, callback) {
        if (this.currentTask) {
            this.nextTask = {options: Pan.base.clone(options), callback: callback};
            this.stopPolling();
        } else {
            this.currentTask = {options: Pan.base.clone(options), callback: callback};
            this.runTask();
        }
    },
    enqueueLogRequest: function () {
        var args = Array.prototype.splice.call(arguments, 0, 0, 'MonitorDirect.enqueueLogRequest');
        var enqueueLogRequestDelegate = PanDirect.run.createDelegate(PanDirect, args);
        if (this.pollingInProgress) {
            PanDirect.run('MonitorDirect.clearQueryAllBySession');
        } else {
            this.pollingInProgress = true;
            enqueueLogRequestDelegate();
        }
        this.fireEvent('pollingInProgress', this, !this.pollingInProgress);
    },
    isFirstPageOfCurrentBlock: function (options) {
        return options && options.params && options.params['limit'] && (options.params['start'] % (options.params['limit'] * 10)) == 0;
    },
    isSessionExpired: function (xmlData) {
        var expired = xmlData && (xmlData.indexOf("status='unauth'") >= 0 || xmlData.indexOf('status="unauth"') >= 0);
        if (expired) {
            Pan.base.redirectToLogout();
        }
        return expired;
    },
    isQueryidInvalidMessages: function (xmlData) {
        if (xmlData) {
            for (var msg in this.queryidInvalidMessages) {
                if (this.queryidInvalidMessages.hasOwnProperty(msg)) {
                    if (xmlData.indexOf(msg) >= 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    },
    isQueryEnqueuedMessages: function (xmlData) {
        if (xmlData) {
            for (var msg in this.queryEnqueuedResponseMessages) {
                if (this.queryEnqueuedResponseMessages.hasOwnProperty(msg)) {
                    if (xmlData.indexOf(msg) >= 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    },
    getXmlDoc: function (xmlData) {
        var doc;
        try {
            if (window.ActiveXObject) {
                doc = new ActiveXObject("Microsoft.XMLDOM");
                doc.async = "false";
                doc.loadXML(xmlData);
            }
            else {
                doc = new DOMParser().parseFromString(xmlData, "text/xml");
            }
        } catch (e) {
            Pan.base.msg.alert(_T('Invalid XML response from server'));
            this.xmlLogDataException();
        }
        return doc;
    },
    isXmlResultFIN: function (doc) {
        var status = doc.getElementsByTagName("status");
        if (status && status[0] && status[0].childNodes && status[0].childNodes[0]) {
            return status[0].childNodes[0].nodeValue == 'FIN';
        }
        return false;
    },
    getXmlCachedLogsCount: function (doc) {
        var cachedlogs = doc.getElementsByTagName("cached-logs");
        if (cachedlogs && cachedlogs[0] && cachedlogs[0].childNodes && cachedlogs[0].childNodes[0]) {
            return parseInt(cachedlogs[0].childNodes[0].nodeValue, 10);
        }
        return -1;
    },
    getXmlID: function (doc) {
        var id = null;
        var result = doc.getElementsByTagName('job');
        if (result && result[0] && result[0].childNodes && result[0].childNodes[0]) {
            for (var i = 0; i < result[0].childNodes.length; i++) {
                if (result[0].childNodes[i].nodeType == 1 && result[0].childNodes[i].nodeName == 'id' && result[0].childNodes[i].childNodes && result[0].childNodes[i].childNodes[0]) {
                    return result[0].childNodes[i].childNodes[0].nodeValue;
                }
            }
            return result[0].childNodes[0].nodeValue;
        }
        result = doc.getElementsByTagName('id');
        if (result && result[0] && result[0].childNodes && result[0].childNodes[0]) {
            return result[0].childNodes[0].nodeValue;
        }
        return null;
    },
    pollJob: function (nextPollInterval) {
        var self = this;
        if (!nextPollInterval) {
            nextPollInterval = 1000;
        } else if (nextPollInterval > 5000) {
            nextPollInterval = 5000;
        }
        this.fireEvent('pollingInProgress', this, false);
        (function () {
            var log = PanLogging.getLogger('base:data:LogStore');
            if (self.currentTask && self.currentTask.queryid && self.currentTask.options && self.currentTask.options.params) {
                var _options = Pan.base.clone(self.currentTask.options);
                if (!Ext.isNumber(self.currentTask.queryid)) {
                    log.warn('*** pollLogRequest currentTask id is malformed');
                    log.warn(self.currentTask.queryid);
                    return;
                }
                PanDirect.run('MonitorDirect.pollLogRequest', [self.currentTask.queryid, self.currentTask.options.params], function (xmlData, tran) {
                    self.processResult(xmlData, _options, nextPollInterval + 1000);
                });
            }
        }).defer(nextPollInterval);
    },
    getCurrentBlockCachedLogCount: function () {
        if (Ext.isDefined(this.counts[this.block])) {
            return this.counts[this.block];
        } else {
            return -1;
        }
    },
    xmlLogDataException: function (doc) {
        this.loadRecords({records: []}, {}, true);
        this.stopPolling();
        if (doc) {
            var msg = Pan.base.collectXmlTextNodes(doc);
            if (msg && !this.queryidInvalidMessages[msg] && msg.toLowerCase().indexOf('query timed out') === -1) {
                Pan.base.msg.alert(msg);
            }
        }
    },
    processResult: function (xmlData, options, nextPollInterval) {
        if (!xmlData || this.isDestroyed) {
            return;
        } else if (xmlData['msg'] === "You don't have permission to view this page") {
            this.xmlLogDataException();
            return;
        } else if (this.isSessionExpired(xmlData)) {
            return;
        }
        var self = this;
        if (this.isQueryidInvalidMessages(xmlData)) {
            this.enqueueExpiredTask(options);
            return;
        }
        var doc = this.getXmlDoc(xmlData);
        if (!doc) {
            return;
        }
        var finish = this.isXmlResultFIN(doc);
        var cachedlogscount = this.getXmlCachedLogsCount(doc);
        var id = this.getXmlID(doc);
        if (Ext.isString(id)) {
            id = parseInt(id, 10);
            this.queryid = id;
        }
        if (Ext.isNumber(id)) {
            if (options && options.params && options.params.logtype)
                Pan.mainui.tasks.addDescription('log', id, _T('{logtype} log view', {logtype: options.params.logtype}));
            if (this.currentTask) {
                this.currentTask.queryid = id;
            }
            if (!this.isQueryEnqueuedMessages(xmlData)) {
                this.responseText = xmlData;
                self.populateWithCurrentLogs(doc, options);
            }
            if (finish) {
                this.currentTask = null;
                this.responseText = xmlData;
                var pagenumber = options.params['start'] / options.params['limit'];
                var currentBlockCachedLogCount = this.getCurrentBlockCachedLogCount();
                if (this.isFirstPageOfCurrentBlock(options)) {
                    if (Pan.monitor.isCachedLoggingBackend()) {
                        this.updateFinalCount(cachedlogscount || 0, pagenumber);
                    } else {
                        if (currentBlockCachedLogCount >= 0) {
                            this.setTotalCountInCurrentBlock(currentBlockCachedLogCount, pagenumber);
                            this.stopPolling();
                        } else {
                            this.enqueueCountOnlyTask(options);
                        }
                    }
                } else {
                    this.setTotalCountInCurrentBlock(currentBlockCachedLogCount, pagenumber);
                    this.stopPolling();
                }
            } else {
                this.pollJob(nextPollInterval);
            }
        } else {
            this.xmlLogDataException(doc);
        }
    },
    populateWithCurrentLogs: function (doc, options) {
        var records = this.reader.readRecords(doc);
        this.loadRecords(records, options, true);
    },
    updateFinalCount: function (count, pagenumber) {
        this.stopPolling();
        this.counts[this.block] = count;
        this.hasNextPage = count > (this.lastOptions.params['limit'] * 10);
        this.setTotalCountInCurrentBlock(count, pagenumber);
    },
    processCount: function (xmlData, options) {
        if (this.isDestroyed || this.isSessionExpired(xmlData)) {
            return;
        }
        var self = this;
        var doc = this.getXmlDoc(xmlData);
        if (!doc) {
            return;
        }
        var finish = this.isXmlResultFIN(doc);
        var id = this.getXmlID(doc);
        var pollJob = Ext.emptyFn;
        if (Ext.isString(id)) {
            id = parseInt(id, 10);
            if (options && options.params && options.params.logtype)
                Pan.mainui.tasks.addDescription('log', id, _T('{logtype} log count', {logtype: options.params.logtype}));
            pollJob = function () {
                var log = PanLogging.getLogger('base:data:LogStore');
                self.fireEvent('pollingInProgress', self, false);
                if (!finish) {
                    (function () {
                        if (!Ext.isNumber(id)) {
                            log.warn('*** pollLogRequest id is malformed');
                            log.warn(id);
                            return;
                        }
                        PanDirect.run('MonitorDirect.pollLogRequest', [id, options.params], function (xmlData, tran) {
                            self.processCount(xmlData, options);
                        });
                    }).defer(1000);
                } else {
                    var logs = doc.getElementsByTagName("logs");
                    var count = 0;
                    if (logs && logs[0]) {
                        count = parseInt(logs[0].getAttribute('count'), 10);
                    }
                    if (isNaN(count)) {
                        count = 0;
                    }
                    var pagenumber = options.params['start'] / options.params['limit'];
                    self.updateFinalCount(count, pagenumber);
                }
            };
        }
        if (Ext.isNumber(id)) {
            pollJob();
        } else {
            this.stopPolling();
        }
    },
    removeOldQueryIdAndAnchor: function () {
        if (this.lastOptions && this.lastOptions.params) {
            delete this.lastOptions.params['queryid'];
            delete this.lastOptions.params['anchor'];
        }
        delete this.anchor;
        delete this.queryid;
        this.anchors = {};
        this.counts = {};
    },
    completeReload: function () {
        this.removeOldQueryIdAndAnchor();
        var o = this.lastOptions || {};
        this.block = 0;
        o.params = o.params || {};
        o.params['start'] = 0;
        this.load(o);
    },
    completeReloadUsingDatabases: function (databases) {
        this.removeOldQueryIdAndAnchor();
        var o = this.lastOptions || {};
        this.block = 0;
        o.params = o.params || {};
        o.params['start'] = 0;
        o.params['databases'] = databases;
        this.load(o);
    },
    changePageSize: function (pageSize) {
        this.removeOldQueryIdAndAnchor();
        var o = this.lastOptions || {};
        this.block = 0;
        o.params = o.params || {};
        o.params['start'] = 0;
        o.params['limit'] = pageSize;
        this.load(o);
    },
    moveNext: function () {
        var o = this.lastOptions || {};
        if (!this.lastOptions || !this.lastOptions.params || !this.anchor || !this.lastOptions.params['limit']) {
            this.completeReload();
        } else {
            this.anchors[this.block] = this.anchor;
            this.block++;
            delete this.queryid;
            delete o.params['queryid'];
            if (this.anchors[this.block]) {
                o.params['start'] = 0;
                o.params['anchor'] = this.anchors[this.block];
            } else {
                o.params['start'] = o.params['limit'] * 10;
                o.params['anchor'] = this.anchor;
            }
            if (Pan.monitor.isCachedLoggingBackend()) {
                o.params['start'] = o.params['limit'] * 10 * this.block;
            }
            this.load(o);
        }
    },
    movePrevious: function () {
        var o = this.lastOptions || {};
        if (this.block <= 1 || !this.lastOptions || !this.lastOptions.params || !this.anchor || !this.lastOptions.params['limit'] || !this.anchors[this.block - 1]) {
            this.completeReload();
        } else {
            this.block--;
            delete this.queryid;
            delete o.params['queryid'];
            o.params['anchor'] = this.anchors[this.block];
            o.params['start'] = 0;
            if (Pan.monitor.isCachedLoggingBackend()) {
                o.params['start'] = o.params['limit'] * 10 * this.block;
            }
            this.load(o);
        }
    },
    getCurrentBlock: function () {
        return this.block;
    },
    setTotalCountInCurrentBlock: function (count, pagenumber) {
        this.totalCountInCurrentBlock = count;
        if (count == 0) {
            self.hasNextPage = false;
        }
        this.fireEvent('blockChange', pagenumber || 0);
    },
    getTotalCountInCurrentBlock: function () {
        return this.totalCountInCurrentBlock;
    },
    setStartLimit: function (start, limit) {
        var o = this.lastOptions || {};
        o.params = o.params || {};
        o.params['start'] = start;
        if (Pan.monitor.isCachedLoggingBackend()) {
            o.params['start'] += o.params['limit'] * 10 * this.block;
        }
        o.params['limit'] = limit;
        if (this.block == 0 && start == 0) {
            this.completeReload();
        } else {
            o.params.isSameBlock = true;
            if (this.anchor) {
                o.params['anchor'] = this.anchor;
            }
            this.load(o);
            delete o.params.isSameBlock;
        }
    }
});
Ext.ns('Pan.base.data');
Pan.base.data.LogXmlReader = Ext.extend(Ext.data.XmlReader, {
    readRecords: function (doc) {
        var result = Pan.base.data.LogXmlReader.superclass.readRecords.call(this, doc);
        var root = doc.documentElement || doc;
        var q = Ext.DomQuery;
        result.success = q.selectValue('@status', root, null) == "success";
        result.anchor = q.selectValue('result/log/logs/@anchor', root, null);
        return result;
    }
});
Ext.ns('Pan.base.data');
Pan.base.data.XMLMemoryProxy = function (response) {
    Pan.base.data.XMLMemoryProxy.superclass.constructor.call(this);
    this.response = response;
};
Ext.extend(Pan.base.data.XMLMemoryProxy, Ext.data.DataProxy, {
    load: function (params, reader, callback, scope, arg) {
        params = params || {};
        var result;
        try {
            result = reader.read(this.response);
        } catch (e) {
            this.fireEvent("loadexception", this, arg, null, e);
            callback.call(scope, null, arg, false);
            return;
        }
        callback.call(scope, result, arg, true);
    }, update: function (params, records) {
    }
});
Ext.ns('Pan.base.data');
Pan.base.data.JsonMemoryReader = Ext.extend(Ext.data.JsonReader, {
    constructor: function (config) {
        Pan.base.data.JsonMemoryReader.superclass.constructor.apply(this, Array.prototype.slice.call(arguments, 0));
        this.json = config.json;
    }, read: function (response) {
        return this.readRecords(this.json);
    }
});
Ext.ns('Pan.base.data');
Pan.base.data.PageSizePlugin = function (cfg) {
    cfg = cfg || {};
    if (cfg.min != undefined && cfg.max && cfg.interval) {
        cfg.data = [];
        for (var i = cfg.min; i <= cfg.max; i += cfg.interval) {
            cfg.data.push([i.toString(), i]);
        }
    }
    if (!cfg.data) {
        cfg.data = [['20', 20], ['30', 30], ['40', 40], ['50', 50], ['75', 75], ['100', 100]];
    }
    if (!cfg.value) {
        cfg.value = 20;
    }
    this.itemsPerPageText = cfg.txt || _T("per page");
    var store = new Ext.data.SimpleStore({fields: ['text', 'value'], data: cfg.data});
    Pan.base.data.PageSizePlugin.superclass.constructor.call(this, {
        store: store,
        value: cfg.value,
        mode: 'local',
        displayField: 'text',
        valueField: 'value',
        editable: false,
        allowBlank: false,
        triggerAction: 'all',
        width: 50
    });
};
Ext.extend(Pan.base.data.PageSizePlugin, Ext.form.ComboBox, {
    init: function (paging) {
        paging.on('render', this.onInitView, this);
    }, onInitView: function (paging) {
        paging.add('-', this, this.itemsPerPageText);
        this.setValue(paging.pageSize);
        this.on('select', this.onPageSizeChanged, paging);
    }, onPageSizeChanged: function (combo) {
        this.pageSize = parseInt(combo.getValue(), 10);
        this.doLoad(0);
    }
});
Pan.base.widgets.LogPagingToolbar = Ext.extend(Ext.PagingToolbar, {
    toolbarMap: {},
    supportRefresh: false,
    pageSize: 20,
    cls: Pan.base.Constants.uiThemes[0],
    displayMsg: _T('Displaying logs') + ' {0} - {1}',
    emptyMsg: "",
    afterPageText: '',
    firstText: _T('First'),
    prevText: _T('Previous Page'),
    nextText: _T('Next Page'),
    lastText: _T('Next Block'),
    refreshText: _T('Refresh'),
    displayInfo: true,
    stateful: true,
    stateId: 'Device/Log Paging Toolbar',
    highlightactionsExcludedList: ["Monitor/Logs/User-ID", "Monitor/Logs/HIP Match", "Monitor/Logs/Configuration", "Monitor/Logs/System", "Monitor/Logs/Alarms", "Monitor/Logs/Authentication", "Monitor/Automated Correlation Engine/Correlated Events"],
    autoRefresh: function () {
        if (!this.store) {
            if (this.autoRefreshTask) {
                if (this.runner) {
                    this.runner.stop(this.autoRefreshTask);
                }
            }
        }
        else {
            if (!this.store.pollingInProgress) {
                this.store.completeReload();
            }
        }
    },
    onAutoRefreshChange: function (combo, record, index) {
        if (this.autoRefreshTask) {
            this.runner.stop(this.autoRefreshTask);
        }
        switch (index) {
            case 1:
                this.autoRefreshTask = {run: this.autoRefresh.createDelegate(this), interval: 10000};
                break;
            case 2:
                this.autoRefreshTask = {run: this.autoRefresh.createDelegate(this), interval: 30000};
                break;
            case 3:
                this.autoRefreshTask = {run: this.autoRefresh.createDelegate(this), interval: 60000};
                break;
        }
        if (index > 0) {
            this.runner.start(this.autoRefreshTask);
        }
    },
    onLogDirectionChange: function (combo, record, index) {
        var dir = index ? 'fwd' : 'bkwd';
        this.store.setBaseParam('dir', dir);
        this.store.block = 0;
        this.store.removeOldQueryIdAndAnchor();
        this.doLoad(0);
    },
    getPagingToolbarItems: function (config) {
        var self = this;
        var rv = [];
        if (this.supportRefresh) {
            rv.push({
                xtype: 'pan-selectbox',
                allowBlank: false,
                store: [_T('Manual Refresh'), _T('Refresh every 10 secs'), _T('Refresh every 30 secs'), _T('Refresh every minute')],
                listeners: {select: this.onAutoRefreshChange.createDelegate(this, [], true)}
            }, '-');
        }
        if (config.treePath !== "Monitor/Correlation Objects/Matches") {
            rv.push({
                itemId: 'logPagingToolbar_resolvehostnameCheckBox',
                enableToggle: true,
                xtype: 'pan-checkbox',
                fieldLabel: _T('Resolve hostname'),
                listeners: {
                    check: function (checkbox, value) {
                        self.store.resolvehostname = value;
                        if (self.rendered)
                            self.saveState();
                        Pan.acc.whois.resolveLogViewerHostnamesToggle = value;
                        if (value) {
                            Pan.acc.whois.resolveLogViewerHostnames();
                        }
                    }
                }
            });
        }
        if (_.indexOf(this.highlightactionsExcludedList, config.treePath) === -1) {
            rv.push(' ', ' ', ' ', ' ', ' ', {
                itemId: 'logPagingToolbar_highlightactionsCheckBox',
                enableToggle: true,
                xtype: 'pan-checkbox',
                fieldLabel: _T('Highlight Policy Actions'),
                listeners: {
                    check: function (checkbox, value) {
                        self.store.highlightactions = value;
                        if (self.rendered)
                            self.saveState();
                        self.store.logviewer.highlightLogViewerActions(value);
                    }
                }
            });
        }
        rv.push('->', '-', {
            xtype: 'pan-selectbox',
            allowBlank: false,
            store: [['DESC', _T('DESC')], ['ASC', _T('ASC')]],
            width: 60,
            listeners: {select: this.onLogDirectionChange.createDelegate(this, [], true)}
        });
        return rv;
    },
    getStateId: function () {
        var stateId = this.treePath + '-' + this.stateId;
        return stateId;
    },
    getState: function () {
        var o = Pan.base.widgets.LogPagingToolbar.superclass.getState.call(this) || {};
        o.resolvehostname = this.store.resolvehostname;
        o.highlightactions = this.store.highlightactions;
        return o;
    },
    applyState: function (state) {
        Pan.base.widgets.LogPagingToolbar.superclass.applyState.call(this, state);
        var item;
        if (state && state.resolvehostname !== undefined) {
            this.store.resolvehostname = state.resolvehostname;
            item = this.findByItemId('logPagingToolbar_resolvehostnameCheckBox');
            if (item) {
                item.setValue(this.store.resolvehostname);
            }
        }
        if (state && state.highlightactions !== undefined) {
            this.store.highlightactions = state.highlightactions;
            item = this.findByItemId('logPagingToolbar_highlightactionsCheckBox');
            if (item) {
                item.setValue(this.store.highlightactions);
            }
        }
    },
    constructor: function (config) {
        if (config && Ext.isDefined(config.supportRefresh)) {
            this.supportRefresh = config.supportRefresh;
        }
        if (this.supportRefresh) {
            this.autoRefreshTask = null;
            this.runner = new Ext.util.TaskRunner();
        }
        config = config || {};
        Ext.apply(config, {items: this.getPagingToolbarItems(config)});
        Pan.base.widgets.LogPagingToolbar.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        this.store.addListener('blockChange', this.redrawPaging, this);
        this.beforePageText = "";
        var id = this.getId();
        for (var i = 0; i < 10; i++) {
            this.beforePageText += "<span><em>  </em><em id='" + id + "-" + i + "'" + "></em></span>";
        }
        Pan.base.widgets.LogPagingToolbar.superclass.initComponent.apply(this, arguments);
        this.prevPage = this.prev;
        this.nextPage = this.next;
        this.nextBlock = this.last;
        this.last.setIconClass("x-tbar-page-next-block");
        this.prevPageNumber = 1;
        this.nextPageNumber = 2;
        this.prevPage.setDisabled(false);
        this.nextPage.setDisabled(false);
        this.toolbarMap[id] = this;
        this.inputItem.setVisible(false);
        if (this.refresh && !this.supportRefresh) {
            this.refresh.setVisible(false);
        }
    },
    onDestroy: function () {
        this.store.removeListener('blockChange', this.redrawPaging, this);
        delete this.toolbarMap[this.id];
        Pan.base.widgets.LogPagingToolbar.superclass.onDestroy.apply(this, arguments);
    },
    moveFirst: function () {
        this.store.completeReload();
    },
    movePrevious: function () {
        var number = this.prevPageNumber;
        if (number == -1) {
            this.movePreviousBlock();
        }
        else {
            this.redrawPaging(number % 10);
            this.store.setStartLimit(number * this.pageSize, this.pageSize);
            return false;
        }
    },
    moveNext: function () {
        var number = this.nextPageNumber;
        if (number == -1) {
            this.moveNextBlock();
        }
        else {
            this.redrawPaging(number % 10);
            this.store.setStartLimit(number * this.pageSize, this.pageSize);
            return false;
        }
    },
    moveLast: function () {
        this.moveNextBlock();
    },
    movePreviousBlock: function () {
        var currentBlock = this.store.getCurrentBlock();
        if (currentBlock > 0) {
            this.store.movePrevious();
            this.redrawPaging(-1);
        }
    },
    moveNextBlock: function () {
        this.store.moveNext();
        this.redrawPaging(-1);
    },
    onPageNumberClick: function (number, id) {
        var scope = Pan.base.widgets.LogPagingToolbar.prototype.toolbarMap[id];
        scope.redrawPaging(number % 10);
        scope.store.setStartLimit(number * scope.pageSize, scope.pageSize);
        return false;
    },
    redrawPaging: function (number) {
        if (!Ext.isDefined(number)) {
            number = 0;
        }
        var store = this.store;
        var block = store.getCurrentBlock();
        var countInBlock = store.getTotalCountInCurrentBlock();
        var firstBlockUnavailable = block == 0 || countInBlock == 0;
        this.first.setDisabled(firstBlockUnavailable);
        var nextBlockUnavailable = !store.hasNextPage || number < 0 || countInBlock == 0;
        this.nextBlock.setDisabled(nextBlockUnavailable);
        var el;
        var i = 0;
        number = number % 10;
        if (number >= 0) {
            var pageStart = block * 10 + 1;
            var totalPages = Math.ceil(countInBlock / this.pageSize);
            var pageMax = Math.min(totalPages, 10);
            if (number == 0) {
                if (firstBlockUnavailable) {
                    this.prevPage.setDisabled(true);
                }
                else {
                    this.prevPageNumber = -1;
                    this.prevPage.setDisabled(false);
                }
            }
            else {
                this.prevPage.setDisabled(false);
                this.prevPageNumber = number - 1;
            }
            if (pageMax - 1 <= number) {
                if (nextBlockUnavailable) {
                    this.nextPage.setDisabled(true);
                }
                else {
                    this.nextPageNumber = -1;
                    this.nextPage.setDisabled(false);
                }
            }
            else {
                this.nextPage.setDisabled(false);
                this.nextPageNumber = number + 1;
            }
            for (i = 0; i < pageMax; i++) {
                el = Ext.get(this.id + "-" + i);
                if (i == number) {
                    el.dom.innerHTML = "<strong><cite>" + (pageStart + i) + "</cite></strong>";
                    el.setStyle('color', 'blue');
                }
                else {
                    el.dom.innerHTML = "" + (pageStart + i);
                    el.setStyle('color', '#036DDA');
                    el.addClass('x-hyperlink');
                    el.removeAllListeners();
                    el.on('click', (function (i_copy, id_copy) {
                        return function () {
                            return Pan.base.widgets.LogPagingToolbar.prototype.onPageNumberClick(i_copy, id_copy);
                        };
                    })(i, this.id));
                }
                el.show();
            }
            var cursor = (pageStart - 1 + number) * this.pageSize;
            this.updatePagingInfo(cursor);
        }
        else {
            this.updatePagingInfo(-1);
        }
        for (; i < 10; i++) {
            el = Ext.get(this.id + "-" + i);
            el.hide();
            el.dom.innerHTML = "";
        }
    },
    updatePagingInfo: function (cursor) {
        if (this.displayItem) {
            var count = this.store.getCount();
            var msg = (cursor < 0 || count == 0) ? this.emptyMsg : String.format(this.displayMsg, cursor + 1, cursor + count);
            this.displayItem.setText(msg);
        }
    },
    onLoad: function (store, r, o) {
        if (!this.rendered) {
            this.dsLoaded = [store, r, o];
            return;
        }
        var p = this.getParams();
        this.cursor = (o.params && o.params[p.start]) ? o.params[p.start] : 0;
        var d = this.getPageData(), ap = d.activePage;
        this.afterTextItem.setText(String.format(this.afterPageText, d.pages));
        this.inputItem.setValue(ap);
        this.refresh.enable();
        this.fireEvent('change', this, d);
    }
});
(function () {
    PanEnvironment.ns('Pan.base.widgets');
    var util = Pan.base.widgets.JobStatusViewerUtil = {
        CANCELABLE_NOT_IN_QUEUE: {
            "AutoCom": true,
            "Commit": true,
            "Validate": true,
            "CommitAll": true,
            "FqdnRefresh": true,
            "HA-Sync": true,
            "EDLRefresh": true,
            "Antivirus": true,
            "WildFire": true,
            "WF-Private": true,
            "MDMApp": true,
            "Pan-URL-DB": true,
            "Content": true
        }, getJobStatus: function (job) {
            if (!job) {
                throw new Error('Job is undefined');
            }
            if (job['async-response']) {
                return getAsyncJobStatus(job);
            }
            var queued = job.queued;
            var status = job.status;
            var showProgressBar = false;
            if (queued === 'YES' && status === 'PEND') {
                status = 'Queued';
            }
            else {
                showProgressBar = true;
            }
            var jobResult = job.result;
            var jobType = job.type;
            var progress = job.progress;
            var newJobId = null;
            var details = PanJson.path(job, '$.details.line.newjob.newmsg');
            if (details) {
                newJobId = PanJson.path(job, '$.details.line.newjob.nextjob');
            }
            else {
                details = job.details;
                if (details && !Ext.isArray(details) && details['line'])
                    details = [details['line']];
            }
            var warnings = job.warnings || [];
            if (warnings && !Ext.isArray(warnings) && warnings['line'])
                warnings = [warnings['line']];
            var showCancelButton = (PanJson.path(job, '$.stoppable') === 'yes') && !(util.CANCELABLE_NOT_IN_QUEUE[jobType] && queued === 'YES');
            return {
                queued: queued,
                status: status,
                showProgressBar: showProgressBar,
                result: jobResult,
                type: jobType,
                progress: progress,
                newJobId: newJobId,
                details: details,
                warnings: warnings,
                showCancelButton: showCancelButton
            };
        }
    };

    function getAsyncJobStatus(asyncJob) {
        var response = PanJson.path(asyncJob, '$.async-response.response');
        var asyncResult = response['@status'] === 'success' ? 'OK' : 'FAIL';
        var asyncDetails = PanJson.path(response, asyncResult === 'OK' ? '$.result.msg' : '$.msg');
        if (asyncDetails.line) {
            asyncDetails = [asyncDetails.line];
        }
        var queued = asyncJob.queued;
        var status = asyncJob.status;
        var showProgressBar = false;
        if (queued === 'YES' && status === 'PEND') {
            status = 'Queued';
        }
        else {
            showProgressBar = true;
        }
        var jobType = asyncJob.type;
        var progress = asyncJob.progress;
        var newJobId = null;
        var details = PanJson.path(asyncJob, '$.details.line.newjob.newmsg');
        if (details) {
            newJobId = PanJson.path(asyncJob, '$.details.line.newjob.nextjob');
        }
        else {
            details = asyncJob.details;
            if (details && !Ext.isArray(details) && details['line'])
                details = [details['line']];
        }
        var warnings = asyncJob.warnings;
        if (warnings && !Ext.isArray(warnings) && warnings['line'])
            warnings = [warnings['line']];
        var showCancelButton = (PanJson.path(asyncJob, '$.stoppable') === 'yes') && !(util.CANCELABLE_NOT_IN_QUEUE[jobType] && queued === 'YES');
        return {
            queued: queued,
            status: status,
            showProgressBar: showProgressBar,
            result: asyncResult,
            type: jobType,
            progress: progress,
            newJobId: newJobId,
            details: asyncDetails,
            warnings: warnings,
            showCancelButton: showCancelButton
        };
    }
})();
Pan.base.widgets.JobStatusViewer = Ext.extend(Pan.base.container.Window, {
    RESULTS: {OK: _T('Successful'), FAIL: _T('Failed'), PEND: _T('Pending'), CANCELLED: _T('Cancelled')},
    STATUS: {
        FIN: _T('Completed'),
        ACT: _T('Active'),
        PEND: _T('Pending'),
        Queued: _T('Queued'),
        UploadPend: _T('Pending'),
        UploadAct: _T('Active'),
        InstallPend: _T('Pending'),
        InstallAct: _T('Active'),
        DeployFin: _T('Completed')
    },
    OPERATIONS: {
        "AutoCom": _T("Auto Commit"),
        "Content": _T("Content"),
        "Antivirus": _T("Antivirus"),
        "Downld": _T("Download"),
        "Exec": _T("Execute"),
        "Install": _T("Install"),
        "SWInstall": _T("Software Install"),
        "Commit": _T("Commit"),
        "Validate": _T("Validate"),
        "HA-Sync": _T("Synchronize HA Peer"),
        "CommitAll": _T("Commit All"),
        "CommitAndPush": _T("Commit and Push"),
        "ValidateAll": _T("Validate All"),
        "ValidateAllPartial": _T("Partial Validate All"),
        "DeployUpload": _T("Deploy and Upload"),
        "DeployInstall": _T("Deploy and Install"),
        "UploadActivate": _T('Upload and Activate'),
        "UploadInstall": _T("Upload and Install"),
        "RefreshLic": _T("Refresh License"),
        "UpdateLicDb": _T("Update License Database"),
        "LicAuthcode": _T("Authorize License"),
        "FqdnRefresh": _T("Refresh FQDN"),
        "DwnldUpldInstl": _T("Download and Install"),
        "Import": _T("Import"),
        "Export-Load": _T("Export Load"),
        "Deactivate-VM": _T("Deactivate VM"),
        "EBLFetch": _T("EBL Fetch"),
        "EBLRefresh": _T("EBL Refresh"),
        "WildFireImport": _T("WildFire Import"),
        "WildFireClusterImport": _T("WildFire Cluster Import"),
        "ResetRuleHit": _T("Reset Rule Hit Counter")
    },
    border: false,
    showShadow: false,
    pollingInterval: 1000,
    defaults: {xtype: 'pan-displayfield'},
    constructor: function (config) {
        config = config || {};
        if (Pan.base.json.path(config, '$.job.details.line.newjob.newmsg')) {
            var newJobId = Pan.base.json.path(config, '$.job.details.line.newjob.nextjob');
            if (newJobId && !isNaN(newJobId)) {
                config.jobid = newJobId;
            }
        }
        var items = [{name: 'type', itemId: 'job_type', fieldLabel: '<b>' + _T('Operation') + '</b>'}, {
            name: 'status',
            itemId: 'job_status',
            fieldLabel: '<b>' + _T('Status') + '</b>'
        }, {name: 'result', itemId: 'job_result', fieldLabel: '<b>' + _T('Result') + '</b>'}, {
            name: 'progress',
            xtype: 'progress',
            hidden: true,
            autoWidth: true,
            fieldLabel: '<b>' + _T('Progress') + '</b>'
        }, {
            name: 'details',
            itemId: 'job_details',
            xtype: 'pan-detailList',
            defaultValue: _T('This operation may take several minutes to complete'),
            fieldLabel: '<b>' + _T('Details') + '</b>'
        }, {
            name: 'warnings',
            itemId: 'job_warnings',
            xtype: 'pan-detailList',
            defaultValue: "",
            fieldLabel: '<b>' + _T('Warnings') + '</b>'
        }];
        var buttons = config.actions || [];
        buttons.push([{
            text: _T('Cancel'),
            id: 'JobStatusViewer_Cancel_Button',
            cls: 'default-btn',
            handler: this.cancel,
            scope: this
        }, {text: _T('Close'), handler: this.close, scope: this}]);
        Ext.applyIf(config, {
            itemId: 'jobStatusViewer',
            title: config.title ? config.title : _T('Job Status'),
            layout: 'form',
            layoutConfig: {trackLabels: true},
            labelWidth: 70,
            autoScroll: true,
            width: 400,
            height: 350,
            items: items,
            plain: true,
            buttons: buttons,
            shadow: false,
            bodyStyle: 'padding: 10px;',
            doHTMLEncode: false
        });
        Pan.base.widgets.JobStatusViewer.superclass.constructor.call(this, config);
    },
    pollingJob: function (jobid, targetContextValue) {
        PanDirect.run('PanDirect.pollJob', [jobid, targetContextValue, function (errorResponse) {
            console.log("Encountered a connection error: %o", errorResponse);
            setTimeout(function () {
                this.pollingJob(jobid, targetContextValue);
            }.createDelegate(this), this.pollingInterval);
        }.createDelegate(this)], function (result) {
            this.updateJobStatus(result, jobid, targetContextValue);
        }.createDelegate(this));
    },
    stopJob: function (jobid, targetContextValue) {
        PanDirect.run('PanDirect.stopJob', [jobid, targetContextValue], function (result) {
            if (result['@status'] != 'success') {
                var msg = Pan.base.json.path(result, '$.msg.*');
                Pan.Msg.hide();
                if (msg) {
                    Pan.Msg.alert(_T('Error'), msg);
                }
            }
        }.createDelegate(this));
    },
    updateJobStatus: function (result, jobid, targetContextValue) {
        var jobStatus = Pan.base.widgets.JobStatusViewerUtil.getJobStatus(PanJson.path(result, '$.result.job'));
        var progressBar = this.findByType('progress')[0];
        if (jobStatus.showProgressBar)
            progressBar.show();
        var jobType = this.findByItemId('job_type');
        if (!jobType)
            return;
        jobType.setValue(this.OPERATIONS[jobStatus.type] || jobStatus.type);
        this.findByItemId('job_status').setValue(this.STATUS[jobStatus.status] || jobStatus.status);
        this.findByItemId('job_result').setValue(this.RESULTS[jobStatus.result] || jobStatus.result);
        this.findByItemId('job_details').setValue(jobStatus.details);
        this.SetCurrentJobStatus(jobStatus.status, jobStatus.result);
        if (jobStatus.warnings.length) {
            this.findByItemId('job_warnings').setValue(jobStatus.warnings);
        }
        if (jobStatus.queued !== 'YES')
            this.updateProgress(jobStatus.progress);
        if (!this.hidden) {
            Ext.getCmp('JobStatusViewer_Cancel_Button').setVisible(jobStatus.showCancelButton);
        }
        if (['PEND', 'ACT', 'Queued'].indexOf(jobStatus.status) !== -1) {
            if (jobStatus.queued !== 'YES')
                this.updateProgress(jobStatus.progress);
            setTimeout(function () {
                this.pollingJob(jobid, targetContextValue);
            }.createDelegate(this), this.pollingInterval);
            return;
        }
        else {
            this.updateProgress(100);
        }
        if (jobStatus.newJobId) {
            this.pollingJob(jobStatus.newJobId, targetContextValue);
            return;
        }
        var fp = this.findByItemId('jobStatusViewer');
        fp.toolbars[0].items.items[0].hide();
        progressBar.hide();
        this.result = result;
        if (this.onJobComplete) {
            this.onJobComplete(this.result, this.caller, this.extraParams);
        }
        if (jobStatus.result == 'OK' && this.closeAfterSuccess) {
            this.close();
        }
        if ((jobStatus.status == 'FIN' || jobStatus.status == 'DeployFin') && this.closeAfterDone === true) {
            Pan.base.widgets.JobStatusViewer.superclass.close.call(this);
            if (this.jobCallback) {
                this.jobCallback(this.result, this.caller, this.extraParams);
            }
        }
    },
    SetCurrentJobStatus: function (status, result) {
        this.currentJobStatus = {status: status, result: result};
    },
    isJobInProgress: function () {
        var status = this.currentJobStatus ? this.currentJobStatus.status : null;
        if (status === 'ACT' || status === 'PEND' || status === 'Queued' || status === 'UploadPend' || status === 'UploadAct' || status === 'InstallPend' || status === 'InstallAct') {
            return true;
        }
        return false;
    },
    updateProgress: function (value) {
        var progressBar = this.findByType('progress');
        if (progressBar && progressBar[0] && Ext.isNumber(value / 100)) {
            var progressText = value + '%';
            progressBar[0].updateProgress(value / 100, progressText);
        }
    },
    show: function () {
        Pan.base.widgets.JobStatusViewer.superclass.show.call(this);
        this.pollingJob(this.jobid, this.targetContextValue);
    },
    cancel: function () {
        Pan.Msg.setDefaultButton(2);
        Pan.Msg.show({
            title: _T('Cancel Job'),
            msg: _T('Do you really want to cancel the ongoing job?'),
            icon: Ext.Msg.QUESTION,
            buttons: Ext.Msg.YESNO,
            scope: this,
            fn: function (response) {
                if (response === 'yes') {
                    this.stopJob(this.jobid, this.targetContextValue);
                }
            }
        });
    },
    close: function () {
        if (this.isJobInProgress()) {
            this.closeAfterDone = true;
            this.hide();
        }
        else {
            Pan.base.widgets.JobStatusViewer.superclass.close.call(this);
            if (this.jobCallback) {
                this.jobCallback(this.result, this.caller, this.extraParams);
            }
        }
        if (Pan.base.json.path(this, "$.result.result.job.type") === 'SWInstall') {
            Pan.appframework.PanAppInterface.refresh();
        }
    }
});
Pan.base.widgets.DetailList = Ext.extend(Pan.base.form.DisplayField, {
    autoHeight: true, border: false, style: 'padding-top: 0px;', setValue: function (lines) {
        var nlines = lines;
        var i = 0;
        if (Ext.isArray(lines)) {
            nlines = [];
            for (i = 0; i < lines.length; i++) {
                var msg = Pan.base.json.paths(lines[i], "$.msg.line.line").join('') || Pan.base.json.paths(lines[i], "$.msg.line").join('') || Pan.base.json.paths(lines[i], "$.msg.*").join('') || Pan.base.json.paths(lines[i], "$.msg").join('') || Pan.base.json.paths(lines[i], "$.newjob.newmsg").join('') || lines[i];
                if (msg && Ext.isString(msg)) {
                    nlines = nlines.concat(msg.split("\n", -1));
                }
            }
            for (i = 0; i < nlines.length; i++) {
                nlines[i] = Pan.base.htmlEncode(nlines[i]);
            }
        }
        else {
            nlines = Pan.base.util.stripHtmlAndEncode(nlines);
        }
        var html = Pan.base.util.array2HTMLList(nlines, "none");
        Pan.base.widgets.DetailList.superclass.setValue.call(this, html);
    }, listeners: {
        afterrender: function (cmp) {
            var _el = cmp.getEl();
            _el.parent().applyStyles('padding-top:3px;');
        }
    }
});
Ext.reg('pan-detailList', Pan.base.widgets.DetailList);
Pan.base.widgets.showJobStatus = function (config) {
    var win = new Pan.base.widgets.JobStatusViewer(config);
    win.show();
    return win;
};
Ext.namespace('Pan.base.component');
Pan.base.component.Browser = Ext.extend(Pan.base.container.Panel, {
    bodyBorder: false, initComponent: function () {
        var pagingStore = new Ext.ux.data.PagingArrayStore({
            storeId: this.storeId,
            autoDestroy: true,
            lastOptions: {params: {start: 0, limit: Pan.base.Constants.defaultGridLocalPagingSize}},
            autoLoad: false,
            remoteSort: true,
            fields: this.recordFields
        });
        var pagingToolbar = {
            xtype: 'pan-paging',
            store: pagingStore,
            pageSize: Pan.base.Constants.defaultGridLocalPagingSize,
            displayInfo: true,
            hideRefresh: true,
            cls: Pan.base.Constants.uiThemes[0]
        };
        var bbarItems = pagingToolbar;
        if (this.useToolbarExportGridAction && this.exportMenu) {
            bbarItems = [];
            bbarItems.push(this.exportMenu);
            bbarItems.push({xtype: 'tbfill'});
            bbarItems.push(pagingToolbar);
        }
        Ext.apply(this, {
            layout: 'fit',
            items: {
                xtype: 'pan-grid',
                itemId: this.itemId,
                theme: Pan.base.Constants.uiThemes[0],
                border: true,
                autoScroll: true,
                stripeRows: true,
                loadMask: true,
                showLoadMaskInitially: true,
                hasGridFilter: false,
                plugins: this.gridPlugins,
                autoExpandColumn: this.expandColumn,
                viewConfig: {scrollOffset: Pan.base.Constants.scrollOffset},
                sm: new Ext.grid.RowSelectionModel({singleSelect: true}),
                colModel: new Ext.grid.ColumnModel(this.columnModel),
                store: pagingStore,
                bbar: bbarItems
            }
        });
        Pan.base.component.Browser.superclass.initComponent.apply(this, arguments);
    }
});
Ext.reg('pan-browser', Pan.base.component.Browser);
Pan.base.component.Chart = Ext.extend(Ext.FlashComponent, {
    disableCaching: Ext.isIE || Ext.isOpera, disableCacheParam: '_dc', allData: [], initComponent: function () {
        Pan.base.component.Chart.superclass.initComponent.call(this);
        if (this.disableCaching) {
            this.url = Ext.urlAppend(this.url, String.format('{0}={1}', this.disableCacheParam, new Date().getTime()));
        }
        this.cacheData = [];
        this.cursor = 50;
    }, initChart: function (all) {
        if (this.swf.initChart)
            this.swf.initChart(all);
        this.startTime = all[0].startTime;
    }, initCache: function (ids) {
        if (!Ext.isEmpty(this.cacheData))
            return;
        this.cursor = 0;
        var count = 50;
        if (this.startTime) {
            for (var i = 0; i < count; i++) {
                var dp = {};
                dp.time = -2000 * i;
                dp.data = {};
                for (var j = 0; j < ids.length; j++) {
                    dp.data[ids[j]] = 0;
                }
                this.cacheData.unshift(dp);
            }
        }
        if (!Pan.base.isEmpty(this.cacheData) && this.swf.resetCache)
            this.swf.resetCache(this.cacheData);
    }, resetMembers: function (ids) {
        if (!Pan.base.isEmpty(this.cacheData) && this.swf.resetCache)
            this.swf.resetCache(this.cacheData);
        if (this.swf.resetMembers)
            this.swf.resetMembers(ids);
        this.ids = ids;
    }, addChartDataPoint: function (dp) {
        this.cursor++;
        this.cacheData.push(dp);
        if (!this.isInitialized)
            return false;
        if (this.cursor == 49) {
            var _dp = {};
            Ext.apply(_dp, dp);
            _dp.time += 100;
            this.cacheData.push(_dp);
            this.resetMembers(this.ids);
        } else {
            if (this.cacheData.length > 50)
                this.cacheData.remove(this.cacheData[0]);
            if (this.swf.addChartDataPoint)
                this.swf.addChartDataPoint(dp);
        }
    }
});
Ext.reg('pan-qos-chart', Pan.base.component.Chart);
Pan.base.component.PanQoSChart = Ext.extend(Pan.base.container.BoxComponent, {
    height: 220,
    highChart: undefined,
    chartType: undefined,
    animation: false,
    chartConfig: undefined,
    qosInterface: "default",
    qosDataIds: [],
    qosCHartMapping: {},
    initComponent: function () {
        Ext.apply(this, {autoEl: {tag: 'div'}, hideLabel: true});
        this.cacheData = {};
        Pan.base.component.PanQoSChart.superclass.initComponent.apply(this, arguments);
    },
    onResize: function (w, h) {
        Pan.base.component.PanQoSChart.superclass.onResize.apply(this, arguments);
        if (this.highChart) {
            this.highChart.setSize(w || this.width, h || this.height, false);
        }
    },
    onDestroy: function () {
        Highcharts.setOptions({global: {useUTC: true}});
        if (this.highChart) {
            this.highChart.destroy();
            delete this.highChart;
        }
        Pan.base.component.PanQoSChart.superclass.onDestroy.apply(this, arguments);
    },
    drawChart: function () {
        var log = PanLogging.getLogger('base:component:PanQoSChart');
        if (this.highChart) {
            this.highChart.destroy();
        }
        Highcharts.setOptions({global: {useUTC: false}});
        try {
            this.highChart = new Highcharts.Chart(this.chartConfig);
        } catch (ex) {
            log.error(ex);
        }
    },
    initChart: function (all) {
        this.chartConfig = {
            chart: {type: 'area', renderTo: this.getId()},
            title: {text: ''},
            exporting: {enabled: false},
            legend: {verticalAlign: "top"},
            tooltip: {valueDecimals: 2},
            xAxis: {type: "datetime", dateTimeLabelFormats: {second: '%H:%M:%S'}},
            yAxis: {min: 0, minRange: 0.1, title: {text: _T("Runtime Bandwidth (Mbps)")}},
            credits: {enabled: false},
            plotOptions: {series: {marker: {radius: 1}}},
            series: []
        };
        this.qosDataIds = [];
        for (var i = 0; i < all.length; i++) {
            this.qosDataIds.push(all[i].id);
            this.qosCHartMapping[all[i].id] = {id: all[i].id, name: all[i].title};
        }
        this.startTime = new Date().getTime();
    },
    initCache: function (ids) {
        this.cacheData = {};
        var count = 50;
        var curDataAr = undefined;
        if (this.startTime) {
            for (var i = 0; i < this.qosDataIds.length; i++) {
                this.cacheData[this.qosDataIds[i]] = [];
                curDataAr = this.cacheData[this.qosDataIds[i]];
                for (var j = 0; j < count; j++) {
                    var dp = [];
                    dp.push(-2000 * j + this.startTime);
                    dp.push(0);
                    curDataAr.unshift(dp);
                }
            }
        }
    },
    resetMembers: function (ids) {
        this.idsMap = {};
        for (var i = 0; i < ids.length; i++) {
            this.idsMap.i = i;
        }
        this.ids = ids;
        this.chartConfig.series = [];
        for (var j = 0; j < ids.length; j++) {
            this.qosCHartMapping[ids[j]].data = this.cacheData[ids[j]] || [];
            this.chartConfig.series.push(this.qosCHartMapping[ids[j]]);
        }
        if (this.highChart) {
            while (this.highChart.series.length > 0) {
                this.highChart.series[0].remove(false);
            }
            for (i = 0; i < this.chartConfig.series.length; i++) {
                this.highChart.addSeries(this.chartConfig.series[i], false);
            }
            this.highChart.redraw(false);
        } else {
            this.drawChart();
        }
    },
    addChartDataPoint: function (dp) {
        this.startTime = new Date().getTime();
        if (!this.highChart)
            return false;
        for (var i = 0; i < this.qosDataIds.length; i++) {
            var _dp = [this.startTime, dp.data[this.qosDataIds[i]] || 0];
            if (!this.cacheData[this.qosDataIds[i]]) {
                this.cacheData[this.qosDataIds[i]] = [];
            }
            this.cacheData[this.qosDataIds[i]].push(_dp);
            if (this.cacheData[this.qosDataIds[i]].length > 50) {
                this.cacheData[this.qosDataIds[i]].splice(0, 1);
            }
            if (this.highChart.get(this.qosDataIds[i])) {
                this.highChart.get(this.qosDataIds[i]).addPoint(_dp, false);
                if (this.highChart.get(this.qosDataIds[i]).data.length > 50) {
                    this.highChart.get(this.qosDataIds[i]).data[0].remove(false);
                }
            }
        }
        this.highChart.redraw(false);
    },
    simulateData: function () {
        var rnd1 = (Math.random() * 10) + 1;
        var rnd2 = (Math.random() * 10) + 1;
        var rnd3 = (Math.random() * 10) + 1;
        return {
            data: {
                "0.0": rnd1 - 1,
                "0.1": rnd2 + 1,
                "0.2": rnd1 + 2,
                "0.3": rnd3 - 1,
                "0.4": rnd1 + 1,
                "0.5": rnd2 + 2,
                "0.6": rnd3,
                "0.7": rnd1 + 1,
                "0.8": rnd2 + 2,
                "1.0": rnd2,
                "2.0": rnd3 + 2,
                "4.0": rnd1 + 1,
                "-2.0": rnd2 + 3,
                "-2.1": rnd1,
                "-2.2": rnd1 + 1,
                "-2.3": rnd3 + 2,
                "-2.4": rnd2,
                "-2.5": rnd3 + 1,
                "-2.6": rnd1 + 2,
                "-2.7": rnd3,
                "-2.8": rnd2
            }
        };
    }
});
Ext.reg('pan-qos-chart-new', Pan.base.component.PanQoSChart);
Pan.base.component.ComponentDataView = Ext.extend(Ext.DataView, {
    defaultType: 'textfield', initComponent: function () {
        Pan.base.component.ComponentDataView.superclass.initComponent.call(this);
        this.components = [];
    }, refresh: function () {
        Ext.destroy(this.components);
        this.components = [];
        Pan.base.component.ComponentDataView.superclass.refresh.call(this);
        this.renderItems(0, this.store.getCount() - 1);
    }, onUpdate: function (ds, record) {
        var index = ds.indexOf(record);
        if (index > -1) {
            this.destroyItems(index);
        }
        Pan.base.component.ComponentDataView.superclass.onUpdate.apply(this, arguments);
        if (index > -1) {
            this.renderItems(index, index);
        }
    }, onAdd: function (ds, records, index) {
        var count = this.all.getCount();
        Pan.base.component.ComponentDataView.superclass.onAdd.apply(this, arguments);
        if (count !== 0) {
            this.renderItems(index, index + records.length - 1);
        }
    }, onRemove: function (ds, record, index) {
        this.destroyItems(index);
        Pan.base.component.ComponentDataView.superclass.onRemove.apply(this, arguments);
    }, onDestroy: function () {
        Pan.base.component.ComponentDataView.onDestroy.call(this);
        Ext.destroy(this.components);
        this.components = [];
    }, renderItems: function (startIndex, endIndex) {
        var ns = this.all.elements;
        var args = [startIndex, 0];
        for (var i = startIndex; i <= endIndex; i++) {
            var r = args[args.length] = [];
            for (var items = this.items, j = 0, len = items.length, c; j < len; j++) {
                c = items[j].render ? c = items[j].cloneConfig() : Ext.create(items[j], this.defaultType);
                r[j] = c;
                if (c.renderTarget) {
                    c.render(Ext.DomQuery.selectNode(c.renderTarget, ns[i]));
                } else if (c.applyTarget) {
                    c.applyToMarkup(Ext.DomQuery.selectNode(c.applyTarget, ns[i]));
                } else {
                    c.render(ns[i]);
                }
                if (Ext.isFunction(c.setValue) && c.applyValue) {
                    c.setValue(this.store.getAt(i).get(c.applyValue));
                    c.on('blur', function (f) {
                        this.store.getAt(this.index).data[this.dataIndex] = f.getValue();
                    }, {store: this.store, index: i, dataIndex: c.applyValue});
                }
            }
        }
        this.components.splice.apply(this.components, args);
    }, destroyItems: function (index) {
        Ext.destroy(this.components[index]);
        this.components.splice(index, 1);
    }
});
Ext.reg('compdataview', Pan.base.component.ComponentDataView);
Pan.base.component.ComponentListView = Ext.extend(Ext.ListView, {
    defaultType: 'textfield', initComponent: function () {
        Pan.base.component.ComponentListView.superclass.initComponent.call(this);
        this.components = [];
    }, refresh: function () {
        Ext.destroy(this.components);
        this.components = [];
        Pan.base.component.ComponentListView.superclass.refresh.apply(this, arguments);
        this.renderItems(0, this.store.getCount() - 1);
    }, onUpdate: function (ds, record) {
        var index = ds.indexOf(record);
        if (index > -1) {
            this.destroyItems(index);
        }
        Pan.base.component.ComponentListView.superclass.onUpdate.apply(this, arguments);
        if (index > -1) {
            this.renderItems(index, index);
        }
    }, onAdd: function (ds, records, index) {
        var count = this.all.getCount();
        Pan.base.component.ComponentListView.superclass.onAdd.apply(this, arguments);
        if (count !== 0) {
            this.renderItems(index, index + records.length - 1);
        }
    }, onRemove: function (ds, record, index) {
        this.destroyItems(index);
        Pan.base.component.ComponentListView.superclass.onRemove.apply(this, arguments);
    }, onDestroy: function () {
        Pan.base.ComponentDataView.onDestroy.call(this);
        Ext.destroy(this.components);
        this.components = [];
    }, renderItems: function (startIndex, endIndex) {
        var ns = this.all.elements;
        var args = [startIndex, 0];
        for (var i = startIndex; i <= endIndex; i++) {
            var r = args[args.length] = [];
            for (var columns = this.columns, j = 0, len = columns.length, c; j < len; j++) {
                var component = columns[j].component;
                if (!component)
                    continue;
                c = component.render ? c = component.cloneConfig() : Ext.create(component, this.defaultType);
                r[j] = c;
                var node = ns[i].getElementsByTagName('dt')[j].firstChild;
                if (c.renderTarget) {
                    c.render(Ext.DomQuery.selectNode(c.renderTarget, node));
                } else if (c.applyTarget) {
                    c.applyToMarkup(Ext.DomQuery.selectNode(c.applyTarget, node));
                } else {
                    c.render(node);
                }
                if (c.applyValue === true) {
                    c.applyValue = columns[j].dataIndex;
                }
                if (Ext.isFunction(c.setValue) && c.applyValue) {
                    c.setValue(this.store.getAt(i).get(c.applyValue));
                    c.on('blur', function (f) {
                        this.store.getAt(this.index).data[this.dataIndex] = f.getValue();
                    }, {store: this.store, index: i, dataIndex: c.applyValue});
                }
            }
        }
        this.components.splice.apply(this.components, args);
    }, destroyItems: function (index) {
        Ext.destroy(this.components[index]);
        this.components.splice(index, 1);
    }
});
Ext.reg('complistview', Pan.base.component.ComponentListView);
Pan.base.component.Callout = Ext.extend(Pan.base.container.Window, {
    closable: false,
    closeAction: 'close',
    anchor: 'left',
    anchorOffset: 0,
    draggable: true,
    plain: true,
    resizable: true,
    border: false,
    frame: true,
    modal: true,
    targetCounter: 0,
    constructor: function (config) {
        Pan.base.component.Callout.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        Pan.base.component.Callout.superclass.initComponent.call(this);
        this.initTarget(this.target);
        this.origAnchor = this.anchor;
    },
    initTarget: function (target) {
        var t;
        if ((t = Ext.get(target))) {
            this.target = t;
        }
        if (this.anchor) {
            this.anchorTarget = this.target;
        }
    },
    onRender: function (ct, position) {
        Pan.base.component.Callout.superclass.onRender.call(this, ct, position);
        this.anchorCls = 'x-tip-anchor-' + this.getAnchorPosition();
        this.anchorEl = this.el.createChild({cls: 'x-tip-anchor ' + this.anchorCls});
    },
    afterRender: function () {
        if (this.actions) {
            for (var i = 0; i < this.actions.length; i++) {
                var action = this.actions[i];
                if (Ext.isString(action.qtip)) {
                    action.qtip = Ext.apply({}, {text: action.qtip, cls: 'x-pan-topmost'});
                }
                this.addTool(action);
            }
        }
        Pan.base.component.Callout.superclass.afterRender.call(this);
    },
    display: function (e) {
        if (this.disabled || e.within(this.target.dom, true)) {
            return;
        }
        var t = e.getTarget(this.delegate);
        if (t) {
            this.targetXY = e.getXY();
            if (this.hidden) {
                this.show();
            } else if (!this.hidden) {
                this.destroy();
                this.show();
            }
        }
    },
    getTargetXY: function () {
        if (this.anchor) {
            this.targetCounter++;
            var offsets = this.getOffsets(),
                xy = (this.anchorToTarget && !this.trackMouse) ? this.el.getAlignToXY(this.anchorTarget, this.getAnchorAlign()) : this.targetXY,
                dw = Ext.lib.Dom.getViewWidth() - 5, dh = Ext.lib.Dom.getViewHeight() - 5,
                de = document.documentElement, bd = document.body, scrollX = (de.scrollLeft || bd.scrollLeft || 0) + 5,
                scrollY = (de.scrollTop || bd.scrollTop || 0) + 5, axy = [xy[0] + offsets[0], xy[1] + offsets[1]],
                sz = this.getSize();
            this.anchorEl.removeClass(this.anchorCls);
            if (this.targetCounter < 2) {
                if (axy[0] < scrollX) {
                    if (this.anchorToTarget) {
                        this.defaultAlign = 'l-r';
                        if (this.mouseOffset) {
                            this.mouseOffset[0] *= -1;
                        }
                    }
                    this.anchor = 'left';
                    return this.getTargetXY();
                }
                if (axy[0] + sz.width > dw) {
                    if (this.anchorToTarget) {
                        this.defaultAlign = 'r-l';
                        if (this.mouseOffset) {
                            this.mouseOffset[0] *= -1;
                        }
                    }
                    this.anchor = 'right';
                    return this.getTargetXY();
                }
                if (axy[1] < scrollY) {
                    if (this.anchorToTarget) {
                        this.defaultAlign = 't-b';
                        if (this.mouseOffset) {
                            this.mouseOffset[1] *= -1;
                        }
                    }
                    this.anchor = 'top';
                    return this.getTargetXY();
                }
                if (axy[1] + sz.height > dh) {
                    if (this.anchorToTarget) {
                        this.defaultAlign = 'b-t';
                        if (this.mouseOffset) {
                            this.mouseOffset[1] *= -1;
                        }
                    }
                    this.anchor = 'bottom';
                    return this.getTargetXY();
                }
            }
            this.anchorCls = 'x-tip-anchor-' + this.getAnchorPosition();
            this.anchorEl.addClass(this.anchorCls);
            this.targetCounter = 0;
            return axy;
        } else {
            var mouseOffset = this.getMouseOffset();
            return [this.targetXY[0] + mouseOffset[0], this.targetXY[1] + mouseOffset[1]];
        }
    },
    getMouseOffset: function () {
        var offset = this.anchor ? [0, 0] : [15, 18];
        if (this.mouseOffset) {
            offset[0] += this.mouseOffset[0];
            offset[1] += this.mouseOffset[1];
        }
        return offset;
    },
    getAnchorPosition: function () {
        if (this.anchor) {
            this.tipAnchor = this.anchor.charAt(0);
        } else {
            var m = this.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
            if (!m) {
                throw'AnchorTip.defaultAlign is invalid';
            }
            this.tipAnchor = m[1].charAt(0);
        }
        switch (this.tipAnchor) {
            case't':
                return 'top';
            case'b':
                return 'bottom';
            case'r':
                return 'right';
        }
        return 'left';
    },
    getAnchorAlign: function () {
        switch (this.anchor) {
            case'top':
                return 'tl-bl';
            case'left':
                return 'tl-tr';
            case'right':
                return 'tr-tl';
            default:
                return 'bl-tl';
        }
    },
    getOffsets: function () {
        var offsets, ap = this.getAnchorPosition().charAt(0);
        if (this.anchorToTarget && !this.trackMouse) {
            switch (ap) {
                case't':
                    offsets = [0, 9];
                    break;
                case'b':
                    offsets = [0, -13];
                    break;
                case'r':
                    offsets = [-13, 0];
                    break;
                default:
                    offsets = [9, 0];
                    break;
            }
        } else {
            switch (ap) {
                case't':
                    offsets = [-15 - this.anchorOffset, 30];
                    break;
                case'b':
                    offsets = [-19 - this.anchorOffset, -13 - this.el.dom.offsetHeight];
                    break;
                case'r':
                    offsets = [-15 - this.el.dom.offsetWidth, -13 - this.anchorOffset];
                    break;
                default:
                    offsets = [25, -13 - this.anchorOffset];
                    break;
            }
        }
        var mouseOffset = this.getMouseOffset();
        offsets[0] += mouseOffset[0];
        offsets[1] += mouseOffset[1];
        return offsets;
    },
    show: function (animateTarget, cb, scope) {
        this.setPosition(-1000, 0);
        var constrainHeader = this.constrainHeader;
        this.constrainHeader = false;
        Pan.base.component.Callout.superclass.show.apply(this, arguments);
        this.constrainHeader = constrainHeader;
        this.syncAnchor(false);
    },
    syncAnchor: function (anchor) {
        var anchorPos, targetPos, offset;
        switch (this.tipAnchor.charAt(0)) {
            case't':
                anchorPos = 'b';
                targetPos = 'tl';
                offset = [20 + this.anchorOffset, 2];
                break;
            case'r':
                anchorPos = 'l';
                targetPos = 'tr';
                offset = [-2, 11 + this.anchorOffset];
                break;
            case'b':
                anchorPos = 't';
                targetPos = 'bl';
                offset = [20 + this.anchorOffset, -2];
                break;
            default:
                anchorPos = 'r';
                targetPos = 'tl';
                offset = [2, 11 + this.anchorOffset];
                break;
        }
        if (anchor)
            this.anchorEl.alignTo(this.el, anchorPos + '-' + targetPos, offset); else
            this.anchorTo(this.anchorTarget, anchorPos + '-' + targetPos);
    },
    setPagePosition: function (x, y) {
        var xy = this.getTargetXY();
        Pan.base.component.Callout.superclass.setPagePosition.call(this, xy[0], xy[1]);
        this.syncAnchor(true);
    },
    beforeDestroy: function () {
        Ext.destroy(this.anchorEl);
        delete this.anchorEl;
        delete this.target;
        Pan.base.component.Callout.superclass.beforeDestroy.call(this);
    }
});
Ext.reg('pan-callout', Pan.base.component.Callout);
Pan.base.component.TagCloud = Ext.extend(Ext.Component, {
    autoEl: 'div', cls: 'x-cloud', constructor: function (config) {
        Pan.base.component.TagCloud.superclass.constructor.call(this, config);
        if (this.store) {
            this.setStore(this.store);
        }
        this.displayField = this.displayField || 'tag';
        this.weightField = this.weightField || 'count';
        this.addEvents({'tagselec': true});
        this.nodes = [];
    }, getDataSource: function () {
        return this.store;
    }, setStore: function (store) {
        store.on('load', this.refresh, this);
        this.store = store;
        this.store.remoteSort = false;
        this.store.sort(this.displayField, 'ASC');
    }, onRender: function (ct, position) {
        Pan.base.component.TagCloud.superclass.onRender.apply(this, arguments);
        this.list = this.el.createChild({tag: 'ol', cls: 'x-cloud-list'});
    }, refresh: function () {
        this.clearNodes();
        this.getWeightDistribution();
        var records = this.store.getRange();
        for (var i = 0; i < records.length; i++) {
            var count = records[i].get(this.weightField);
            var child = this.list.createChild({
                tag: 'li',
                cls: 'x-cloud-item ' + this.getWeightClassification(count),
                html: '<a class="x-hyperlink">' + records[i].get(this.displayField) + (this.displayWeight ? ' (' + count + ')' : '') + '</a>'
            });
            child.on('click', this.onSelect, this);
        }
        this.list.fadeIn({duration: 0.5, block: true});
        this.nodes = this.list.dom.childNodes;
    }, clearNodes: function () {
        while (this.list.dom.firstChild) {
            this.list.dom.removeChild(this.list.dom.firstChild);
        }
    }, onSelect: function (e, t) {
        var item = t.parentNode;
        var index = this.indexOf(item);
        var selected = this.list.query('.x-cloud-item-selected');
        if (selected.lenght > 0) {
            Ext.get(selected[0]).removeClass('x-cloud-item-selected');
        }
        item.addClass('x-cloud-item-selected');
        this.fireEvent('tagselect', this, this.getDataSource().getAt(index), index);
        e.stopEvent();
    }, indexOf: function (node) {
        var ns = this.nodes;
        for (var i = 0; i < ns.length; i++) {
            if (ns[i] == node) {
                return i;
            }
        }
        return -1;
    }, getWeightClassification: function (weight) {
        if (weight == this.max)
            return 'largest';
        if (weight == this.min)
            return 'smallest';
        if (weight > (this.min + (this.distribution * 2)))
            return 'large';
        if (weight > (this.min + this.distribution))
            return 'medium';
        return 'small';
    }, getWeightDistribution: function () {
        var records = this.store.getRange();
        if (records.length == 0) {
            this.max = this.min = 0;
            return;
        }
        this.max = records[0].data.count;
        this.min = records[0].data.count;
        for (var i = 0; i < records.length; i++) {
            var count = records[i].get(this.weightField);
            if (count > this.max) {
                this.max = count;
            }
            if (count < this.min) {
                this.min = count;
            }
        }
        if (!this.distribution) {
            this.distribution = (this.max - this.min) / 5;
        }
    }
});
Ext.reg('pan-tagcloud', Pan.base.component.TagCloud);
Pan.base.component.Breadcrumb = Ext.extend(Ext.Toolbar, {
    homeText: _T('Home'),
    cls: 'pan-breadcrumb',
    name: 'breadcrumb',
    crumbXType: "pan-linkbutton",
    separatorText: ">",
    constructor: function (config) {
        config = Ext.apply({layout: 'column'}, config);
        Pan.base.component.Breadcrumb.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        this.addEvents('nodeclicked');
        this.defaultButtonConfig = this.defaultButtonConfig || {
            xtype: this.crumbXType,
            handler: this.onCrumbClicked,
            scope: this
        };
        this.homeButtonConfig = Ext.apply({}, this.homeButtonConfig, this.defaultButtonConfig);
        this.homeCrumbXType = this.homeButtonConfig.crumbXType;
        Pan.base.component.Breadcrumb.superclass.initComponent.apply(this, arguments);
        this.populate(this.initialCrumbs);
    },
    populate: function (crumbs) {
        this.addHomeCrumb();
        if (crumbs) {
            for (var i = 0; i < crumbs.length; i++) {
                this.addCrumb(crumbs[i]);
            }
        }
    },
    onCrumbClicked: function (crumb) {
        for (var i = this.items.length - 1; i >= 0; i--) {
            var item = this.get(i);
            if (item.itemId !== crumb.itemId) {
                this.remove(item, true);
            } else {
                break;
            }
        }
        this.doLayout(false, true);
        this.crumbHandler(crumb);
    },
    homeCrumbHandler: Ext.emptyFn,
    crumbHandler: function (crumb) {
        var currentCrumb = this.getCurrentCrumb();
        if (currentCrumb && currentCrumb.userCallback) {
            currentCrumb.userCallback.apply(currentCrumb.scope, [currentCrumb]);
        }
    },
    removeCrumb: function (crumb) {
        for (var i = this.items.length - 1; i >= 0; i--) {
            var item = this.get(i);
            if (item) {
                if (item.itemId == '$') {
                    break;
                }
                if (item.initialConfig.userScope && item.initialConfig.userScope.key && item.initialConfig.userScope.val && crumb.userScope && crumb.userScope.key && crumb.userScope.val) {
                    if (item.initialConfig.userScope.key == crumb.userScope.key && item.initialConfig.userScope.val == crumb.userScope.val) {
                        this.remove(item, true);
                        this.remove(this.get(i - 1), true);
                    }
                }
            }
        }
        this.doLayout(false, true);
    },
    removeAllCrumbs: function () {
        for (var i = this.items.length - 1; i >= 0; i--) {
            var item = this.get(i);
            if (item.itemId == '$') {
                break;
            }
            this.remove(item, true);
        }
        this.doLayout(false, true);
    },
    addHomeCrumb: function () {
        var currentCrumb = this.getCurrentCrumb();
        if (!currentCrumb) {
            var home = Ext.applyIf({
                itemId: "$",
                text: this.homeText,
                userCallback: this.homeCrumbHandler,
                userScope: this.homeCrumbScope
            }, this.homeButtonConfig);
            return this.addButton(home);
        }
    },
    addCrumb: function (crumb, relayout) {
        var currentCrumb = this.getCurrentCrumb();
        if (!currentCrumb) {
            this.addHomeCrumb();
        }
        this.addSeparator();
        if (Ext.isString(crumb)) {
            crumb = {text: crumb};
        } else {
            crumb = Ext.apply({userCallback: crumb.handler, userScope: crumb.scope}, crumb);
        }
        crumb = Ext.apply({itemId: currentCrumb.itemId + "." + crumb.text}, this.defaultButtonConfig, crumb);
        var button = this.addButton(crumb);
        if (relayout) {
            this.doLayout();
        }
        return button;
    },
    constructButton: function (item) {
        if (item.text) {
            item.text = Pan.base.htmlEncode(item.text);
        }
        return Pan.base.component.Breadcrumb.superclass.constructButton(item);
    },
    getCurrentCrumb: function () {
        var allCrumbs = this.getAllCrumbs();
        return (allCrumbs && allCrumbs.length > 0) ? allCrumbs[allCrumbs.length - 1] : undefined;
    },
    getAllCrumbs: function () {
        return this.findBy(function (c) {
            return c.isXType(this.crumbXType, false) || (this.crumbXType !== this.homeCrumbXType && c.isXType(this.homeCrumbXType, false));
        }, this);
    },
    addSeparator: function () {
        return this.add({xtype: 'tbbutton', cls: 'crumb-separator', text: this.separatorText});
    },
    internalDefaults: {}
});
Ext.reg('pan-breadcrumb', Pan.base.component.Breadcrumb);
Pan.base.component.ToolTip = Ext.extend(Ext.ToolTip, {
    onShow: function () {
        Ext.getDoc().un('mousedown', this.onDocMouseDown, this);
        Pan.base.component.ToolTip.superclass.onShow.call(this);
    }, showAt: function (xy) {
        var rv = Pan.base.component.ToolTip.superclass.showAt.apply(this, arguments);
        if (!this.anchor) {
            this.anchorEl.hide();
        }
        return rv;
    }
});
Ext.reg('pan-tooltip', Pan.base.component.ToolTip);
Pan.base.component.MultiSelectCombo = Ext.extend(Ext.ux.form.SuperBoxSelect, {
    minChars: 1,
    resizable: true,
    anchor: '100%',
    addNewDataOnBlur: true,
    valueDelimiter: "'",
    queryValuesDelimiter: "'",
    ddGroup: "",
    autoSelect: false,
    itemIconCls: "",
    tpl: '<tpl for="."><div class="x-combo-list-item"><span class="x-superboxselect-item {iconCls}">{display:htmlEncode}</span></div></tpl>',
    constructor: function (config) {
        this.queryValuesDelimiter = Pan.global.isCmsSelected() ? "|" : "'";
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        config = Ext.apply({}, config);
        Ext.applyIf(config, {triggerAction: 'all', forceSelection: true});
        if (this.readOnly || config.readOnly) {
            this.allowQueryAll = false;
            this.editable = false;
            this.renderFieldBtns = false;
        }
        Pan.base.component.MultiSelectCombo.superclass.constructor.call(this, config);
        this.on('newitem', function (combo, value) {
            if (!this.allowAddNewData) {
                return;
            }
            if (Ext.isString(value)) {
                value = value.trim();
                if (!value) {
                    return;
                }
            }
            var record = this.findRecord(this.valueField, value);
            if (record) {
                this.addRecord(record);
                return;
            }
            var newRecord = new Object();
            newRecord[this.valueField] = value;
            newRecord[this.displayField] = value;
            var rec = this.createRecord(newRecord);
            this.store.add(rec);
            this.addRecord(rec);
        }, this);
        this.on('additem', function (combo, value, record) {
            this.createDragZone(combo, value, record);
        }, this);
    },
    createDragZone: function (combo, value, record) {
        this.items.each(function (item) {
            if (item[this.valueField] == value) {
                item.dd = new Ext.dd.DragZone(item.getEl(), {
                    ddGroup: this.ddGroup, getDragData: function (e) {
                        var t = Ext.lib.Event.getTarget(e);
                        item.owner.clearCurrentFocus();
                        item.onLnkFocus();
                        item.owner.currentFocus = item;
                        return {ddel: t, dvalue: item.value, ditem: item};
                    }, onStartDrag: function () {
                        this.el.focus();
                    }
                });
            }
        }, this);
    },
    initComponent: function () {
        if (this.store && this.store.ztype) {
            var config = Ext.apply({
                autoLoad: false,
                record: this.getRecord(),
                queryValuesDelimiter: this.queryValuesDelimiter,
                __pdefaults: this.__pdefaults
            }, this.store.zconfig);
            this.store = new this.store.ztype(config);
        }
        if (this.mode === 'local' && this['enum']) {
            Ext.apply(this, {store: this['enum']});
        }
        if (this.store.fields) {
            for (var i = 0, n = this.store.fields.items.length; i < n; i++) {
                var field = this.store.fields.itemAt(i);
                if (field.uiHint) {
                    if (field.uiHint.isKeyField) {
                        this.valueField = field.name;
                    }
                    if (field.uiHint.isDisplayField) {
                        this.displayField = field.name;
                    }
                }
            }
        }
        this.store.autoSave = false;
        Pan.base.component.MultiSelectCombo.superclass.initComponent.call(this);
        if (this.mode === 'local') {
        } else {
            this.store.addListener("load", function () {
                this.store.clearFilter();
                var anyMatch = true, caseSensitive = false, exactMatch = false;
                if (this.remoteFilter && !Ext.isEmpty(this.lastQuery)) {
                    var filterFields = [{property: 'display'}];
                    this.store.doStringFilter(this.lastQuery, filterFields, anyMatch, caseSensitive, exactMatch);
                } else {
                    this.store.filter(this.displayField, this.lastQuery, anyMatch, caseSensitive, exactMatch);
                }
            }, this);
        }
        this.on({scope: this, render: this.createDropZone});
    },
    clearValueEx: function (validate, clearValue) {
        if (clearValue) {
            this.fieldValue = undefined;
            if (this.noneString) {
                this.setValue(this.noneString);
            } else {
                this.clearValue();
            }
        }
        if (validate) {
            this.validateValue();
        }
        if (this.store.isStoreLoaded) {
            this.store.isStoreLoaded = false;
            if (this.preloadStore) {
                this.store.removeAll();
                this.lastQuery = null;
            } else {
                this.store.reload();
            }
        }
    },
    setValue: function (value) {
        if (!this.rendered) {
            this.value = value;
            return;
        }
        this.removeAllItems().resetStore();
        this.remoteLookup = [];
        if (this.readOnly) {
            if (Ext.isEmpty(value)) {
                return;
            }
            if (!Ext.isArray(value)) {
                value = [value];
            }
            Ext.each(value, function (v) {
                this.addReadOnlyItem(v);
            }, this);
        } else {
            this.addValue(value);
        }
    },
    addReadOnlyItem: function (v) {
        this.addItemBox(v, v, v, "", "");
    },
    validateValue: function (val) {
        if (this.items.getCount() === 0) {
            if (this.allowBlank) {
                this.clearInvalid();
                return true;
            } else {
                this.markInvalid(this.blankText);
                return false;
            }
        } else {
            for (var i = 0, len = this.items.getCount(); i < len; i++) {
                if (this.items.get(i).getActiveError()) {
                    this.markInvalid(this.invalidText);
                    return false;
                }
            }
        }
        this.clearInvalid();
        return true;
    },
    addComboItem: function (val) {
        var rec = this.findInStore(val);
        if (rec === false) {
            if (!this.hasValue(val)) {
                this.fireNewItemEvent(val);
                return;
            }
        } else {
            this.addRecord(rec);
        }
    },
    addExactComboItem: function (val) {
        var rec = this.findExactInStore(val);
        if (rec === false) {
            if (!this.hasValue(val)) {
                this.fireNewItemEvent(val);
                return;
            }
        } else {
            this.addRecord(rec);
        }
    },
    findExactInStore: function (val) {
        var index = this.store.findExact(this.valueField, val);
        if (index > -1) {
            return this.store.getAt(index);
        }
        return false;
    },
    onBlur: function () {
        this.outerWrapEl.removeClass(this.focusClass);
        this.clearCurrentFocus();
        if (!this.addNewDataOnBlur && this.el.dom.value !== '') {
            this.applyEmptyText();
            this.autoSize();
        }
        Ext.ux.form.SuperBoxSelect.superclass.onBlur.call(this);
    },
    getValue: function () {
        var value = Pan.base.component.MultiSelectCombo.superclass.getValue.call(this);
        if (value)
            return value.split(this.valueDelimiter);
        return [];
    },
    createDropZone: function () {
        this.dropTarget = new Ext.dd.DropZone(this.outerWrapEl, {
            ddGroup: this.ddGroup,
            notifyEnter: function (dd, e, data) {
                return true;
            },
            onNodeDrop: function (n, dd, e, data) {
                return true;
            },
            notifyOver: this.notifyOver.createDelegate(this),
            notifyDrop: this.notifyDrop.createDelegate(this)
        });
    },
    notifyOver: function (dragSource, event, data) {
        var index = this.calculatePositionIndex(event);
        var prev = index - 1, next = index, len = this.items.getCount();
        for (var i = 0; i < len; i++) {
            var item = this.items.itemAt(i);
            if (i == prev || i == next) {
                item.el.addClass('x-superboxselect-item-hover');
            } else {
                item.el.removeClass('x-superboxselect-item-hover');
            }
        }
        return true;
    },
    notifyDrop: function (dragSource, event, data) {
        var positionIndex = this.calculatePositionIndex(event, data.ditem.value);
        if (positionIndex < this.items.getCount()) {
            var insertKey = this.insert(positionIndex, data.ditem);
            var nextFocus = this.items.get(insertKey);
            if (nextFocus) {
                (function () {
                    for (var i = 0; i < this.items.getCount(); i++) {
                        this.items.itemAt(i).el.removeClass('x-superboxselect-item-hover');
                    }
                    nextFocus.onLnkFocus();
                    this.currentFocus = nextFocus;
                }).defer(200, this);
            }
        }
        return true;
    },
    insert: function (position, insertSource) {
        var value = insertSource.value;
        this.deleteItem(insertSource);
        var newRecord = new Object();
        newRecord[this.valueField] = value;
        newRecord[this.displayField] = value;
        var key = this.insertItem(position, newRecord, true);
        return key;
    },
    deleteItem: function (item) {
        if (item.fireEvent('remove', item) === false) {
            return;
        }
        item.hidden.remove();
        item.hidden = null;
        item.destroy();
    },
    insertItem: function (position, newItemObject, forcedAdd) {
        var val = newItemObject[this.valueField];
        var insertKey;
        if (this.disabled) {
            return false;
        }
        if (this.preventDuplicates && this.hasValue(val)) {
            return;
        }
        var record = this.findRecord(this.valueField, val);
        if (record) {
            insertKey = this.insertRecord(position, record);
            return insertKey;
        } else if (!this.allowAddNewData) {
            return;
        }
        if (this.mode === 'remote') {
            this.remoteLookup.push(newItemObject);
            this.doQuery(val, false, false, forcedAdd);
            return;
        }
        var rec = this.createRecord(newItemObject);
        this.store.add(rec);
        insertKey = this.insertRecord(position, rec);
        return insertKey;
    },
    insertRecord: function (position, record) {
        var display = record.data[this.displayField], caption = this.getCaption(record),
            val = record.data[this.valueField], cls = this.classField ? record.data[this.classField] : '',
            style = this.styleField ? record.data[this.styleField] : '';
        if (this.removeValuesFromStore) {
            this.usedRecords.add(val, record);
            this.store.remove(record);
        }
        var insertKey = this.insertItemBox(position, val, display, caption, cls, style);
        this.fireEvent('additem', this, val, record);
        return insertKey;
    },
    autoSize: function () {
        var currentHeight = this.getHeight();
        if (this.currentHeight && this.currentHeight != currentHeight) {
            var window = this.findParentByType("pan-window");
            if (window) {
                window.setHeight(window.getHeight() + (currentHeight - this.currentHeight));
            }
        }
        this.currentHeight = currentHeight;
        return Pan.base.component.MultiSelectCombo.superclass.autoSize.apply(this, arguments);
    },
    onRender: function (ct, position) {
        Pan.base.component.MultiSelectCombo.superclass.onRender.call(this, ct, position);
        if (this.readOnly) {
            this.inputEl.dom.style.display = "none";
            this.outerWrapEl.addClass('x-superboxselect-read-only');
        }
    },
    htmlEncodeCaption: function (itemCaption) {
        var caption = itemCaption;
        if (Ext.isObject(itemCaption)) {
            caption = "<table style='border-spacing: 10px 5px'>";
            for (var key in itemCaption) {
                if (itemCaption.hasOwnProperty(key)) {
                    caption += "<tr><td>" + Pan.base.htmlEncode(key) + "</td><td>" + (Pan.base.htmlEncode(itemCaption[key]) || "") + "</td></tr>";
                }
            }
            caption += "</table>";
        } else {
            caption = Pan.base.htmlEncode(itemCaption);
        }
        return caption;
    },
    onWrapClick: function (e) {
        var rv = Pan.base.component.MultiSelectCombo.superclass.onWrapClick.apply(this, arguments);
        if (e.target.className === "x-hyperlink") {
            var display = undefined;
            var value = undefined;
            if (this.items) {
                var outerHTML = e.target.outerHTML;
                for (var i = 0; i < this.items.length; i++) {
                    var ithItem = this.items.get(i);
                    if (ithItem) {
                        if (ithItem.display === outerHTML) {
                            display = e.target.textContent || e.target.innerText || "";
                            value = ithItem.value;
                            break;
                        }
                    }
                }
            }
            var url = Pan.base.Evaluation.evaluate(this.urlTemplate, Ext.applyIf({
                value: value,
                display: display
            }, this));
            if (url) {
                window.open(url);
            }
        }
        return rv;
    },
    addItemBox: function (itemVal, itemDisplay, itemCaption, itemClass, itemStyle) {
        var val = Pan.base.htmlEncode(itemDisplay);
        if (this.urlTemplate) {
            val = '<em class="x-hyperlink">' + val + '</em>';
        }
        Pan.base.component.MultiSelectCombo.superclass.addItemBox.call(this, itemVal, val, this.htmlEncodeCaption(itemCaption), itemClass, itemStyle);
    },
    insertItemBox: function (position, itemVal, itemDisplay, itemCaption, itemClass, itemStyle) {
        var hConfig, parseStyle = function (s) {
            var ret = '';
            switch (typeof s) {
                case'function':
                    ret = s.call();
                    break;
                case'object':
                    for (var p in s) {
                        ret += p + ':' + s[p] + ';';
                    }
                    break;
                case'string':
                    ret = s + ';';
            }
            return ret;
        }, itemKey = Ext.id(null, 'sbx-item'), box = new Ext.ux.form.SuperBoxSelectItem({
            owner: this,
            disabled: this.disabled,
            cls: this.extraItemCls + ' ' + itemClass,
            style: parseStyle(this.extraItemStyle) + ' ' + itemStyle,
            caption: this.htmlEncodeCaption(itemCaption),
            display: itemDisplay,
            value: itemVal,
            key: itemKey,
            listeners: {
                'remove': function (item) {
                    if (this.fireEvent('beforeremoveitem', this, item.value) === false) {
                        return false;
                    }
                    this.items.removeKey(item.key);
                    if (this.removeValuesFromStore) {
                        if (this.usedRecords.containsKey(item.value)) {
                            this.store.add(this.usedRecords.get(item.value));
                            this.usedRecords.removeKey(item.value);
                            this.sortStore();
                            if (this.view) {
                                this.view.render();
                            }
                        }
                    }
                    if (!this.preventMultipleRemoveEvents) {
                        this.fireEvent.defer(250, this, ['removeitem', this, item.value, this.findInStore(item.value)]);
                    }
                }, destroy: function () {
                    this.collapse();
                    this.autoSize().manageClearBtn().validateValue();
                }, scope: this
            }
        });
        box.render(this.wrapEl, position);
        hConfig = {tag: 'input', type: 'hidden', value: itemVal, name: (this.hiddenName || this.name)};
        if (this.disabled) {
            Ext.apply(hConfig, {disabled: 'disabled'});
        }
        box.hidden = this.el.insertSibling(hConfig, 'before');
        this.items.insert(position, itemKey, box);
        this.applyEmptyText().autoSize().manageClearBtn().validateValue();
        return itemKey;
    },
    calculatePositionIndex: function (e, value) {
        var positionIndex = 0, items = this.items.items, count = items.length, outerWrapXY = this.outerWrapEl.getXY(),
            xTotal = outerWrapXY[0], yTotal = outerWrapXY[1], eXY = e.getXY(), xHover = eXY[0], yHover = eXY[1];
        var tIndex = -1;
        for (var index = 0; index < count; index++) {
            var item = items[index], el = item.getEl(), width = el.getWidth(), height = el.getHeight(), midpoint,
                y = el.getXY()[1];
            if (item.value === value) {
                tIndex = index;
            }
            if (yHover - y > 0 && yHover - y <= height) {
                midpoint = xTotal + width / 2;
                xTotal += width;
                if (xHover < midpoint) {
                    positionIndex = index;
                    break;
                }
            }
            positionIndex = index + 1;
        }
        if (tIndex != -1) {
            positionIndex = positionIndex - 1;
        }
        return positionIndex;
    },
    onKeyDownHandler: function (e, t) {
        if (this.editable === false) {
            return;
        }
        var toDestroy, nextFocus, idx;
        if (e.getKey() === e.ESC) {
            if (!this.isExpanded()) {
                if (this.el.dom.value != '' && (this.clearOnEscape || this.clearLastQueryOnEscape)) {
                    if (this.clearOnEscape) {
                        this.el.dom.value = '';
                    }
                    if (this.clearLastQueryOnEscape) {
                        this.lastQuery = '';
                    }
                    e.stopEvent();
                }
            }
        }
        if ((e.getKey() === e.DELETE || e.getKey() === e.SPACE) && this.currentFocus) {
            e.stopEvent();
            toDestroy = this.currentFocus;
            this.on('expand', function () {
                this.collapse();
            }, this, {single: true});
            idx = this.items.indexOfKey(this.currentFocus.key);
            this.clearCurrentFocus();
            if (idx < (this.items.getCount() - 1)) {
                nextFocus = this.items.itemAt(idx + 1);
            }
            toDestroy.preDestroy(true);
            if (nextFocus) {
                (function () {
                    nextFocus.onLnkFocus();
                    this.currentFocus = nextFocus;
                }).defer(200, this);
            }
            return true;
        }
        var val = this.el.dom.value, it;
        if (this.itemDelimiterKey === e.getKey() || e.getKey() === e.TAB) {
            if (e.getKey() === e.TAB && val == '') {
                this.clearCurrentFocus();
                return;
            }
            e.stopEvent();
            if (val !== "") {
                if (!this.isExpanded()) {
                    this.addExactComboItem(val);
                } else {
                    var index = this.view.getSelectedIndexes()[0], s = this.store, r = s.getAt(index);
                    if (r) {
                        this.onSelect(r, index);
                    } else {
                        this.collapse();
                        this.addExactComboItem(val);
                    }
                    if (this.unsetDelayCheck) {
                        this.delayedCheck = true;
                        this.unsetDelayCheck.defer(10, this);
                    }
                }
            } else {
                if (!this.isExpanded()) {
                    return;
                }
                this.onViewClick();
                if (this.unsetDelayCheck) {
                    this.delayedCheck = true;
                    this.unsetDelayCheck.defer(10, this);
                }
            }
            return true;
        }
        if (val !== '') {
            this.autoSize();
            return;
        }
        if (e.getKey() === e.HOME) {
            e.stopEvent();
            if (this.items.getCount() > 0) {
                this.collapse();
                it = this.items.get(0);
                it.el.focus();
            }
            return true;
        }
        if (e.getKey() === e.BACKSPACE) {
            e.stopEvent();
            if (this.currentFocus) {
                toDestroy = this.currentFocus;
                this.on('expand', function () {
                    this.collapse();
                }, this, {single: true});
                idx = this.items.indexOfKey(toDestroy.key);
                this.clearCurrentFocus();
                if (idx < (this.items.getCount() - 1)) {
                    nextFocus = this.items.itemAt(idx + 1);
                }
                toDestroy.preDestroy(true);
                if (nextFocus) {
                    (function () {
                        nextFocus.onLnkFocus();
                        this.currentFocus = nextFocus;
                    }).defer(200, this);
                }
                return;
            } else {
                it = this.items.get(this.items.getCount() - 1);
                if (it) {
                    if (this.backspaceDeletesLastItem) {
                        this.on('expand', function () {
                            this.collapse();
                        }, this, {single: true});
                        it.preDestroy(true);
                    } else {
                        if (this.navigateItemsWithTab) {
                            it.onElClick();
                        } else {
                            this.on('expand', function () {
                                this.collapse();
                                this.currentFocus = it;
                                this.currentFocus.onLnkFocus.defer(20, this.currentFocus);
                            }, this, {single: true});
                        }
                    }
                }
                return true;
            }
        }
        if (!e.isNavKeyPress()) {
            this.multiSelectMode = false;
            this.clearCurrentFocus();
            return;
        }
        if (e.getKey() === e.LEFT || (e.getKey() === e.UP && !this.isExpanded())) {
            e.stopEvent();
            this.collapse();
            it = this.items.get(this.items.getCount() - 1);
            if (this.navigateItemsWithTab) {
                if (it) {
                    it.focus();
                }
            } else {
                if (this.currentFocus) {
                    idx = this.items.indexOfKey(this.currentFocus.key);
                    this.clearCurrentFocus();
                    if (idx !== 0) {
                        this.currentFocus = this.items.itemAt(idx - 1);
                        this.currentFocus.onLnkFocus();
                    }
                } else {
                    this.currentFocus = it;
                    if (it) {
                        it.onLnkFocus();
                    }
                }
            }
            return true;
        }
        if (e.getKey() === e.DOWN) {
            if (this.currentFocus) {
                this.collapse();
                e.stopEvent();
                idx = this.items.indexOfKey(this.currentFocus.key);
                if (idx == (this.items.getCount() - 1)) {
                    this.clearCurrentFocus.defer(10, this);
                } else {
                    this.clearCurrentFocus();
                    this.currentFocus = this.items.itemAt(idx + 1);
                    if (this.currentFocus) {
                        this.currentFocus.onLnkFocus();
                    }
                }
                return true;
            }
        }
        if (e.getKey() === e.RIGHT) {
            this.collapse();
            it = this.items.itemAt(0);
            if (this.navigateItemsWithTab) {
                if (it) {
                    it.focus();
                }
            } else {
                if (this.currentFocus) {
                    idx = this.items.indexOfKey(this.currentFocus.key);
                    this.clearCurrentFocus();
                    if (idx < (this.items.getCount() - 1)) {
                        this.currentFocus = this.items.itemAt(idx + 1);
                        if (this.currentFocus) {
                            this.currentFocus.onLnkFocus();
                        }
                    }
                } else {
                    this.currentFocus = it;
                    if (it) {
                        it.onLnkFocus();
                    }
                }
            }
        }
    }
});
Ext.reg('multiselect-combo', Pan.base.component.MultiSelectCombo);
Ext.override(Ext.ux.form.SuperBoxSelectItem, {
    onElClick: function (e) {
        var o = this.owner;
        o.clearCurrentFocus().collapse();
        if (o.navigateItemsWithTab) {
            this.focus();
            (function () {
                this.onLnkFocus();
                o.currentFocus = this;
            }).defer(10, this);
        } else {
            o.el.dom.focus();
            var that = this;
            (function () {
                this.onLnkFocus();
                o.currentFocus = this;
            }).defer(10, this);
        }
    }, setupKeyMap: function () {
        this.keyMap = new Ext.KeyMap(this.lnk, [{
            key: [Ext.EventObject.BACKSPACE, Ext.EventObject.DELETE, Ext.EventObject.SPACE],
            fn: this.preDestroy,
            scope: this
        }, {
            key: [Ext.EventObject.RIGHT, Ext.EventObject.DOWN], fn: function () {
                this.moveFocus('right');
            }, scope: this
        }, {
            key: [Ext.EventObject.LEFT, Ext.EventObject.UP], fn: function () {
                this.moveFocus('left');
            }, scope: this
        }, {
            key: [Ext.EventObject.HOME], fn: function () {
                var l = this.owner.items.get(0).el.focus();
                if (l) {
                    l.el.focus();
                }
            }, scope: this
        }, {
            key: [Ext.EventObject.END], fn: function () {
                this.owner.el.focus();
            }, scope: this
        }, {
            key: Ext.EventObject.ENTER, fn: function () {
            }
        }, {
            key: Ext.EventObject.TAB, scope: this, fn: function () {
                var owner = this.owner;
                if (owner.navigateItemsWithTab) {
                    var it = owner.items.itemAt(0);
                    if (owner.currentFocus) {
                        var idx = owner.items.indexOfKey(owner.currentFocus.key);
                        owner.clearCurrentFocus();
                        if (idx < (owner.items.getCount() - 1)) {
                            owner.currentFocus = owner.items.itemAt(idx + 1);
                            if (owner.currentFocus) {
                                owner.currentFocus.onLnkFocus();
                            }
                        } else {
                            owner.el.focus();
                        }
                    } else {
                        owner.currentFocus = it;
                        if (it) {
                            it.onLnkFocus();
                        }
                    }
                }
            }
        }]);
        this.keyMap.stopEvent = true;
    }
});
Ext.ns("Pan.base.component");
Pan.base.component.GroupEditor = Ext.extend(Pan.base.autorender.GridRecordField, {
    onAddClick: function () {
        var sm = this.findByItemId("src-tree").getSelectionModel();
        var n = sm.getSelectedNode();
        if (!n || !n.isLeaf() || !n.attributes.addable) {
            return;
        }
        var list = this.findByItemId('groupIncludeList');
        if (list.listView.store.find("value", n.text) >= 0) {
            return;
        }
        if (Ext.isNumber(this.maxCount) && list.listView.store.getCount() === this.maxCount) {
            var msg = _T("Only {maxCount} groups can be selected", {maxCount: this.maxCount});
            Pan.Msg.alert(_T('Error'), msg);
            return;
        }
        var selData = new Object();
        selData.dn = [];
        var rObj = new Object();
        rObj = {"value": n.text};
        selData.dn.push(rObj);
        list.listView.store.loadData(selData, true);
        list.listView.store.sort([{field: 'value'}]);
        this.ownerCt.ownerCt.browseNotifier.scope.component.setValue(this.getValue());
    }, onRemoveClick: function () {
        var list = this.findByItemId('groupIncludeList');
        var selRecords = list.listView.getSelectedRecords();
        list.listView.store.remove(selRecords);
        this.ownerCt.ownerCt.browseNotifier.scope.component.setValue(this.getValue());
    }, updateTree: function (response, node) {
        var nodeMap = {};
        if (!response.completions) {
            return;
        }
        var gmtree = this.findByItemId('src-tree');
        var hasFilter = gmtree.topToolbar.findByType("textfield")[0].getValue();
        var dataEntries = response.completions;
        if (!node) {
            gmtree.getRootNode().removeAll(true);
        }
        if (!dataEntries) return;
        if (dataEntries.length > Pan.base.Constants.maxTreeNodeChildrenCount) {
            dataEntries = dataEntries.slice(0, Pan.base.Constants.maxTreeNodeChildrenCount);
            dataEntries.push({"@value": '(' + _T('Please filter for more entries') + ')', iconCls: ' '});
        }
        if (dataEntries.length === 0) {
            dataEntries.push({"@value": '(' + _T('No data to display') + ')', iconCls: ' '});
        }
        Ext.each(dataEntries, function (entry) {
            var nodeName = entry["@value"];
            if (!nodeMap[nodeName]) {
                nodeMap[nodeName] = nodeName;
                var parentNode;
                var newNode;
                parentNode = gmtree.getRootNode();
                if (!parentNode) {
                    return true;
                }
                if (entry['@type'] == 'user-group') {
                    newNode = new Ext.tree.AsyncTreeNode({
                        text: nodeName,
                        leaf: true,
                        addable: true,
                        iconCls: entry["iconCls"] || 'icon-user-group'
                    });
                } else {
                    newNode = new Ext.tree.AsyncTreeNode({
                        text: nodeName,
                        leaf: true,
                        addable: false,
                        iconCls: entry["iconCls"] || ' '
                    });
                }
                parentNode.appendChild(newNode);
            }
        }, this);
    }, getValue: function () {
        var result = [];
        var listStore = this.findByItemId('groupIncludeList').listView.getStore();
        if (listStore.getCount() > 0) {
            for (var i = 0; i < listStore.getCount(); i++) {
                result.push(listStore.getAt(i).get('value'));
            }
        }
        return result;
    }, initComponent: function () {
        this.Store = new Ext.data.JsonStore({
            autoDestroy: true,
            root: 'dn',
            fields: [{name: 'value'}],
            sortInfo: {field: 'value', direction: 'ASC'}
        });
        this.Store.on('load', this.updateDisplayField, this);
        var adjHeight = (Pan.global.isCms() || !Pan.global.isMultiVsys() || !(Pan.global.getLocVal() === "" || Pan.global.getLocVal() === "shared")) ? 0 : 80;
        Ext.apply(this, {
            items: [{
                xtype: 'pan-container',
                layout: 'hbox',
                style: {"padding-top": 5, "padding-bottom": 5},
                layoutConfig: {align: 'stretch'},
                height: 281 + adjHeight,
                items: [{
                    autoScroll: true,
                    flex: 1,
                    xtype: 'pan-treepanel',
                    root: {nodeType: 'async', text: _T('Root')},
                    title: _T("Available Groups"),
                    itemId: 'src-tree',
                    anchor: '100%',
                    hideLabel: true,
                    rootVisible: false,
                    listeners: {'dblclick': this.onAddClick, scope: this},
                    filterConfig: {
                        filterHandler: function (filterString) {
                            if (this.el) {
                                this.mask = new Pan.base.widgets.LoadMask(this.el, {msg: _T('Searching...')});
                                this.mask.show();
                            }
                            PanDirect.run(this.ownerCt.ownerCt.api.read, [{
                                vsysName: Pan.global.getLoc().val,
                                query: filterString
                            }], function (result) {
                                if (this.mask) {
                                    this.mask.hide();
                                    this.mask.destroy();
                                }
                                if (result['@status'] == 'success') {
                                    this.ownerCt.ownerCt.updateTree(result);
                                } else {
                                    var msg = Pan.base.extractJsonMsg(result);
                                    if (msg) {
                                        Pan.base.msg.alert(msg);
                                    }
                                }
                            }.createDelegate(this));
                        }
                    },
                    loader: new Pan.base.tree.TreeLoader({
                        directFn: PanDirect.runCallback(this.api.read), listeners: {
                            scope: this, beforeload: function (loader, node) {
                                if (this.el) {
                                    this.mask = new Pan.base.widgets.LoadMask(this.el, {msg: _T('Searching...')});
                                    this.mask.show();
                                }
                                var filterValue = this.findByItemId('src-tree').topToolbar.findByType("textfield")[0].getValue();
                                loader.baseParams.vsysName = Pan.global.getLoc().val;
                                loader.baseParams.query = filterValue;
                            }, load: function (loader, node, response) {
                                this.treeLoaded = true;
                                if (this.mask) {
                                    this.mask.hide();
                                    this.mask.destroy();
                                }
                                if (Ext.isEmpty(response.responseText)) {
                                    return;
                                }
                                if (Pan.base.json.path(response.responseText, '$.@status') == 'success') {
                                    this.updateTree(response.responseText, node);
                                } else {
                                    var msg = Pan.base.extractJsonMsg(response.responseText);
                                    if (msg) {
                                        Pan.base.msg.alert(msg);
                                    }
                                }
                            }
                        }
                    })
                }, {
                    xtype: 'pan-container',
                    width: 24,
                    layout: 'vbox',
                    layoutConfig: {align: 'middle', pack: 'center'},
                    items: [{
                        xtype: 'pan-container',
                        layout: 'form',
                        layoutConfig: {columns: 1},
                        border: false,
                        defaults: {xtype: 'pan-button', cls: 'plain-btn'},
                        items: [{iconCls: 'icon-add', handler: this.onAddClick, scope: this}, {
                            iconCls: 'icon-delete',
                            handler: this.onRemoveClick,
                            scope: this
                        }]
                    }]
                }, {
                    xtype: 'pan-list',
                    itemId: 'groupIncludeList',
                    multiSelect: true,
                    flex: 1,
                    hideHeaders: true,
                    listeners: {'dblclick': this.onRemoveClick, scope: this},
                    cls: 'x-list-item-with-icon',
                    columns: [{tpl: '<img src ="/images/user_group.gif" ext:qtip="{value}"/>' + ' ' + "{value}"}],
                    title: _T("Included Groups"),
                    store: this.Store
                }]
            }]
        });
        Pan.base.component.GroupEditor.superclass.initComponent.apply(this, arguments);
    }, updateDisplayField: function (store, records) {
        Ext.each(records, function (record) {
        }, this);
    }, afterRender: function () {
        var listView = this.findByItemId('groupIncludeList').listView;
        var selData = new Object();
        var selected = this.ownerCt.ownerCt.browseNotifier.scope.component.getValue();
        selData.dn = [];
        selData.dn = selected.map(function (item) {
            return {"value": item};
        });
        listView.store.loadData(selData, true);
        listView.store.sort([{field: 'value'}]);
        Pan.base.component.GroupEditor.superclass.afterRender.apply(this, arguments);
    }
});
Ext.reg('pan-group-editor', Pan.base.component.GroupEditor);
Pan.base.component.ItemSelector = Ext.extend(Pan.base.autorender.GridRecordField, {
    height: 150, displayField: 'display', valueField: 'value', theme: 'lightgrey', initComponent: function () {
        if (this.store && this.store.ztype) {
            var config = Ext.apply({
                autoLoad: true,
                autoSave: false,
                record: this.getRecord(),
                __pdefaults: this.__pdefaults
            }, this.store.zconfig);
            this.store = new this.store.ztype(config);
            this.store.addListener('load', function () {
                this.storeIsLoaded = true;
                this.populate();
            }, this);
        }
        this.completionStore = this.store;
        this.store = new Ext.data.ArrayStore({fields: this.completionStore.fields.items});
        Ext.apply(this, {
            layout: 'hbox',
            cls: "item-selector",
            layoutConfig: {align: 'stretch'},
            items: [{
                flex: 1,
                xtype: "listview",
                cls: this.theme,
                multiSelect: true,
                store: this.completionStore,
                columns: [{header: this.availableHeader || _T("Available"), dataIndex: this.displayField}],
                itemId: "availableList",
                associationEvent: 'selectionchange',
                listeners: {"dblclick": this.onAddClick, scope: this}
            }, {
                xtype: 'pan-container',
                width: 120,
                layout: 'vbox',
                layoutConfig: {
                    align: 'stretch',
                    pack: 'center',
                    defaultMargins: {left: 10, top: 10, right: 6, bottom: 10}
                },
                items: [{
                    xtype: 'pan-button',
                    text: _T('Add') + " >",
                    disabled: true,
                    handler: this.onAddClick,
                    scope: this,
                    plugins: [{ptype: "association"}],
                    avail: {
                        match: {
                            evaluate: '&&',
                            operands: [{
                                evaluate: 'fieldEvt',
                                operands: [{event: 'selectionchange', field: 'availableList'}]
                            }, {
                                evaluate: '>',
                                operands: [{
                                    evaluate: 'fieldFn',
                                    operands: [{fn: 'getSelectionCount', field: 'availableList'}]
                                }, 0]
                            }]
                        }
                    }
                }, {
                    xtype: 'pan-button',
                    text: "< " + _T('Remove'),
                    disabled: true,
                    handler: this.onRemoveClick,
                    scope: this,
                    plugins: [{ptype: "association"}],
                    avail: {
                        match: {
                            evaluate: '&&',
                            operands: [{
                                evaluate: 'fieldEvt',
                                operands: [{event: 'selectionchange', field: 'selectedList'}]
                            }, {
                                evaluate: '>',
                                operands: [{
                                    evaluate: 'fieldFn',
                                    operands: [{fn: 'getSelectionCount', field: 'selectedList'}]
                                }, 0]
                            }]
                        }
                    }
                }]
            }, {
                flex: 1,
                xtype: "listview",
                cls: this.theme,
                multiSelect: true,
                store: this.store,
                columns: [{header: this.selectedHeader || _T("Selected"), dataIndex: this.displayField}],
                itemId: "selectedList",
                associationEvent: 'selectionchange',
                listeners: {"dblclick": this.onRemoveClick, scope: this}
            }]
        });
        Pan.base.component.ItemSelector.superclass.initComponent.apply(this, arguments);
    }, onDestroy: function () {
        this.store.removeListener('load', this.populate, this);
        Pan.base.component.ItemSelector.superclass.onDestroy.apply(this, arguments);
    }, onAddClick: function () {
        var availableList = this.findByItemId("availableList");
        var selectedList = this.findByItemId("selectedList");
        var records = availableList.getSelectedRecords();
        if (records && records.length > 0) {
            availableList.store.remove(records);
            selectedList.store.add(records);
        }
    }, onRemoveClick: function () {
        var availableList = this.findByItemId("availableList");
        var selectedList = this.findByItemId("selectedList");
        var records = selectedList.getSelectedRecords();
        if (records && records.length > 0) {
            selectedList.store.remove(records);
            availableList.store.add(records);
        }
    }, getValue: function () {
        var rv = [];
        this.store.each(function (r) {
            rv.push(r.get(this.valueField));
        }, this);
        return rv;
    }, setValue: function (value) {
        this.fieldValue = value;
        this.populate();
    }, populate: function () {
        if (!this.completionStore.isStoreLoaded && !this.storeIsLoaded) {
            return;
        }
        Pan.base.component.ItemSelector.superclass.setValue.apply(this, arguments);
        var records = Array.prototype.slice.call(this.store.data.items);
        if (records && records.length > 0) {
            this.store.remove(records);
            this.completionStore.add(records);
        }
        if (Ext.isArray(this.fieldValue) && this.fieldValue.length > 0) {
            var foundItems = [];
            for (var i = 0; i < this.fieldValue.length; i++) {
                var index = this.completionStore.find(this.valueField, this.fieldValue[i]);
                if (index >= 0) {
                    foundItems.push(this.completionStore.getAt(index));
                }
            }
            if (foundItems && foundItems.length > 0) {
                this.completionStore.remove(foundItems);
                this.store.add(foundItems);
            }
        }
    }
});
Ext.reg('pan-itemselector', Pan.base.component.ItemSelector);
Ext.ns('Pan.base.tree');
Pan.base.tree.TreeLoader = Ext.extend(Ext.tree.TreeLoader, {
    paramsAsHash: true, constructor: function (config) {
        Pan.base.tree.TreeLoader.superclass.constructor.apply(this, [config]);
    }
});
Ext.ns('Pan.base.tree.TreeNode');
Ext.apply(Ext.tree.TreeNode.prototype, {
    getMenuPath: function () {
        var path = [];
        var node = this;
        while (node && node.text != 'root') {
            path.push(node.text);
            node = node.parentNode;
        }
        path.reverse();
        return path.join('/');
    }
});
Pan.base.tree.TreeNode = Ext.extend(Ext.tree.TreeNode, {
    constructor: function (config) {
        config.expanded = true;
        Pan.base.tree.TreeNode.superclass.constructor.apply(this, [config]);
        this.buildTree(config, this);
    }, buildTree: function (config, node) {
        if (!config) return null;
        var c = config.children;
        config.expanded = true;
        var child;
        if (!node) {
            node = new Ext.tree.TreeNode(config);
        }
        if (node && c && c.length) {
            for (var i = 0; i < c.length; i++) {
                child = this.buildTree(c[i]);
                if (child) node.appendChild(child);
            }
        }
        return node;
    }
});
Pan.base.tree.processDynamicTreeNodes = function (treeNode) {
    if (treeNode) {
        Ext.each(treeNode.children || treeNode.childNodes, function (dynamicTreeNode) {
            var insertAfterPath = dynamicTreeNode.insertAfter || (dynamicTreeNode.attributes && dynamicTreeNode.attributes.insertAfter);
            if (insertAfterPath) {
                var insertAsChild = false;
                var paths = insertAfterPath.split("/");
                if (paths && paths.length) {
                    var tab = paths.shift().toLowerCase();
                    if (tab && tab !== "dynamic") {
                        var parent = Pan.base.admin.treeNodesMap[tab];
                        var grandParent = null;
                        while (parent && paths.length) {
                            var path = paths.shift();
                            if (path === "") {
                                insertAsChild = true;
                                break;
                            } else {
                                grandParent = parent;
                                parent = _.find(parent.children || parent.childNodes, function (childNode) {
                                    return childNode.text === path || childNode.id === path || (childNode.attributes && (childNode.attributes.text === path || childNode.attributes.id === path));
                                });
                            }
                        }
                        if (parent && paths && paths.length === 0) {
                            if (parent instanceof Ext.tree.TreeNode) {
                                if (insertAsChild) {
                                    parent.appendChild(node);
                                } else {
                                    if (parent.parentNode) {
                                        if (parent.nextSibling) {
                                            parent.parentNode.insertBefore(node, parent.nextSibling);
                                        } else {
                                            parent.parentNode.appendChild(node);
                                        }
                                    }
                                }
                            } else {
                                if (grandParent) {
                                    if (grandParent.children) {
                                        if (insertAsChild) {
                                            grandParent.children.push(dynamicTreeNode);
                                        } else {
                                            var index = grandParent.children.indexOf(parent);
                                            if (index === -1) {
                                            } else if (index == grandParent.children.length - 1) {
                                                grandParent.children.push(dynamicTreeNode);
                                            } else {
                                                grandParent.children.splice(index + 1, 0, dynamicTreeNode);
                                            }
                                        }
                                    }
                                } else {
                                    parent.children.push(dynamicTreeNode);
                                }
                            }
                        }
                    }
                }
            }
        });
    }
};
Ext.ns('Pan.base.tree');
Pan.base.tree.TreeFilter = Ext.extend(Ext.tree.TreeFilter, {
    filter: function (value, attr, startNode) {
        var animate = this.tree.animate;
        this.tree.animate = false;
        this.tree.expandAll();
        this.tree.animate = animate;
        this.filterAttr = attr;
        this.filterValue = value;
        Pan.base.tree.TreeFilter.superclass.filter.apply(this, arguments);
    }, filterBy: function (fn, scope, startNode) {
        scope = this;
        fn = function (n) {
            return n.attributes[scope.filterAttr].toLowerCase().indexOf(scope.filterValue.toLowerCase()) >= 0;
        };
        startNode = startNode || this.tree.root;
        if (this.autoClear) {
            this.clear();
        }
        var af = this.filtered, rv = this.reverse;
        var f = function (n) {
            if (n === startNode) {
                return true;
            }
            if (af[n.id]) {
                return false;
            }
            var m = fn.call(scope || n, n);
            if (!m || rv) {
                af[n.id] = n;
                n.ui.hide();
                return true;
            } else {
                if (af.hasOwnProperty(n.id))
                    delete af[n.id];
                n.ui.show();
                var p = n.parentNode;
                while (p && p !== this.root) {
                    p.ui.show();
                    if (af.hasOwnProperty(p.id))
                        delete af[p.id];
                    p = p.parentNode;
                }
                return true;
            }
        };
        startNode.cascade(f);
        Ext.each(startNode.childNodes, function (item) {
            item.ui.updateCheck(true);
        });
        for (var id in af) {
            if (typeof id != "function") {
                var n = af[id];
                var immediateParentNode = n.parentNode;
                var p = n.parentNode;
                var anyParentNotFitlered = false;
                while (p && p !== scope.tree.root) {
                    if (!af[p.id]) {
                        anyParentNotFitlered = true;
                        break;
                    }
                    p = p.parentNode;
                }
                if (n && immediateParentNode && anyParentNotFitlered) {
                    var m = fn.call(scope || p, p);
                    if (m) {
                        n.ui.show();
                        p.collapse();
                    }
                }
            }
        }
    }
});
Ext.reg('pan-treefilter', Pan.base.tree.TreeFilter);
Ext.ns('Pan.base.tree');
Pan.base.tree.TreePanel = Ext.extend(Ext.tree.TreePanel, {
    useArrows: Pan.base.Constants.treeRendererUseArrows,
    directFn: undefined,
    nodeNameAttribute: undefined,
    childNodeNameAttribute: undefined,
    nodeChildrenAttribute: 'children',
    expandAllNodes: false,
    hasTreeFilter: true,
    singleSelect: true,
    filterConfig: {
        localFilter: true, filterHandler: function (filterString) {
            var treeFilter = new Pan.base.tree.TreeFilter(this, {remove: true});
            treeFilter.filter(filterString, 'text', this.root);
        }, autoWidthOffset: 75, width: 230
    },
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.tree.TreePanel.superclass.constructor.apply(this, [config]);
    },
    initComponent: function () {
        var loader;
        if (this.directFn) {
            loader = new Pan.base.tree.TreeLoader({
                directFn: this.directFn,
                listeners: {scope: this, beforeload: this.onBeforeLoad, load: this.onLoad}
            });
        }
        Ext.applyIf(this, {loader: loader});
        if (Ext.isObject(this.loader)) {
            Ext.applyIf(this.loader, {paramsAsHash: true});
        }
        Pan.base.tree.TreePanel.superclass.initComponent.call(this);
        if (this.hasTreeFilter) {
            this.addPlugin(new Pan.appframework.plugin.PanGridFilters());
        }
    },
    convertToolBarToActions: function (barString) {
        if (barString && this[barString]) {
            if (Ext.isArray(this[barString])) {
                this[barString] = this[barString].slice(0);
            }
            var bar = this[barString];
            Pan.createActionBar(bar, undefined, this);
        }
    },
    addPlugin: function (p) {
        if (this.plugins) {
            if (!Ext.isArray(this.plugins)) {
                this.plugins = [this.plugins];
            }
        } else {
            this.plugins = [];
        }
        this.plugins.push(p);
    },
    onBeforeLoad: Ext.emptyFn,
    onLoad: function (loader, node, response) {
        if (Pan.base.json.path(response.responseText, '$.@status') == 'success') {
            if (response.responseText.result) {
                this.setValue(response.responseText.result);
            }
        } else {
            var msg = Pan.base.htmlEncode(Pan.base.json.path(response.responseText, '$.msg.*'));
            if (msg) {
                Pan.base.msg.alert(msg);
            }
        }
    },
    getCheckedNodes: function (node) {
        var cs = node.childNodes;
        var treeString = '';
        for (var i = 0; i < cs.length; i++) {
            if (cs[i].hasChildNodes()) {
                treeString += cs[i].text;
                treeString += ',';
                this.getCheckedNodes(cs[i]);
            }
            else if (cs[i].getUI().isChecked()) {
                treeString += cs[i].text;
                treeString += ',';
            }
        }
        return treeString;
    },
    setValue: function (response) {
        var v = response.entry;
        if (!v) {
            return;
        }
        var r = this.getRootNode();
        while (r.childNodes.length > 0) {
            r.removeChild(r.childNodes[0]);
        }
        for (var i = 0; i < v.length; i++) {
            var node = new Ext.tree.AsyncTreeNode(v[i]);
            r.appendChild(node);
        }
    },
    getValue: function () {
        var rNode = this.getRootNode();
        return this.getCheckedNodes(rNode);
    },
    getSelectionModel: function () {
        if (!this.selModel) {
            if (Ext.isBoolean(this.singleSelect) && this.singleSelect) {
                this.selModel = new Ext.tree.DefaultSelectionModel();
            } else {
                this.selModel = new Ext.tree.MultiSelectionModel();
            }
        }
        return this.selModel;
    },
    getSelections: function () {
        if (Ext.isBoolean(this.singleSelect) && this.singleSelect) {
            return this.getSelectionModel().getSelectedNode();
        } else {
            return this.getSelectionModel().getSelectedNodes();
        }
    },
    createTreeNode: function (config) {
        if (this.treeNodeActions) {
            var availableActions = [];
            for (var i = 0; i < this.treeNodeActions.length; i++) {
                var action = this.treeNodeActions[i];
                if (!action.treeNodeActionAvail || action.treeNodeActionAvail.apply(this, arguments)) {
                    availableActions.push(action);
                }
            }
            if (availableActions.length > 0) {
                config = Ext.applyIf({treeNodeActions: availableActions}, config);
            }
        }
        return new Pan.base.tree.TreeNode(config);
    },
    createRootNode: function (config) {
        return new Ext.tree.AsyncTreeNode(config);
    }
});
Ext.reg('pan-treepanel', Pan.base.tree.TreePanel);
Ext.ns('Pan.base.tree');
Pan.base.tree.TreeNodeUI = Ext.extend(Ext.tree.TreeNodeUI, {
    partial: false, defaultTreeNodeActionAlign: 'right', onClick: function (e) {
        var target = e.getTarget('img');
        if (target && Ext.fly(target).hasClass('x-tree-node-action')) {
            this.doAction(e);
        } else {
            if (!this.handleSingleClick(e)) {
                Pan.base.tree.TreeNodeUI.superclass.onClick.apply(this, arguments);
            }
        }
    }, handleSingleClick: function (e) {
        if (!this.disabled && this.fireEvent("beforeclick", this.node, e) !== false) {
            var a = e.getTarget('a');
            if (!this.node.attributes.href || !a) {
                if (this.checkbox) {
                    e.preventDefault();
                    if (a && e.ctrlKey) {
                        e.stopEvent();
                    }
                    this.toggleCheck();
                    return true;
                }
            }
        }
        return false;
    }, doAction: function (event) {
        var a;
        for (var i = 0; i < this.node.attributes.treeNodeActions.length; i++) {
            var action = this.node.attributes.treeNodeActions[i];
            var iconCls = action.initialConfig.iconCls;
            if (event.target.className.indexOf(iconCls) >= 0) {
                a = action;
            }
        }
        if (a) {
            a.execute(this.node.ownerTree, this.node.attributes, event);
        }
    }, prepareTreeNodeActions: function (n) {
        var treeNodeActionIcons = "";
        for (var i = 0; i < n.attributes.treeNodeActions.length; i++) {
            var action = n.attributes.treeNodeActions[i];
            treeNodeActionIcons += Pan.base.renderer.RendererCommon.createActionImage(action, {
                defaultAlign: this.defaultTreeNodeActionAlign,
                additionalClass: "x-tree-node-action"
            });
        }
        return treeNodeActionIcons;
    }, renderElements: function (n, a, targetNode, bulkRender) {
        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';
        var rightSideActionIcon = "";
        if (n.attributes.treeNodeActions) {
            rightSideActionIcon = this.prepareTreeNodeActions(n);
        }
        var emptyTip = _T("'{nodeName}' is configured", {nodeName: n.text});
        var cb = Ext.isBoolean(a.checked), nel, href = a.href ? a.href : Ext.isGecko ? "" : "#",
            buf = ['<li class="x-tree-node"><div ext:tree-node-id="', n.id, '" class="x-tree-node-el x-tree-node-leaf x-unselectable ', a.cls, '" unselectable="on">', '<span class="x-tree-node-indent">', this.indentMarkup, "</span>", '<img src="', this.emptyIcon, '" class="x-tree-ec-icon x-tree-elbow" />', '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon', (a.icon ? " x-tree-node-inline-icon" : ""), (a.iconCls ? " " + a.iconCls : ""), '" unselectable="on" />', cb ? ('<span class="x-tree-node-tristate-cb-wrap ' + (a.checked ? ' x-tree-node-tristate-cb-full-checked' : '') + '"><input class="x-tree-node-cb x-tree-node-tristate-cb" type="checkbox" ' +
                (a.checked ? 'checked="checked" />' : '/>') + '</span>') : '', a.image ? Ext.isFunction(a.image) ? a.image.apply(this, arguments) : ('<img border="0" src="' + a.image + '"/>') : "", '<a hidefocus="on" class="x-tree-node-anchor" href="', href, '" tabIndex="1" ', a.hrefTarget ? ' target="' + a.hrefTarget + '"' : "", '><span unselectable="on">', n.text, "</span></a>", rightSideActionIcon, '<span class="not-empty-node-el" ext:qtip="', emptyTip, '"><span class="not-empty-node-icon"></span></span>', "</div>", '<ul class="x-tree-node-ct" style="display:none;"></ul>', "</li>"].join('');
        if (bulkRender !== true && n.nextSibling && (nel = n.nextSibling.ui.getEl())) {
            this.wrap = Ext.DomHelper.insertHtml("beforeBegin", nel, buf);
        } else {
            this.wrap = Ext.DomHelper.insertHtml("beforeEnd", targetNode, buf);
        }
        this.elNode = this.wrap.childNodes[0];
        this.ctNode = this.wrap.childNodes[1];
        var cs = this.elNode.childNodes;
        this.indentNode = cs[0];
        this.ecNode = cs[1];
        this.iconNode = cs[2];
        var index = 3;
        if (cb) {
            this.checkbox = cs[3].firstChild;
            this.checkbox.defaultChecked = this.checkbox.checked;
            index++;
        }
        this.anchor = cs[index];
        this.textNode = cs[index].firstChild;
        if (a.checked) {
            n.bubble(function (n) {
                if (n.parentNode) {
                    n.getUI().updateCheck(true);
                }
            });
        }
    }, toggleCheck: function (value, partial, isLoad) {
        var cb = this.checkbox;
        if (cb) {
            cb.checked = (value === undefined ? !cb.checked : value);
            cb.parentNode.className = 'x-tree-node-tristate-cb-wrap' + (cb.checked ? (partial ? ' x-tree-node-tristate-cb-partial-checked' : ' x-tree-node-tristate-cb-full-checked') : '');
            this.partial = cb.checked && partial;
            if (!isLoad) {
                this.onCheckChange();
            }
        }
    }, updateCheck: function (isLoad) {
        if (this.node.childNodes.length == 0) {
            return;
        }
        this.partial = 0;
        Ext.each(this.node.childNodes, function (item) {
            var ui = item.getUI();
            if (ui.isChecked() && item.hidden !== true) {
                this.partial++;
                if (ui.partial) {
                    this.toggleCheck(true, true, isLoad);
                    return false;
                }
            }
        }, this);
        if (this.partial !== true) {
            this.toggleCheck(this.partial > 0, this.partial < this.node.childNodes.length, isLoad);
        }
    }
});
Ext.tree.TreeNode.prototype.defaultUI = Pan.base.tree.TreeNodeUI;
Ext.ns('Pan.base.tree');
Pan.base.tree.CheckTreePanel = Ext.extend(Pan.base.tree.TreePanel, {
    checkedNodes: [], expandOnCheck: false, constructor: function (config) {
        Pan.base.tree.CheckTreePanel.superclass.constructor.apply(this, [config]);
    }, initComponent: function () {
        this.setupBBar();
        this.convertToolBarToActions('bbar');
        Pan.base.tree.CheckTreePanel.superclass.initComponent.call(this);
        this.on('checkchange', this.checkChange);
    }, setupBBar: function () {
        this.bbar = [{
            handler: function () {
                this.ownerCt.ownerCt.checkChange(this.ownerCt.ownerCt.root, true);
            }, text: 'Select All'
        }, {
            handler: function () {
                this.ownerCt.ownerCt.checkChange(this.ownerCt.ownerCt.root, false);
            }, text: 'Deselect All'
        }];
    }, checkChange: function (node, checked, suppressEvents) {
        if (!this.changing) {
            this.changing = true;
            var checkParentAndChild = function (node) {
                if (checked) {
                    node.cascade(function (node) {
                        node.getUI().toggleCheck(true, undefined, suppressEvents);
                    });
                } else {
                    node.cascade(function (node) {
                        node.getUI().toggleCheck(false, undefined, suppressEvents);
                    });
                }
                node.bubble(function (node) {
                    if (node.parentNode) {
                        node.getUI().updateCheck(suppressEvents);
                    }
                });
            };
            if (this.expandOnCheck) {
                node.expand(true, false, checkParentAndChild);
            } else {
                checkParentAndChild(node);
            }
            this.changing = false;
        }
    }, getCheckedNodes: function (node) {
        var cs = node.childNodes;
        for (var i = 0; i < cs.length; i++) {
            if (cs[i].hasChildNodes()) {
                this.getCheckedNodes(cs[i]);
            }
            if (!cs[i].hidden && cs[i].getUI().isChecked() && !cs[i].getUI().partial) {
                this.checkedNodes.push(cs[i]);
            }
        }
        return this.checkedNodes;
    }, hasCheckedNodes: function (node, deep) {
        var cs = node.childNodes;
        for (var i = 0; i < cs.length; i++) {
            if (cs[i].getUI().isChecked() || cs[i].getUI().partial)
                return true;
            if (deep === true) {
                if (cs[i].hasChildNodes()) {
                    this.hasCheckedNodes(cs[i]);
                }
            }
        }
        return false;
    }, setValue: function (v) {
        if (!v) {
            return;
        }
        var r = this.getRootNode();
        while (r.childNodes.length > 0) {
            r.removeChild(r.childNodes[0]);
        }
        this.checkedNodes = [];
        for (var i = 0; i < v.length; i++) {
            var entry = v[i];
            var node = this.createTreeNode({
                text: entry['@name'] || entry[this.nodeNameAttribute] || entry,
                checked: false,
                expanded: true
            });
            r.appendChild(node);
            var children = [];
            if (entry[this.nodeChildrenAttribute] && entry[this.nodeChildrenAttribute].entry) {
                var childEntry = entry[this.nodeChildrenAttribute].entry;
                for (var j = 0; j < childEntry.length; j++) {
                    var childNode = this.createTreeNode({
                        text: childEntry[j]['@name'] || childEntry[j][this.childNodeNameAttribute] || childEntry,
                        checked: false,
                        nodeType: this.nodeChildrenAttribute,
                        expanded: true,
                        parent: node.text
                    });
                    node.appendChild(childNode);
                }
            }
        }
        if (this.expandAllNodes) {
            this.expandAll();
        }
    }, getValue: function () {
        var rNode = this.getRootNode();
        return this.getCheckedNodes(rNode);
    }, getSelectionModel: function () {
        if (!this.selModel) {
            this.selModel = new Ext.tree.MultiSelectionModel();
        }
        return this.selModel;
    }, beforeDestroy: function () {
        this.checkedNodes.length = 0;
        this.checkedNodes = null;
        Pan.base.tree.CheckTreePanel.superclass.beforeDestroy.call(this);
    }
});
Ext.reg('pan-checktreepanel', Pan.base.tree.CheckTreePanel);
Ext.ns('Pan.base.tree');
Pan.base.tree.MenuTreePanel = Ext.extend(Pan.base.tree.TreePanel, {
    hasTreeFilter: false, constructor: function (config) {
        var self = this;
        var newConfig = Ext.apply({autoScroll: true, rootVisible: false}, config);
        this.tab = newConfig.root.text;
        Pan.base.tree.MenuTreePanel.superclass.constructor.call(this, newConfig);
        this.on('afterlayout', this.initialSelectNode, this);
        this.on('beforeclick', function (newnode) {
            if (newnode.hasChildNodes()) {
                newnode.toggle();
                if (!Ext.isDefined(newnode.attributes.renderView))
                    return false;
            }
        }, this);
        if (this.handler) {
            this.on('click', function (node) {
                if (!node.hasChildNodes() || Ext.isDefined(node.attributes.renderView)) {
                    var key = self.tab + "-last-visited-node";
                    var value = node.id;
                    Pan.base.cookie.set(key, value, 365);
                }
                this.handler.apply(this.scope, arguments);
            }, this);
        }
    }, initialSelectNode: function () {
        this.un('afterlayout', this.initialSelectNode, this);
        Pan.base.util.invokeLater(1, this.initialSelectNodeImp, this);
    }, initialSelectNodeImp: function () {
        if (this.getSelectionModel().getSelectedNode()) {
            return;
        }
        var root = this.getRootNode();
        var node = Pan.base.param('node');
        if (node) {
            node = root.findChild('id', node, true);
        }
        if (node && !node.hidden) {
            node.select();
            var nodeconfig = Pan.base.param('nodeconfig');
            if (nodeconfig) {
                nodeconfig = Ext.util.JSON.decode(nodeconfig);
            }
            this.handler.call(this.scope, node, nodeconfig);
            return;
        }
        var key = this.tab + "-last-visited-node";
        node = Pan.base.cookie.get(key);
        if (node) {
            node = root.findChild('id', node, true);
        }
        if (node && !node.hidden) {
            node.select();
            this.handler.call(this.scope, node);
            return;
        }
        node = root.findChildBy(function (node) {
            return !node.hasChildNodes() && !node.hidden;
        }, null, true);
        if (node) {
            node.select();
            this.handler.call(this.scope, node);
        }
    }
});
Ext.ns('Pan.base.list');
Pan.base.list.ListPanel = Ext.extend(Pan.base.container.Panel, {
    listView: undefined, layout: 'fit', unselectable: "off", constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.list.ListPanel.superclass.constructor.apply(this, arguments);
    }, initComponent: function () {
        var config = this.initialConfig;
        if (config.plugins) {
            var plugins = [];
            if (!Ext.isArray(config.plugins)) {
                config.plugins = [config.plugins];
            }
            for (var i = 0; i < config.plugins.length; i++) {
                if (!(config.plugins[i] instanceof Ext.ux.FieldHelp)) {
                    plugins.push(config.plugins[i]);
                }
            }
            config.plugins = plugins;
        }
        Ext.applyIf(config, {
            internalTpl: new Ext.XTemplate('<div class="x-list-header"><div class="x-list-header-inner">', '<tpl for="columns">', '<div style="width:{[values.width*100]}%;text-align:{align};"><em class="' + (this.unselectable === "off" ? "x-grid-selectable" : "") + '" unselectable="' + (this.unselectable || "on") + '" id="', this.id, '-xlhd-{#}">', '{header}', '</em></div>', '</tpl>', '<div class="x-clear"></div>', '</div></div>', '<div class="x-list-body"><div class="x-list-body-inner">', '</div></div>'),
            tpl: new Ext.XTemplate('<tpl for="rows">', '<dl>', '<tpl for="parent.columns">', '<dt style="width:{[values.width*100]}%;text-align:{align};">', '<em class="' + (this.unselectable === "off" ? "x-grid-selectable" : "") + '" unselectable="' + (this.unselectable || "on") + '"<tpl if="cls"> class="{cls}</tpl>">', '{[values.tpl.apply(parent)]}', '</em></dt>', '</tpl>', '<div class="x-clear"></div>', '</dl>', '</tpl>')
        });
        delete config.ownerCt;
        this.cls = this.cls || "";
        this.cls = this.cls + ' ' + 'x-list-panel';
        this.setupStoreConfig(config);
        this.setupColumnsConfig(config);
        this.setupList(config);
        this.setupBar(this.tbar);
        this.setupBar(this.bbar);
        this.setupBar(this.fbar);
        Pan.base.list.ListPanel.superclass.initComponent.apply(this, arguments);
    }, setupStoreConfig: function (config) {
        if (config.store && config.store.ztype) {
            config.store = new config.store.ztype(Ext.apply({
                record: this.getRecord(),
                __pdefaults: this.__pdefaults
            }, config.store.zconfig));
        }
        return config;
    }, setupColumnsConfig: function (config) {
        if (!config.columns) {
            config.columns = [];
            for (var i = 0, n = config.store.fields.items.length; i < n; i++) {
                var field = config.store.fields.itemAt(i);
                var columnConfig = field.uiHint && field.uiHint.columnConfig;
                columnConfig = Ext.apply({
                    header: (field.uiHint && field.uiHint.header) || (field.uiHint && field.uiHint.fieldLabel) || field.name,
                    dataIndex: field.name,
                    width: (field.uiHint && field.uiHint.width),
                    sortable: (field.uiHint && field.uiHint.sortable),
                    renderer: (field.uiHint && field.uiHint.renderer)
                }, columnConfig);
                if (Ext.isString(columnConfig.renderer)) {
                    Ext.applyIf(columnConfig, {xtype: columnConfig.renderer});
                    delete columnConfig.renderer;
                }
                delete columnConfig.editor;
                config.columns.push(columnConfig);
            }
        }
        var allConfigColumns = config.columns;
        config.columns = [];
        for (var j = 0; j < allConfigColumns.length; j++) {
            if (!allConfigColumns[j].hidden) {
                config.columns.push(Pan.base.clone(allConfigColumns[j]));
            }
        }
        this.allConfigColumns = allConfigColumns;
        return config;
    }, setupList: function (config) {
        this.listView = new Ext.list.ListView(config);
        this.items = this.listView;
        this.store = this.listView.store;
    }, setupBar: function (bar) {
        if (bar) {
            var makeHandler = function (o, action) {
                o.handler = Pan.base.util.createExtension(function (element, event) {
                    var config = {list: this, component: this, action: action, event: event};
                    config.record = this.getSelectedRecords();
                    arguments.callee.superFunction.call(this, this, config, event);
                }, o.handler, this);
            };
            for (var i = 0; i < bar.length; i++) {
                bar[i] = Pan.createAction(bar[i], this);
                if (bar[i].handler) {
                    makeHandler.call(this.getListView(), bar[i], bar[i]);
                } else if (bar[i].initialConfig && bar[i].initialConfig.handler) {
                    makeHandler.call(this.getListView(), bar[i].initialConfig, bar[i]);
                }
            }
        }
    }, getListView: function () {
        return this.listView;
    }, setValue: function (v) {
        if (v && Ext.isArray(v)) {
            var store = this.listView.store;
            var records = [];
            for (var i = 0; i < v.length; i++) {
                records.push(this.createRecord(v[i], store.fields));
            }
            if (records.length > 0) {
                store.loadRecords({records: records}, {}, true);
            }
        }
    }, getValue: function () {
        return this.getFieldData();
    }, createRecord: function (data, fields) {
        var rdata = {};
        var id, store = this.listView.store;
        var items = fields.items;
        if (items.length == 1) {
            rdata[items[0].name] = id = data;
        } else {
            var field;
            if (store.idProperty) {
                field = fields.get(store.idProperty);
            }
            if (!field) {
                field = items[0];
            }
            rdata[field.name] = id = data[field.attrName];
        }
        return new Ext.data.Record(rdata, id);
    }
});
Ext.reg('pan-list', Pan.base.list.ListPanel);
Ext.ns('Pan.base.grid');
Pan.base.grid.AddRecordAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Add'),
            iconCls: 'icon-add',
            ref: '../addRecordAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        if (config.checkCount) {
            var checkCountConfig;
            if (Ext.isObject(config.checkCount)) {
                checkCountConfig = config.checkCount;
            }
            newConfig.availConfig = Pan.base.util.integrateArray(Ext.apply({
                type: 'CheckCountAvail',
                count: '__field.maxCount'
            }, checkCountConfig), config.availConfig);
        }
        Pan.base.grid.AddRecordAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
        this.action(element, config, event);
    }, setupRecord: function (config) {
        this.recstore = this.store || config.component.store;
        if (this.recstore.beginAdd) {
            this.rec = this.recstore.beginAdd();
        }
        else {
            var rec = new this.recstore.recordType();
            rec.fields.each(function (f) {
                rec.data[f.name] = f.defaultValue;
            });
            this.rec = rec;
        }
    }, preAction: function (element, config) {
        if (config.grid) {
            config.grid.stopEditing();
            var colModel = config.grid.colModel;
            var colCount = colModel.getColumnCount();
            for (var index = 0; index < colCount; index++) {
                var column = colModel.getColumnAt(index);
                if ((!column.hidden || column.hideable !== false) && column.editor && column.editor.isARecordEditor) {
                    this.editor = column.editor;
                    break;
                }
            }
        }
        this.setupRecord(config);
    }, createRecordConfig: function (config, opts) {
        var recFormConfig = opts || {};
        var rec = this.rec;
        if (this.editor) {
            Ext.applyIf(recFormConfig, {
                store: rec.store,
                record: rec,
                recordFormPostLoadChangeConfig: this.initialConfig.recordFormPostLoadChangeConfig,
                recordFormPostLoadChangeCallback: function (gridRecordForm) {
                    var copyToDataExtractor = gridRecordForm.__pdefaults.__dataExtractor;
                    var changeConfigs = gridRecordForm.recordForm.recordFormPostLoadChangeConfig;
                    changeConfigs = Pan.base.util.integrateArray([], changeConfigs);
                    for (var i = 0; i < changeConfigs.length; i++) {
                        var changeConfig = changeConfigs[i];
                        var data;
                        if (changeConfig.copyFromPath) {
                            data = undefined;
                        }
                        if (changeConfig.copyFromData) {
                            if (Ext.isFunction(changeConfig.copyFromData)) {
                                data = changeConfig.copyFromData(data);
                            }
                            else {
                                data = changeConfig.copyFromData;
                            }
                        }
                        var field = copyToDataExtractor(changeConfig.copyToPath, '');
                        field.setValue(data);
                        if (changeConfig.disabled) {
                            field.setIsAvail(false);
                        }
                    }
                }
            });
            Ext.applyIf(recFormConfig, this.editor.initialConfig || this.editor);
            if (rec.store.localStore) {
                Ext.applyIf(recFormConfig, {
                    okCallback: function (recordForm) {
                        var updateRecord = recordForm.recordForm.updateRecord || recordForm.updateRecord;
                        updateRecord.call(this);
                        recordForm.store.add(rec);
                        recordForm.onCancel();
                        return false;
                    }, cancelCallback: function (recordForm) {
                        recordForm.onDestroy();
                        return true;
                    }
                });
            }
        }
        return recFormConfig;
    }, action: function (element, config) {
        if (this.editor) {
            var recFormConfig = this.createRecordConfig(config);
            Pan.base.autorender.GridRecordForm.showRecordForm(recFormConfig, config.grid);
        }
        else {
            var row = this.addRecord(this.recstore, this.rec, true);
            if (config.grid) {
                var columnCount = config.grid.colModel.getColumnCount();
                for (var i = 0; i < columnCount; i++) {
                    if (!config.grid.colModel.isHidden(i) && config.grid.colModel.isCellEditable(i, row)) {
                        if (config.grid.scrollToBottom) {
                            config.grid.scrollToBottom();
                        }
                        var onAdd = function (row, col) {
                            var selModel = config.grid.getSelectionModel();
                            if (selModel.selectRow) {
                                selModel.selectRow(row);
                            }
                            this.startEditing(row, col, true);
                        };
                        if (this.initialConfig.delayStartEditing) {
                            var task = new Ext.util.DelayedTask(onAdd, config.grid, [row, i]);
                            task.delay(100);
                        }
                        else {
                            onAdd.call(config.grid, row, i);
                        }
                        break;
                    }
                }
            }
        }
    }, addRecord: function (recstore, rec, skipFilter) {
        recstore.add(rec, skipFilter);
        return recstore.getCount() - 1;
    }
});
Pan.areg('addRecordAction', Pan.base.grid.AddRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.DeleteRecordAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Delete'),
            iconCls: 'icon-delete',
            ref: '../deleteRecordAction',
            handler: function (element, config, event) {
                var r = config.record;
                if (r) {
                    var store = this.store || config.component.store;
                    store.bulkRemove(r);
                }
            }
        }, config);
        if (config.checkCount) {
            var checkCountConfig;
            if (Ext.isObject(config.checkCount)) {
                checkCountConfig = config.checkCount;
            }
            newConfig.availConfig = Pan.base.util.integrateArray(Ext.apply({
                type: 'CheckCountAvail',
                count: 0,
                operation: '>'
            }, checkCountConfig), config.availConfig);
        }
        newConfig.availConfig = Pan.base.util.integrateArray({
            type: 'HasSelectionAvail',
            hasSelectionMethod: config.hasSelectionMethod
        }, newConfig.availConfig);
        Pan.base.grid.DeleteRecordAction.superclass.constructor.call(this, newConfig);
    }
});
Pan.areg("deleteRecordAction", Pan.base.grid.DeleteRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.MoveUpRecordAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Move Up'),
            iconCls: 'icon-move-up',
            ref: '../moveUpRecordAction',
            handler: function (element, config) {
                if (config.row === undefined || config.row == 0)
                    return;
                if (Ext.isFunction(config.component.move)) {
                    config.component.move(false, config.row, config.col, config);
                    if (Ext.isFunction(config.component.getView)) {
                        config.component.getView().refresh();
                    }
                }
            }
        }, config);
        if (!config.doNotCheckSelection) {
            newConfig.availConfig = Pan.base.util.integrateArray({
                type: 'CheckCountAndSelectionAvail',
                hasSelectionMethod: config.hasSelectionMethod || 'getSelectionModel.hasOneSelection',
                count: 1,
                operation: '>'
            }, newConfig.availConfig);
        }
        Pan.base.grid.MoveUpRecordAction.superclass.constructor.call(this, newConfig);
    }
});
Pan.areg("moveUpRecordAction", Pan.base.grid.MoveUpRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.MoveDownRecordAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Move Down'),
            iconCls: 'icon-move-down',
            ref: '../moveDownRecordAction',
            handler: function (element, config) {
                var store = this.store || config.component.store;
                if (config.row === undefined || ((config.row + 1) >= store.getCount()))
                    return;
                if (Ext.isFunction(config.component.move)) {
                    config.component.move(true, config.row, config.col, config);
                    if (Ext.isFunction(config.component.getView)) {
                        config.component.getView().refresh();
                    }
                }
            }
        }, config);
        if (!config.doNotCheckSelection) {
            newConfig.availConfig = Pan.base.util.integrateArray({
                type: 'CheckCountAndSelectionAvail',
                hasSelectionMethod: config.hasSelectionMethod || 'getSelectionModel.hasOneSelection',
                count: 1,
                operation: '>'
            }, newConfig.availConfig);
        }
        Pan.base.grid.MoveDownRecordAction.superclass.constructor.call(this, newConfig);
    }
});
Pan.areg("moveDownRecordAction", Pan.base.grid.MoveDownRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.GridPanel = Pan.base.util.cextend(Ext.ux.grid.livegrid.EditorGridPanel, "isLiveGrid", {
    trackMouseOver: true,
    showEllipsisValue: "<em class='x-grid-ellipsis'>" + _T("more...") + "</em>",
    showEllipsisEntryCount: undefined,
    columnLines: true,
    miniCellRowLines: true,
    stripeRows: true,
    hasExpander: false,
    pageableCheckBoxSelection: true,
    showAdjustColumnsButton: false,
    hdMouseOverShowCompleteInfo: false,
    forceFit: true,
    hasCellDropZone: false,
    hasCellDragZone: false,
    hasActionCallout: false,
    hasAdjustColumnMenu: true,
    autoAdjustColumnWidth: false,
    isOrdered: false,
    saveData: false,
    stateful: true,
    allowAddNewEntries: false,
    cellHeight: undefined,
    theme: Pan.base.Constants.uiThemes[1],
    blankText: _T("Require at least one entry"),
    disableAutoVflex: undefined,
    disableLiveRowUpdate: false,
    storeScrollPosition: true,
    enableCellEditing: true,
    filterSelected: false,
    supportLocalPaging: undefined,
    showLocalPagingBarOnDemand: true,
    showBbar: true,
    showSelectedCount: false,
    showSelectedText: _T('Filter Selected'),
    localPagingParams: {
        start: 0,
        limit: Pan.base.Constants.defaultGridLocalPagingSize,
        displayMsg: _T('Displaying') + ' {0} - {1}/ {2}'
    },
    hasGridFilter: true,
    filterStateFul: true,
    filterValue: null,
    filterConfig: {
        localFilter: true, filterHandler: function (filterString) {
            var anyMatch = true, caseSensitive = false, exactMatch = false;
            var store = this.store;
            store.__filterSessionIndex = store.__filterSessionIndex || 0;
            var filterSessionIndex = store.__filterSessionIndex++;
            var grid = this;
            var filterFields = [];
            for (var i = (this.firstDataColumn || 0), n = this.colModel.getColumnCount(); i < n; i++) {
                var col = this.colModel.getColumnAt(i);
                if (!col.hidden || col.hideable !== false) {
                    var filterField = {property: col.dataIndex, getFilterString: col.getFilterString};
                    (function () {
                        var fieldName = col.dataIndex;
                        var colIndex = i;
                        var renderer = col.renderer;
                        var spanCellRenderer = col.spanCellRenderer;
                        var spanCellMapping = col.spanCellMapping || this.spanCellMapping || 'value';
                        var colFilterField = filterField;
                        var match = function (v, original) {
                            if (v && v !== '&#160;') {
                                if (colFilterField.getFilterString) {
                                    v = colFilterField.getFilterString(v, original);
                                    return colFilterField.valueMatcher.test(String(v));
                                }
                                else if (Ext.isArray(v)) {
                                    return colFilterField.valueMatcher.test(String(v));
                                }
                                else if (Ext.isObject(v)) {
                                    return colFilterField.valueMatcher.test(v[spanCellMapping] || v.value);
                                }
                                else {
                                    if (v !== undefined && v.search) {
                                        if (v.indexOf('x-grid3-check-col') >= 0) {
                                            v = !!original;
                                        }
                                        else if (v.search(/^\s*</g) >= 0) {
                                            v = v.replace(/<.*?>/g, '').trim();
                                        }
                                    }
                                    return colFilterField.valueMatcher.test(v);
                                }
                            }
                            else {
                                return false;
                            }
                        };
                        Ext.applyIf(colFilterField, {
                            fn: function (r, key, rIndex) {
                                var original = r.data[fieldName];
                                var v = original;
                                if (renderer) {
                                    v = renderer.call(this, v, {}, r, rIndex, colIndex, store, grid, filterSessionIndex);
                                }
                                if (Ext.isArray(v)) {
                                    var i;
                                    if (spanCellRenderer) {
                                        for (i = 0; i < v.length; i++) {
                                            var vv = v[i];
                                            vv = spanCellRenderer.call(this, vv, {}, r, i, colIndex, store, grid, filterSessionIndex);
                                            if (match(vv, original)) {
                                                return true;
                                            }
                                        }
                                    }
                                    else {
                                        for (i = 0; i < v.length; i++) {
                                            if (match(v[i], original)) {
                                                return true;
                                            }
                                        }
                                    }
                                }
                                else {
                                    return match(v, original);
                                }
                                return false;
                            },
                            scope: col.scope || col,
                            header: col.header,
                            valueMatcher: Ext.util.MixedCollection.prototype.createValueMatcher(filterString, anyMatch, caseSensitive, exactMatch)
                        });
                    })();
                    filterFields.push(filterField);
                }
            }
            var mask;
            if (this.el) {
                mask = new Pan.base.widgets.LoadMask(this.el, {msg: _T('Filtering...')});
                mask.show();
            }
            Pan.base.util.invokeLater(1, function () {
                var log = PanLogging.getLogger('base:grid:GridPanel');
                this.__doStringFilterInProgress = true;
                try {
                    if (Pan.base.RecordQuery.isRecordQueryString(filterString)) {
                        this.store.doRecordQueryFilter(filterString, filterFields);
                    }
                    else {
                        this.store.doStringFilter(filterString, filterFields, anyMatch, caseSensitive, exactMatch);
                    }
                }
                catch (ex) {
                    log.error(ex);
                }
                delete this.__doStringFilterInProgress;
                if (mask) {
                    mask.hide();
                    mask.destroy();
                }
            }, this);
        }
    },
    protect: function () {
        var el = this.body.select('.x-grid3-scroller');
        el.addClass('x-protect-mask');
        el.mask();
        el = this.el.select('.x-panel-bbar');
        el.addClass('x-protect-mask');
        el.mask();
        this.view.headersDisabled = true;
    },
    unprotect: function () {
        var el = this.body.select('.x-grid3-scroller');
        el.removeClass('x-protect-mask');
        el.unmask();
        el = this.el.select('.x-panel-bbar');
        el.removeClass('x-protect-mask');
        el.unmask();
        this.view.headersDisabled = false;
    },
    doLayout: function () {
        Pan.base.grid.GridPanel.superclass.doLayout.apply(this, arguments);
        if (this.view && this.view.grid) {
            if (this.store.getCount() > 0) {
                if (this.getHeight() > 0 && Ext.fly(this.el.select(".x-grid3")).getHeight() === 0) {
                    this.view.onDataChange();
                }
            }
        }
    },
    supportFormValidation: false,
    preventMark: false,
    allowBlankValidation: false,
    invalidText: 'This field is invalid.',
    invalidClass: 'x-form-invalid',
    requiredFieldClass: 'x-form-required',
    msgTarget: 'qtip',
    msgDisplay: '',
    setupValidation: function () {
        if (this.supportFormValidation) {
            if (this.saveData || !this.useCheckBoxSelection) {
                this.addListener('afteredit', this.validate, this);
            }
            else if (Ext.isFunction(this.getSelectionModel().getCount)) {
                this.getSelectionModel().addListener('selectionchange', this.validate, this);
            }
        }
        if (this.allowBlankValidation) {
            this.preventMark = false;
        }
    },
    isValid: function (preventMark) {
        if (!this.supportFormValidation || this.disabled) {
            return true;
        }
        var restore = this.preventMark;
        this.preventMark = preventMark === true;
        var v = this.validateValue(this.store);
        this.preventMark = restore;
        return v;
    },
    validate: function () {
        if (!this.supportFormValidation || this.disabled || this.validateValue(this.store)) {
            this.clearInvalid();
            return true;
        }
        return false;
    },
    markInvalid: function (msg) {
        if (this.rendered && !this.preventMark) {
            msg = msg || this.invalidText;
            var el = this.bwrap;
            if (msg === this.blankText) {
                el = el.child('.x-grid3-scroller');
                el.addClass(this.requiredFieldClass);
            }
            else {
                el.addClass(this.invalidClass);
            }
            el.dom.qtip = msg;
            el.dom.qclass = 'x-form-invalid-tip';
            if (Ext.QuickTips) {
                Ext.QuickTips.enable();
            }
        }
        this.setActiveError(msg);
    },
    clearInvalid: function () {
        if (this.rendered && !this.preventMark) {
            var el = this.bwrap;
            el.removeClass(this.invalidClass);
            el.dom.qtip = '';
            var bodyEl = el.child('.x-grid3-scroller');
            bodyEl.removeClass(this.requiredFieldClass);
            bodyEl.dom.qtip = '';
        }
        this.unsetActiveError();
    },
    setActiveError: function (msg, suppressEvent) {
        this.activeError = msg;
        if (suppressEvent !== true) this.fireEvent('invalid', this, msg);
    },
    unsetActiveError: function (suppressEvent) {
        delete this.activeError;
        if (suppressEvent !== true) this.fireEvent('valid', this);
    },
    validateValue: function (store) {
        var error = this.getErrors(store)[0];
        if (error == undefined) {
            this.clearInvalid();
            return true;
        }
        else {
            this.markInvalid(error);
            return false;
        }
    },
    getErrors: function (store) {
        if (!store) {
            store = this.store;
        }
        var errors = [];
        if (!this.allowBlank && this.allowBlankValidation) {
            if (this.saveData) {
                if (this.isEmpty(store)) {
                    errors.push(this.blankText);
                }
            }
            else {
                if (Ext.isFunction(this.getSelectionModel().getCount)) {
                    if (this.getSelectionModel().getCount() < 1) {
                        errors.push(this.blankText);
                    }
                }
            }
        }
        var me = this;
        if (errors.length === 0) {
            store.each(function (rec) {
                if (rec.error) {
                    errors.push(me.getRecordError.call(me, rec));
                    return false;
                }
            });
        }
        return errors;
    },
    setDisableLiveRowUpdate: function (value) {
        this.disableLiveRowUpdate = value;
    },
    isDisableLiveRowUpdate: function () {
        return this.disableLiveRowUpdate;
    },
    getRecordError: function (record) {
        var message = _T("Error in table cell");
        if (this.store.idProperty) {
            if (record.data[this.store.idProperty]) {
                message = _T("Error in table record") + " " + record.data[this.store.idProperty];
            }
        }
        return message;
    },
    reset: function () {
        this.clearInvalid();
    },
    getSelections: function () {
        return this.getSelectionModel().getSelections();
    },
    afterAddSelectionAndSetField: Ext.emptyFn,
    addSelection: function (selection, config) {
        var recordFieldName = config && config.recordFieldName;
        var previousSelection;
        if (recordFieldName) {
            previousSelection = this.getSelectionModel().getSelections();
            if (previousSelection.length > 0) {
                previousSelection = previousSelection[0];
                if (Ext.isArray(selection) && selection.length === 1) {
                    previousSelection.set(recordFieldName, selection[0]);
                }
                else {
                    previousSelection.set(recordFieldName, selection);
                }
            }
            this.afterAddSelectionAndSetField(previousSelection);
            return;
        }
        var index;
        var replaceSelection = config && config.replaceSelection;
        if (replaceSelection) {
            previousSelection = this.getSelectionModel().getSelections();
            if (previousSelection.length > 0) {
                previousSelection = previousSelection[0];
                index = this.store.indexOf(previousSelection);
                this.store.remove(previousSelection);
            }
        }
        if (!this.saveData && this.useCheckBoxSelection) {
            this.fieldValue = this.fieldValue || [];
            if (Ext.isArray(selection)) {
                for (var i = 0; i < selection.length; i++) {
                    this.fieldValue.push(selection[i]);
                }
            }
            else {
                this.fieldValue.push(selection);
            }
        }
        else {
            var starField = this.getStarField();
            var records = [];
            for (var j = 0; j < selection.length; j++) {
                records.push(this.createRecord(selection[j], starField));
            }
            if (records.length > 0) {
                if (Ext.isNumber(index)) {
                    this.store.insert(index, records);
                }
                else {
                    this.store.loadRecords({records: records}, {add: true}, true);
                }
                this.validate();
            }
        }
    },
    getFirstFullyVisibleDomRow: function () {
        var rows = this.getView().getRows();
        if (rows && rows.length > 0) {
            var scrollTop = this.view.scroller.dom.scrollTop;
            for (var i = 0; i < rows.length; i++) {
                if (rows[i].offsetTop >= scrollTop) {
                    break;
                }
            }
            return Math.min(i, rows.length - 1);
        }
        return -1;
    },
    getFirstFullyVisibleRecord: function () {
        var index = this.getFirstFullyVisibleDomRow();
        var rec = undefined;
        if (index >= 0) {
            var rows = this.getView().getRows();
            var rowIndex = rows[index].rowIndex;
            rec = this.store.getAt(rowIndex);
        }
        return rec;
    },
    getLastFullyVisibleDomRow: function () {
        var rows = this.getView().getRows();
        if (rows && rows.length > 0) {
            var scrollTop = this.view.scroller.dom.scrollTop;
            var scrollOffsetHeight = this.view.scroller.dom.offsetHeight;
            for (var i = 0; i < rows.length; i++) {
                if (rows[i].offsetTop + rows[i].offsetHeight > scrollTop + scrollOffsetHeight) {
                    break;
                }
            }
            return Math.max(i - 1, 0);
        }
        return -1;
    },
    getLastFullyVisibleRecord: function () {
        var index = this.getLastFullyVisibleDomRow();
        var rec = undefined;
        if (index >= 0) {
            var rows = this.getView().getRows();
            var rowIndex = rows[index].rowIndex;
            rec = this.store.getAt(rowIndex);
        }
        return rec;
    },
    isRecordFullyVisible: function (record) {
        var selectedIndex = this.store.indexOfId(record.id);
        var row = this.view.getRows()[selectedIndex];
        if (row) {
            var stop = this.view.scroller.dom.scrollTop;
            var ctop = row.offsetTop;
            var cbot = ctop + this.view.getRows()[selectedIndex].offsetHeight;
            var sbot = stop + this.view.scroller.dom.clientHeight;
            if (ctop > stop && cbot < sbot) {
                return true;
            }
        }
        return false;
    },
    saveScrollState: function (view, index) {
        if (index == 0) {
            if (this.getSelections().length <= 0) {
                this.firstRecordInScroller = undefined;
            }
            delete this.currentFirstFullyVisibleRecord;
            delete this.currentLastFullyVisibleRecord;
            return;
        }
        this.currentFirstFullyVisibleRecord = this.getFirstFullyVisibleRecord();
        this.currentLastFullyVisibleRecord = this.getLastFullyVisibleRecord();
        var lastRecord, record = null;
        if (this.getSelections().length > 0) {
            record = this.getSelections()[0];
            if (!this.isLiveGrid && this.isRecordFullyVisible(record)) {
                record = this.currentFirstFullyVisibleRecord;
                lastRecord = this.currentLastFullyVisibleRecord;
                this.lastRecordInScroller = lastRecord.id;
            }
            else
                this.lastRecordInScroller = undefined;
        }
        else {
            record = this.currentFirstFullyVisibleRecord;
            lastRecord = this.currentLastFullyVisibleRecord;
            if (lastRecord)
                this.lastRecordInScroller = lastRecord.id;
        }
        if (record) {
            this.firstRecordInScroller = record.id;
        }
    },
    scrollToLastPosition: function (store) {
        var firstRecordInScroller = this.firstRecordInScroller;
        var lastRecordInScroller = this.lastRecordInScroller;
        if (!this.__doStringFilterInProgress) {
            if (this.currentFirstFullyVisibleRecord) {
                firstRecordInScroller = this.currentFirstFullyVisibleRecord.id;
            }
            if (this.currentLastFullyVisibleRecord) {
                lastRecordInScroller = this.currentLastFullyVisibleRecord.id;
            }
        }
        if (!firstRecordInScroller)
            return;
        var record;
        if (this.__doStringFilterInProgress && this.getSelections().length > 0) {
            record = this.getSelections()[0];
        }
        if (this.isLiveGrid) {
            if (this.getView().isScrolling !== true) {
                this.getView().liveScroller.dom.scrollTop = this.getView().lastScrollPos;
                if (record && !this.view.isRecordRendered(record))
                    this.getView().liveGridScrollTo(store.indexOfId(record.id));
            }
        }
        else {
            this.scrollTo(firstRecordInScroller);
            var firstIndex = this.store.indexOfId(firstRecordInScroller);
            var lastIndex = this.store.indexOfId(lastRecordInScroller);
            if (lastIndex > firstIndex && lastRecordInScroller)
                this.scrollTo(lastRecordInScroller);
            if (record && !this.isRecordFullyVisible(record))
                this.scrollTo(record.id);
        }
    },
    scrollToSelection: function () {
        if (this.getSelections().length > 0) {
            var record = this.getSelections()[0];
            if (this.isLiveGrid) {
            }
            else {
                this.scrollTo(record.id);
            }
        }
    },
    scrollTo: function (id, highlight, callback) {
        var rowIndex = this.store.indexOfId(id);
        if (this.view.incrementalRenderBodyTask) {
            this.view.incrementalRenderBodyTask.afterTask = this.scrollTo.createDelegate(this, arguments);
            return;
        }
        if (rowIndex < 0) {
            return;
        }
        this.getView().focusRow(rowIndex);
        if (highlight) {
            var el = this.getRowEl(rowIndex);
            if (el) {
                el.highlight();
                if (el.hasClass('x-grid3-row-selected')) {
                    el.addClass('x-grid3-row-selected-checker-highlight');
                    el.removeClass('x-grid3-row-selected');
                    Pan.base.util.invokeLater(1000, function (rowIndex) {
                        var el = this.getRowEl(rowIndex);
                        if (el) {
                            el.addClass('x-grid3-row-selected');
                            el.removeClass('x-grid3-row-selected-checker-highlight');
                        }
                    }, this, [rowIndex]);
                }
            }
        }
        if (Ext.isFunction(callback)) {
            callback.defer(100, this);
        }
    },
    scrollToTop: function () {
        this.getView().scrollToTop();
    },
    scrollToBottom: function () {
        this.getView().scrollToBottom();
    },
    move: function (dirDown, row, col) {
        this.stopEditing();
        var newRow = row + (dirDown ? 1 : -1);
        if (this.maxMiniCellRows) {
            var tmp = this.maxMiniCellRows[row];
            this.maxMiniCellRows[row] = this.maxMiniCellRows[newRow];
            this.maxMiniCellRows[newRow] = tmp;
        }
        var record = this.store.getAt(row);
        this.store.remove(record);
        this.store.insert(newRow, record);
        var sm = this.getSelectionModel();
        if (sm.select)
            sm.select(newRow, col); else
            sm.selectRow(newRow);
    },
    constructor: function (config) {
        config = Ext.apply({}, config);
        if (config.isLiveGrid || this.isLiveGrid || (!this.supportLocalPaging && !Ext.isDefined(config.supportLocalPaging))) {
            this.supportLocalPaging = false;
        }
        this.supportFastRender = Ext.isDefined(this.supportFastRender) ? this.supportFastRender : true;
        if (config.isLiveGrid || this.isLiveGrid) {
            this.supportFastRender = false;
        }
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.grid.GridPanel.superclass.constructor.call(this, config);
    },
    initEvents: function () {
        var loadMask = this.loadMask;
        this.loadMask = false;
        Pan.base.grid.GridPanel.superclass.initEvents.call(this);
        if (loadMask) {
            if (this.isLiveGrid) {
                this.maskEl = this.getView().mainBody.dom.parentNode.parentNode;
            }
            else {
                this.maskEl = this.bwrap;
            }
            this.loadMask = new Pan.base.widgets.LoadMask(this.maskEl, Ext.apply({store: this.store}, loadMask));
            if (this.showLoadMaskInitially) {
                this.loadMask.show();
            }
        }
    },
    reconfigure: function (store, _colModel) {
        var loadMask = this.loadMask;
        this.loadMask = false;
        var rendered = this.rendered;
        if (rendered) {
            if (loadMask) {
                loadMask.destroy();
                if (this.isLiveGrid) {
                    this.maskEl = this.getView().mainBody.dom.parentNode.parentNode;
                }
                else {
                    this.maskEl = this.bwrap;
                }
                loadMask = new Pan.base.widgets.LoadMask(this.maskEl, Ext.apply({}, {store: store}, loadMask));
            }
        }
        Pan.base.grid.GridPanel.superclass.reconfigure.apply(this, arguments);
        this.loadMask = loadMask;
    },
    getView: function () {
        if (!this.view) {
            this.viewConfig = this.viewConfig || {};
            Ext.applyIf(this.viewConfig, {
                cellSelectorDepth: 5,
                forceFit: this.forceFit,
                scrollOffset: this.forceFit === true ? 1 : Pan.base.Constants.scrollOffset
            });
            this.viewConfig.isLiveGrid = this.isLiveGrid;
            this.view = this.createView();
            if (this.storeScrollPosition === true) {
                if (this.isLiveGrid) {
                    this.view.addListener('cursormove', this.saveScrollState, this, {buffer: 250});
                }
                else {
                    this.addListener('bodyscroll', this.saveScrollState, this, {buffer: 250});
                }
            }
            if (this.supportFastRender) {
                this.addListener('bodyscroll', this.view.doFastRender, this.view);
            }
        }
        return this.view;
    },
    createView: function () {
        return new Pan.base.grid.SpanningGridView(this.viewConfig);
    },
    onCellDblClick: function () {
    },
    onAutoEditClick: function () {
    },
    initComponent: function () {
        this.setupStore();
        this.setupView();
        this.setupSelectionModel();
        this.setupExpander();
        this.setupExtraPlugins();
        this.setupRowActions(this.rowActions);
        this.setupBrowseRowAction();
        if (this.initialConfig.preInit) {
            this.initialConfig.preInit(this);
        }
        this.setupBars();
        this.setupValidation();
        Pan.base.grid.GridPanel.superclass.initComponent.call(this);
        this.setupListeners();
    },
    onRender: function (_ct, _position) {
        var rv = Pan.base.grid.GridPanel.superclass.onRender.apply(this, arguments);
        if (this.enableColumnMove) {
            var view = this.getView();
            view.columnDrag.addInvalidHandleClass('x-grid3-td-checker');
            view.columnDrop.onNodeDrop = Pan.base.util.createExtension(function (n, dd, e) {
                var td = Ext.get(e.getTarget("td"));
                for (var i = 0, len = view.columnDrag.invalidHandleClasses.length; i < len; i++) {
                    if (td.hasClass(view.columnDrag.invalidHandleClasses[i])) {
                        return false;
                    }
                }
                return arguments.callee.superFunction.apply(this, arguments);
            }, view.columnDrop.onNodeDrop);
        }
        return rv;
    },
    setupListeners: function () {
        this.addListener('render', function () {
            if (!this.saveData && this.useCheckBoxSelection) {
                this.store.addListener("load", this.selectRecords, this);
            }
            if (this.showSelectedCount && Ext.isFunction(this.selModel.getCount)) {
                this.selModel.addListener('selectionchange', this.updateSelectionCountText, this);
                this.store.addListener("datachanged", this.updateSelectionCountText, this);
            }
        }, this, {single: true});
    },
    onResize: function (_w, _h) {
        var rv = Pan.base.grid.GridPanel.superclass.onResize.apply(this, arguments);
        if (this.hasAdjustColumnMenu && this.autoAdjustColumnWidth) {
            this.onAllByContentClick();
        }
        return rv;
    },
    getCellEl: function (rowIndex, columnIndex) {
        return Ext.fly(this.getView().getCell(rowIndex, columnIndex));
    },
    getRowEl: function (rowIndex) {
        return Ext.fly(this.getView().getRow(rowIndex));
    },
    getCellText: function (rowEl, columnIndex) {
        var cell = rowEl.cells[columnIndex];
        if (cell) {
            return cell.textContent || cell.innerText;
        }
    },
    setupView: function () {
        this.cls = this.cls || "";
        this.cls = this.theme + " " + this.cls;
        Ext.applyIf(this, {stateId: this.getStateId()});
        if (this.isLiveGrid) {
            this.cls += " x-live-grid-panel";
            this.cellHeight = Pan.base.Constants.liveGridMiniRowHeight + "px";
        }
        this.viewConfig = this.viewConfig || {};
        var i;
        if (this.bbarStrings) {
            if (!this.bbar) {
                this.bbar = [];
            }
            else {
                this.bbar = this.bbar.slice(0);
            }
            for (i = 0; i < this.bbarStrings.length; i++) {
                this.bbar.push(this.bbarStrings[i]);
            }
        }
        var isAlreadyOnTheRight = false;
        if (this.supportLocalPaging && this.showBbar) {
            if (!isAlreadyOnTheRight) {
                if (!this.bbar) {
                    this.bbar = [];
                }
                else {
                    this.bbar = this.bbar.slice(0);
                }
                this.bbar.push('->');
                isAlreadyOnTheRight = true;
            }
            this.bbar.push({
                xtype: "pan-paging",
                cls: this.theme,
                supportLocalPaging: true,
                pageableCheckBoxSelection: this.pageableCheckBoxSelection,
                showLocalPagingBarOnDemand: this.showLocalPagingBarOnDemand,
                pageSize: this.localPagingParams.limit,
                displayInfo: Ext.isDefined(this.localPagingParams.displayMsg),
                displayMsg: this.localPagingParams.displayMsg,
                hideDisplayMsg: this.localPagingParams.hideDisplayMsg || false,
                hideRefresh: this.localPagingParams.hideRefresh || false,
                hideBorder: true,
                store: this.store,
                grid: this
            });
        }
        if (this.showSelectedCount && this.showBbar) {
            if (!this.bbar) {
                this.bbar = [];
            }
            else {
                this.bbar = this.bbar.slice(0);
            }
            this.bbar.push('->');
            this.bbar.push({
                xtype: 'pan-checkbox',
                tooltip: _T('Apply Selected Item Filter'),
                itemId: 'selection_count',
                checked: this.filterSelected,
                boxLabel: this.showSelectedText + ' (0) ',
                listeners: {
                    'check': {
                        fn: function (comp, value) {
                            if (this.store.useFilters === true) {
                                if (value) {
                                    this.store.addStoreFilter([{
                                        fn: function (r) {
                                            return this.selModel.isSelected(r);
                                        }, scope: this, id: 'showselected'
                                    }]);
                                }
                                else {
                                    this.store.deleteStoreFilter([{id: 'showselected'}]);
                                }
                            }
                            else {
                                if (value) {
                                    this.store.filterBy(function (r) {
                                        return this.selModel.isSelected(r);
                                    }, this);
                                }
                                else {
                                    this.store.clearFilter();
                                }
                            }
                        }, scope: this
                    }, 'afterrender': {
                        fn: function (comp) {
                            var value = comp.checked;
                            if (this.store.useFilters === true) {
                                if (value) {
                                    this.store.addStoreFilter([{
                                        fn: function (r) {
                                            return this.selModel.isSelected(r);
                                        }, scope: this, id: 'showselected'
                                    }]);
                                }
                                else {
                                    this.store.deleteStoreFilter([{id: 'showselected'}]);
                                }
                            }
                            else {
                                if (value) {
                                    this.store.filterBy(function (r) {
                                        return this.selModel.isSelected(r);
                                    }, this);
                                }
                                else {
                                    this.store.clearFilter();
                                }
                            }
                        }, scope: this
                    }
                }
            });
        }
        if (this.showAdjustColumnsButton) {
            if (!isAlreadyOnTheRight) {
                if (!this.bbar) {
                    this.bbar = [];
                }
                this.bbar.push('->');
                isAlreadyOnTheRight = true;
            }
            this.bbar.push({atype: 'expandAllColumnsAction'});
        }
        if (this.colModel) {
            this.userDefinedColModel = true;
        }
        else {
            var n;
            var columnsMap = {};
            var additionalColumns = [];
            var useColumns = (this.useColumns && !_.isArray(this.useColumns)) ? this[this.useColumns] : this.useColumns;
            if (useColumns) {
                var tmpUseColumns = [];
                for (i = 0; i < useColumns.length; i++) {
                    if (Ext.isString(useColumns[i])) {
                        columnsMap[useColumns[i]] = true;
                        var storeField = this.store.fields.get(useColumns[i]);
                        if (storeField) {
                            tmpUseColumns.push(storeField);
                        }
                    }
                    else {
                        tmpUseColumns.push(useColumns[i]);
                        additionalColumns.push(useColumns[i]);
                    }
                }
                useColumns = tmpUseColumns;
            }
            else if (this.columns) {
                for (i = 0; i < this.columns.length; i++) {
                    columnsMap[this.columns[i]['dataIndex']] = true;
                }
            }
            else {
                columnsMap = undefined;
            }
            if (!this.columns) {
                this.columns = [];
                var items = useColumns || (this.store && this.store.fields && this.store.fields.items) || [];
                for (i = 0, n = items.length; i < n; i++) {
                    var field = items[i];
                    if ((columnsMap && columnsMap[field.name]) || (columnsMap === undefined && (!field.children || field.isCollection || field.isTerminalForDisplay || field.nodetype === 'union' || field.nodetype === 'choice'))) {
                        this.columns.push(this.createDefaultColumnConfig(field, i));
                    }
                    else {
                        this.columns.push(field);
                    }
                }
            }
            else {
                var newColumns = [];
                for (i = 0; i < this.columns.length; i++) {
                    var dataIndex = this.columns[i]['dataIndex'];
                    if (columnsMap[dataIndex] || columnsMap[dataIndex + i]) {
                        newColumns[newColumns.length] = this.columns[i];
                    }
                }
                for (i = 0; i < additionalColumns.length; i++) {
                    newColumns.push(additionalColumns[i]);
                }
                this.columns = newColumns;
            }
            var visibleColumns = 0;
            this.onClickRegistrationComplete = false;
            this.onMouseOverRegistrationComplete = false;
            this.theNonhiddenAndNonhideableColumnCandidate = undefined;
            for (var j = 0; j < this.columns.length; j++) {
                var col = this.columns[j] = Ext.apply({}, this.columns[j]);
                this.setupColumn(col, j);
                if (!col.hidden) {
                    visibleColumns++;
                }
            }
            if (this.theNonhiddenAndNonhideableColumnCandidate) {
                Ext.applyIf(this.theNonhiddenAndNonhideableColumnCandidate, {hideable: false});
                delete this.theNonhiddenAndNonhideableColumnCandidate;
            }
            delete this.onClickRegistrationComplete;
            delete this.onMouseOverRegistrationComplete;
            if (visibleColumns <= 1 && (!this.initialConfig || !this.initialConfig.enableHdMenu)) {
                Ext.apply(this, {enableHdMenu: false});
            }
        }
        if (this.initialConfig && this.initialConfig.autoExpandColumn) {
            this.autoExpandColumn = this.initialConfig.autoExpandColumn;
        }
        if (!this.userDefinedColModel) {
            this.firstDataColumn = 0;
            if (this.supportScrollOffsetColumn) {
                this.forceFit = true;
                if (this.columns.length === 1) {
                    this.columns[0].resizable = false;
                }
                Ext.apply(this.viewConfig, {
                    scrollOffset: 0, forceFit: true, getTotalWidth: function () {
                        return "auto";
                    }
                });
            }
            var hasOneHideableColumn = false;
            for (var k = 0; k < this.columns.length; k++) {
                if (this.columns[k].hideable !== false) {
                    hasOneHideableColumn = true;
                    break;
                }
            }
            if (!hasOneHideableColumn) {
                Ext.applyIf(this, {enableColumnHide: false});
            }
        }
        this.setupLayout();
    },
    setupLayout: function () {
        if (this.disableAutoVflex !== true && this.__pdefaults && Ext.isDefined(this.__pdefaults.__recordFormAutoHeight)) {
            Ext.applyIf(this, {vflex: !this.__pdefaults.__recordFormAutoHeight});
        }
    },
    setupStore: function () {
        if (this.store && this.store.ztype) {
            this.store = new this.store.ztype(this.createStoreConfig(this.store));
        }
        var ds = this.store;
        if (ds) {
            ds.__recordFormRecord = this.getRecord();
            if (ds._autoLoad === true) {
                delete ds._autoLoad;
                this.addListener({
                    afterrender: function () {
                        ds.load.defer(200, ds);
                    }, delay: 100
                });
            }
            if (this.storeScrollPosition === true) {
                if (this.isLiveGrid) {
                    this.store.addListener("afterload", this.scrollToLastPosition, this);
                }
                else {
                    this.store.addListener("load", function (store) {
                        Pan.base.util.invokeLater(1, this.scrollToLastPosition, this, [store]);
                    }, this);
                }
            }
        }
    },
    createStoreConfig: function (store) {
        var config = Ext.applyIf({
            record: this.getRecord(),
            __pdefaults: this.__pdefaults,
            starField: this.getStarField(),
            supportLocalPaging: this.supportLocalPaging,
            localPagingParams: this.localPagingParams
        }, store.zconfig);
        if (store.zconfig.reader) {
            config.reader = new this.store.zconfig.reader(config);
        }
        return config;
    },
    getInternalScrollOffsetColumn: function () {
        return undefined;
    },
    getState: function () {
        if (this.headers && this.headers.rows) {
            var o = Pan.base.grid.GridPanel.superclass.getState.call(this);
            o.rows = this.headers.rows;
            return o;
        }
        else {
            return Pan.base.grid.GridPanel.superclass.getState.call(this);
        }
    },
    applyState: function (state) {
        var cm = this.colModel, cs = state.columns, store = this.store, s, c, oldIndex;
        if (state.rows) {
            if (this.headers && this.headers.rows && (state.rows.length == this.headers.rows.length)) {
                for (var row = 0, rlen = state.rows.length; row < rlen; row++) {
                    var ritems = state.rows[row];
                    var rColSpanCount = 0;
                    var tColSpanCount = 0;
                    var sIdx = 0;
                    var titems = this.headers.rows[row];
                    if (ritems.length != titems.length) {
                        return;
                    }
                    var rheadercount = 0;
                    var theadercount = 0;
                    var headermatches = true;
                    Ext.each(titems, function (item) {
                        tColSpanCount += titems[sIdx].colspan || 1;
                        rColSpanCount += ritems[sIdx++].colspan || 1;
                        if (item['header']) {
                            theadercount++;
                            headermatches = false;
                            rheadercount = 0;
                            Ext.each(ritems, function (ritem) {
                                if (ritem['header']) {
                                    rheadercount++;
                                    if (item['header'] == ritem['header']) {
                                        headermatches = true;
                                    }
                                }
                            });
                            if (headermatches == false) {
                                return false;
                            }
                        }
                    });
                    if ((headermatches == true) && (theadercount == rheadercount) && (tColSpanCount == rColSpanCount)) {
                        Ext.apply(this.colModel.rows[row], state.rows[row]);
                    }
                    else {
                        return;
                    }
                }
            }
            else {
                return;
            }
        }
        if (cs && cs.length === cm.getColumnCount()) {
            for (var i = 0, len = cs.length; i < len; i++) {
                s = cs[i];
                c = cm.getColumnById(s.id);
                if (c) {
                    if (c.hideable !== false) {
                        c.hidden = s.hidden;
                    }
                    if (!c.fixed) {
                        if (!Ext.isNumber(c.minimumInitialWidth) || !Ext.isNumber(s.width) || c.minimumInitialWidth < s.width) {
                            c.width = s.width;
                        }
                    }
                    oldIndex = cm.getIndexById(s.id);
                    if (oldIndex != i) {
                        cm.moveColumn(oldIndex, i);
                    }
                }
            }
        }
        if (store) {
            s = state.sort;
            if (s) {
                var sortColumnIndex = cm.findColumnIndex(s.field);
                var sortColumn = cm.getColumnAt(sortColumnIndex);
                if (sortColumn && sortColumn.sortable) {
                    if (!store.multiSortInfo) {
                        store[store.remoteSort ? 'setDefaultSort' : 'sort'](s.field, s.direction);
                    }
                }
            }
            if (store.groupBy) {
                if (this.view && this.view.enableGrouping) {
                    store.groupBy(store.getGroupState());
                }
                else {
                    store.clearGrouping();
                }
            }
        }
        Ext.grid.GridPanel.superclass.applyState.call(this, state);
    },
    getStateId: function () {
        var stateId = this.itemId || this.name;
        if (this.__pdefaults && this.__pdefaults.__treePath) {
            stateId = this.__pdefaults.__treePath + '-' + stateId;
        }
        return stateId;
    },
    setupSelectionModel: function () {
        if (this.sm) {
            this.selModel = this.sm;
            delete this.sm;
        }
        if (!this.selModel) {
            if ((this.useCheckBoxSelection) && !this.isLiveGrid) {
                Ext.applyIf(this, {checkBoxSelectionModelConfig: {useHeaderChecker: true}});
            }
            this.selModel = new Pan.base.grid.CheckboxSelectionModel(Ext.apply({
                isLiveGrid: this.isLiveGrid,
                pageable: this.pageableCheckBoxSelection
            }, this.checkBoxSelectionModelConfig));
            if (this.initialConfig && Ext.isBoolean(this.initialConfig.singleSelect)) {
                Ext.apply(this.selModel, {singleSelect: this.initialConfig.singleSelect});
            }
            else if (Ext.isBoolean(this.singleSelect)) {
                Ext.apply(this.selModel, {singleSelect: this.singleSelect});
            }
        }
        if (this.useCheckBoxSelection && this.columns) {
            if (this.appendCheckBoxSelection) {
                this.columns.push(this.selModel);
            }
            else {
                this.columns.splice(0, 0, this.selModel);
                this.firstDataColumn++;
            }
        }
    },
    updateSelectionCountText: function () {
        var label, sm = this.selModel;
        var total = 0, inStoreTotal = 0;
        if (sm.getResultCount) {
            var resultCount = sm.getResultCount();
            total = resultCount.total;
            inStoreTotal = resultCount.inStoreTotal;
        }
        else {
            total = inStoreTotal = sm.getCount();
        }
        label = this.showSelectedText + ' (' + total + ') ';
        var selCountItem = this.getBottomToolbar().findByItemId('selection_count');
        selCountItem.setBoxLabel(label);
    },
    resetColumnActions: function () {
        for (var j = 0; j < this.colModel.getColumnCount(); j++) {
            var col = this.colModel.getColumnAt(j);
            this.setupColumnActions(col, j);
        }
    },
    setupColumn: function (col, index, registerClickHandler) {
        var available = true;
        if (Ext.isFunction(col.columnAvail)) {
            available = col.columnAvail(this);
        }
        if (available) {
            this.setupColumnActions(col, index);
            if (!this.onClickRegistrationComplete && (registerClickHandler || (col.renderer && col.renderer.onClick))) {
                this.addListener('cellclick', this.handleClick, this);
                this.onClickRegistrationComplete = true;
            }
            if (col.autoExpandColumn && this.forceFit) {
                this.autoExpandColumn = col.id;
            }
        }
        else {
            Ext.applyIf(col, {hideable: false, hidden: true});
        }
        if (col.hidden !== true && col.hideable === false) {
            this.theNonhiddenAndNonhideableColumnCandidate = col;
        }
        if (!this.theNonhiddenAndNonhideableColumnCandidate && (col.hidden !== true && !Ext.isDefined(col.hideable))) {
            this.theNonhiddenAndNonhideableColumnCandidate = col;
        }
        if (col.headerActions) {
            this.columnHeaderActions = this.columnHeaderActions || [];
            for (var i = 0; i < col.headerActions.length; i++) {
                var action = Pan.createActions(col.headerActions[i], this.makeHandler, this);
                action.actionId = this.columnHeaderActions.length;
                this.columnHeaderActions.push(action);
            }
        }
    },
    handleEllipsisClick: function (_grid, _config, _evt) {
    },
    handleClick: function (grid, rowIndex, columnIndex, e, config) {
        if (grid.getColumnModel()) {
            var column = grid.getColumnModel().getColumnAt(columnIndex);
            var renderer = column.renderer;
            var scope = null;
            if (e.getTarget() && e.getTarget().className && e.getTarget().className.indexOf("x-grid-ellipsis") >= 0) {
                if (!config) {
                    config = grid.getCellEventInfo(rowIndex, columnIndex, e);
                }
                this.handleEllipsisClick(grid, config, e);
                return true;
            }
            else if (renderer && renderer.onClick) {
                scope = renderer.scope || column.scope || this || window;
                if (!config) {
                    config = grid.getCellEventInfo(rowIndex, columnIndex, e);
                }
                if (!renderer.beforeClick || (renderer.beforeClick.call(scope, grid, config, e) !== false)) {
                    return renderer.onClick.call(scope, grid, config, e);
                }
            }
            else {
                var spanCellRenderer = column.spanCellRenderer;
                if (spanCellRenderer && spanCellRenderer.onClick) {
                    scope = spanCellRenderer.scope || column.scope || this || window;
                    if (!config) {
                        config = grid.getCellEventInfo(rowIndex, columnIndex, e);
                    }
                    if (!spanCellRenderer.beforeClick || (spanCellRenderer.beforeClick.call(scope, grid, config, e) !== false)) {
                        return spanCellRenderer.onClick.call(scope, grid, config, e);
                    }
                }
            }
        }
    },
    getCellEventInfo: function (rowIndex, columnIndex, e) {
        var record = this.store.getAt(rowIndex);
        var row = jQuery(e.target).closest("tr").get(0);
        var cell = jQuery(e.target).closest("td").get(0);
        var miniCellRowIndex;
        if (row) {
            var rows = row.parentNode.rows;
            if (rows) {
                for (var i = 0; i < rows.length; i++) {
                    if (rows[i] === row) {
                        miniCellRowIndex = i;
                        break;
                    }
                }
            }
        }
        return {
            record: record,
            grid: this,
            row: rowIndex,
            col: columnIndex,
            miniCellRowEl: row,
            miniCellColEl: cell,
            miniCellRowIndex: miniCellRowIndex,
            event: e
        };
    },
    setupExpander: function () {
        if (this.hasExpander) {
            var expander = new Pan.base.grid.RowPanelExpander({
                createExpandingRowPanelItems: function (record, rowIndex) {
                    var expanderConfig = this.grid.expanderConfig || {
                        panelItems: function () {
                            return [{
                                plain: true,
                                style: 'padding:5px;',
                                xtype: 'panel',
                                border: true,
                                items: [{
                                    title: _T('Expander Panel'),
                                    html: '<h2>You need to provide <i>expanderConfig with panelItems</i> method from your PanGridViewer.</h2>'
                                }]
                            }];
                        }
                    };
                    return expanderConfig.panelItems(record, rowIndex, this.grid);
                }
            });
            expander.hideable = false;
            this.addPlugin(expander);
            this.columns.unshift(expander);
            this.firstDataColumn++;
        }
    },
    collapseExpandedRow: function (rowIndex) {
        for (var i = 0; this.hasExpander && this.plugins && i < this.plugins.length; i++) {
            if (this.plugins[i].id == "expander") {
                this.plugins[i].collapseRow(rowIndex);
            }
        }
    },
    fieldLabelPluginSetVisible: function (visible) {
        var header = Ext.get(this.id + "-fieldLabelHeader");
        if (header) {
            if (visible) {
                header.removeClass("x-hide-display");
            }
            else {
                header.addClass("x-hide-display");
            }
            this.view.layout();
        }
    },
    setupExtraPlugins: function () {
        if (this.fieldLabelPlugin && this.columns) {
            for (var i = 0; i < this.columns.length; i++) {
                if (this.columns[i].id && this.columns[i].id.indexOf("id") >= 0) {
                    this.columns[i].header = '<span id="' + this.id + '-label"></span>' + this.columns[i].header;
                    break;
                }
            }
        }
        if (this.headers) {
            this.addPlugin(new Pan.base.grid.RowSpanningColumnHeaderGroup(this.headers));
        }
        else if (this.viewConfig) {
            this.viewConfig.handleHdDown = Pan.base.util.createExtension(this.handleHdDown, Ext.grid.GridView.prototype.handleHdDown);
            this.viewConfig.handleHdMenuClick = Pan.base.util.createExtension(this.handleHdMenuClick, Ext.grid.GridView.prototype.handleHdMenuClick);
        }
        if (this.hdMouseOverShowCompleteInfo) {
            this.viewConfig.handleHdMove = Ext.grid.GridView.prototype.handleHdMove.createSequence(function (e, t) {
                if (Ext.fly(t).hasClass('x-grid3-hd-over-show-complete-info')) {
                    var headerCell = this.view.findHeaderCell(t);
                    var columnIndex = this.view.getCellIndex(headerCell);
                    var col = this.colModel.getColumnAt(columnIndex);
                    if (col && col.dataIndex) {
                        this.showCompleteColumnInfo(columnIndex, headerCell, col);
                    }
                }
                else {
                    this.cleanupColumnWindow();
                }
            }, this);
        }
        if (this.hasGridFilter) {
            this.addPlugin(new Pan.appframework.plugin.PanGridFilters({
                hideSearchInfo: this.hideSearchInfo,
                filterFieldXType: this.filterFieldXType
            }));
        }
        if (this.hasCellDropZone) {
            this.addPlugin(new Pan.base.grid.CellDropZone());
        }
        if (this.hasCellDragZone) {
            this.addPlugin(new Pan.base.grid.CellDragZone());
        }
        if (this.enableDragDrop) {
            this.addPlugin(new Pan.base.grid.GridDropTarget());
        }
        if (this.hasCellDropZone) {
            this.addPlugin(new Pan.base.grid.ActionCallout());
        }
        if (this.hasAdjustColumnMenu) {
            this.addPlugin(new Pan.base.grid.ColumnWidthCalculator());
        }
        if (Ext.isObject(this.tagColumnMapConfig)) {
            this.addPlugin(new Pan.appframework.plugin.TagPlugin());
        }
    },
    addPlugin: function (p) {
        if (this.plugins) {
            if (!Ext.isArray(this.plugins)) {
                this.plugins = [this.plugins];
            }
        }
        else {
            this.plugins = [];
        }
        this.plugins.push(p);
    },
    setValue: function (v) {
        this.fieldValue = v;
        if (this.fieldValue) {
            if (!this.saveData && this.useCheckBoxSelection) {
                this.selectRecords(this.store);
            }
            else {
                var starField = this.getStarField();
                if (Ext.isFunction(this.store.setValue)) {
                    this.store.setValue(this.fieldValue, starField);
                }
                else {
                    var records = [];
                    for (var i = 0; i < this.fieldValue.length; i++) {
                        records.push(this.createRecord(this.fieldValue[i], starField));
                    }
                    if (records.length > 0) {
                        this.store.loadRecords({records: records}, {}, true);
                    }
                }
                if (this.hasAdjustColumnMenu && this.autoAdjustColumnWidth) {
                    this.onAllByContentClick();
                }
            }
        }
        else if (v === undefined || this.isAnEditor) {
            if (!this.saveData && this.useCheckBoxSelection) {
                this.getSelectionModel().clearSelections();
            }
            else {
                this.store.removeAll();
            }
        }
    },
    selectRecords: function (store, suspendEvents) {
        if (this.fieldValue && !this.saveData && this.useCheckBoxSelection) {
            var selectedRecords = [];
            for (var i = 0; i < this.fieldValue.length; i++) {
                var r = store.getById(this.fieldValue[i]);
                if (r) {
                    selectedRecords.push(r);
                }
            }
            if (selectedRecords.length > 0) {
                var sm = this.getSelectionModel();
                if (suspendEvents) {
                    sm.suspendEvents(false);
                }
                sm.selectRecords(selectedRecords, false);
                if (suspendEvents) {
                    sm.resumeEvents();
                    sm.fireEvent('selectionchange', sm);
                }
            }
        }
    },
    isEmpty: function (store) {
        return store.getCount() < 1;
    },
    getValue: function () {
        var results = [];
        if (!this.saveData && this.useCheckBoxSelection) {
            results = this.getValueFromSelection();
        }
        else {
            if (Ext.isFunction(this.store.getValue)) {
                return this.store.getValue(this.getStarField());
            }
            else {
                var snapshot = this.store.snapshot || this.store.data;
                snapshot.each(function (r) {
                    results.push(this.getRecordValue(r));
                }, this);
            }
        }
        return results;
    },
    getValueFromSelection: function () {
        var results = [];
        if (this.store.recordBinder) {
            var rb = this.store.recordBinder;
            var sm = this.getSelectionModel();
            sm.each(function (r) {
                results.push(rb.getNameId(r.json));
            });
        }
        return results;
    },
    getStarField: function () {
        return this.__field && this.__field.children && this.__field.children[0];
    },
    createRecord: function (data, starField) {
        var fields = this.getRecordFields();
        var rdata = {};
        var id;
        var colModel = this.colModel;
        if (!starField.children || Ext.isString(data)) {
            rdata[colModel.getColumnAt(this.firstDataColumn).dataIndex] = id = data;
        }
        else {
            var columnCount = colModel.getColumnCount();
            for (var i = 0; i < columnCount; i++) {
                var column = colModel.getColumnAt(i);
                if (column.id === 'expander')
                    continue;
                rdata[column.dataIndex] = starField.getChildData(data, fields.get(column.dataIndex).attrPath);
            }
            if (this.store.idProperty) {
                id = rdata[this.store.idProperty];
            }
        }
        var record = new this.store.recordType(rdata, id);
        record.json = data;
        return record;
    },
    getRecordValue: function (r) {
        var fields = this.getRecordFields();
        var starField = this.__field.children[0];
        var colModel = this.colModel;
        if (!starField.children) {
            return this.getFieldValue(r, colModel.getColumnAt(this.firstDataColumn).dataIndex);
        }
        else {
            var rv = r.json || {};
            var columnCount = colModel.getColumnCount();
            for (var i = 0; i < columnCount; i++) {
                var column = colModel.getColumnAt(i);
                if (column.id === 'expander')
                    continue;
                starField.setChildData(rv, fields.get(column.dataIndex).attrPath, this.getFieldValue(r, column.dataIndex));
            }
            return rv;
        }
    },
    getFieldValue: function (r, fname) {
        return r.data[fname];
    },
    createDefaultColumnConfig: function (field, index) {
        var rv = {isGenerated: true};
        if (this.columnConfig) {
            var columnConfig = this.columnConfig[field.name];
            Ext.applyIf(rv, columnConfig);
        }
        if (field.uiHint) {
            var uiHint = field.uiHint;
            if (uiHint.columnConfig) {
                Ext.applyIf(rv, uiHint.columnConfig);
            }
            var width = uiHint.width;
            var minimumInitialWidth = undefined;
            if (!Ext.isDefined(width) && field.isCollection) {
                width = Pan.base.Constants.minimumInitialColumnWidthForArray;
                minimumInitialWidth = Pan.base.Constants.minimumInitialColumnWidthForArray;
            }
            Ext.applyIf(rv, {
                header: uiHint.header || uiHint.fieldLabel || field.name,
                dataIndex: field.name,
                width: width,
                minimumInitialWidth: minimumInitialWidth,
                sortable: !this.isOrdered && uiHint.sortable !== false,
                hidden: uiHint.hidden,
                hideable: uiHint.hideable,
                id: uiHint.id,
                autoExpandColumn: uiHint.autoExpandColumn
            });
            if (uiHint.renderer) {
                Ext.applyIf(rv, {renderer: uiHint.renderer});
            }
            else {
                if (rv.urlTemplate) {
                    Ext.applyIf(rv, {
                        renderer: Pan.renderer({
                            xtype: 'LabelRenderer', link: function (value) {
                                return value;
                            }, onClick: function (grid, config) {
                                var url = Pan.base.Evaluation.evaluate(this.urlTemplate, Ext.apply({value: config.record.get(field.name)}, config.record.json, this));
                                if (url) {
                                    window.open(url);
                                }
                            }
                        })
                    });
                }
            }
            if (Ext.isString(rv.renderer)) {
                Ext.applyIf(rv, {xtype: rv.renderer});
                delete rv.renderer;
            }
            if (field.nodetype === 'array' && !rv.xtype && !rv.renderer && !rv.spanCellRenderer) {
                if (field.children && field.children[0].children && field.children[0].children.length > 1) {
                    rv.spanCellRenderer = function (v) {
                        if (Ext.isObject(v)) {
                            var childrenAttrNames = arguments.callee.childrenAttrNames;
                            var value = "";
                            for (var i = 0; i < childrenAttrNames.length; i++) {
                                var childName = childrenAttrNames[i];
                                if (i !== 0) {
                                    value += ": ";
                                }
                                value += Pan.base.htmlEncode(v[childName]);
                            }
                            v = value;
                        }
                        return v;
                    };
                    var childrenAttrNames = [];
                    for (var i = 0; i < field.children[0].children.length; i++) {
                        childrenAttrNames.push(field.children[0].children[i].attrName);
                    }
                    rv.spanCellRenderer.childrenAttrNames = childrenAttrNames;
                }
            }
            if (uiHint.isKeyField) {
                Ext.applyIf(rv, {id: "id" + index, autoExpandColumn: true});
                if (rv.hidden !== true) {
                    Ext.apply(rv, {hideable: false});
                }
            }
        }
        return rv;
    },
    setupBars: function () {
        this.setupBar("tbar");
        this.setupBar("bbar");
        this.setupBar("fbar");
    },
    setupBar: function (barString) {
        if (barString && this[barString]) {
            if (Ext.isArray(this[barString])) {
                this[barString] = this[barString].slice(0);
            }
            var bar = this[barString];
            Pan.createActionBar(bar, this.makeHandler, this);
        }
    },
    createToolbar: function (tb, options) {
        if (this.theme) {
            options = options || {};
            options.cls = options.cls ? this.theme + ' ' + options.cls : this.theme;
        }
        return Pan.base.grid.GridPanel.superclass.createToolbar.call(this, tb, options);
    },
    setupRowActions: function (rowActions) {
        if (rowActions) {
            for (var i = 0; i < rowActions.length; i++) {
                rowActions[i] = Pan.createAction(rowActions[i], this);
                if (rowActions[i].initialConfig) {
                    var copyAttributes = "iconIndex,qtipIndex,qtip,hideIndex,hide,align,style,iconCls,tooltip,scope,handler";
                    if (rowActions[i].initialConfig.useText) {
                        copyAttributes += ",text,textIndex";
                    }
                    rowActions[i] = Ext.copyTo({}, rowActions[i].initialConfig, copyAttributes);
                }
                rowActions[i].callback = Pan.base.util.createExtension(function (grid, record, action, row, col) {
                    arguments.callee.superFunction.call(this, grid, {
                        record: record,
                        grid: grid,
                        row: row,
                        col: col,
                        action: action
                    });
                }, rowActions[i].handler, this);
                if (this.showRowActionsOnlyForSelectedRow) {
                    Ext.applyIf(rowActions[i], {hideIndex: '__hideAction'});
                }
            }
            this.action = new Pan.base.grid.RowActions({
                header: _T('Actions'),
                autoWidth: Ext.isBoolean(this.rowActionsAutoWidth) ? this.rowActionsAutoWidth : true,
                additionalPadding: 24,
                keepSelection: true,
                actions: rowActions,
                getData: function (value, cell, record, row) {
                    if (this.grid.showRowActionsOnlyForSelectedRow) {
                        return Ext.applyIf({__hideAction: this.grid.rowOverRow !== row}, record.data);
                    }
                    else {
                        return record.data || {};
                    }
                }
            });
            this.columns.push(this.action);
            this.addPlugin(this.action);
            if (this.action.destroy === undefined) this.action.destroy = Ext.emptyFn;
        }
    },
    setupBrowseRowAction: function () {
        if (this.browseNotifier) {
            this.browseNotifier = Pan.createAction(this.browseNotifier, this);
            if (this.browseNotifier.initialConfig) {
                this.browseNotifier = Ext.copyTo({}, this.browseNotifier.initialConfig, "iconIndex,qtipIndex,qtip,hideIndex,hide,align,style,iconCls,tooltip,scope,handler");
            }
            this.browseNotifier.callback = Pan.base.util.createExtension(function (grid, record, action) {
                arguments.callee.superFunction.call(this, grid, {
                    record: record,
                    component: grid,
                    target: this.browseNotifier.target,
                    notifier: this.browseNotifier.notifier,
                    action: action
                });
            }, this.browseNotifier.handler, this);
            this.browse = new Ext.ux.grid.RowActions({
                hideable: false,
                header: '',
                autoWidth: false,
                keepSelection: true,
                actions: [this.browseNotifier]
            });
            this.columns.push(this.browse);
            this.addPlugin(this.browse);
            if (this.browse.destroy === undefined) this.browse.destroy = Ext.emptyFn;
        }
    },
    findMiniCell: function (e) {
        var t = e.getTarget('td.x-grid3-cell', this.view.cellSelectorDepth);
        if (!t) {
            return false;
        }
        var el = Ext.fly(t);
        if (el.hasClass('x-grid-cell-void')) {
            return false;
        }
        if (el.select("em.x-grid-ellipsis").elements.length > 0) {
            return false;
        }
        var r = el.child('.x-grid3-cell-inner');
        if (r && r.hasClass('active')) {
            return r;
        }
        if (r && r.dom.offsetWidth < r.dom.scrollWidth) {
            this.el.select('.x-grid3-cell-inner.active').removeClass('active');
            r.addClass('active');
            return r;
        }
        this.el.select('.x-grid3-cell-inner.active').removeClass('active');
        return el;
    },
    extractCompleteText: function (record, dataIndex) {
        return record.get(dataIndex);
    },
    showCompleteText: function (data, menuitem) {
        if (!this.wrapTextWindow) {
            this.wrapTextWindow = Ext.create({
                xtype: "menu",
                items: {
                    xtype: 'pan-textarea',
                    itemId: 'wrapData',
                    autoScroll: true,
                    readOnly: true,
                    width: 250,
                    height: 70
                }
            });
            this.wrapDataTextArea = this.wrapTextWindow.findByItemId("wrapData");
        }
        this.wrapDataTextArea.setValue(data);
        if (!this.wrapTextWindow.el) {
            this.wrapTextWindow.render();
        }
        var xy = this.wrapTextWindow.el.getAlignToXY(menuitem, 'c-c');
        this.wrapTextWindow.showAt(xy);
        this.wrapDataTextArea.focus(true, 300);
    },
    showCompleteColumnInfo: function (columnIndex, headerCell, col) {
        if (this.view.getRows().length <= 0) {
            return;
        }
        this.cleanupColumnWindow();

        function cleanUp(el) {
            if (el.nodeType == 1) {
                el.id = Ext.id();
                for (var i = 0; i < el.childNodes.length; i++) {
                    cleanUp(el.childNodes[i]);
                }
            }
        }

        var q = headerCell.parentNode, h = headerCell.cloneNode(true), header;
        var size = Ext.fly(headerCell).getSize();
        var maxWidth = size.width;
        h.style.height = size.height;
        h.style.width = '100%';
        Ext.fly(h).addClass('column-content-tip');
        cleanUp(h);
        while (!Ext.fly(q).hasClass("x-grid3-viewport")) {
            header = q.cloneNode(false);
            cleanUp(header);
            header.style.width = '100%';
            q = q.parentNode;
            header.appendChild(h);
            h = header;
        }
        header = h;
        var body = this.view.mainBody.dom.cloneNode(false);
        cleanUp(body);
        body.style.width = '100%';
        var i = 0;
        var cell = this.view.getCell(i, columnIndex);
        while (cell) {
            var p = cell.parentNode, c = cell.cloneNode(true);
            var cMaxWidth = Math.max(Ext.fly(cell).getWidth(), Ext.fly(cell).getTextWidth());
            if (maxWidth < cMaxWidth) {
                maxWidth = cMaxWidth;
            }
            cleanUp(c);
            var new_p;
            while (p && !Ext.fly(p).hasClass('x-grid3-body')) {
                new_p = p.cloneNode(false);
                cleanUp(new_p);
                new_p.style.width = '100%';
                new_p.appendChild(c);
                p = p.parentNode;
                c = new_p;
            }
            if (new_p) {
                body.appendChild(new_p);
            }
            i++;
            if (!this.view.getRow(i)) {
                break;
            }
            cell = this.view.getCell(i, columnIndex);
        }
        maxWidth = col.completeForceWidth ? col.completeForceWidth : maxWidth + 14;
        var tipWidth = maxWidth.constrain(40, 300);
        this.columnWindow = new Pan.base.grid.GridViewer({
            target: headerCell,
            width: tipWidth,
            cls: this.theme,
            autoHide: true,
            html: ['<div class="x-grid3-header">', header.innerHTML, '</div>', '<div class="x-panel-body x-panel-body-noheader" style="height: 100%;">', '<div class="x-grid3" style="width: 100%;">', body.innerHTML, '</div>', '</div>'].join('')
        });
        this.columnWindow.show();
    },
    addGlobalFindColumnActionConfig: function (col) {
        if (col.enableGlobalFind !== false && this.enableGlobalFind !== false && this.fields && Ext.isFunction(this.fields.get)) {
            var enableGlobalFind = false;
            if (col.enableGlobalFind === true) {
                enableGlobalFind = true;
            }
            else if (this.enableGlobalFind === true) {
                enableGlobalFind = true;
            }
            else {
                var field = this.fields.get(col.dataIndex);
                if (field) {
                    var fieldSchema = window.jsonPath(Pan._currentschema, field.attrPath);
                    if (fieldSchema) {
                        fieldSchema = fieldSchema[0];
                        if (Ext.isObject(fieldSchema["@attr"]) && Ext.isArray(fieldSchema["@attr"]["memberof"]) && !Ext.isEmpty(fieldSchema["@attr"]["memberof"])) {
                            enableGlobalFind = true;
                        }
                    }
                }
            }
            if (enableGlobalFind) {
                var i = 0, len = col.columnActions.length;
                for (; i < len; ++i) {
                    var action = col.columnActions[i];
                    if (action.globalFindColumnAction === true) {
                        break;
                    }
                }
                if (i === len) {
                    col.columnActions.push({
                        text: _T("Global Find"),
                        globalFindColumnAction: true,
                        iconCls: 'pan-search',
                        handler: function (grid) {
                            var column = grid.getColumnModel().getColumnAt(grid.cellEventInfo.col);
                            var value = grid.cellEventInfo.miniCellColEl ? jQuery(grid.cellEventInfo.miniCellColEl).text() : "";
                            if (column && Ext.isFunction(column.globalFindValueExtractor)) {
                                value = column.globalFindValueExtractor.call(column, grid.cellEventInfo, grid, value);
                            }
                            if (Pan.mainui.finderIcon && Ext.isString(value) && value) {
                                Pan.mainui.finderIcon.search('"' + value.trim() + '"');
                            }
                        }
                    });
                }
            }
        }
    },
    setupAdditionalColumnActionConfig: function (col, index) {
        col.columnActions = col.columnActions || [];
        var foundEllipsisAction = false;
        for (var i = 0; i < col.columnActions.length; i++) {
            var action = col.columnActions[i];
            if (action.ellipsisAction === true) {
                foundEllipsisAction = true;
                break;
            }
        }
        if (!foundEllipsisAction && ((Ext.isDefined(col.wrap) && col.wrap === false) || col.wrapWithEllipsis === true) && col.showEllipsisMenu !== false) {
            col.columnActionsMode = col.columnActionsMode || 'mixed';
            col.columnActionToolbarClass = col.columnActionToolbarClass || '';
            col.columnActionToolbarClass += ' ellipsis-menu';
            col.columnActions.push({
                ellipsisAction: true,
                columnActionsMode: 'button',
                iconCls: 'icon-ellipsis',
                dataIndex: col.wrapTextDataIndex ? col.wrapTextDataIndex : col.dataIndex,
                handler: function (item, event) {
                    var cellEventInfo = this.cellEventInfo;
                    var textData, record;
                    if (cellEventInfo) {
                        record = cellEventInfo.record;
                        textData = this.extractCompleteText(record, event.action.dataIndex);
                    }
                    this.showCompleteText(textData, event.event.getTarget(), col, record);
                },
                scope: this
            });
        }
        this.addGlobalFindColumnActionConfig(col, index);
    },
    setupColumnActions: function (col, index) {
        this.setupAdditionalColumnActionConfig(col, index);
        if (!Ext.isEmpty(col.columnActions)) {
            if (!this.onMouseOverRegistrationComplete) {
                this.addListener('mouseover', this.mouseover, this);
                this.addListener('cellclick', function (grid, rowIndex, columnIndex, e) {
                    if (!e.eventProcessed) {
                        this.mouseover(e);
                    }
                }, this);
                this.onMouseOverRegistrationComplete = true;
            }
            var columnActions = col.columnActions;
            if (!Ext.isArray(columnActions)) {
                columnActions = [columnActions];
            }
            else {
                columnActions = columnActions.slice(0);
            }
            var defaultColumnsActionMode = 'menu';
            var columnActionsMode = col.columnActionsMode || defaultColumnsActionMode;
            var toolbarItems;
            var i = 0;
            if (columnActionsMode === 'menu') {
                for (i = 0; i < columnActions.length; i++) {
                    columnActions[i] = Ext.apply({}, columnActions[i]);
                    columnActions[i].xtype = 'menuitem';
                    columnActions[i].useMiniCellSelection = true;
                }
                columnActions = Pan.createActionBar(columnActions, this.makeHandler, this);
                toolbarItems = [{
                    cls: 'x-toolbar-grid-cell-hint',
                    menuAlign: 'tl-tl?',
                    menu: {id: 'columnaction-' + index, items: columnActions}
                }];
            }
            else if (columnActionsMode === 'mixed') {
                var menuColumnActions = [];
                var buttonColumnActions = [];
                for (i = 0; i < columnActions.length; i++) {
                    var mode = columnActions[i].columnActionsMode || defaultColumnsActionMode;
                    if (mode === 'menu') {
                        columnActions[i] = Ext.apply({}, columnActions[i]);
                        columnActions[i].xtype = 'menuitem';
                        columnActions[i].useMiniCellSelection = true;
                        menuColumnActions.push(columnActions[i]);
                    }
                    else {
                        columnActions[i] = Ext.applyIf({text: ''}, columnActions[i]);
                        columnActions[i].useMiniCellSelection = true;
                        buttonColumnActions.push(columnActions[i]);
                    }
                }
                menuColumnActions = Pan.createActionBar(menuColumnActions, this.makeHandler, this);
                buttonColumnActions = Pan.createActionBar(buttonColumnActions, this.makeHandler, this);
                columnActions = buttonColumnActions.concat(menuColumnActions);
                toolbarItems = buttonColumnActions.concat(['->']);
                if (menuColumnActions.length > 0) {
                    toolbarItems.push({
                        cls: 'x-toolbar-grid-cell-hint',
                        menuAlign: 'tl-tl?',
                        menu: {id: 'columnaction-' + index, items: menuColumnActions}
                    });
                }
            }
            else {
                for (i = 0; i < columnActions.length; i++) {
                    columnActions[i] = Ext.applyIf({text: ''}, columnActions[i]);
                    columnActions[i].useMiniCellSelection = true;
                }
                toolbarItems = Pan.createActionBar(columnActions, this.makeHandler, this);
            }
            col.columnActions = columnActions;
            col.toolbar = {
                xtype: 'toolbar',
                cls: 'x-toolbar-grid-cell-hint ' + col.columnActionToolbarClass,
                items: toolbarItems
            };
        }
        else if (col.showFullTextInCell) {
            if (!this.onMouseOverRegistrationComplete) {
                this.addListener('mouseover', this.mouseover, this);
                this.onMouseOverRegistrationComplete = true;
            }
        }
        else {
            delete col.toolbar;
        }
    },
    supportsColumnActions: function (rowIndex, columnIndex) {
        var cellEl = this.getView().getCell(rowIndex, columnIndex);
        var cellText = cellEl.textContent || cellEl.innerText;
        if (cellText && cellText.trim()) {
            return true;
        }
        return false;
    },
    mouseover: function (e) {
        if (this.isDestroyed) {
            return;
        }
        var cell = this.findMiniCell(e);
        if (cell) {
            e.preventDefault();
            var columnIndex = this.view.findCellIndex(e.target);
            var column = this.colModel.getColumnAt(columnIndex);
            var rowIndex = this.view.findRowIndex(e.target);
            var editRowIndex = this.lastEdit && this.lastEdit.row;
            var editColIndex = this.lastEdit && this.lastEdit.col;
            if (Ext.isNumber(rowIndex) && column && column.toolbar && (!this.editing || editRowIndex !== rowIndex || editColIndex !== columnIndex)) {
                if (!this.supportsColumnActions(rowIndex, columnIndex, e)) {
                }
                else {
                    if (!this.isColumnActionMenuVisible()) {
                        this.cleanupColumnAction();
                        this.cellEventInfo = this.getCellEventInfo(rowIndex, columnIndex, e);
                        this.cellWindow = Ext.create({
                            layout: 'contextmenu',
                            xtype: "menu",
                            shadow: false,
                            cls: column.toolbar.cls,
                            items: column.toolbar,
                            scope: this
                        });
                        if (!this.cellWindow.el) {
                            this.cellWindow.render();
                        }
                        var numItems = column.columnActionsMode === "mixed" ? column.toolbar.items.length - 1 : column.toolbar.items.length;
                        var width = 30;
                        if (numItems - 1 > 0) {
                            width += (numItems - 1) * (20);
                        }
                        var cellAlignPosition = undefined;
                        var cellAlignOffset = undefined;
                        if (column.columnActionsMode === "mixed") {
                            var childWidth = 0;
                            var children = Ext.get(cell.dom).select('.x-grid3-cell-inner>*');
                            children = children.elements;
                            if (children.length > 0) {
                                for (var i = 0; i < children.length; i++) {
                                    var w = Ext.get(children[i]).getWidth();
                                    if (Ext.isNumber(w)) {
                                        childWidth += w;
                                    }
                                }
                            }
                            else if (cell.hasClass('active') && cell.getStyle("white-space") !== "normal") {
                                childWidth = cell.getTextWidth();
                            }
                            if (childWidth > 0) {
                                var innerCell = Ext.get(Ext.get(cell.dom).select('.x-grid3-cell-inner').elements[0]);
                                var cellWidth = cell.getWidth() - (innerCell ? innerCell.getPadding('lr') : 0);
                                var remainder = cellWidth - childWidth;
                                if (remainder < width) {
                                    cellAlignPosition = 'l-r';
                                    cellAlignOffset = [-remainder, 0];
                                    remainder = width;
                                }
                                width = remainder;
                            }
                        }
                        this.cellWindow.el.setWidth(width);
                        var xy = this.cellWindow.el.getAlignToXY(cell, cellAlignPosition ? cellAlignPosition : cell.hasClass('active') ? 'l-r' : 'r-r', cellAlignOffset ? cellAlignOffset : cell.hasClass('active') ? [-5, 0] : [0, 0]);
                        if (this.view.isIntersectingVerticalScroll(xy[0], this.cellWindow.getBox().width)) {
                            xy[0] = this.view.scroller.dom.getBoundingClientRect().right - 32;
                        }
                        if (!this.view.isIntersectingVerticalScroll(xy[0], this.cellWindow.getBox().width)) {
                            this.cellWindow.showAt(xy);
                            return;
                        }
                    }
                }
            }
        }
        if (!this.isColumnActionMenuVisible()) {
            this.cleanupColumnAction();
        }
    },
    isColumnActionMenuVisible: function () {
        for (var i = 0; i < this.colModel.getColumnCount(); i++) {
            var columnActionMenu = Ext.get("columnaction-" + i);
            var columnActionMenuVisible = columnActionMenu && columnActionMenu.isVisible();
            if (columnActionMenuVisible) {
                return true;
            }
        }
        return false;
    },
    cleanupColumnAction: function () {
        if (this.cellWindow) {
            delete this.cellWindow.scope;
            this.cellWindow.setVisible(false);
            this.cellWindow.destroy();
            this.cellWindow = undefined;
            delete this.cellEventInfo;
        }
    },
    cleanupColumnWindow: function () {
        if (this.columnWindow) {
            this.columnWindow.setVisible(false);
            this.columnWindow.destroy();
            this.columnWindow = undefined;
        }
    },
    makeHandler: function (o, action) {
        if (o.handler && o.handler.__extended) {
            return;
        }
        o.handler = Pan.base.util.createExtension(function (element, event) {
            var config = {grid: this, component: this, action: action, event: event, actionElement: element};
            if ((action.initialConfig && action.initialConfig.useMiniCellSelection || action.useMiniCellSelection) && this.cellEventInfo) {
                if (this.store.indexOf(this.cellEventInfo.record) < 0) {
                    this.cellEventInfo = this.getCellEventInfo(this.cellEventInfo.row, this.cellEventInfo.col, this.cellEventInfo.event);
                }
                Ext.applyIf(config, this.cellEventInfo);
            }
            else {
                var selModel = this.getSelectionModel();
                if (Ext.isFunction(selModel.getSelectedCell)) {
                    if (selModel.selection) {
                        config.record = selModel.selection.record;
                        config.row = selModel.selection.cell[0];
                        config.col = selModel.selection.cell[1];
                    }
                }
                else {
                    config.record = selModel.getSelections();
                    if (config.record) {
                        var firstRecord = config.record;
                        if (Ext.isArray(firstRecord)) {
                            firstRecord = firstRecord[0];
                        }
                        if (firstRecord) {
                            config.row = this.store.indexOfId(firstRecord.id);
                        }
                        else {
                            this.setDefaultRowForHandler(config);
                        }
                    }
                }
            }
            arguments.callee.superFunction.call(this, this, config, event);
        }, o.handler, this);
        o.handler.__extended = true;
    },
    setDefaultRowForHandler: function () {
    },
    setMenuItemVisible: function (menuItems, itemId, visible) {
        var item = menuItems.get(itemId);
        item.setVisible(visible);
        var separatorIndex = menuItems.indexOf(item) + 1;
        if (separatorIndex > 0 && separatorIndex < menuItems.length) {
            var separator = menuItems.get(separatorIndex);
            if (separator.itemCls === 'x-menu-sep') {
                separator.setVisible(visible);
            }
        }
    },
    handleHdDown: function (e, t) {
        var el = Ext.get(t);
        if (el.hasClass('x-grid3-hd-btn')) {
            var hd = this.findHeaderCell(t);
            var index = this.getCellIndex(hd);
            var ms = this.hmenu.items, cm = this.cm;
            var visible = cm.isSortable(index);
            ms.get('asc').setVisible(visible);
            this.grid.setMenuItemVisible(ms, 'desc', visible);
            this.grid.setMenuItemVisible(ms, 'columns', !this.grid.columnsHideable);
            var headerActions = cm.getColumnAt(index).headerActions;
            for (var i = 0; i < ms.items.length; i++) {
                var item = ms.items[i];
                var actionId = item.actionId;
                if (Ext.isDefined(actionId)) {
                    var visi = false;
                    if (headerActions) {
                        for (var j = 0; j < headerActions.length; j++) {
                            if (headerActions[j].actionId === actionId) {
                                visi = true;
                                break;
                            }
                        }
                    }
                    item.setVisible(visi);
                }
            }
        }
        arguments.callee.superFunction.apply(this, arguments);
    },
    handleHdMenuClick: function (item) {
        var returnVal = arguments.callee.superFunction.apply(this, arguments);
        var colIndex = this.hdCtxIndex, cm = this.cm, id = item.getItemId();
        var itemIndex;
        if (id !== 'asc' && id !== 'desc') {
            itemIndex = cm.getIndexById(id.substr(4));
            if (itemIndex != -1 && !item.checked) {
                cm.config.splice(colIndex + 1, 0, cm.config[itemIndex]);
                if (itemIndex > colIndex)
                    itemIndex++;
                cm.config.splice(itemIndex, 1);
                this.grid.reconfigure(this.grid.store, cm);
            }
        }
        return returnVal;
    },
    getColumnTooltip: function (i) {
        var tt = this.cm.getColumnTooltip(i);
        if (tt) {
            if (Ext.QuickTips.isEnabled()) {
                return Pan.base.htmlEncode('ext:qtip="' + tt + '"');
            }
            else {
                return Pan.base.htmlEncode('title="' + tt + '"');
            }
        }
        return '';
    },
    onDestroy: function () {
        if (this.cellWindow) {
            this.cellWindow.setVisible(false);
            this.cellWindow.destroy();
            this.cellWindow = undefined;
        }
        this.cleanupColumnWindow();
        if (Ext.isFunction(this.getSelectionModel().getCount)) {
            this.getSelectionModel().removeListener('selectionchange', this.validate, this);
            this.getSelectionModel().removeListener('selectionchange', this.updateSelectionCountText, this);
            this.store.removeListener("datachanged", this.updateSelectionCountText, this);
        }
        delete this.currentFirstFullyVisibleRecord;
        delete this.currentLastFullyVisibleRecord;
        this.store.removeListener("load", this.selectRecords, this);
        this.store.removeListener("afterload", this.scrollToLastPosition, this);
        this.view.removeListener('cursormove', this.saveScrollState, this);
        this.store.removeListener("load", this.scrollToLastPosition, this);
        this.removeListener('bodyscroll', this.saveScrollState, this);
        if (this.supportFastRender) {
            this.removeListener('bodyscroll', this.view.doFastRender, this.view);
            if (this.view && this.view.incrementalRenderBodyTask) {
                this.view.incrementalRenderBodyTask.cancel();
                delete this.view.incrementalRenderBodyTask;
            }
        }
        Pan.base.grid.GridPanel.superclass.onDestroy.apply(this, arguments);
    }
});
Ext.reg("pan-grid", Pan.base.grid.GridPanel);
Pan.base.grid.ContextMenuLayout = Ext.extend(Ext.layout.MenuLayout, {
    type: 'contextmenu', setContainer: function (ct) {
        this.monitorResize = !ct.floating;
        Ext.layout.MenuLayout.superclass.setContainer.call(this, ct);
    }
});
Ext.Container.LAYOUTS['contextmenu'] = Pan.base.grid.ContextMenuLayout;
Pan.base.grid.SpanningGridView = Pan.base.util.cextend(Ext.ux.grid.livegrid.GridView, "isLiveGrid", {
    spanningRowPlaceHolderForFastRenderDivBegin: '<div class="x-grid3-row {alt}" style="{tstyle}">',
    spanningRowPlaceHolderForFastRenderDivEnd: '</div>',
    constructor: function (config) {
        this.addEvents({'beforebufferload': true});
        Pan.base.grid.SpanningGridView.superclass.constructor.call(this, config);
    },
    onLoad: function () {
        if (this.isLiveGrid || !this.grid.storeScrollPosition) {
            return Pan.base.grid.SpanningGridView.superclass.onLoad.apply(this, arguments);
        }
    },
    scrollToBottom: function () {
        this.scroller.dom.scrollTop = this.scroller.dom.scrollHeight;
    },
    refresh: function (_headersToo) {
        if (!Ext.isDefined(this.grid))
            return;
        if (this.grid.supportFastRender) {
            if (this.incrementalRenderBodyTask) {
                this.incrementalRenderBodyTask.cancel();
                delete this.incrementalRenderBodyTask;
            }
            this.__willPerformFastRender = true;
        }
        Pan.base.grid.SpanningGridView.superclass.refresh.apply(this, arguments);
        if (this.grid.supportFastRender) {
            this.__willPerformFastRender = false;
            this.scroller.dom.scrollTop = 0;
            this.doFastRender();
            this.grid.scrollToLastPosition();
        }
    },
    initTemplates: function () {
        Pan.base.grid.SpanningGridView.superclass.initTemplates.call(this);
        var ts = this.templates;
        if (this.grid.hdMouseOverShowCompleteInfo) {
            ts.hcell = new Ext.Template('<td class="x-grid3-hd x-grid3-cell x-grid3-td-{id} {css}" style="{style}"><div {tooltip} {attr} class="x-grid3-hd-inner x-grid3-hd-{id}" unselectable="on" style="{istyle}">', this.grid.enableHdMenu ? '<a class="x-grid3-hd-btn" href="#"></a>' : '', '<div class="x-grid3-hd-over-show-complete-info"></div>', '{value}<img class="x-grid3-sort-icon" src="', Ext.BLANK_IMAGE_URL, '" />', '</div></td>');
        }
        ts.cell = new Ext.XTemplate('<td class="x-grid3-col x-grid3-cell x-grid3-td-{id} {css} ' + (this.grid.unselectable === "off" ? "x-grid-selectable" : "") + '" style="{cellHeight} {style}" tabIndex="0" {cellAttr}>', '<tpl if="tag == &quot;&quot;">', '<div class="x-grid3-cell-inner x-grid3-col-{id}" unselectable="' + (this.grid.unselectable || "on") + '" {attr}>{value}</div>', '</tpl>', '<tpl if="tag != &quot;&quot;">', '<div class="x-grid3-cell-inner x-grid3-col-{id} tag-cell" unselectable="' + (this.grid.unselectable || "on") + '" {attr}><div class="{tag}">{value}</div></div>', '</tpl>', '</td>');
        var spanningRowInnerTableArray = ['<table class="x-grid3-row-table" border="0" cellspacing="0" cellpadding="0" style="{tstyle}">', '<tbody>{[this.computeRow(values)]}', (this.enableRowBody ? '<tr class="x-grid3-row-body-tr" style="{bodyStyle}"><td colspan="{cols}" class="x-grid3-body-cell" tabIndex="0" hidefocus="on"><div class="x-grid3-row-body">{body}</div></td></tr>' : ''), '</tbody></table>'];
        var spanningRowXTemplateFunctions = {
            applyCellTemplate: function (value, cellData, r, c, isEllipsis, cellRowIndex) {
                if (!isEllipsis) {
                    if (cellData.column.doHTMLEncode !== false && Ext.isString(value) && value != "&#160;") {
                        value = Pan.base.htmlEncode(value);
                    }
                    if (Ext.isFunction(cellData.column.spanCellRenderer)) {
                        value = cellData.column.spanCellRenderer.call(cellData.column.scope, value, cellData.metaData, cellData.record, r, c, cellData.store, cellData.grid || cellData.metaData.grid);
                    }
                }
                cellData.metaData.value = value;
                if (Ext.isArray(cellData.metaData.tags) && cellData.metaData.tags[cellRowIndex]) {
                    cellData.metaData.tag = 'icon-tag icon-combo-' + cellData.metaData.tags[cellRowIndex];
                }
                else {
                    cellData.metaData.tag = '';
                }
                return cellData.cellTemplate.apply(cellData.metaData);
            }, computeRowAndColumnSpans: function (values) {
                var cells = values.cells;
                var metaDataArray = values.metaDataArray;
                var numCol = cells.length;
                var maxRowLength = 1;
                var colRowCells = [];
                var grid = values.grid;
                var r;
                for (var c = 0; c < numCol; c++) {
                    var cellData = cells[c];
                    var rowCells = colRowCells[c] = [];
                    if (!cellData.templateApplied) {
                        var rendererValue = cellData.metaData.value;
                        if (Ext.isArray(rendererValue)) {
                            var spanCellMapping = cellData.column.spanCellMapping || grid.spanCellMapping || 'value';
                            var spanCellRenderer = cellData.column.spanCellRenderer;
                            var rIndex = 0;
                            var length = rendererValue.length;
                            var showEllipsis = false;
                            var ellipsisEntryCount = cellData.column.showEllipsisEntryCount !== undefined ? cellData.column.showEllipsisEntryCount : grid.showEllipsisEntryCount;
                            if (ellipsisEntryCount !== undefined && rendererValue.length > ellipsisEntryCount) {
                                length = ellipsisEntryCount + 1;
                                showEllipsis = true;
                            }
                            for (r = 0; r < length; r++) {
                                var value = rendererValue[r];
                                if (value === Pan.base.SPAN_SLOT) {
                                    rowCells[rIndex] = Pan.base.SPAN_SLOT;
                                }
                                else {
                                    var rowspan = undefined;
                                    var colspan = undefined;
                                    if (!spanCellRenderer && Ext.isObject(value)) {
                                        rowspan = value.rowspan;
                                        colspan = value.colspan;
                                        value = value[spanCellMapping] || value.value || "";
                                    }
                                    var isEllipsis = showEllipsis && r === length - 1;
                                    if (isEllipsis) {
                                        value = cellData.column.showEllipsisValue || grid.showEllipsisValue;
                                    }
                                    var rc = rowCells[rIndex] = {
                                        cellData: cellData,
                                        r: r,
                                        c: c,
                                        value: value,
                                        isEllipsis: isEllipsis
                                    };
                                    if (rowspan || colspan) {
                                        if (colspan && colspan > 1) {
                                            rc.colspan = colspan;
                                        }
                                        if (rowspan) {
                                            if (rowspan > 1) {
                                                rc.rowspan = rowspan;
                                                for (var k = 1; k < rowspan; k++) {
                                                    rowCells[++rIndex] = Pan.base.SPAN_SLOT;
                                                }
                                            }
                                            else if (rowspan < 0 && r == rendererValue.length - 1) {
                                                rc.rowSpanRemaining = true;
                                            }
                                        }
                                    }
                                }
                                rIndex++;
                            }
                            rowCells.trueLength = rIndex;
                            if (!grid.getColumnModel().isHidden(c)) {
                                maxRowLength = Math.max(maxRowLength, rIndex);
                            }
                        }
                        else {
                            rowCells[0] = rendererValue.toString();
                            rowCells.trueLength = 1;
                        }
                    }
                    else {
                        rowCells[0] = cellData;
                        rowCells.trueLength = 1;
                    }
                }
                var hasExpander = grid.hasExpander;
                var expanderOffset = 1;
                if (grid.expanderConfig && grid.expanderConfig.expanderOffset)
                    expanderOffset = grid.expanderConfig.expanderOffset;
                grid.maxMiniCellRows = grid.maxMiniCellRows || [];
                grid.maxMiniCellRows[values.rowIndex] = maxRowLength;
                for (var l = 0; l < colRowCells.length; l++) {
                    var col = colRowCells[l];
                    var lastRow = col[col.length - 1];
                    if (Ext.isObject(lastRow)) {
                        lastRow.noCSS = true;
                    }
                    if (col.trueLength < maxRowLength) {
                        if (Ext.isObject(lastRow)) {
                            if (lastRow.rowSpanRemaining) {
                                lastRow.rowspan = maxRowLength - col.trueLength + 1;
                                break;
                            }
                        }
                        var meta;
                        if (Ext.isObject(lastRow) && lastRow.templateApplied) {
                            meta = Ext.apply({}, lastRow.metaData);
                            meta.css = meta.css.replace(/cell-invalid|x-cell-editable|x-grid3-dirty-cell/g, "");
                        }
                        else {
                            meta = Ext.apply({}, metaDataArray[l]);
                        }
                        meta.css += " x-grid-cell-void";
                        if (meta.cellVerticalAlign && col.length === 1) {
                            col[0].rowspan = maxRowLength;
                        }
                        else {
                            col[col.length] = {value: "", rowspan: maxRowLength - col.trueLength, metaData: meta};
                        }
                        if (hasExpander && l < expanderOffset) {
                            col[col.length - 1].rowspan++;
                        }
                    }
                    else {
                        if (hasExpander) {
                            if (l < expanderOffset) {
                                if (Ext.isObject(lastRow)) {
                                    if (!lastRow.templateApplied) {
                                        lastRow.rowspan = 2;
                                    }
                                    else if (Ext.isString(lastRow.value)) {
                                        lastRow.value = lastRow.value.replace("<td", "<td rowspan=2");
                                    }
                                }
                            }
                        }
                    }
                }
                values.maxRowLength = maxRowLength;
                values.colRowCells = colRowCells;
            }, computeRow: function (values) {
                var cells = values.cells;
                var cellTemplate = values.templates.cell;
                var metaDataArray = values.metaDataArray;
                var numCol = cells.length;
                this.computeRowAndColumnSpans(values);
                var maxRowLength = values.maxRowLength;
                var colRowCells = values.colRowCells;
                var r, c;
                var str = "";
                for (var j = 0; j < maxRowLength; j++) {
                    str += "<tr>";
                    for (var i = 0; i < numCol; i++) {
                        var colData = colRowCells[i];
                        if (j < colData.length) {
                            var cd = colData[j];
                            if (cd != Pan.base.SPAN_SLOT) {
                                if (Ext.isObject(cd)) {
                                    if (cd.cellData) {
                                        cd.cellData.metaData.css = metaDataArray[i].css;
                                        cd.cellData.metaData.cellAttr = metaDataArray[i].cellAttr;
                                        if (cd.noCSS != true) {
                                            cd.cellData.metaData.css = cd.cellData.metaData.css || "";
                                            if (cd.cellData.column.miniCellRowLines !== undefined ? cd.cellData.column.miniCellRowLines : cd.cellData.metaData.grid.miniCellRowLines) {
                                                cd.cellData.metaData.css += " x-grid3-mini-cell";
                                            }
                                        }
                                        if (!cd.rowspan) cd.rowspan = 1;
                                        if (cd.rowspan || cd.colspan) {
                                            cd.cellData.metaData.cellAttr = '';
                                            if (cd.rowspan) {
                                                cd.cellData.metaData.cellAttr = cd.cellData.metaData.cellAttr || "";
                                                cd.cellData.metaData.cellAttr += " rowspan=" + cd.rowspan;
                                            }
                                            if (cd.colspan) {
                                                cd.cellData.metaData.cellAttr = cd.cellData.metaData.cellAttr || "";
                                                cd.cellData.metaData.cellAttr += " colspan=" + cd.colspan;
                                                cd.cellData.metaData.style = cd.cellData.metaData.style.replace(new RegExp("width:[^;]*;"), "");
                                            }
                                        }
                                        r = j;
                                        c = i;
                                        cd = this.applyCellTemplate(cd.value, cd.cellData, r, c, cd.isEllipsis, j);
                                    }
                                    else {
                                        if (cd.templateApplied) {
                                            cd = cd.value;
                                        }
                                        else if (cd.rowspan) {
                                            var metaData = cd.metaData;
                                            metaData.cellAttr = " rowspan=" + cd.rowspan;
                                            metaData.value = '';
                                            metaData.tag = '';
                                            cd = cellTemplate.apply(metaData);
                                        }
                                    }
                                }
                                str += cd;
                            }
                        }
                    }
                    str += "</tr>";
                }
                return str;
            }
        };
        ts.spanningRowPlaceHolderForFastRender = new Ext.XTemplate(this.spanningRowPlaceHolderForFastRenderDivBegin, this.spanningRowPlaceHolderForFastRenderDivEnd, spanningRowXTemplateFunctions);
        ts.spanningRowInnerTableForFastRender = new Ext.XTemplate(spanningRowInnerTableArray.join(""), spanningRowXTemplateFunctions);
        ts.spanningRow = new Ext.XTemplate(this.spanningRowPlaceHolderForFastRenderDivBegin, spanningRowInnerTableArray.join(""), this.spanningRowPlaceHolderForFastRenderDivEnd, spanningRowXTemplateFunctions);
    },
    fastRenderExtraPixelLines: 200,
    doFastRender: function () {
        var rows = this.getRows();
        if (rows && rows.length > 0) {
            var scrollerHeight = this.scroller.getHeight();
            var scrollTop = this.scroller.dom.scrollTop;
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (row.offsetTop >= scrollTop + scrollerHeight + this.fastRenderExtraPixelLines) {
                    break;
                }
                if (row.offsetTop + row.offsetHeight >= scrollTop) {
                    if (row.childNodes.length === 0) {
                        var index = row.rowIndex;
                        var html = this.doRender(this.getColumnData(), this.grid.store.getRange(index, index), this.grid.store, index, this.grid.colModel.getColumnCount(), this.grid.stripeRows, true);
                        Ext.fly(row).insertHtml('afterBegin', html);
                    }
                    this.processSingleRow(rows[i]);
                }
            }
        }
    },
    doRender: function (cs, rows, ds, startRow, colCount, stripe, fullRender) {
        var metaDataArray = [];
        var templates = this.templates;
        var cellTemplate = templates.cell;
        var rowTemplate = templates.row;
        var last = colCount - 1;
        var tstyle = 'width:' + this.getTotalWidth() + ';';
        var buf = [], cb, c, p = {}, rp = {tstyle: tstyle}, row;
        for (var j = 0, len = rows.length; j < len; j++) {
            row = rows[j];
            cb = [];
            var rowIndex = j + startRow;
            var isSpanning = Pan.global.isShowingGlobalFindPreview();
            for (var i = 0; i < colCount; i++) {
                c = cs[i];
                p.id = c.id;
                p.css = i === 0 ? 'x-grid3-cell-first ' : (i == last ? 'x-grid3-cell-last ' : '');
                p.attr = p.cellAttr = '';
                p.grid = this.grid;
                if (p.grid.cellHeight) {
                    p.cellHeight = "height:" + p.grid.cellHeight + ";";
                }
                var v = row.data[c.name];
                if (c.doHTMLEncode !== false && Ext.isString(v) && v !== "&#160;") {
                    v = Pan.base.htmlEncode(v);
                }
                p.value = c.renderer.call(c.scope, v, p, row, rowIndex, i, ds, p.grid);
                p.style = c.style;
                if (Ext.isEmpty(p.value)) {
                    p.value = '&#160;';
                }
                if (c.scope && c.scope.wrap === false) {
                    p.css += " x-grid-cell-nowrap";
                }
                p.tags = [];
                p.tag = '';
                if (c.scope && c.scope.tagable == true) {
                    var tagFn = p.grid.getColorCode;
                    if (Ext.isFunction(tagFn)) {
                        var rc, colorcode, col_dataIndex = c.scope.dataIndex, col_type = c.scope.type;
                        if (Ext.isArray(v)) {
                            for (rc = 0; rc < v.length; rc++) {
                                if (Ext.isNumber(p.grid.showEllipsisEntryCount) && rc == p.grid.showEllipsisEntryCount) {
                                    break;
                                }
                                colorcode = tagFn(row, v[rc], col_dataIndex, col_type);
                                if (!Ext.isEmpty(colorcode)) {
                                    p.tags.push('icon-tag icon-combo-' + colorcode);
                                }
                                else {
                                    p.tags.push('');
                                }
                            }
                        }
                        else {
                            colorcode = tagFn(row, v, col_dataIndex, col_type);
                            if (!Ext.isEmpty(colorcode)) {
                                p.tag = 'icon-tag icon-combo-' + colorcode;
                            }
                        }
                    }
                }
                var metaData = Ext.apply({}, p);
                if (!metaDataArray[i]) {
                    metaDataArray[i] = metaData;
                }
                if (this.grid.colModel.isCellEditable(i, rowIndex)) {
                    metaData.css += " x-cell-editable";
                }
                if (i !== this.grid.getInternalScrollOffsetColumn()) {
                    var cellError = false;
                    if (row.error && Ext.isDefined(row.error[c.name])) {
                        metaData.css += " cell-invalid";
                        metaData.value = '<div qclass="x-form-invalid-tip"' + (row.error[c.name] ? ' qtip="' + row.error[c.name] + '"' : '') + '>' + metaData.value + '</div>';
                        cellError = true;
                    }
                    if (!cellError && this.markDirty && row.dirty && row.modified && Ext.isDefined(row.modified[c.name])) {
                        metaData.css += ' x-grid3-dirty-cell';
                    }
                }
                if (c.cellVerticalAlign || this.grid.cellVerticalAlign) {
                    if (!Ext.isArray(metaData.value)) {
                        metaData.cellVerticalAlign = c.cellVerticalAlign || this.grid.cellVerticalAlign;
                        metaData.value = [metaData.value];
                        metaData.style = (Ext.isString(metaData.style) ? metaData.style : "") + "vertical-align:" + metaData.cellVerticalAlign + ";";
                    }
                }
                if ((Ext.isObject(metaData.value) || Ext.isArray(metaData.value))) {
                    cb[cb.length] = {
                        value: row.data[c.name],
                        metaData: metaData,
                        record: row,
                        rowIndex: rowIndex,
                        colIndex: i,
                        store: ds,
                        cellTemplate: cellTemplate,
                        column: c
                    };
                    isSpanning = true;
                }
                else {
                    if (Ext.isArray(metaData.tags) && metaData.tags[0]) {
                        metaData.tag = metaData.tags[0];
                    }
                    cb[cb.length] = {value: cellTemplate.apply(metaData), metaData: metaData, templateApplied: true};
                }
            }
            var alt = [];
            if (stripe && ((rowIndex + 1) % 2 === 0)) {
                alt[0] = 'x-grid3-row-alt';
            }
            if (row.dirty) {
                alt[1] = ' x-grid3-dirty-row';
            }
            rp.cols = colCount;
            if (this.getRowClass) {
                alt[2] = this.getRowClass(row, rowIndex, rp, ds);
            }
            rp.alt = alt.join(' ');
            if (isSpanning || this.grid.supportFastRender) {
                rp.cells = cb;
                rp.templates = templates;
                rp.metaDataArray = metaDataArray;
                rp.grid = this.grid;
                rp.rowIndex = Ext.isFunction(ds.getRealIndex) ? ds.getRealIndex(rowIndex) : rowIndex;
                if (fullRender) {
                    buf[buf.length] = templates.spanningRowInnerTableForFastRender.apply(rp);
                }
                else if (this.grid.supportFastRender && this.__willPerformFastRender) {
                    buf[buf.length] = templates.spanningRowPlaceHolderForFastRender.apply(rp);
                }
                else {
                    buf[buf.length] = templates.spanningRow.apply(rp);
                }
            }
            else {
                rp.cells = "";
                for (var k = 0; k < cb.length; k++) {
                    if (cb[k].value) {
                        rp.cells += cb[k].value;
                    }
                }
                buf[buf.length] = rowTemplate.apply(rp);
            }
        }
        return buf.join('');
    },
    syncHeaderScroll: function () {
        Pan.base.grid.SpanningGridView.superclass.syncHeaderScroll.apply(this, arguments);
    },
    isIntersectingVerticalScroll: function (x, w) {
        var scrollRect = this.scroller.dom.getBoundingClientRect();
        return (scrollRect.right < x + w);
    },
    getColumnData: function () {
        var cs = Pan.base.grid.SpanningGridView.superclass.getColumnData.apply(this, arguments);
        var cm = this.cm, colCount = cm.getColumnCount();
        for (var i = 0; i < colCount; i++) {
            cs[i].getFilterString = cm.config[i].getFilterString;
            cs[i].spanCellRenderer = cm.config[i].spanCellRenderer;
            cs[i].miniCellRowLines = cm.config[i].miniCellRowLines;
            cs[i].spanCellMapping = cm.config[i].spanCellMapping;
            cs[i].doHTMLEncode = cm.config[i].doHTMLEncode;
            cs[i].cellVerticalAlign = cm.config[i].cellVerticalAlign;
            cs[i].showEllipsisEntryCount = cm.config[i].showEllipsisEntryCount;
            cs[i].showEllipsisValue = cm.config[i].showEllipsisValue;
        }
        return cs;
    },
    updateAllColumnWidths: function () {
        var tw = this.getTotalWidth(), clen = this.cm.getColumnCount(), ws = [], len, i;
        for (i = 0; i < clen; i++) {
            ws[i] = this.getColumnWidth(i);
        }
        if (this.innerHd) {
            this.innerHd.firstChild.style.width = this.getOffsetWidth();
            this.innerHd.firstChild.firstChild.style.width = tw;
            this.mainBody.dom.style.width = tw;
            for (i = 0; i < clen; i++) {
                var hd = this.getHeaderCell(i);
                hd.style.width = ws[i];
            }
            var ns = this.getRows(), row, trow;
            for (i = 0, len = ns.length; i < len; i++) {
                row = ns[i];
                if (!row.style) {
                    continue;
                }
                row.style.width = tw;
                if (row.firstChild) {
                    row.firstChild.style.width = tw;
                    trow = row.firstChild.rows[0];
                    for (var j = 0; j < clen; j++) {
                        trow.childNodes[j].style.width = ws[j];
                    }
                }
            }
            this.onAllColumnWidthsUpdated(ws, tw);
        }
    },
    updateColumnWidth: function (col) {
        var w = this.getColumnWidth(col);
        var tw = this.getTotalWidth();
        this.innerHd.firstChild.style.width = this.getOffsetWidth();
        this.innerHd.firstChild.firstChild.style.width = tw;
        this.mainBody.dom.style.width = tw;
        var hd = this.getHeaderCell(col);
        hd.style.width = w;
        var ns = this.getRows(), row;
        for (var i = 0, len = ns.length; i < len; i++) {
            row = ns[i];
            row.style.width = tw;
            if (row.firstChild) {
                row.firstChild.style.width = tw;
                if (row.firstChild.rows) {
                    var children = row.firstChild.rows[0].childNodes;
                    var realCol = col;
                    var lastColSpan = undefined, colspan = undefined;
                    var lastColSpanIndex = undefined;
                    for (var j = 0; j <= col && j < children.length; j++) {
                        colspan = children[j].colSpan;
                        if (colspan && colspan > 1) {
                            realCol -= colspan - 1;
                            lastColSpanIndex = j;
                            lastColSpan = colspan;
                        }
                    }
                    if (!lastColSpanIndex || (col - lastColSpanIndex > lastColSpan)) {
                        children[realCol].style.width = w;
                    }
                }
            }
        }
        this.onColumnWidthUpdated(col, w, tw);
    },
    updateColumnHidden: function (col, hidden) {
        var tw = this.getTotalWidth();
        this.innerHd.firstChild.style.width = this.getOffsetWidth();
        this.innerHd.firstChild.firstChild.style.width = tw;
        this.mainBody.dom.style.width = tw;
        var display = hidden ? 'none' : '';
        var hd = this.getHeaderCell(col);
        hd.style.display = display;
        var ns = this.getRows(), row;
        for (var i = 0, len = ns.length; i < len; i++) {
            row = ns[i];
            if (row.style) {
                row.style.width = tw;
            }
            if (row.firstChild) {
                row.firstChild.style.width = tw;
                var td = row.firstChild.getElementsByTagName("td")[col];
                var className = td.className;
                if (className.indexOf("x-grid3-mini-cell") < 0) {
                    for (var miniRow = 0; miniRow < row.firstChild.rows.length; miniRow++) {
                        var cc = row.firstChild.rows[miniRow].childNodes[col];
                        if (cc && cc.className.indexOf("x-grid3-mini-cell") < 0) {
                            cc.style.display = display;
                        }
                    }
                }
                else {
                    var clsName = '';
                    var classes = className.split(" ");
                    for (var cls = 0; cls < classes.length; cls++) {
                        if (classes[cls].indexOf("x-grid3-td-") >= 0) {
                            clsName = classes[cls];
                        }
                    }
                    var tds = row.firstChild.getElementsByClassName(clsName);
                    for (var t = 0; t < tds.length; t++) {
                        var c = tds[t];
                        if (c) {
                            c.style.display = display;
                        }
                    }
                }
            }
        }
        this.onColumnHiddenUpdated(col, hidden, tw);
        delete this.lastViewWidth;
        this.layout();
    },
    renderUI: function () {
        var loadMask = this.loadMask;
        this.loadMask = Ext.apply({}, this.loadMask);
        Pan.base.grid.SpanningGridView.superclass.renderUI.apply(this, arguments);
        this.loadMask = loadMask;
        var actions = this.grid.columnHeaderActions;
        if (actions) {
            var v = this.grid.view;
            if (v.hmenu) {
                for (var i = 0; i < actions.length; i++) {
                    v.hmenu.add(actions[i]);
                }
            }
        }
        if (this.hmenu) {
            this.hmenu.cls = this.grid.theme;
        }
        if (this.colMenu) {
            this.colMenu.cls = this.grid.theme;
        }
    },
    onDelayRowOver: function () {
        delete this.onRowOverTask;
        var currentRowOverRow = this.currentRowOverRow;
        var oldRowOverRow = this.grid.rowOverRow;
        if (Ext.isDefined(oldRowOverRow)) {
            if (oldRowOverRow !== currentRowOverRow) {
                delete this.grid.rowOverRow;
                this.refreshRow(oldRowOverRow);
            }
        }
        if (oldRowOverRow !== currentRowOverRow) {
            this.grid.rowOverRow = currentRowOverRow;
            this.refreshRow(currentRowOverRow);
        }
    },
    onRowOver: function (e, t) {
        var row;
        if ((row = this.findRowIndex(t)) !== false) {
            this.addRowClass(row, 'x-grid3-row-over');
        }
        var col = this.findCellIndex(t);
        if (Ext.isNumber(col)) {
            if (this.grid.colModel.isCellEditable(col, row) && this.grid.enableCellEditing) {
                var id = this.grid.colModel.getColumnAt(col).id;
                this.fly(this.getRow(row)).select('td.x-grid3-td-' + id).addClass('x-cell-editable-over');
            }
        }
        if (this.grid.action && this.grid.showRowActionsOnlyForSelectedRow) {
            this.currentRowOverRow = row;
            if (!this.onRowOverTask) {
                this.onRowOverTask = new Ext.util.DelayedTask(this.onDelayRowOver, this);
                this.onRowOverTask.delay(200);
            }
        }
    },
    onRowOut: function (e, t) {
        var row;
        if ((row = this.findRowIndex(t)) !== false && !e.within(this.getRow(row), true)) {
            this.removeRowClass(row, 'x-grid3-row-over');
        }
        var col = this.findCellIndex(t);
        if (Ext.isNumber(col)) {
            if (this.grid.colModel.isCellEditable(col, row)) {
                var id = this.grid.colModel.getColumnAt(col).id;
                this.fly(this.getRow(row)).select('td.x-grid3-td-' + id).removeClass('x-cell-editable-over');
            }
        }
    },
    renderRows: function (startRow, endRow) {
        if (endRow < startRow) {
            return;
        }
        return Pan.base.grid.SpanningGridView.superclass.renderRows.apply(this, arguments);
    }
});
Ext.apply(Pan.base.grid.SpanningGridView.prototype, {
    focusRow: function (row) {
        if (!this.isLiveGrid && this.grid.disableFocusRowOnRowSelectWhenRowHeightExceedsTableHeight) {
            var resolved = this.resolveCell(row, 0, false);
            if (resolved && resolved.row) {
                var rowEl = resolved.row, c = this.scroller.dom;
                if (rowEl.offsetHeight > c.clientHeight) {
                    return;
                }
            }
        }
        return Pan.base.grid.SpanningGridView.superclass.focusRow.apply(this, arguments);
    }, ensureVisible: function (row, col, hscroll) {
        if (!this.isLiveGrid) {
            var resolved = this.resolveCell(row, col, hscroll);
            if (!resolved || !resolved.row) {
                return;
            }
            var rowEl = resolved.row, cellEl = resolved.cell, c = this.scroller.dom, ctop = 0, p = rowEl,
                stop = this.el.dom;
            while (p && p != stop) {
                ctop += p.offsetTop;
                p = p.offsetParent;
            }
            ctop -= this.mainHd.dom.offsetHeight;
            stop = parseInt(c.scrollTop, 10);
            var cbot = ctop + rowEl.offsetHeight, ch = c.clientHeight, sbot = stop + ch;
            if (ctop < stop) {
                c.scrollTop = ctop;
            }
            else if (cbot > sbot) {
                if (rowEl.offsetHeight > c.clientHeight) {
                    c.scrollTop = cbot - ch - rowEl.offsetHeight;
                }
                else {
                    c.scrollTop = cbot - ch;
                }
            }
            if (hscroll !== false) {
                var cleft = parseInt(cellEl.offsetLeft, 10);
                var cright = cleft + cellEl.offsetWidth;
                var sleft = parseInt(c.scrollLeft, 10);
                var sright = sleft + c.clientWidth;
                if (cleft < sleft) {
                    c.scrollLeft = cleft;
                }
                else if (cright > sright) {
                    c.scrollLeft = cright - c.clientWidth;
                }
            }
            return this.getResolvedXY(resolved);
        }
        return Pan.base.grid.SpanningGridView.superclass.ensureVisible.apply(this, arguments);
    }, showLoadMask: function (show) {
        if (!this.loadMask || show == this.loadMaskDisplayed) {
            return;
        }
        if (show) {
            this.grid.loadMask.show();
        }
        else {
            this.grid.loadMask.hide();
        }
        this.loadMaskDisplayed = show;
    }, refreshRow: function (record) {
        var attr, index;
        if (this.isLiveGrid) {
            var ds = this.ds;
            if (typeof record == 'number') {
                index = record;
                record = ds.getAt(index);
            }
            else {
                index = ds.indexOf(record);
            }
            var viewIndex = index + this.ds.bufferRange[0];
            var max = this.rowIndex + this.visibleRows;
            max += Math.max(this.rowClipped, this.lastRowHasMultipleMiniRowsAndIsClipped);
            if (viewIndex < this.rowIndex || viewIndex >= max) {
                this.fireEvent("rowupdated", this, viewIndex, record);
                return;
            }
            this.insertRows(ds, index, index, true);
            var row1 = this.getRow(index);
            if (row1) {
                attr = document.createAttribute('rowid');
                attr.nodeValue = record.data.name;
                row1.firstChild.firstChild.firstChild.attributes.setNamedItem(attr);
            }
            this.fireEvent("rowupdated", this, viewIndex, record);
        }
        else {
            var result = Pan.base.grid.SpanningGridView.superclass.refreshRow.apply(this, arguments);
            index = this.ds.indexOf(record);
            if (index >= 0) {
                attr = document.createAttribute('rowid');
                attr.nodeValue = record.data.name;
                var row = this.getRow(index);
                if (row.firstChild) {
                    row.firstChild.firstChild.firstChild.attributes.setNamedItem(attr);
                }
            }
            return result;
        }
    }, makeAdjustmentsToVisibleRows: function () {
        if (this.isLiveGrid) {
            this.lastRowHasMultipleMiniRowsAndIsClipped = 0;
            var rows = this.getRows();
            if (rows) {
                var i, rh;
                var totalRows = 0;
                for (i = 0; i < rows.length; i++) {
                    rh = rows[i].offsetHeight;
                    totalRows += Math.floor(rh / this.rowHeight);
                    if (totalRows == this.visibleMiniRows) {
                        i++;
                        break;
                    }
                    else if (totalRows > this.visibleMiniRows) {
                        this.lastRowHasMultipleMiniRowsAndIsClipped = 1;
                        break;
                    }
                }
                this.visibleRows = i;
            }
        }
    }, getVisibleMiniRows: function () {
        var totalRows = 0;
        var rows = this.getRows();
        if (rows) {
            var i, rh;
            for (i = 0; i < rows.length; i++) {
                rh = rows[i].offsetHeight;
                totalRows += Math.floor(rh / this.rowHeight);
                if (totalRows == this.visibleMiniRows) {
                    i++;
                    break;
                }
                else if (totalRows > this.visibleMiniRows) {
                    break;
                }
            }
        }
        return totalRows;
    }, makeAdjustmentsToLiveScroll: function (updateLiveRowsCursor) {
        this.makeAdjustmentsToVisibleRows();
        if (Ext.isNumber(updateLiveRowsCursor)) {
            this.updateLiveRows(updateLiveRowsCursor);
        }
        this.adjustBufferInset();
    }, onAllColumnWidthsUpdated: function (_ws, _tw) {
        Pan.base.grid.SpanningGridView.superclass.onAllColumnWidthsUpdated.apply(this, arguments);
        if (this.isLiveGrid) {
            this.makeAdjustmentsToLiveScroll();
        }
    }, onColumnWidthUpdated: function (_col, _w, _tw) {
        Pan.base.grid.SpanningGridView.superclass.onColumnWidthUpdated.apply(this, arguments);
        if (this.isLiveGrid) {
            this.makeAdjustmentsToLiveScroll();
        }
    }, onColumnMove: function (cm, oldIndex, newIndex) {
        if (this.isLiveGrid) {
            this.indexMap = null;
            this.replaceLiveRows(this.rowIndex, true, undefined, {visibleRows: this.visibleMiniRows});
            this.updateHeaders();
            this.updateHeaderSortState();
            this.afterMove(newIndex);
            this.grid.fireEvent('columnmove', oldIndex, newIndex);
        }
        else {
            return Pan.base.grid.SpanningGridView.superclass.onColumnMove.apply(this, arguments);
        }
    }, refreshCurrentRows: function () {
        this.grid.stopEditing(true);
        var result = this.reRenderBody();
        this.mainBody.update(result).setWidth(this.getTotalWidth());
        this.processRows(0, false);
    }, reRenderBody: function () {
        var rows = this.getRows();
        if (rows && rows.length > 0) {
            var startRow = rows[0].rowIndex;
            var endRow = rows[rows.length - 1].rowIndex;
            var offset = this.ds && this.ds.bufferRange ? this.ds.bufferRange[0] : 0;
            startRow = startRow - offset;
            endRow = endRow - offset;
            var markup = this.renderRows(startRow, Math.max(startRow, endRow));
            return this.templates.body.apply({rows: markup});
        }
    }, renderBody: function () {
        if (this.isLiveGrid) {
            this.makeAdjustmentsToVisibleRows();
            var markup = this.renderRows(0, Math.max(0, this.visibleRows - 1));
            return this.templates.body.apply({rows: markup});
        }
        else {
            var store = this.grid.store;
            var count = store.getCount();
            if (this.__willPerformFastRender && count > 0) {
                return this.incrementalRenderBody(true);
            }
            else {
                return Pan.base.grid.SpanningGridView.superclass.renderBody.apply(this, arguments);
            }
        }
    }, syncFocusEl: function (_row, _col, _hscroll) {
        if (this.getRows().length > 0) {
            return Pan.base.grid.SpanningGridView.superclass.syncFocusEl.apply(this, arguments);
        }
    }, incrementalRenderBody: function (restartAndReturnHTML) {
        var store = this.grid.store;
        var count = store.getCount();
        var tstyle = 'width:' + this.getTotalWidth() + ';';
        var div = this.spanningRowPlaceHolderForFastRenderDivBegin.replace('{tstyle}', tstyle);
        var stripe = this.grid.stripeRows;
        var records = store.getRange(0, count - 1);
        var rowParams = {tstyle: tstyle, cols: this.grid.colModel.getColumnCount()};
        var rows = this.getRows();
        var rowsLength = rows.length;
        var firstRowIndex = 0;
        if (!restartAndReturnHTML && rowsLength > 0) {
            if (rows[0].rowIndex !== 0) {
                count = rows[0].rowIndex;
            }
            else {
                firstRowIndex = rows[rowsLength - 1].rowIndex + 1;
            }
        }
        var i = firstRowIndex;
        var rv = [];
        for (var j = 0; j < 200 && i < count; j++, i++) {
            var alt = [];
            if (stripe && ((i + 1) % 2 === 0)) {
                alt[0] = 'x-grid3-row-alt';
            }
            if (records[i].dirty) {
                alt[1] = ' x-grid3-dirty-row';
            }
            if (this.getRowClass) {
                alt[2] = this.getRowClass(records[i], i, rowParams, store);
            }
            alt = alt.join(' ');
            rv.push(div.replace('{alt}', alt) + this.spanningRowPlaceHolderForFastRenderDivEnd);
        }
        var result = rv.join("");
        if (!restartAndReturnHTML) {
            Ext.fly(this.mainBody).insertHtml('beforeEnd', result);
            rows = this.getRows();
            for (var k = rowsLength, l = firstRowIndex; k < rows.length; k++) {
                rows[k].rowIndex = l++;
            }
        }
        if (i < count) {
            if (!this.incrementalRenderBodyTask) {
                this.incrementalRenderBodyTask = new Ext.util.DelayedTask(this.incrementalRenderBody, this);
            }
            this.incrementalRenderBodyTask.delay(10);
        }
        else {
            if (this.incrementalRenderBodyTask) {
                var incrementalRenderBodyTask = this.incrementalRenderBodyTask;
                incrementalRenderBodyTask.cancel();
                delete this.incrementalRenderBodyTask;
                if (incrementalRenderBodyTask.afterTask) {
                    var afterTask = incrementalRenderBodyTask.afterTask;
                    delete incrementalRenderBodyTask.afterTask;
                    afterTask();
                }
            }
        }
        return result;
    }, onAdd: function (ds, records, index) {
        if (this.isLiveGrid) {
            this.updateLiveRows(index, true, true, {forceOutOfRange: true});
        }
        else {
            Pan.base.grid.SpanningGridView.superclass.onAdd.apply(this, arguments);
        }
    }, onUpdate: function (_ds, _record) {
        Pan.base.grid.SpanningGridView.superclass.onUpdate.apply(this, arguments);
        if (this.isLiveGrid) {
            this.makeAdjustmentsToLiveScroll();
        }
    }, layout: function () {
        Pan.base.grid.SpanningGridView.superclass.layout.apply(this, arguments);
        if (this.isLiveGrid) {
            this.makeAdjustmentsToLiveScroll();
        }
        else if (this.grid.supportFastRender) {
            this.doFastRender();
        }
    }, adjustVisibleRows: function () {
        if (this.rowHeight == -1) {
            if (this.getRows()[0]) {
                this.rowHeight = this.getRows()[0].offsetHeight;
                if (this.rowHeight <= 0) {
                    this.rowHeight = Pan.base.Constants.liveGridMiniRowHeight;
                }
            }
            else {
                this.rowHeight = Pan.base.Constants.liveGridMiniRowHeight;
            }
        }
        this.isScrolling = false;
        var g = this.grid, ds = g.store;
        var c = g.getGridEl();
        var cm = this.cm;
        var size = c.getSize();
        var width = size.width;
        var vh = size.height;
        var vw = width - this.getScrollOffset();
        if (cm.getTotalWidth() > vw) {
            vh -= this.horizontalScrollOffset;
        }
        vh -= this.mainHd.getHeight();
        var totalLength = ds.totalLength || 0;
        var visibleRows = Math.max(1, Math.floor(vh / this.rowHeight));
        this.visibleMiniRows = visibleRows;
        this.makeAdjustmentsToVisibleRows();
        this.rowClipped = 0;
        if (totalLength > visibleRows && this.rowHeight / 3 < (vh - (visibleRows * this.rowHeight))) {
            visibleRows = Math.min(visibleRows + 1, totalLength);
            this.rowClipped = 1;
        }
        if (this.visibleRows == visibleRows) {
            return;
        }
        this.visibleRows = visibleRows;
        if (this.isBuffering && !this.isPrebuffering) {
            return;
        }
        if (this.rowIndex + (visibleRows - this.rowClipped) > totalLength) {
            this.rowIndex = Math.max(0, totalLength - (visibleRows - this.rowClipped));
            this.lastRowIndex = this.rowIndex;
        }
        this.updateLiveRows(this.rowIndex, true);
    }, handleWheel: function (e) {
        if (this.isLiveGrid) {
            if (this.rowHeight == -1) {
                e.stopPropagation();
                return;
            }
            var d = e.getWheelDelta();
            this.adjustScrollerPos(-(d * this.rowHeight));
            e.stopPropagation();
        }
        else {
            Pan.base.grid.SpanningGridView.superclass.handleWheel.apply(this, arguments);
        }
    }, onLiveScroll: function () {
        var forceRepaint = this.softwareScroll;
        var softwareScrollCallback = this.softwareScrollCallback;
        delete this.softwareScroll;
        delete this.softwareScrollCallback;
        var scrollTop = this.liveScroller.dom.scrollTop;
        var cursor = Math.floor((scrollTop) / this.rowHeight);
        this.rowIndex = cursor;
        if (cursor == this.lastRowIndex) {
            return;
        }
        this.isScrolling = true;
        var storeLoadOccurred = this.updateLiveRows(cursor, forceRepaint, undefined, {visibleRows: this.visibleMiniRows});
        if (!storeLoadOccurred) {
            this.makeAdjustmentsToVisibleRows();
            var totalRows = cursor + this.visibleRows;
            if (totalRows < this.grid.store.getTotalCount()) {
                this.makeAdjustmentsToLiveScroll(cursor);
            }
            if (softwareScrollCallback) {
                softwareScrollCallback();
            }
        }
        this.lastScrollPos = this.liveScroller.dom.scrollTop;
    }, liveBufferUpdate: function (records, options, success) {
        if (success === true) {
            this.adjustBufferInset();
            this.fireEvent('buffer', this, this.ds, this.rowIndex, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength, options);
            this.grid.selModel.replaceSelections(records);
            this.isBuffering = false;
            this.isPrebuffering = false;
            this.showLoadMask(false);
            if (this.requestQueue >= 0) {
                if (!this.isInRange(this.rowIndex)) {
                    var offset = this.requestQueue;
                    this.requestQueue = -1;
                    this.updateLiveRows(offset);
                    return;
                }
            }
            if (this.isInRange(this.rowIndex)) {
                this.replaceLiveRows(this.rowIndex, true, undefined, {visibleRows: this.visibleMiniRows});
                this.makeAdjustmentsToLiveScroll(this.rowIndex);
            }
            else {
                this.updateLiveRows(this.rowIndex);
            }
            return;
        }
        else {
            this.fireEvent('bufferfailure', this, this.ds, options);
        }
        this.requestQueue = -1;
        this.isBuffering = false;
        this.isPrebuffering = false;
        this.showLoadMask(false);
    }, updateLiveRows: function (index, forceRepaint, forceReload, additionalConfig) {
        if (this.grid.isDisableLiveRowUpdate()) {
            return;
        }
        var visibleRows = this.visibleRows;
        if (additionalConfig && Ext.isNumber(additionalConfig.visibleRows)) {
            visibleRows = additionalConfig.visibleRows;
        }
        var forceOutOfRange = false;
        if (additionalConfig && additionalConfig.forceOutOfRange) {
            forceOutOfRange = additionalConfig.forceOutOfRange;
        }
        var inRange = !forceOutOfRange && this.isInRange(index);
        if (this.isBuffering) {
            if (this.isPrebuffering) {
                if (inRange) {
                    this.replaceLiveRows(index, forceRepaint, undefined, additionalConfig);
                }
                else {
                    this.showLoadMask(true);
                }
            }
            this.fireEvent('cursormove', this, index, Math.min(this.ds.totalLength, visibleRows - this.rowClipped), this.ds.totalLength);
            this.requestQueue = index;
            return false;
        }
        var lastIndex = this.lastIndex;
        this.lastIndex = index;
        inRange = !forceOutOfRange && this.isInRange(index);
        var down = false;
        if (inRange && forceReload !== true) {
            this.replaceLiveRows(index, forceRepaint, undefined, additionalConfig);
            this.fireEvent('cursormove', this, index, Math.min(this.ds.totalLength, visibleRows - this.rowClipped), this.ds.totalLength);
            if (index > lastIndex) {
                down = true;
                var totalCount = this.ds.totalLength;
                if (index + visibleRows + this.nearLimit <= this.ds.bufferRange[1]) {
                    return false;
                }
                if (this.ds.bufferRange[1] + 1 >= totalCount) {
                    return false;
                }
            }
            else if (index < lastIndex) {
                down = false;
                if (this.ds.bufferRange[0] <= 0) {
                    return false;
                }
                if (index - this.nearLimit > this.ds.bufferRange[0]) {
                    return false;
                }
            }
            else {
                return false;
            }
            this.isPrebuffering = true;
        }
        this.isBuffering = true;
        var bufferOffset = this.getPredictedBufferIndex(index, inRange, down);
        if (!inRange) {
            this.showLoadMask(true);
        }
        this.fireEvent('beforebufferload', this);
        this.ds.suspendEvents();
        var sInfo = this.ds.sortInfo;
        var params = {};
        if (this.ds.lastOptions) {
            Ext.apply(params, this.ds.lastOptions.params);
        }
        params.start = bufferOffset;
        params.limit = this.ds.bufferSize;
        if (sInfo) {
            params.dir = sInfo.direction;
            params.sort = sInfo.field;
        }
        var opts = {
            forceRepaint: forceRepaint,
            callback: this.liveBufferUpdate,
            scope: this,
            params: params,
            suspendLoadEvent: true
        };
        this.fireEvent('beforebuffer', this, this.ds, index, Math.min(this.ds.totalLength, visibleRows - this.rowClipped), this.ds.totalLength, opts);
        this.ds.load(opts);
        this.ds.resumeEvents();
        return true;
    }, replaceLiveRows: function (cursor, forceReplace, processRows, additionalConfig) {
        var visibleRows = this.visibleRows;
        if (additionalConfig && Ext.isNumber(additionalConfig.visibleRows)) {
            visibleRows = additionalConfig.visibleRows;
        }
        var spill = cursor - this.lastRowIndex;
        if (spill == 0 && forceReplace !== true) {
            return;
        }
        var append = spill > 0;
        spill = Math.abs(spill);
        var bufferRange = this.ds.bufferRange;
        var bufferStart = bufferRange[0];
        var bufferEnd = bufferRange[1];
        if (bufferStart < 0) {
            return;
        }
        var cursorBuffer = cursor - bufferStart;
        var newRowIndex = this.rowIndex;
        var lpIndex = Math.min(cursorBuffer + visibleRows - 1, bufferEnd - bufferStart);
        if (spill >= visibleRows || spill == 0) {
            this.mainBody.update(this.renderRows(cursorBuffer, lpIndex));
        }
        else {
            var html;
            var rows;
            if (append) {
                this.removeRows(0, spill - 1);
                rows = this.getRows();
                if (rows.length > 0) {
                    newRowIndex = rows[0].rowIndex;
                }
                var currentVisibleMiniRows = this.getVisibleMiniRows();
                var miniRowsToFill = this.visibleMiniRows - currentVisibleMiniRows;
                var insertStartRow;
                if (miniRowsToFill > 0) {
                    if (cursorBuffer + visibleRows - spill <= bufferEnd - bufferStart) {
                        var doNotInsert = false;
                        insertStartRow = cursorBuffer + visibleRows - spill;
                        if (rows.length > 0) {
                            insertStartRow = rows[rows.length - 1].rowIndex + 1 - bufferStart;
                            lpIndex = insertStartRow + miniRowsToFill;
                        }
                        if (!this.ds.getAt(insertStartRow + bufferStart)) {
                            if (rows.length <= 0) {
                                insertStartRow = 0;
                            }
                            else {
                                doNotInsert = true;
                            }
                        }
                        if (!doNotInsert) {
                            if (!this.ds.getAt(lpIndex + bufferStart)) {
                                lpIndex = bufferEnd - bufferStart;
                            }
                            if (rows.length <= 0) {
                                newRowIndex = insertStartRow + bufferStart;
                            }
                            html = this.renderRows(insertStartRow, lpIndex);
                            Ext.DomHelper.insertHtml('beforeEnd', this.mainBody.dom, html);
                        }
                    }
                    else {
                        if (rows.length > 0) {
                            insertStartRow = rows[0].rowIndex - bufferStart;
                        }
                        else {
                            insertStartRow = cursor - bufferStart;
                        }
                        lpIndex = insertStartRow + this.visibleMiniRows;
                        if (!this.ds.getAt(insertStartRow + bufferStart)) {
                            insertStartRow = 0;
                        }
                        if (!this.ds.getAt(lpIndex + bufferStart)) {
                            lpIndex = bufferEnd - bufferStart;
                        }
                        newRowIndex = insertStartRow + bufferStart;
                        this.mainBody.update(this.renderRows(insertStartRow, lpIndex));
                    }
                }
            }
            else {
                rows = this.getRows();
                this.removeRows(visibleRows - spill, rows.length - 1);
                var insertEndRow = cursorBuffer + spill - 1;
                if (rows && rows.length > 0 && rows[0].rowIndex === insertEndRow) {
                    insertEndRow = rows[0].rowIndex - 1;
                }
                html = this.renderRows(cursorBuffer, insertEndRow);
                if (!this.mainBody.dom.firstChild) {
                    return;
                }
                Ext.DomHelper.insertHtml('beforeBegin', this.mainBody.dom.firstChild, html);
            }
        }
        if (this.rowIndex !== newRowIndex) {
            this.rowIndex = newRowIndex;
        }
        if (processRows !== false) {
            this.processRows(0, undefined, true);
        }
        try {
            this.applyEmptyText();
        }
        catch (err) {
        }
        this.lastRowIndex = cursor;
    }, getPredictedBufferIndex: function (index, inRange, down) {
        if (!inRange) {
            if (index + this.ds.bufferSize >= this.ds.totalLength) {
                var result = this.ds.totalLength - this.ds.bufferSize;
                if (result < 0) {
                    result = 0;
                }
                return result;
            }
            return Math.max(0, (index + this.visibleRows) - Math.round(this.ds.bufferSize / 2));
        }
        if (!down) {
            return Math.max(0, (index - this.ds.bufferSize) + this.visibleRows);
        }
        if (down) {
            return Math.max(0, Math.min(index, this.ds.totalLength - this.ds.bufferSize));
        }
    }, processSingleRow: function (row) {
        if (!this.ds || this.ds.getCount() < 1) {
            return;
        }
        var rowIndex = row.rowIndex;
        var rowEl = this.fly(row);
        if (this.grid.selModel.isSelected(rowIndex) === true) {
            if (!rowEl.hasClass(this.selectedRowClass)) {
                this.addRowClass(rowIndex, this.selectedRowClass);
                rowEl.removeClass("x-grid3-row-over");
            }
        }
        else {
            if (rowEl.hasClass(this.selectedRowClass)) {
                this.removeRowClass(rowIndex, this.selectedRowClass);
                rowEl.removeClass("x-grid3-row-over");
            }
        }
    }, processRows: function (startRow, skipStripe, paintSelections) {
        if (!this.ds || this.ds.getCount() < 1) {
            return;
        }
        var attr;
        var rows = this.getRows(), len = rows.length;
        var row = null;
        if (!this.isLiveGrid) {
            for (var i = 0; i < len; i++) {
                row = rows[i];
                if (row) {
                    if (this.ds.getAt(i).data) {
                        attr = document.createAttribute('rowid');
                        attr.nodeValue = this.ds.getAt(i).data.name;
                        if (row.firstChild) {
                            row.firstChild.firstChild.firstChild.attributes.setNamedItem(attr);
                        }
                    }
                }
            }
            if (rows.length > 0) {
                return Pan.base.grid.SpanningGridView.superclass.processRows.apply(this, arguments);
            }
            else {
                return;
            }
        }
        skipStripe = skipStripe || !this.grid.stripeRows;
        var cursor = this.rowIndex;
        var index = 0;
        for (var idx = 0; idx < len; idx++) {
            row = rows[idx];
            row.rowIndex = index = cursor + idx;
            row.className = row.className.replace(this.rowClsRe, ' ');
            if (!skipStripe && (index + 1) % 2 === 0) {
                row.className += ' x-grid3-row-alt';
            }
            if (paintSelections !== false) {
                if (this.grid.selModel.isSelected(this.ds.getAt(index)) === true) {
                    this.addRowClass(index, this.selectedRowClass);
                }
                else {
                    this.removeRowClass(index, this.selectedRowClass);
                }
                this.fly(row).removeClass("x-grid3-row-over");
            }
            var indexRecord = this.ds.getAt(index);
            if (indexRecord) {
                attr = document.createAttribute('rowid');
                attr.nodeValue = indexRecord.data.name;
                if (row.firstChild) {
                    row.firstChild.firstChild.firstChild.attributes.setNamedItem(attr);
                }
            }
        }
        if (cursor === 0 && rows[0]) {
            Ext.fly(rows[0]).addClass(this.firstRowCls);
        }
        else if (cursor + rows.length == this.ds.totalLength) {
            var lastRow = rows[rows.length - 1];
            if (lastRow) {
                Ext.fly(lastRow).addClass(this.lastRowCls);
            }
        }
    }, liveGridScrollTo: function (row, callback) {
        var rowPixel = row * this.rowHeight;
        if (rowPixel + this.liveScroller.dom.offsetHeight > this.liveScroller.dom.scrollHeight) {
            rowPixel = this.liveScroller.dom.scrollHeight - this.liveScroller.dom.offsetHeight;
        }
        if (rowPixel === this.liveScroller.dom.scrollTop) {
            if (callback) {
                callback();
            }
        }
        else {
            this.softwareScroll = true;
            this.softwareScrollCallback = callback;
            this.liveScroller.dom.scrollTop = rowPixel;
        }
    }, adjustBufferInset: function () {
        var liveScrollerDom = this.liveScroller.dom;
        var g = this.grid, ds = g.store;
        var c = g.getGridEl();
        var elWidth = c.getSize().width;
        var hiddenRows = (ds.totalLength == this.visibleRows - this.rowClipped) ? 0 : Math.max(0, ds.totalLength - (this.visibleRows - this.rowClipped));
        if (hiddenRows == 0) {
            this.scroller.setWidth(elWidth);
            liveScrollerDom.style.display = 'none';
            return;
        }
        else {
            this.scroller.setWidth(elWidth - this.getScrollOffset());
            liveScrollerDom.style.display = '';
        }
        var scrollbar = this.cm.getTotalWidth() + this.getScrollOffset() > elWidth;
        var contHeight = liveScrollerDom.parentNode.offsetHeight +
            ((ds.totalLength > 0 && scrollbar) ? -this.horizontalScrollOffset : 0)
            - this.hdHeight;
        liveScrollerDom.style.height = Math.max(contHeight, this.horizontalScrollOffset * 2) + "px";
        if (this.rowHeight == -1) {
            return;
        }
        var h = (hiddenRows == 0 ? 0 : contHeight + (hiddenRows * this.rowHeight));
        var oh = h;
        var len = this.liveScrollerInsets.length;
        if (h == 0) {
            h = 0;
        }
        else {
            h = Math.round(h / len);
        }
        if (h > 0) {
            for (var i = 0; i < len; i++) {
                if (i == len - 1 && h != 0) {
                    h -= (h * 3) - oh;
                }
                this.liveScrollerInsets[i].style.height = h + "px";
            }
        }
    }
});
Pan.base.grid.RowSpanningColumnHeaderGroup = Ext.extend(Ext.ux.grid.ColumnHeaderGroup, {
    init: function (grid) {
        this.viewConfig = Ext.apply({}, this.viewConfig);
        this.viewConfig.renderHeaders = function () {
            var ts = this.templates, headers = [], cm = this.cm, rows = cm.rows,
                tstyle = 'width:' + this.getTotalWidth() + ';';
            for (var row = 0, rlen = rows.length; row < rlen; row++) {
                var r = rows[row], cells = [];
                for (var i = 0, gcol = 0, len = r.length; i < len; i++) {
                    var group = r[i];
                    group.colspan = group.colspan || 1;
                    var id = this.getColumnId(group.dataIndex ? cm.findColumnIndex(group.dataIndex) : gcol),
                        gs = Ext.ux.grid.ColumnHeaderGroup.prototype.getGroupStyle.call(this, group, gcol);
                    cells[i] = ts.gcell.apply({
                        cls: 'ux-grid-hd-group-cell ' + (group.rowspan ? 'ux-grid-hd-group-cell-rowspan' : '') + (group.header ? ' ux-grid-hd-group-cell-with-header' : ''),
                        id: id,
                        row: row,
                        style: 'width:' + gs.width + ';' + (gs.hidden ? 'display:none;' : '') + (group.align ? 'text-align:' + group.align + ';' : ''),
                        tooltip: group.tooltip ? (Ext.QuickTips.isEnabled() ? 'ext:qtip' : 'title') + '="' + Pan.base.htmlEncode(group.tooltip) + '"' : '',
                        istyle: group.align == 'right' ? 'padding-right:16px' : '',
                        btn: this.grid.enableHdMenu && group.header,
                        value: group.header || '&nbsp;'
                    });
                    gcol += group.colspan;
                }
                if (row === rows.length - 1) {
                    tstyle += '" id="' + grid.id + '-fieldLabelHeader';
                }
                headers[row] = ts.header.apply({tstyle: tstyle, cells: cells.join('')});
            }
            headers.push(this.constructor.prototype.renderHeaders.apply(this, arguments));
            return headers.join('');
        };
        this.viewConfig.handleHdDown = Pan.base.util.createExtension(grid.handleHdDown, this.viewConfig.handleHdDown);
        this.viewConfig.handleHdMenuClick = Pan.base.util.createExtension(function (item) {
            var index = this.hdCtxIndex, cm = this.cm, ds = this.ds, id = item.getItemId();
            switch (id) {
                case'asc':
                    ds.sort(cm.getDataIndex(index), 'ASC');
                    break;
                case'desc':
                    ds.sort(cm.getDataIndex(index), 'DESC');
                    break;
                default:
                    if (id.substr(0, 5) == 'group') {
                        var i = id.split('-'), row = parseInt(i[1], 10), col = parseInt(i[2], 10),
                            r = this.cm.rows[row], group, gcol = 0;
                        for (i = 0, len = r.length; i < len; i++) {
                            group = r[i];
                            if (col >= gcol && col < gcol + group.colspan) {
                                break;
                            }
                            gcol += group.colspan;
                        }
                        if (item.checked) {
                            var max = cm.getColumnsBy(this.isHideableColumn, this).length;
                            for (i = gcol, len = gcol + group.colspan; i < len; i++) {
                                if (!cm.isHidden(i)) {
                                    max--;
                                }
                            }
                            if (max < 1) {
                                this.onDenyColumnHide();
                                return false;
                            }
                        }
                        var len;
                        for (i = gcol, len = gcol + group.colspan; i < len; i++) {
                            if (cm.config[i].fixed !== true && cm.config[i].hideable !== false) {
                                cm.setHidden(i, item.checked);
                            }
                        }
                    }
                    else {
                        index = cm.getIndexById(id.substr(4));
                        if (index != -1) {
                            if (item.checked && cm.getColumnsBy(this.isHideableColumn, this).length <= 1) {
                                this.onDenyColumnHide();
                                return false;
                            }
                            cm.setHidden(index, item.checked);
                        }
                    }
                    item.checked = !item.checked;
                    var parentMenu = item, parentItem;
                    parentMenu = parentMenu.parentMenu;
                    while (parentMenu) {
                        if (!parentMenu.parentMenu || !(parentItem = parentMenu.parentMenu.items.get(parentMenu.getItemId())) || !parentItem.setChecked) {
                            break;
                        }
                        var checked = parentMenu.items.findIndexBy(function (m) {
                            return m.checked;
                        }) >= 0;
                        parentItem.setChecked(checked, true);
                        parentMenu = parentMenu.parentMenu;
                    }
                    item.checked = !item.checked;
            }
            return true;
        }, this.viewConfig.handleHdMenuClick);
        Pan.base.grid.RowSpanningColumnHeaderGroup.superclass.init.apply(this, arguments);
    }
});
Ext.grid.GridView.SplitDragZone.prototype.allowHeaderDrag = Pan.base.util.createExtension(function (e) {
    if (this.view.grid.getInternalScrollOffsetColumn) {
        var t = this.view.findHeaderCell(e.getTarget());
        if (this.view.findCellIndex(t) === this.view.grid.getInternalScrollOffsetColumn()) {
            return false;
        }
    }
    return arguments.callee.superFunction.apply(this, arguments);
}, Ext.grid.GridView.SplitDragZone.prototype.allowHeaderDrag);
Ext.grid.GridView.SplitDragZone.prototype.b4StartDrag = function (x, y) {
    this.dragHeadersDisabled = this.view.headersDisabled;
    this.view.headersDisabled = true;
    var h = this.view.mainWrap.getHeight();
    this.marker.setHeight(h);
    this.marker.show();
    this.marker.alignTo(this.view.getHeaderCell(this.cellIndex), 'tl-tl', [-2, 0]);
    this.proxy.setHeight(h);
    var w = this.cm.getColumnWidth(this.cellIndex),
        minw = Math.max(w - (Ext.isNumber(this.cm.config[this.cellIndex].minColumnWidth) ? this.cm.config[this.cellIndex].minColumnWidth : this.grid.minColumnWidth), 0),
        maxw = Math.max((Ext.isNumber(this.cm.config[this.cellIndex].maxColumnWidth) ? this.cm.config[this.cellIndex].maxColumnWidth : 1000) - w, 0);
    this.resetConstraints();
    this.setXConstraint(minw, maxw);
    this.setYConstraint(0, 0);
    this.minX = x - minw;
    this.maxX = x + maxw;
    this.startPos = x;
    Ext.dd.DDProxy.prototype.b4StartDrag.call(this, x, y);
};
Ext.grid.ColumnModel.prototype.setColumnWidth = function (col, width, suppressEvent) {
    var newWidth = Math.max(width, (Ext.isNumber(this.config[col].minColumnWidth) ? this.config[col].minColumnWidth : 0));
    if (Ext.isNumber(this.config[col].maxColumnWidth)) {
        newWidth = Math.min(newWidth, this.config[col].maxColumnWidth);
    }
    if (Math.abs(this.config[col].width - newWidth) > 0.01) {
        this.config[col].width = newWidth;
        this.totalWidth = null;
        if (!suppressEvent) {
            this.fireEvent("widthchange", this, col, this.config[col].width);
        }
    }
};
Pan.base.grid.GridViewer = Ext.extend(Pan.base.component.ToolTip, {
    anchor: 'top',
    anchorCls: '',
    anchorOffset: -34,
    autoHide: false,
    border: false,
    shadow: false,
    onRender: function (ct, position) {
        this.cls = this.cls || '';
        this.cls += ' x-grid-viewer';
        Ext.ToolTip.superclass.onRender.call(this, ct, position);
        Ext.applyIf(this, {anchorCls: 'x-tip-anchor-' + this.getAnchorPosition()});
        this.anchorEl = this.el.createChild({cls: this.anchorCls});
    },
    getTargetXY: function () {
        var rv = Pan.base.grid.GridViewer.superclass.getTargetXY.apply(this, arguments);
        if (this.anchor != 'top') {
            this.anchor = 'top';
            var offsets = this.getOffsets(),
                xy = (this.anchorToTarget && !this.trackMouse) ? this.el.getAlignToXY(this.anchorTarget, this.getAnchorAlign()) : this.targetXY;
            rv = [xy[0] + offsets[0], xy[1] + offsets[1]];
            return rv;
        }
        rv[1] += this.anchorOffset;
        return rv;
    }
});
Ext.grid.ColumnModel.defaultRenderer = function (value) {
    if (typeof value == "string" && value.length < 1) {
        return "&#160;";
    }
    return Pan.base.htmlEncode(value);
};
Ext.grid.CheckboxSelectionModel.prototype.doHTMLEncode = false;
Ext.ux.grid.CheckColumn.prototype.doHTMLEncode = false;
Ext.ux.grid.RowExpander.prototype.doHTMLEncode = false;
Ext.ux.grid.RowPanelExpander.prototype.doHTMLEncode = false;
Ext.ns('Pan.base.grid');
Pan.base.grid.EditorGridPanel = Ext.extend(Pan.base.grid.GridPanel, {
    keyFieldColumnIsUsingDialogEditor: false,
    useNameAsLabel: false,
    saveData: true,
    supportFormValidation: true,
    allowBlankValidation: true,
    preventMark: true,
    forceValidation: true,
    validateAllCells: true,
    disableAutoVflex: false,
    testValueChangedElementEvents: [],
    testValueChangedEvents: ['afterupdate', false, 'afterremove', false],
    disableEdit: false,
    onDestroy: function () {
        if (this.store) {
            this.store.removeListener('remove', this.onRecordRemove, this);
            this.store.removeListener('add', this.onRecordAdd, this);
            this.store.removeListener('update', this.onUpdate, this);
            this.store.removeListener('bulkremove', this.onBulkRemove, this);
        }
        this.removeListener("validateedit", this.onValidateEdit, this);
        Pan.base.grid.EditorGridPanel.superclass.onDestroy.call(this);
    },
    initComponent: function () {
        this.cls = this.cls || "";
        Pan.base.grid.EditorGridPanel.superclass.initComponent.apply(this, arguments);
        this.addListener("beforeedit", function (event) {
            var ed = this.colModel.getCellEditor(event.column, event.row);
            if (ed && ed.field && Ext.isFunction(ed.field.beforeEdit)) {
                ed.field.beforeEdit.call(ed.field.scope || ed.field, event);
            }
        }, this);
        this.store.addListener('afterload', this.initAfterLoadListeners, this);
        this.store.addListener('remove', this.onRemove, this, {delay: 1});
        this.store.addListener('bulkremove', this.onBulkRemove, this, {delay: 1});
        this.addListener("validateedit", this.onValidateEdit, this);
    },
    initAfterLoadListeners: function () {
        if (!this.addAfterLoadListeners) {
            this.store.removeListener("afterload", arguments.callee, this);
            this.store.addListener('add', this.onRecordAdd, this, {delay: 1});
            this.store.addListener('update', this.onUpdate, this, {delay: 1});
            this.addAfterLoadListeners = true;
        }
    },
    setValue: function (v) {
        Pan.base.grid.EditorGridPanel.superclass.setValue.apply(this, arguments);
        this.initAfterLoadListeners();
    },
    createView: function () {
        var view;
        if (this.allowAddNewEntries === true) {
            view = new Pan.base.grid.EditorSpanningGridView(this.viewConfig);
        }
        else {
            view = Pan.base.grid.EditorGridPanel.superclass.createView.call(this);
        }
        view.getEditorParent = Pan.base.util.createExtension(this.getEditorParent, view.getEditorParent);
        return view;
    },
    getEditorParent: function (ed) {
        if (ed && ed.field && ed.field.isPanelEditor) {
            ed.__grid = this.grid;
            var ownerCt = this.grid;
            while (ownerCt.ownerCt && ownerCt.el && ownerCt.el.dom) {
                ownerCt = ownerCt.ownerCt;
            }
            return ownerCt.el.dom;
        }
        else {
            return arguments.callee.superFunction.apply(this, arguments);
        }
    },
    afterAddSelectionAndSetField: function (record) {
        var event = {record: record, grid: this};
        this.validateEdit(event);
        this.validate();
    },
    onBulkRemove: function (store, bulkRemovedRecords) {
        if (bulkRemovedRecords) {
            if (!Ext.isArray(bulkRemovedRecords)) {
                bulkRemovedRecords = [bulkRemovedRecords];
            }
            for (var i = 0; i < bulkRemovedRecords.length; i++) {
                var event = {record: bulkRemovedRecords[i], grid: this, disableEvent: true};
                this.validateEdit(event);
            }
            this.validate();
            this.fireEvent("afterremove");
        }
    },
    onUpdate: function (store, record, type, internalEvent) {
        var event = {record: record, grid: this};
        if (!internalEvent) {
            this.validateEdit(event);
            this.validate();
        }
        this.fireEvent("afterupdate", event);
    },
    onRecordAdd: function (store, records, index) {
        var event = {record: Ext.isArray(records) ? records[0] : records, grid: this, disableEvent: false};
        this.validateEdit(event);
        this.validate();
    },
    onRecordRemove: function (store, record, index) {
        var event = {record: record, grid: this, disableEvent: true};
        this.validateEdit(event);
        this.validate();
        this.fireEvent("afterremove", event);
    },
    onValidateEdit: function (event) {
        this.validateEdit(event);
    },
    validateEdit: function (event) {
        var error = false;
        var eventRec = event.record;
        var eventVal = event.value;
        var eventField = event.field;
        var store = event.grid.store;
        var fireEvent = false;
        for (var i = this.firstDataColumn || 0, n = this.getInternalScrollOffsetColumn() || this.colModel.getColumnCount(); i < n; i++) {
            error = false;
            var col = this.colModel.getColumnAt(i);
            if (col.hidden) {
                continue;
            }
            var fieldName = col.dataIndex;
            var field = store.fields.get(fieldName);
            if (field && field.hasOwnProperty('proxyFieldMapping')) {
                continue;
            }
            if (fieldName === store.groupField) continue;
            var fieldValue = eventRec.data[fieldName];
            if (eventField !== undefined && fieldName === eventField) {
                fieldValue = eventVal;
            }
            if (Ext.isFunction(col.getCellEditor)) {
                var ed = col.getCellEditor(event.row || 0);
                if (ed && ed.field && ed.field.setValue) {
                    if (fieldName !== eventField && (!this.editing || this.activeEditor !== ed)) {
                        ed.field.setValue(fieldValue);
                    }
                    if (ed.field.getErrors) {
                        var fieldError = ed.field.getErrors();
                        if (Ext.isArray(fieldError) && fieldError.length > 0) {
                            error = fieldError[0];
                        }
                    }
                }
            }
            if (!error && store.idProperty && fieldName == store.idProperty) {
                if (eventRec.dupId) {
                    var otherRec = store.getById(eventRec.dupId);
                    if (otherRec && otherRec.error) {
                        delete otherRec.error[fieldName];
                        if (Pan.base.isEmpty(otherRec.error)) {
                            otherRec.clearError();
                        }
                        store.fireEvent('update', store, otherRec, Ext.data.Record.EDIT, true);
                    }
                }
                store.each(function (rec) {
                    if (rec.id != eventRec.id) {
                        if (rec.data[fieldName] == fieldValue) {
                            rec.dupId = eventRec.id;
                            error = _T("Duplicate Identification");
                            return false;
                        }
                    }
                });
            }
            if (error && (!ed || !ed.record || eventRec.id === ed.record.id)) {
                eventRec.error = eventRec.error || {};
                eventRec.error[fieldName] = error;
                fireEvent = true;
            }
            else {
                if (eventRec.error) {
                    delete eventRec.error[fieldName];
                    if (Pan.base.isEmpty(eventRec.error)) {
                        eventRec.clearError();
                    }
                    fireEvent = true;
                }
            }
        }
        if (!event.disableEvent && fireEvent) {
            store.fireEvent('update', store, eventRec, Ext.data.Record.EDIT, true);
        }
    },
    getErrors: function (store) {
        var errors = Pan.base.grid.EditorGridPanel.superclass.getErrors.apply(this, arguments);
        if (!store) {
            store = this.store;
        }
        if (errors.length === 0) {
            if (this.__field && Ext.isDefined(this.__field.maxCount) && store.getCount() > this.__field.maxCount) {
                errors.push(_T("The number of entries exceed {count}", {count: this.__field.maxCount}));
            }
        }
        return errors;
    },
    setupColumn: function (col, index) {
        var field = this.store.fields.get(col.dataIndex);
        if (field) {
            if (field.attrName == '@name' && this.useNameAsLabel) {
                col.header = _T('Name');
            }
            this.setupEditor(col, field);
        }
        if (this.disableEdit) {
            Ext.applyIf(col, {editable: false});
        }
        if (this.allowAddNewEntries === true) {
            var newObjectActionItems = this.menuActions ? this.menuActions : [];
            var bbarActions = this.bbar;
            col.columnActions = [];
            Ext.each(bbarActions, function (action) {
                if (!Ext.isObject(action) || !action.nontransferable) {
                    var actionObj = action;
                    if (!Ext.isObject(action)) {
                        actionObj = {atype: action};
                    }
                    col.columnActions.unshift(Ext.applyIf({disableAssociation: true}, actionObj));
                }
            }, this);
            Ext.applyIf(col, {columnActionsMode: col.columnActionsMode || (col.columnActions.length > 1 ? 'menu' : 'button')});
            col.newActions = [];
            Ext.each(newObjectActionItems, function (item) {
                if (item.componentItemId) {
                    col.newActions.unshift({
                        atype: item.atype,
                        text: item.text,
                        componentItemId: item.componentItemId,
                        treePath: item.treePath,
                        rbaPath: item.rbaPath
                    });
                }
            }, this);
            delete this.bbar;
        }
        Pan.base.grid.EditorGridPanel.superclass.setupColumn.call(this, col, index, Ext.isDefined(col.editor));
    },
    getRecordFormField: function (field) {
        return this.getStarField();
    },
    setupEditor: function (col, field) {
        if (col.editor && field.uiHint) {
            col.editor = Ext.applyIf({}, col.editor);
            Ext.applyIf(col.editor, field.uiHint);
            Ext.applyIf(col.editor, {
                validateAllCells: this.validateAllCells,
                lazyRender: true,
                isAnEditor: true,
                recordFormField: this.getRecordFormField(field)
            });
            var builder = col.editor.builder;
            if (builder) {
                if (field.uiHint.isKeyField && col.isGenerated) {
                    Ext.applyIf(this, {useCheckBoxSelection: true});
                }
                if (Ext.isString(builder)) {
                    builder = Pan.base.autorender.builder.BuilderMgr.get(builder);
                }
                if (Ext.isFunction(builder)) {
                    builder.call(this, col.editor, {
                        field: field,
                        fields: (this.__pdefaults && this.__pdefaults.__fields) || this.store.fields,
                        caller: this
                    });
                }
            }
            Ext.applyIf(col.editor, new Pan.base.autorender.ComponentCommonInfo(undefined, field));
            Ext.applyIf(col.editor, {
                xtype: field.uiHint.uitype ? field.uiHint.uitype : Pan.appframework.schema.PanType.getType2XTypeMap()[field.type.type] || 'pan-textfield',
                __pdefaults: this.__pdefaults
            });
            if (col.editor.frame) {
                delete col.editor.frame;
                Ext.applyIf(col.editor, {itemId: field.name});
                col.editor = Ext.applyIf({
                    xtype: 'pan-editorpanel',
                    isPanelEditor: true,
                    autoHeight: true,
                    frame: Ext.isDefined(col.editor.showFrame) ? col.editor.showFrame : true,
                    monitorValid: true,
                    __pdefaults: this.__pdefaults,
                    items: col.editor
                });
                Ext.applyIf(col.editor, new Pan.base.autorender.ComponentCommonInfo(undefined, field));
                col.editor.listeners = col.editor.listeners || {};
                Ext.applyIf(col.editor.listeners, {
                    'beforecollapse': function () {
                        return false;
                    }
                });
            }
        }
        if (this.__pdefaults && this.__pdefaults.__readOnly && col.editor && !col.editor.isInWindow) {
            delete col.editor;
        }
    },
    createDefaultColumnConfig: function (field, index) {
        var col = Pan.base.grid.EditorGridPanel.superclass.createDefaultColumnConfig.apply(this, arguments);
        if (field.uiHint) {
            if (Ext.isObject(col.editor) && Pan.base.isEmpty(col.editor)) {
                delete col.editor;
            }
            else {
                Ext.applyIf(col, {editor: Ext.apply({}, field.uiHint.editor)});
                if (this.defaultColumnIsUsingDialogEditor(field)) {
                    Ext.applyIf(col.editor, {
                        builder: 'PanEditorDialogBuilder',
                        recordFormField: this.getRecordFormField(field)
                    });
                }
                else if (!field.uiHint.isKeyField && this.disableInlineEdit) {
                    delete col.editor;
                }
            }
        }
        return col;
    },
    defaultColumnIsUsingDialogEditor: function (field) {
        var editorInDialog = false;
        if (field.uiHint.isKeyField && !field.isStar) {
            if (field.attrName == '@name' && this.useNameAsLabel) {
                field.uiHint.fieldLabel = _T('Name');
            }
            if (this.keyFieldColumnIsUsingDialogEditor) {
                editorInDialog = true;
            }
            else {
                this.getStarField().visit(function (field) {
                    if (field.isCollection || (field.uiHint.association || field.uiHint.avail)) {
                        editorInDialog = true;
                        return false;
                    }
                }, this);
            }
        }
        return editorInDialog;
    },
    onEditComplete: function (ed, value, startValue) {
        this.editing = false;
        this.lastActiveEditor = this.activeEditor;
        this.activeEditor = null;
        var r = ed.record, field = this.colModel.getDataIndex(ed.col);
        value = this.postEditValue(value, startValue, r, field);
        if (this.forceValidation === true) {
            var e = {
                grid: this,
                record: r,
                field: field,
                originalValue: startValue,
                value: value,
                row: ed.row,
                column: ed.col,
                cancel: false
            };
            if (this.fireEvent("validateedit", e) !== false && !e.cancel) {
                r.set(field, e.value);
                delete e.cancel;
                this.fireEvent("afteredit", e);
            }
        }
        this.view.focusCell(ed.row, ed.col);
    },
    startEditing: function (row, col, activeEditorIsInitialAdd) {
        this.activeEditorIsInitialAdd = activeEditorIsInitialAdd;
        Pan.base.grid.EditorGridPanel.superclass.startEditing.apply(this, arguments);
        if (this.activeEditor) {
            var field = this.activeEditor.field || this.activeEditor;
            if (!field.ownerCt) {
                field.parentOwner = this;
            }
            if (Ext.isFunction(field.initEditor)) {
                field.initEditor();
            }
        }
    },
    onCellDblClick: function () {
        if (this.userDefinedColModel === true) {
            Pan.base.grid.GridPanel.superclass.onCellDblClick.apply(this, arguments);
        }
    },
    onAutoEditClick: function () {
    },
    onClick: function (e) {
        var currentEditor = this.activeEditor;
        Pan.base.grid.EditorGridPanel.superclass.onClick.apply(this, arguments);
        if (this.activeEditor && this.activeEditor === currentEditor) {
            if (this.isInActiveEditor(e)) {
                return;
            }
            this.stopEditing();
        }
    },
    handleClick: function (grid, rowIndex, columnIndex, e) {
        if (grid.isCellEditable && !grid.isCellEditable(rowIndex, columnIndex))
            return false;
        if (this.activeEditor) {
            if (this.isInActiveEditor(e)) {
                return false;
            }
        }
        var t = e.getTarget();
        if (t.className.indexOf('x-grid3-add-new-cell-inner') >= 0 || t.className.indexOf('x-grid-empty-add-new') >= 0) {
            if (!this.addAction) {
                this.addAction = Pan.createAction({atype: 'addRecordAction', delayStartEditing: true}, this);
            }
            this.addAction.doAction.call(this.addAction, t, {grid: this, component: this}, e);
            this.scrollToBottom();
            return true;
        }
        else {
            grid.startEditing(rowIndex, columnIndex);
            return Pan.base.grid.EditorGridPanel.superclass.handleClick.apply(this, arguments);
        }
    },
    getValue: function () {
        this.stopEditing();
        return Pan.base.grid.EditorGridPanel.superclass.getValue.call(this);
    },
    isInActiveEditor: function (e) {
        var id = this.activeEditor.id;
        var node = e.target;
        if (node.className && node.className.indexOf("x-grid3-add-new") >= 0) {
            return true;
        }
        while (node.parentNode) {
            node = node.parentNode;
            if (node.id == id) {
                return true;
            }
        }
        return false;
    },
    preEditValue: function (r, field) {
        var activeEditor;
        if (this.activeEditor) {
            activeEditor = this.activeEditor.field || this.activeEditor;
            activeEditor.__editRecord = r;
        }
        var cindex = this.colModel.findColumnIndex(field);
        var column = this.colModel.getColumnAt(cindex);
        if ((column.editor && column.editor.isARecordEditor) || (activeEditor && activeEditor.isARecordEditor)) {
            return r;
        }
        return Pan.base.grid.EditorGridPanel.superclass.preEditValue.apply(this, arguments);
    },
    onMouseDown: function (e) {
        var t = e.getTarget();
        if (t.className.indexOf('x-grid3-add-new-cell-inner') >= 0) {
            return;
        }
        Pan.base.grid.EditorGridPanel.superclass.onMouseDown.apply(this, arguments);
    },
    mouseover: function (e) {
        var cell = this.findMiniCell(e);
        if (cell && cell.hasClass("x-grid-empty-add-new")) {
            e.preventDefault();
            e.stopPropagation();
            e.stopEvent();
            var columnIndex = this.view.findCellIndex(e.target);
            var column = this.colModel.getColumnAt(columnIndex);
            var rowIndex = this.store.getCount();
            if (Ext.isNumber(rowIndex) && column && column.toolbar) {
                var newActions = column.newActions;
                if (!Ext.isArray(newActions)) {
                    newActions = [newActions];
                }
                else {
                    newActions = newActions.slice(0);
                }
                var menuActions = [];
                for (var i = 0; i < newActions.length; i++) {
                    newActions[i] = Ext.apply({}, newActions[i]);
                    newActions[i].xtype = "menuitem";
                    menuActions.push(newActions[i]);
                }
                if (menuActions.length == 0) return;
                var newToolbarItems;
                if (menuActions.length > 1) {
                    menuActions = Pan.createActionBar(menuActions, this.makeHandler, this);
                    newToolbarItems = [{
                        cls: "x-toolbar-grid-cell-hint",
                        menuAlign: 'tl-tl?',
                        menu: {items: menuActions}
                    }];
                }
                else {
                    for (i = 0; i < newActions.length; i++) {
                        newActions[i] = Ext.applyIf({text: ''}, newActions[i]);
                        newActions[i].useMiniCellSelection = true;
                    }
                    newToolbarItems = Pan.createActionBar(newActions, this.makeHandler, this);
                }
                var newToolbar = {xtype: 'toolbar', cls: "x-toolbar-grid-cell-hint", items: newToolbarItems};
                this.newCellWindow = column.newCellWindow;
                if (!this.newCellWindow) {
                    this.newCellWindow = Ext.create({
                        xtype: "menu",
                        shadow: false,
                        cls: "x-toolbar-grid-cell-hint",
                        items: newToolbar
                    });
                    column.newCellWindow = this.newCellWindow;
                }
                if (!this.newCellWindow.el) {
                    this.newCellWindow.render();
                }
                this.newCellWindow.el.setWidth(30);
                var xy = this.newCellWindow.el.getAlignToXY(cell, 'r-r');
                this.newCellWindow.showAt(xy);
                return;
            }
            if (this.newCellWindow) {
                this.newCellWindow.setVisible(false);
            }
        }
        else {
            Pan.base.grid.EditorGridPanel.superclass.mouseover.apply(this, arguments);
        }
    }
});
Ext.reg("pan-editorgrid", Pan.base.grid.EditorGridPanel);
Pan.base.grid.EditorSpanningGridView = Ext.extend(Pan.base.grid.SpanningGridView, {
    initTemplates: function () {
        Pan.base.grid.EditorSpanningGridView.superclass.initTemplates.call(this);
        var ts = this.templates || {};
        ts.body = new Ext.Template('{rows} {addNewRow}');
        if (!ts.addNewRow) {
            ts.addNewRow = new Ext.Template('<div class="x-grid3-row {alt} x-grid3-add-new-row" style="{tstyle}"><table class="x-grid3-row-table" border="0" cellspacing="0" cellpadding="0" style="{tstyle}">', '<tbody><tr>{cells}</tr>', (this.enableRowBody ? '<tr class="x-grid3-row-body-tr" style="{bodyStyle}"><td colspan="{cols}" class="x-grid3-body-cell" tabIndex="0" hidefocus="on"><div class="x-grid3-row-body">{body}</div></td></tr>' : ''), '</tbody></table></div>');
        }
    }, onLoad: function () {
        if (Ext.isGecko) {
            if (!this.scrollToTopTask) {
                this.scrollToTopTask = new Ext.util.DelayedTask(this.scrollToBottom, this);
            }
            this.scrollToTopTask.delay(1);
        }
        else {
            this.scrollToBottom();
        }
    }, afterRender: function () {
        if (!this.ds || !this.cm) {
            return;
        }
        if (this.grid.allowAddNewEntries) {
            this.mainBody.dom.innerHTML = (this.renderRows() + this.renderAddNewRow()) || '&#160;';
        }
        else {
            this.mainBody.dom.innerHTML = this.renderRows() || '&#160;';
        }
        this.processRows(0, true);
        if (this.deferEmptyText !== true) {
            this.applyEmptyText();
        }
        this.grid.fireEvent('viewready', this.grid);
    }, renderBody: function () {
        if (this.grid.allowAddNewEntries) {
            return this.templates.body.apply({rows: this.renderRows(), addNewRow: this.renderAddNewRow()});
        }
        else {
            Pan.base.grid.EditorSpanningGridView.superclass.renderBody.call(this);
        }
    }, renderAddNewRow: function () {
        var g = this.grid, cm = g.colModel;
        var colCount = cm.getColumnCount();
        var cs = this.getColumnData();
        return this.doRenderAddNewRow(cs, colCount);
    }, doRenderAddNewRow: function (columns, colCount) {
        var templates = this.templates;
        var addNewRowTemplate = templates.addNewRow,
            cellTemplate = new Ext.Template('<td class="x-grid3-col x-grid3-cell x-grid3-td-{id} {css} ' + (this.grid.unselectable === "off" ? "x-grid-selectable" : "") + '" style="{style}" tabIndex="0" {cellAttr}>', '<div class="x-grid3-cell-inner x-grid3-col-{id} x-grid3-add-new-cell-inner" unselectable="' + (this.grid.unselectable || "on") + '" {attr}>{value}</div>', '</td>'),
            last = colCount - 1;
        var tstyle = 'width:' + this.getTotalWidth() + ';';
        var colBuffer = [], rowParams = {}, meta = {}, column;
        colBuffer = [];
        for (var i = 0; i < colCount; i++) {
            column = columns[i];
            meta.id = column.id;
            if (i === 0) {
                meta.css = " x-grid-empty-add-new";
                meta.value = _T("Add Entry");
            }
            else {
                meta.css = '';
                meta.value = '';
            }
            meta.attr = meta.cellAttr = '';
            meta.style = column.style;
            colBuffer[colBuffer.length] = cellTemplate.apply(meta);
        }
        rowParams.cols = colCount;
        rowParams.alt = '';
        rowParams.cells = colBuffer.join('');
        return addNewRowTemplate.apply(rowParams);
    }, onRowOver: function (e, t) {
        var et = e.getTarget();
        if (et.className.indexOf('add-new') >= 0) {
            return;
        }
        Pan.base.grid.EditorSpanningGridView.superclass.onRowOver.apply(this, arguments);
    }, onRowOut: function (e, t) {
        var et = e.getTarget();
        if (et.className.indexOf('add-new') >= 0) {
            return;
        }
        Pan.base.grid.EditorSpanningGridView.superclass.onRowOut.apply(this, arguments);
    }, processRows: function (startRow, skipStripe) {
        if (!this.ds || this.ds.getCount() < 1) {
            return;
        }
        var rows = this.getRows(), len = rows.length, i, r;
        skipStripe = skipStripe || !this.grid.stripeRows;
        startRow = startRow || 0;
        for (i = 0; i < len; i++) {
            r = rows[i];
            if (r) {
                r.rowIndex = i;
                if (!skipStripe) {
                    if (r.className) {
                        r.className = r.className.replace(this.rowClsRe, ' ');
                        if ((i + 1) % 2 === 0) {
                            r.className += ' x-grid3-row-alt';
                        }
                    }
                }
            }
        }
        if (startRow === 0) {
            Ext.fly(rows[0]).addClass(this.firstRowCls);
        }
        Ext.fly(rows[rows.length - 1]).addClass(this.lastRowCls);
    }
});
(function () {
    Pan.base.grid.createRowActionColumn = function createRowActionColumn(gridPanel, rowActionConfig) {
        rowActionConfig = _.merge({
            autoWidth: false,
            destroy: Ext.emptyFn,
            hideable: false,
            header: '',
            keepSelection: true
        }, rowActionConfig);
        var column = new Ext.ux.grid.RowActions(rowActionConfig);
        gridPanel.addPlugin(column);
        return column;
    };
}());
Ext.ns('Pan.base.grid');
Pan.base.grid.GroupingGridPanel = Ext.extend(Pan.base.grid.EditorGridPanel, {
    groupByComboSelections: undefined,
    hasGridFilter: false,
    useCheckBoxSelection: true,
    saveData: true,
    autoGenerateRecordName: true,
    groupRecordNamePrefix: 'Add Entry',
    groupNamePrefix: 'Add Group',
    supportFastRender: false,
    initComponent: function () {
        Pan.base.grid.GroupingGridPanel.superclass.initComponent.apply(this, arguments);
    },
    applyState: function (state) {
        var cs = state.columns;
        if (this.store && cs && Ext.isDefined(this.groupByComboSelections)) {
            var groupByComboSelections = this.groupByComboSelections;
            if (Ext.isString(groupByComboSelections)) {
                groupByComboSelections = [groupByComboSelections];
            }
            if (this.view && this.view.enableGrouping && groupByComboSelections && this.store.getGroupState() === "") {
                for (var i = 0, len = cs.length; i < len; i++) {
                    var s = cs[i];
                    var c = this.colModel.getColumnById(s.id);
                    if (c) {
                        for (var j = 0; j < groupByComboSelections.length; j++) {
                            if (groupByComboSelections[j] === c.dataIndex) {
                                delete s.hidden;
                            }
                        }
                    }
                }
            }
        }
        return Pan.base.grid.GroupingGridPanel.superclass.applyState.apply(this, arguments);
    },
    setupBars: function () {
        var dataIndex, colModel, index, data, display;
        if (Ext.isArray(this.groupByComboSelections)) {
            data = [];
            for (var i = 0; i < this.groupByComboSelections.length; i++) {
                dataIndex = this.groupByComboSelections[i];
                if (dataIndex) {
                    colModel = this.colModel || this.cm || new Ext.grid.ColumnModel(this.columns);
                    index = colModel.findColumnIndex(dataIndex);
                    if (index >= 0) {
                        data.push({value: dataIndex, display: colModel.getColumnAt(index).header});
                    }
                }
                else {
                    data.push({value: '', display: _T(Pan.base.Constants.nonestr)});
                }
            }
            this.bbar = Pan.base.util.integrateArray(this.bbar, [_T('Group By'), {
                stateful: true,
                stateId: "groupByCombo-" + this.itemId,
                stateEvents: ['valuechange'],
                getState: function () {
                    return {value: this.getValue()};
                },
                applyState: function (state) {
                    this.setValue(state.value);
                },
                xtype: 'pan-combo',
                itemId: 'groupByCombo',
                iconCls: '',
                store: {
                    ztype: Pan.base.autorender.GridRecordStore,
                    zconfig: {fields: ['value', 'display'], data: data}
                },
                listeners: {
                    valuechange: function (combo, value) {
                        this.store.groupBy(value, true);
                        if (this.rendered && this.hasAdjustColumnMenu && this.autoAdjustColumnWidth) {
                            this.onAllByContentClick();
                        }
                    }, scope: this
                },
                value: data[0].value,
                valueField: 'value',
                displayField: 'display',
                mode: 'local'
            }]);
        }
        else if (Ext.isString(this.groupByComboSelections)) {
            colModel = this.colModel || this.cm || new Ext.grid.ColumnModel(this.columns);
            index = colModel.findColumnIndex(this.groupByComboSelections);
            if (index >= 0) {
                display = colModel.getColumnAt(index).header;
            }
            else {
                display = _T(Pan.base.Constants.nonestr);
            }
            this.bbar = Pan.base.util.integrateArray(this.bbar, [{
                stateful: true,
                stateId: "groupByCheckbox-" + this.itemId,
                xtype: 'pan-checkbox',
                fieldLabel: _T('Group By {display}', {display: display}),
                listeners: {
                    check: function (checkbox, value) {
                        if (value) {
                            this.store.groupBy(this.groupByComboSelections, true);
                        }
                        else {
                            this.store.groupBy("", true);
                        }
                        if (this.rendered && this.hasAdjustColumnMenu && this.autoAdjustColumnWidth) {
                            this.onAllByContentClick();
                        }
                    }, scope: this
                }
            }]);
        }
        Pan.base.grid.GroupingGridPanel.superclass.setupBars.apply(this, arguments);
    },
    createStoreConfig: function (_store) {
        var config = Pan.base.grid.GroupingGridPanel.superclass.createStoreConfig.apply(this, arguments);
        Ext.applyIf(config, {useSerializationToClone: true, groupStarField: this.getGroupStarField()});
        return config;
    },
    createDefaultColumnConfig: function (field, _index) {
        var col = Pan.base.grid.GroupingGridPanel.superclass.createDefaultColumnConfig.apply(this, arguments);
        if (field.uiHint) {
            if (field.uiHint.isKeyField && !field.isStar) {
                Ext.apply(col.editor, {recordFormField: this.getGroupStarField()});
            }
        }
        return col;
    },
    getGroupStarField: function () {
        if (!this.__field) {
            return undefined;
        }
        var starChild = this.__field.children[0];
        if (starChild.children) {
            for (var i = 0, n = starChild.children.length; i < n; i++) {
                if (starChild.children[i].children) {
                    var nextLevelStarChild = starChild.children[i].children[0].children[0];
                    if (this.groupedField) {
                        if (nextLevelStarChild.name == this.groupedField) {
                            return nextLevelStarChild;
                        }
                    }
                    else {
                        return nextLevelStarChild;
                    }
                }
            }
        }
        return this.getStarField();
    },
    getView: function () {
        if (!this.view) {
            this.viewConfig = this.viewConfig || {};
            Ext.applyIf(this.viewConfig, {forceFit: true, scrollOffset: 1});
            if (this.groupTextTpl) {
                Ext.apply(this.viewConfig, this.groupTextTpl);
            }
            this.view = new Pan.base.grid.GroupingGridView(this.viewConfig);
        }
        return this.view;
    },
    getNextGroupRecordName: function (groupFieldName) {
        var recIdx = 0;
        this.store.getSnapshot().each(function (r) {
            if (r.data[this.store.groupField] === groupFieldName) {
                var idx = r.data[this.getGroupStarField().name + ".@name"] ? r.data[this.getGroupStarField().name + ".@name"].substr(this.groupRecordNamePrefix.length + 1) : 100;
                recIdx = Math.max(recIdx, idx);
            }
        }, this);
        return this.groupRecordNamePrefix + ' ' + (recIdx + 1);
    },
    getGroupFieldName: function () {
        var grpFldNamePrefix = this.groupNamePrefix;
        var grpIdx = 0;
        this.store.getSnapshot().each(function (r) {
            var data = r.data[this.store.groupField];
            var idx = data ? data.substr(grpFldNamePrefix.length + 1) : 0;
            grpIdx = Math.max(grpIdx, idx);
        }, this);
        return grpFldNamePrefix + ' ' + (grpIdx + 1);
    },
    setDefaultRowForHandler: function (config) {
        config.row = this.getSelectedGroup();
    },
    getSelectedGroup: function () {
        var groupRow = this.el.query('.x-grid-group-title.x-grid3-row-selected')[0];
        if (groupRow) {
            return groupRow.lastChild.data;
        }
        return null;
    },
    move: function (dirDown, row, col, config) {
        this.stopEditing();
        if (!Ext.isNumber(row)) {
            var groupFieldName = row;
            var deletedRecords = [];
            var startIdx = -1, nextIdx = -1, lastIdx = 0;
            var adjacentGroup, adjacentGroupFieldName;
            this.store.getSnapshot().each(function (r) {
                var data = r.data[this.store.groupField];
                if (data === groupFieldName) {
                    if (startIdx < 0) {
                        startIdx = lastIdx;
                    }
                    deletedRecords.unshift(r);
                    nextIdx = lastIdx;
                }
                lastIdx++;
            }, this);
            var newIdx = (dirDown ? nextIdx + 1 : startIdx - 1);
            adjacentGroup = this.store.getAt(newIdx);
            if (!Ext.isDefined(adjacentGroup)) return;
            adjacentGroupFieldName = adjacentGroup.data[this.store.groupField];
            lastIdx = 0;
            var focusIdx = -1;
            this.store.suspendEvents(false);
            this.store.remove(deletedRecords);
            if (dirDown) {
                this.store.getSnapshot().each(function (r) {
                    var data = r.data[this.store.groupField];
                    if (data === adjacentGroupFieldName) {
                        nextIdx = lastIdx;
                    }
                    lastIdx++;
                }, this);
                this.store.insert(nextIdx + 1, deletedRecords);
                focusIdx = nextIdx + 1;
            }
            else {
                nextIdx = -1;
                this.store.getSnapshot().each(function (r) {
                    var data = r.data[this.store.groupField];
                    if (data === adjacentGroupFieldName) {
                        if (nextIdx < 0) {
                            nextIdx = lastIdx;
                            return false;
                        }
                    }
                    lastIdx++;
                }, this);
                this.store.insert(nextIdx, deletedRecords);
                if (nextIdx <= 0) {
                    focusIdx = nextIdx;
                }
                else {
                    focusIdx = nextIdx - 1;
                }
            }
            this.store.resumeEvents();
            this.store.fireEvent("dataChanged", this.store);
            if (focusIdx <= 0) {
                this.getView().scrollToTop();
            }
            else {
                this.getView().focusRow(focusIdx);
            }
            var elems = this.el.query('.x-grid-group-title');
            Ext.each(elems, function (item) {
                if (item.lastChild.data === row) {
                    item.className = 'x-grid-group-title x-grid3-row-selected';
                }
            });
        }
        else {
            var r = config.record;
            r.sort(function (a, b) {
                return (dirDown ? config.grid.store.indexOf(a) < config.grid.store.indexOf(b) ? 1 : -1 : config.grid.store.indexOf(a) < config.grid.store.indexOf(b) ? -1 : 1);
            });
            for (var i = 0; i < r.length; i++) {
                var record = r[i];
                var row1 = config.grid.store.indexOfId(record.id);
                var newRow = row1 + (dirDown ? 1 : -1);
                var newRowRecord = this.store.getAt(newRow);
                if (!newRowRecord || (record.data[this.store.groupField] != newRowRecord.data[this.store.groupField]) || r.indexOf(newRowRecord) >= 0) {
                    continue;
                }
                this.store.suspendEvents(false);
                this.store.remove(record);
                this.store.insert(newRow, record);
                this.store.resumeEvents();
                this.store.fireEvent("dataChanged", this.store);
                var sm = this.getSelectionModel();
                if (sm.select)
                    sm.select(newRow, col); else
                    sm.selectRow(newRow, true);
            }
        }
    }
});
Ext.reg("pan-groupinggrid", Pan.base.grid.GroupingGridPanel);
Pan.base.grid.GroupingGridView = Ext.extend(Pan.base.grid.SpanningGridView, {});
(function () {
    for (var p in Ext.grid.GroupingView.prototype) {
        if (Ext.grid.GroupingView.prototype.hasOwnProperty(p) && p !== 'constructor') {
            Pan.base.grid.GroupingGridView.prototype[p] = Ext.grid.GroupingView.prototype[p];
        }
    }
}());
Ext.apply(Pan.base.grid.GroupingGridView.prototype, {
    enableGroupingMenu: false,
    enableExpandAndCollapse: true,
    enableGroupSelect: false,
    emptyGroupTextTpl: "{gvalue}",
    templateFunctions: {},
    initTemplates: function () {
        Pan.base.grid.GroupingGridView.superclass.initTemplates.call(this);
        this.state = {};
        var sm = this.grid.getSelectionModel();
        sm.on(sm.selectRow ? 'beforerowselect' : 'beforecellselect', this.onBeforeRowSelect, this);
        Ext.apply(this.templateFunctions, {
            isValidGroup: function (groupName) {
                return groupName !== "";
            }
        });
        if (!this.startGroup) {
            this.startGroup = new Ext.XTemplate('<div id="{groupId}" class="x-grid-group {cls}" groupname="{groupName}">', '<div id="{groupId}-hd" class="x-grid-group-hd" style="{style}"><div class="x-grid-group-title" >', '<tpl if="this.isValidGroup(groupName)">' + '<span ', this.enableGroupSelect ? 'class="x-grid-group-select-icon"' : '', '>&nbsp;</span>', '</tpl>' + '<img src="', Ext.BLANK_IMAGE_URL, '" ', this.enableExpandAndCollapse ? 'class="x-grid-group-expand-collapse-icon"' : '', ' />', this.groupTextTpl, '</div></div>', '<div id="{groupId}-bd" class="x-grid-group-body">', this.templateFunctions);
        }
        this.startGroup.compile();
        if (this.supportEmptyGroups && !this.emptyStartGroup) {
            this.emptyStartGroup = new Ext.XTemplate('<div id="{groupId}" class="x-grid-group {cls}" groupname="{groupName}">', '<div id="{groupId}-hd" class="x-grid-group-hd" style="{style}"><div class="x-grid-group-title" >', '<tpl if="this.isValidGroup(groupName)">' + '<span ', this.enableGroupSelect ? 'class="x-grid-group-select-icon"' : '', '>&nbsp;</span>', '</tpl>' + '<img src="', Ext.BLANK_IMAGE_URL, '" ', this.enableExpandAndCollapse ? 'class="x-grid-group-expand-collapse-icon"' : '', ' />', this.emptyGroupTextTpl, '</div></div>', '<div id="{groupId}-bd" class="x-grid-group-body">', this.templateFunctions);
            this.emptyStartGroup.compile();
        }
        if (!this.endGroup) {
            this.endGroup = '</div></div>';
        }
    },
    renderRows: function (_startRow, _endRow) {
        var ds = this.grid.store;
        if (ds.getCount() < 1 && !this.supportEmptyGroups) {
            return '';
        }
        var groupField = this.getGroupField();
        var eg = !!groupField;
        if (this.hideGroupedColumn) {
            var colIndex = this.cm.findColumnIndex(groupField), hasLastGroupField = Ext.isDefined(this.lastGroupField);
            if (!eg && hasLastGroupField) {
                this.mainBody.update('');
                this.cm.setHidden(this.cm.findColumnIndex(this.lastGroupField), false);
                delete this.lastGroupField;
            }
            else if (eg && !hasLastGroupField) {
                this.lastGroupField = groupField;
                this.cm.setHidden(colIndex, true);
            }
            else if (eg && hasLastGroupField && groupField !== this.lastGroupField) {
                this.mainBody.update('');
                var oldIndex = this.cm.findColumnIndex(this.lastGroupField);
                this.cm.setHidden(oldIndex, false);
                this.lastGroupField = groupField;
                this.cm.setHidden(colIndex, true);
            }
        }
        return Pan.base.grid.GroupingGridView.superclass.renderRows.apply(this, arguments);
    },
    renderUI: function () {
        Ext.grid.GroupingView.prototype.renderUI.apply(this, arguments);
        if (this.enableGroupingMenu && this.hmenu) {
            this.hmenu.items.each(function (item) {
                if (item.itemId === 'groupBy') {
                    item.hidden = true;
                    return false;
                }
            });
        }
    },
    renderBody: function () {
        return Pan.base.grid.SpanningGridView.superclass.renderBody.apply(this, arguments);
    },
    fastRenderExtraPixelLines: 200,
    doFastRender: function () {
        var rows = this.getRows();
        if (rows && rows.length > 0) {
            var scrollerHeight = this.scroller.getHeight();
            var scrollTop = this.scroller.dom.scrollTop;
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (row.offsetTop >= scrollTop + scrollerHeight + this.fastRenderExtraPixelLines) {
                    break;
                }
                if (row.offsetTop + row.offsetHeight >= scrollTop) {
                    if (row.childNodes.length === 0) {
                        var index = row.rowIndex;
                        var html = Pan.base.grid.GroupingGridView.superclass.doRender.call(this, this.getColumnData(), this.grid.store.getRange(index, index), this.grid.store, index, this.grid.colModel.getColumnCount(), this.grid.stripeRows, true);
                        Ext.fly(row).insertHtml('afterBegin', html);
                    }
                    this.processSingleRow(rows[i]);
                }
            }
        }
    },
    renderBlankRows: function (start, length) {
        var store = this.grid.store;
        var count = store.getCount();
        if (length + start < count) {
            count = length + start;
        }
        var tstyle = 'width:' + this.getTotalWidth() + ';';
        var div = this.spanningRowPlaceHolderForFastRenderDivBegin.replace('{tstyle}', tstyle);
        var stripe = this.grid.stripeRows;
        var records = store.getRange(0, count - 1);
        var rowParams = {tstyle: tstyle, cols: this.grid.colModel.getColumnCount()};
        var i = start;
        var rv = [];
        for (var j = 0; j < 1000 && i < count; j++, i++) {
            var alt = "";
            if (stripe && ((i + 1) % 2 === 0)) {
                alt = 'x-grid3-row-alt';
            }
            if (records[i].dirty) {
                alt += ' x-grid3-dirty-row';
            }
            if (this.getRowClass) {
                alt += this.getRowClass(records[i], i, rowParams, store);
            }
            rv.push(div.replace('{alt}', alt) + this.spanningRowPlaceHolderForFastRenderDivEnd);
        }
        return rv.join("");
    },
    doRender: function (cs, rs, ds, startRow, colCount, stripe) {
        if (rs.length < 1 && !this.supportEmptyGroups) {
            return '';
        }
        if (!this.canGroup() || this.isUpdating) {
            return Pan.base.grid.GroupingGridView.superclass.doRender.apply(this, arguments);
        }
        var groupField = this.getGroupField(), colIndex = this.cm.findColumnIndex(groupField), g,
            gstyle = 'width:' + this.getTotalWidth() + ';', cfg = this.cm.config[colIndex],
            groupRenderer = cfg.groupRenderer || cfg.renderer,
            prefix = this.showGroupName ? (cfg.groupName || cfg.header) + ': ' : '', groups = [], curGroup, i, len, gid;
        for (i = 0, len = rs.length; i < len; i++) {
            var rowIndex = startRow + i, r = rs[i], gvalue = r.data[groupField];
            g = this.getGroup(gvalue, r, groupRenderer, rowIndex, colIndex, ds);
            if (!curGroup || curGroup.group != g) {
                gid = this.constructId(gvalue, groupField, colIndex);
                this.state[gid] = !(Ext.isDefined(this.state[gid]) ? !this.state[gid] : this.startCollapsed);
                curGroup = {
                    group: g,
                    gvalue: gvalue,
                    groupName: Ext.util.Format.htmlEncode(gvalue),
                    text: prefix + g,
                    groupId: gid,
                    startRow: rowIndex,
                    rs: [r],
                    cls: this.state[gid] ? '' : 'x-grid-group-collapsed',
                    style: gstyle
                };
                groups.push(curGroup);
            }
            else {
                curGroup.rs.push(r);
            }
            r._groupId = gid;
        }
        var buf = [];
        for (i = 0, len = groups.length; i < len; i++) {
            g = groups[i];
            this.doGroupStart(buf, g, cs, ds, colCount);
            if (!this.supportFastRender) {
                buf[buf.length] = Pan.base.grid.GroupingGridView.superclass.doRender.call(this, cs, g.rs, ds, g.startRow, colCount, stripe);
            }
            else {
                buf[buf.length] = this.renderBlankRows(g.startRow, g.rs.length);
            }
            this.doGroupEnd(buf, g, cs, ds, colCount);
        }
        if (this.supportEmptyGroups) {
            var missingGroups = ds.getMissingGroups();
            if (Ext.isArray(missingGroups) && missingGroups.length > 0) {
                for (var j = 0; j < missingGroups.length; j++) {
                    this.doEmptyGroupStart(buf, missingGroups[j], gstyle);
                    this.doGroupEnd(buf);
                }
            }
        }
        return buf.join('');
    },
    doEmptyGroupStart: function (buf, missingGroup, gstyle) {
        var groupName = missingGroup.name;
        var myGroup = {
            group: groupName,
            gvalue: groupName,
            text: groupName,
            groupId: groupName,
            cls: 'x-grid-group-collapsed',
            style: gstyle
        };
        buf[buf.length] = this.emptyStartGroup.apply(myGroup);
        this.doGroupEnd(buf, myGroup);
    },
    interceptMouse: function (e) {
        if (this.isGroupingByParent) {
            var hd = e.getTarget('.x-grid-group-hd', this.mainBody);
            if (this.enableExpandAndCollapse && e.getTarget().className === 'x-grid-group-expand-collapse-icon') {
                e.stopEvent();
                this.toggleGroup(hd.parentNode);
            }
            if (this.enableGroupSelect && e.getTarget().className === 'x-grid-group-select-icon') {
                e.stopEvent();
                this.selectGroup(hd.parentNode);
            }
            var elems = this.el.query('.x-grid-group-title');
            Ext.each(elems, function (item) {
                item.className = 'x-grid-group-title';
            });
            var grpRow = e.getTarget('.x-grid-group-title', this.mainBody);
            if (grpRow) {
                e.stopEvent();
                var sm = this.grid.getSelectionModel();
                sm.clearSelections();
                grpRow.className = 'x-grid-group-title x-grid3-row-selected';
            }
        }
        else {
            var hdr = e.getTarget('.x-grid-group-hd', this.mainBody);
            if (hdr && e.getTarget().tagName == "A") {
                return;
            }
            if (this.enableExpandAndCollapse) {
                Ext.grid.GroupingView.prototype.interceptMouse.apply(this, arguments);
            }
        }
    },
    toggleGroup: function (_group, _expanded) {
        var result = Ext.grid.GroupingView.prototype.toggleGroup.apply(this, arguments);
        if (this.grid.supportFastRender) {
            this.doFastRender();
        }
        return result;
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.RowPanelExpander = Ext.extend(Ext.ux.grid.RowPanelExpander, {
    doHTMLEncode: false, createExpandingRowPanel: function (record, rowBody, rowIndex) {
        this.expandingRowPanel = [];
        Pan.base.grid.RowPanelExpander.superclass.createExpandingRowPanel.call(this, record, rowBody, rowIndex);
    }, renderer: function () {
        return [{value: '<div class="x-grid3-row-expander">&#160;</div>'}];
    }, getRowClass: function () {
        if (this.grid.clearRowExpanderStateOnRefresh) {
            this.state = {};
        }
        return Pan.base.grid.RowPanelExpander.superclass.getRowClass.apply(this, arguments);
    }, expandRow: function (row) {
        if (typeof row == 'number') {
            row = this.grid.view.getRow(row);
        }
        var record = this.grid.store.getAt(row.rowIndex);
        var body = Ext.DomQuery.selectNode('tr:nth(' + (this.grid.maxMiniCellRows[row.rowIndex] + 1) + ') div.x-grid3-row-body', row);
        if (this.beforeExpand(record, body, row.rowIndex)) {
            this.state[record.id] = true;
            Ext.fly(row).replaceClass('x-grid3-row-collapsed', 'x-grid3-row-expanded');
            this.fireEvent('expand', this, record, body, row.rowIndex);
        }
    }
});
Ext.preg('pan-rowexpander', Pan.base.grid.RowPanelExpander);
Pan.base.grid.CheckColumn = Ext.extend(Ext.grid.BooleanColumn, {
    constructor: function (config) {
        Pan.base.grid.CheckColumn.superclass.constructor.call(this, config);
        Ext.apply(this, Ext.ux.grid.CheckColumn.prototype);
        this.renderer = function (v, p) {
            var cls = '';
            var editor = this.getCellEditor ? this.getCellEditor() : undefined;
            if (Ext.isObject(v) || v === true || v === 'true' || v === 1 || v === 'yes') {
                cls = 'x-grid3-check-col-on';
                if (!editor || editor.viewOnlyEditor) {
                    cls += ' x-grid3-check-col-on-nonediting x-item-disabled';
                }
            }
            else {
                cls = 'x-grid3-check-col';
                if (!editor || editor.viewOnlyEditor) {
                    cls += ' x-grid3-check-col-nonediting x-item-disabled';
                }
            }
            if (p) {
                p.css += ' x-grid3-check-col-td';
            }
            return String.format('<div class="{0}"></div>', cls);
        };
        if (config && config.renderer) {
            this.renderer = Pan.base.util.createExtension(config.renderer, this.renderer);
        }
    }
});
Ext.grid.Column.types.panbooleancolumn = Pan.base.grid.CheckColumn;
Pan.base.grid.CheckColumn.Singleton = (function () {
    var instance = null;
    return new function () {
        this.getInstance = function () {
            if (instance == null) {
                instance = new Pan.base.grid.CheckColumn();
            }
            return instance;
        };
    }();
})();
Pan.base.grid.CheckLinkColumn = Ext.extend(Ext.grid.BooleanColumn, {
    constructor: function (config) {
        Pan.base.grid.CheckLinkColumn.superclass.constructor.call(this, config);
        Ext.apply(this, Ext.ux.grid.CheckColumn.prototype);
        this.renderer = function (v, p) {
            var cls = config.columnCls ? config.columnCls : '';
            var editor = this.getCellEditor ? this.getCellEditor() : undefined;
            if (Ext.isObject(v) || v === true || v === 'true' || v === 1 || v === 'yes') {
                cls += ' x-grid3-check-col-on';
                if (!editor || editor.viewOnlyEditor) {
                    cls += ' x-grid3-check-col-on-nonediting';
                }
            }
            else {
                cls += ' x-grid3-check-col';
                if (!editor || editor.viewOnlyEditor) {
                    cls += ' x-grid3-check-col-nonediting';
                }
            }
            if (p) {
                p.css += ' x-grid3-check-col-td';
            }
            return String.format('<div class="{0}"><a href="javascript:void(0)" style="display: block; width: 100%; height: 100%;"></a></div>', cls);
        };
        if (config && config.renderer) {
            this.renderer = Pan.base.util.createExtension(config.renderer, this.renderer);
        }
    }
});
Ext.grid.Column.types.panbooleanlinkcolumn = Pan.base.grid.CheckLinkColumn;
Pan.base.grid.CheckColumnEditor = Ext.extend(Ext.util.Observable, {
    startEdit: function (el, value) {
        var boundEl = Ext.get(el);
        var v = value !== undefined ? value : boundEl.dom.innerHTML;
        if (this.fireEvent('beforestartedit', this, boundEl, v) !== false) {
            this.startValue = v;
            this.completeEdit();
        }
    }, completeEdit: function () {
        if (this.fireEvent('beforecomplete', this, undefined, this.startValue) !== false) {
            this.fireEvent('complete', this, !this.startValue, this.startValue);
        }
    }, cancelEdit: function () {
    }, destroy: function () {
    }
});
Ext.reg('panbooleancolumneditor', Pan.base.grid.CheckColumnEditor);
Pan.base.grid.SequenceCheckColumnEditor = Ext.extend(Pan.base.grid.CheckColumnEditor, {
    completeEdit: function () {
        if (this.fireEvent('beforecomplete', this, undefined, this.startValue) !== false) {
            this.fireEvent('complete', this, !this.startValue ? {} : undefined, this.startValue);
        }
    }
});
Ext.reg('pansequencebooleancolumneditor', Pan.base.grid.SequenceCheckColumnEditor);
Ext.ns('Pan.base.grid');
Pan.base.grid.CheckboxSelectionModel = Pan.base.util.cextend(Ext.ux.grid.livegrid.RowSelectionModel, "isLiveGrid", {
    doHTMLEncode: false,
    pageable: undefined,
    header: '<div class="x-grid3-hd-checker">&#160;</div>',
    useHeaderChecker: false,
    checkerInNthColumn: false,
    width: Ext.isChrome ? 18 : 20,
    sortable: false,
    menuDisabled: true,
    fixed: true,
    hideable: false,
    dataIndex: '',
    id: 'checker',
    constructor: function (config) {
        Pan.base.grid.CheckboxSelectionModel.superclass.constructor.apply(this, arguments);
        if (!this.useHeaderChecker) {
            this.header = '';
        }
        if (config && config.header) {
            this.header = config.header;
            this.id = 'checker1';
        }
        if (config && config.checkerInNthColumn) {
            this.id = 'checkerN';
        }
        if (this.checkOnly || (config && config.checkerInNthColumn)) {
            this.handleMouseDown = Ext.emptyFn;
        }
    },
    initEvents: function () {
        if (this.grid.supportFastRender && !Ext.isFunction(this.isRowSelectable)) {
            Ext.apply(this, {supportFastRender: this.grid.supportFastRender});
        }
        Pan.base.grid.CheckboxSelectionModel.superclass.initEvents.call(this);
        this.grid.on('render', function () {
            var view = this.grid.getView();
            view.mainBody.on('mousedown', this.onMouseDown, this);
            Ext.fly(view.innerHd).on('mousedown', this.onHdMouseDown, this);
        }, this);
        if (Ext.isFunction(this.isRowSelectable)) {
            this.addListener('beforerowselect', function (selModel, index, keepExisting, record) {
                return this.isRowSelectable(record);
            }, this);
        }
    },
    handleMouseDown: function (g, rowIndex, e) {
        this.lastMouseEvent = {rowIndex: rowIndex, event: e};
        if (Ext.isDefined(arguments[1])) {
            if (!Ext.fly(e.target).hasClass('x-grid3-row-checker') && !Ext.fly(e.target).hasClass("row-selection-disabled")) {
                if (this.supportFastRender) {
                    this.suspendEvents(false);
                    this.selections && this.selections.suspendEvents(false);
                    if (this.selections.getCount() > 1500) {
                        this.__enableFastClearSelections = true;
                    }
                }
                Pan.base.grid.CheckboxSelectionModel.superclass.handleMouseDown.apply(this, arguments);
                if (this.supportFastRender) {
                    var fastClearSelectionsPerformed = this.__enableFastClearSelections;
                    delete this.__enableFastClearSelections;
                    this.selections && this.selections.resumeEvents();
                    this.resumeEvents();
                    this.fireEvent('selectionchange', this);
                    if (fastClearSelectionsPerformed) {
                        this.grid.view.doFastRender();
                    }
                }
                this.mouseHandled = false;
            }
        }
    },
    clearSelections: function (fast) {
        if (this.isLiveGrid) {
            Pan.base.grid.CheckboxSelectionModel.superclass.clearSelections.call(this, fast || this.__enableFastClearSelections);
        }
        else {
            if (this.isLocked()) {
                return;
            }
            if (fast !== true) {
                var ds = this.grid.store;
                var s = this.selections;
                var index = 0;
                ds.each(function (r) {
                    if (this.isSelected(r)) {
                        this.deselectRow(index);
                    }
                    index++;
                }, this);
                s.clear();
            }
            else {
                this.selections.clear();
            }
            this.last = false;
        }
    },
    onMouseDown: function (e, t) {
        if (this.grid.selectionAlwaysToggleOnAndOff || (e.button === 0 && t.className == 'x-grid3-row-checker')) {
            e.stopEvent();
            if (this.preventRowSelectClassName && e.getTarget('.' + this.preventRowSelectClassName)) {
                return;
            }
            var row = e.getTarget('.x-grid3-row');
            if (!this.mouseHandled && row) {
                var index = row.rowIndex;
                if (this.isSelected(index)) {
                    this.deselectRow(index);
                }
                else {
                    this.selectRow(index, true);
                }
                if (this.pageable) {
                    this.updatePagingBar();
                }
            }
        }
        this.mouseHandled = false;
    },
    onHdMouseDown: function (e, t) {
        if (t.className == 'x-grid3-hd-checker') {
            e.stopEvent();
            var hd = Ext.fly(t.parentNode);
            var isChecked = hd.hasClass('x-grid3-hd-checker-on');
            if (isChecked) {
                hd.removeClass('x-grid3-hd-checker-on');
                this.clearSelectionsP();
            }
            else {
                hd.addClass('x-grid3-hd-checker-on');
                this.selectAll();
            }
            this.updatePagingBar();
        }
    },
    hasOneSelection: function () {
        return this.selections.length == 1;
    },
    updatePagingBar: function () {
        if (this.pageable && this.grid.bottomToolbar) {
            this.grid.bottomToolbar.items.each(function (c) {
                if (Ext.isFunction(c.updateInfo)) {
                    c.updateInfo();
                }
            });
        }
    },
    renderer: function (v, p, record) {
        if (this.isRowSelectable && this.isRowSelectable(record) === false) {
            return "";
        }
        return '<div class="x-grid3-row-checker">&#160;</div>';
    },
    onRefresh: function () {
        if (this.pageable || this.supportFastRender) {
            var ds = this.grid.store, index;
            var s = this.getSelections();
            if (this.supportFastRender) {
                this.suspendEvents(false);
                this.selections && this.selections.suspendEvents(false);
            }
            for (var i = 0, len = s.length; i < len; i++) {
                var r = s[i];
                if (!ds.getById(r.id)) {
                    this.selections.remove(r);
                }
            }
            index = 0;
            ds.each(function (r) {
                if (this.isSelected(r)) {
                    this.selectRowP(index, true, undefined, r.id);
                }
                index++;
            }, this);
            if (this.supportFastRender) {
                this.selections && this.selections.resumeEvents();
                this.resumeEvents();
            }
            this.fireEvent('selectionchange', this);
        }
        else {
            Pan.base.grid.CheckboxSelectionModel.superclass.onRefresh.apply(this, arguments);
        }
    },
    selectRowP: function (index, keepExisting, preventViewNotify, rId) {
        if (this.isLocked() || (index < 0 || index >= this.grid.store.getTotalCount())) {
            return;
        }
        var r;
        if (Ext.isDefined(rId)) {
            r = this.grid.store.getById(rId);
            if (r === undefined)
                r = this.grid.store.pagingSnapshot.get(rId);
        }
        else {
            if (this.grid.store.pagingSnapshot) {
                r = this.grid.store.pagingSnapshot.itemAt(index);
            }
            else {
                r = this.grid.store.getAt(index);
            }
        }
        if (r && this.fireEvent('beforerowselect', this, index, keepExisting, r) !== false) {
            if (!keepExisting || this.singleSelect) {
                this.clearSelections();
            }
            this.selections.add(r);
            this.last = this.lastActive = index;
            if (!preventViewNotify) {
                this.grid.getView().onRowSelect(index);
            }
            this.fireEvent('rowselect', this, index, r);
            this.fireEvent('selectionchange', this);
        }
    },
    selectAll: function () {
        if (this.pageable) {
            if (this.isLocked()) {
                return;
            }
            if (this.grid.store.pagingSnapshot) {
                this.selections.addAll(this.grid.store.pagingSnapshot.items);
            }
            var i, len;
            if (this.isLiveGrid) {
                var view = this.grid.getView();
                var rows = view.getRows(), cursor = view.rowIndex;
                for (i = 0, len = rows.length; i < len; i++) {
                    this.selectRowP(cursor + i, true);
                }
            }
            else {
                for (i = 0, len = this.grid.store.getCount(); i < len; i++) {
                    this.selectRowP(i, true);
                }
            }
        }
        else {
            Pan.base.grid.CheckboxSelectionModel.superclass.selectAll.apply(this, arguments);
        }
    },
    selectRecords: function (records, keepExisting, doPerformanceReindex) {
        if (!this.grid) {
            return;
        }
        if (this.pageable) {
            if (!keepExisting) {
                this.clearSelections();
            }
            var ds = this.grid.store;
            var items = ds.pagingSnapshot || ds.data;
            if (doPerformanceReindex) {
                for (var k = 0; k < items.length; k++) {
                    items.items[k].__storeIndex = k;
                }
            }
            if (doPerformanceReindex) {
                this.suspendEvents(false);
            }
            var notFoundArray = [];
            for (var i = 0, len = records.length; i < len; i++) {
                if (!records[i]) {
                    continue;
                }
                if (doPerformanceReindex) {
                    var item = items.item(records[i].id);
                    if (item) {
                        this.selectRowP(item.__storeIndex, true);
                    }
                    else {
                        notFoundArray.push(records[i]);
                    }
                }
                else {
                    var index = items.indexOf(records[i]);
                    if (index >= 0) {
                        this.selectRowP(index, true);
                    }
                    else {
                        notFoundArray.push(records[i]);
                    }
                }
            }
            if (notFoundArray.length > 0) {
                this.selections.addAll(notFoundArray);
            }
            if (doPerformanceReindex) {
                this.resumeEvents();
            }
        }
        else {
            Pan.base.grid.CheckboxSelectionModel.superclass.selectRecords.apply(this, arguments);
        }
    },
    clearSelectionsP: function (fast) {
        if (this.pageable && this.grid.store.pagingSnapshot) {
            if (this.isLocked()) {
                return;
            }
            var ds = this.grid.store;
            var ps = this.grid.store.pagingSnapshot;
            for (var i = 0; i < ps.items.length; i++) {
                var storeIndex = ds.indexOfId(ps.items[i].id);
                if (storeIndex !== -1) {
                    this.deselectRow(storeIndex);
                }
                else {
                    this.selections.remove(ps.items[i]);
                }
            }
            this.last = false;
        }
        else {
            if (this.grid) {
                Pan.base.grid.CheckboxSelectionModel.superclass.clearSelections.apply(this, arguments);
            }
        }
    },
    getResultCount: function () {
        var inStoreTotal = 0;
        var total = 0;
        var s = this.selections;
        s.each(function (r) {
            total++;
            if (r.store.data.key(r.id)) {
                inStoreTotal++;
            }
        }, this);
        return {total: total, inStoreTotal: inStoreTotal};
    }
});
Pan.base.grid.ColumnWidthCalculator = Ext.extend(Object, {
    init: function (grid) {
        this.grid = grid;
        var v = grid.getView();
        v.renderUI = v.renderUI.createSequence(this.renderUI, this);
        grid.onAllByContentClick = this.onAllByContentClick.createDelegate(this);
    }, renderUI: function () {
        var g = this.grid, v = g.view;
        var _this = this;
        if (!this.getCellTextWidth) {
            Pan.base.grid.ColumnWidthCalculator.prototype.getCellTextWidth = Pan.base.util.textWidthCalculator(g.el);
        }
        if (v.hmenu) {
            var adjAllCol = {
                itemId: 'adjAllCol',
                hideOnClick: true,
                text: _T('Adjust Columns'),
                iconCls: '',
                scope: _this,
                handler: _this.onAllByContentClick
            };
            v.hmenu.add('separator');
            v.hmenu.add(adjAllCol);
        }
    }, onAllByContentClick: function () {
        var grid = this.grid;
        var firstIndex = 0;
        var lastIndex = grid.getView().mainBody ? grid.getView().getRows().length - 1 : -1;
        if (lastIndex >= 0) {
            var view = grid.view;
            var i = 0;
            var columnIndex = 0;
            var columnConfig;
            var minWidthArray = [];
            var needToResizeColumns = [];
            var flexibleWidthColumns = [];
            var colModel = grid.getColumnModel();
            var colCount = colModel.getColumnCount();
            for (i = 0; i < colCount; i++) {
                columnConfig = colModel.getColumnAt(i);
                if (colModel.isFixed(i)) {
                    minWidthArray[i] = colModel.getColumnWidth(i);
                }
                else if (colModel.isHidden(i)) {
                    minWidthArray[i] = 0;
                }
                else {
                    minWidthArray[i] = Ext.isNumber(columnConfig.minColumnWidth) ? columnConfig.minColumnWidth : grid.minColumnWidth;
                    needToResizeColumns.push(i);
                    if (columnConfig.flexibleWidth) {
                        flexibleWidthColumns.push(i);
                    }
                }
            }
            var optimalWidthArray = minWidthArray.slice(0);
            var avgWidthArray = minWidthArray.slice(0);
            var minGridWidth = 0;
            for (i = 0; i < colCount; i++) {
                minGridWidth += minWidthArray[i];
            }
            var totalWidth = grid.getWidth();
            if (minGridWidth < totalWidth) {
                var rows = view.getRows();
                for (i = 0; i < needToResizeColumns.length; i++) {
                    columnIndex = needToResizeColumns[i];
                    columnConfig = colModel.getColumnAt(columnIndex);
                    var additionalPadding = Ext.isNumber(columnConfig.additionalPadding) ? columnConfig.additionalPadding : 0;
                    var largestWidth = this.getCellTextWidth(columnConfig.header) + 24 + additionalPadding;
                    var minWidth = minWidthArray[columnIndex];
                    var widthSum = 0;
                    var maxColumnWidth = columnConfig.maxColumnWidth;
                    if (!Ext.isNumber(columnConfig.maxColumnWidth)) {
                        maxColumnWidth = parseInt(totalWidth * 0.6);
                    }
                    var selector = ".x-grid3-col-" + columnConfig.id;
                    for (var j = firstIndex; j <= lastIndex; j++) {
                        var rv = Ext.fly(rows[j]).select(selector).elements;
                        for (var k = 0; k < rv.length; k++) {
                            var text = rv[k].innerHTML;
                            var currentWidth = Math.max(minWidth, this.getCellTextWidth(text) + 13 + additionalPadding);
                            widthSum += currentWidth;
                            largestWidth = Math.max(largestWidth, currentWidth);
                        }
                        if (largestWidth >= maxColumnWidth) {
                            largestWidth = maxColumnWidth;
                        }
                    }
                    avgWidthArray[columnIndex] = widthSum / (lastIndex - firstIndex + 1);
                    optimalWidthArray[columnIndex] = Math.max(minWidth, largestWidth);
                    if (avgWidthArray[columnIndex] > optimalWidthArray[columnIndex]) {
                        avgWidthArray[columnIndex] = optimalWidthArray[columnIndex];
                    }
                }
                if (view.forceFit) {
                    var optimalGridWidth = 0;
                    for (i = 0; i < colCount; i++) {
                        optimalGridWidth += optimalWidthArray[i];
                    }
                    var extraWidth = 0;
                    if (optimalGridWidth < totalWidth) {
                        if (flexibleWidthColumns.length === 0) {
                            flexibleWidthColumns = needToResizeColumns;
                        }
                        if (flexibleWidthColumns.length > 0) {
                            extraWidth = (totalWidth - optimalGridWidth) / flexibleWidthColumns.length;
                            var potentiallyNeedFurtherReadjustColumns = [];
                            var needToReadjust = false;
                            for (i = 0; i < flexibleWidthColumns.length; i++) {
                                columnIndex = flexibleWidthColumns[i];
                                optimalWidthArray[columnIndex] += extraWidth;
                                if (optimalWidthArray[columnIndex] > colModel.getColumnAt(columnIndex).maxColumnWidth) {
                                    optimalWidthArray[columnIndex] = colModel.getColumnAt(columnIndex).maxColumnWidth;
                                    needToReadjust = true;
                                }
                                else {
                                    potentiallyNeedFurtherReadjustColumns.push(columnIndex);
                                }
                            }
                            if (needToReadjust && potentiallyNeedFurtherReadjustColumns.length > 0) {
                                optimalGridWidth = 0;
                                for (i = 0; i < colCount; i++) {
                                    optimalGridWidth += optimalWidthArray[i];
                                }
                                extraWidth = (totalWidth - optimalGridWidth) / potentiallyNeedFurtherReadjustColumns.length;
                                for (i = 0; i < potentiallyNeedFurtherReadjustColumns.length; i++) {
                                    columnIndex = potentiallyNeedFurtherReadjustColumns[i];
                                    optimalWidthArray[columnIndex] += extraWidth;
                                }
                            }
                        }
                    }
                    else {
                        if (needToResizeColumns.length > 0) {
                            var needFurtherReadjustColumns = [];
                            for (i = 0; i < needToResizeColumns.length; i++) {
                                columnIndex = needToResizeColumns[i];
                                if (Ext.isNumber(colModel.getColumnAt(columnIndex).minColumnWidth)) {
                                    optimalWidthArray[columnIndex] = minWidthArray[columnIndex];
                                }
                                else {
                                    optimalWidthArray[columnIndex] = avgWidthArray[columnIndex];
                                    needFurtherReadjustColumns.push(columnIndex);
                                }
                            }
                            optimalGridWidth = 0;
                            for (i = 0; i < colCount; i++) {
                                optimalGridWidth += optimalWidthArray[i];
                            }
                            if (Math.abs(optimalGridWidth - totalWidth) >= 0.01) {
                                if (needFurtherReadjustColumns.length > 0) {
                                    var needFurtherReadjustColumnsTotalWidth = 0;
                                    for (i = 0; i < needFurtherReadjustColumns.length; i++) {
                                        columnIndex = needFurtherReadjustColumns[i];
                                        needFurtherReadjustColumnsTotalWidth += optimalWidthArray[columnIndex];
                                    }
                                    var extraTotalWidth = totalWidth - optimalGridWidth;
                                    for (i = 0; i < needFurtherReadjustColumns.length; i++) {
                                        columnIndex = needFurtherReadjustColumns[i];
                                        optimalWidthArray[columnIndex] += (optimalWidthArray[columnIndex] / needFurtherReadjustColumnsTotalWidth) * extraTotalWidth;
                                    }
                                }
                            }
                        }
                    }
                }
                var needToUpdateColumnWidth = false;
                for (i = 0; i < needToResizeColumns.length; i++) {
                    var resizeIndex = needToResizeColumns[i];
                    optimalWidthArray[resizeIndex] = Math.floor(optimalWidthArray[resizeIndex]);
                    if (Math.abs(optimalWidthArray[resizeIndex] - colModel.getColumnWidth(resizeIndex)) >= 0.01) {
                        colModel.setColumnWidth(resizeIndex, optimalWidthArray[resizeIndex], true);
                        needToUpdateColumnWidth = true;
                    }
                }
                if (needToUpdateColumnWidth) {
                    view.updateAllColumnWidths();
                    this.grid.saveState();
                }
            }
        }
    }, initHeaderTextWidth: function (el) {
        if (Pan.base.headerTextWidthMap) {
            return;
        }
        Pan.base.headerTextWidthMap = {};
        for (var i = 32; i < 127; i++) {
            Pan.base.headerTextWidthMap[i] = el.getTextWidth(String.fromCharCode(i));
        }
    }, getHeaderTextWidth: function (text) {
        var width = 8 * 2;
        if (text) {
            for (var i = 0; i < text.length; i++) {
                var current = Pan.base.headerTextWidthMap[text.charCodeAt(i)];
                current = Ext.isNumber(current) ? current : Pan.base.headerTextWidthMap[37];
                width += current;
            }
        }
        return width;
    }
});
Pan.base.grid.ColumnWidthCalculator_OLD = Ext.extend(Ext.ux.ColumnWidthCalculator, {
    init: function (grid) {
        this.grid = grid;
        var v = grid.getView();
        v.renderUI = v.renderUI.createSequence(this.renderUI, this);
        grid.onAllByContentClick = this.onAllByContentClick.createDelegate(this);
    }, renderUI: function () {
        var g = this.grid, v = g.view;
        var _this = this;
        if (v.hmenu) {
            var adjAllCol = {
                itemId: 'adjAllCol',
                hideOnClick: true,
                text: _T('Adjust Columns'),
                iconCls: '',
                scope: _this,
                handler: _this.onAllByContentClick
            };
            v.hmenu.add('separator');
            v.hmenu.add(adjAllCol);
        }
    }, resizeByHeader: function (colIndex, isCanceled, callback) {
        if (callback) {
            callback();
        }
    }, onAllByContentClick: function () {
        var cfg = this.grid.colModel.config;
        if (this.grid.store.getCount() <= 0) {
            return;
        }
        for (var i = 0; i < cfg.length; i++) {
            if (cfg[i].id === 'checker' || cfg[i].id == 'expander') {
                cfg[i].autoAdjust = 'header';
            }
            else {
                cfg[i].autoAdjust = 'content';
            }
        }
        this.initTask(cfg).start();
    }, initTask: function (cols) {
        return this.task.init({
            queue: cols, scope: this, success: function () {
                this.unMask();
                this.cleanEl();
            }, stepScope: this, beforeStep: function (col, i, queue) {
                this.mask(this.maskTemplate.apply({header: col.header, percent: Math.round(i * 100 / queue.length)}));
                this.createEl();
            }, step: function (col, i, task) {
                var type = col.autoAdjust;
                var fn = this[type === 'header' ? 'resizeByHeader' : 'resizeByContent'];
                fn.call(this, i, function () {
                    return task.isCanceled();
                }, function () {
                    task.next();
                });
            }, onCancel: function () {
                this.unMask();
                this.cleanEl();
            }
        });
    }, mask: function () {
    }, unMask: function () {
    }, onMaskClick: function () {
    }, resizeByContent: function (colIndex, isCanceled, callback) {
        var g = this.grid, cm = g.colModel, v = g.getView(), ds = g.store;
        var rowIndex = v.isLiveGrid ? ds.bufferRange[0] : 0;
        var rowCount = v.isLiveGrid ? ds.bufferRange[1] + 1 : ds.getCount();
        var col = cm.config[colIndex];
        var max = 0, w, c, hw, row = rowIndex;
        var _this = this;
        (function () {
            if (isCanceled()) {
                return;
            }
            c = Ext.fly(v.getHeaderCell(colIndex));
            c = c.first('.x-grid3-hd-inner');
            _this.initHeaderTextWidth(c);
            _this.initCellTextWidth(_this.el);
            hw = _this.getHeaderTextWidth(col.header);
            for (var x = 0; x < rowCount; x++) {
                if (row < rowCount) {
                    var p = {};
                    p.id = col.id;
                    p.grid = _this.grid;
                    var text = col.renderer(ds.getAt(row).get(col.dataIndex), p, ds.getAt(row), row, col, ds, g);
                    if (Ext.isArray(text)) {
                        for (var r = 0; r < text.length; r++) {
                            var value = text[r];
                            var minicelltext = col.spanCellRenderer ? col.spanCellRenderer(value, p, ds.getAt(row), row, col, ds, g) : value;
                            w = _this.getCellTextWidth(minicelltext) + 12;
                            max = Math.max(max, w);
                        }
                    }
                    else {
                        w = _this.getCellTextWidth(text) + 12;
                        max = Math.max(max, w);
                    }
                }
                else {
                    max = Math.max(max, hw);
                    v.onColumnSplitterMoved(colIndex, max);
                    if (callback) {
                        callback();
                    }
                    return;
                }
                row++;
            }
            setTimeout(arguments.callee, 0);
        }).call(this);
    }, initHeaderTextWidth: function (el) {
        if (Pan.base.headerTextWidthMap) {
            return;
        }
        Pan.base.headerTextWidthMap = {};
        for (var i = 32; i < 127; i++) {
            Pan.base.headerTextWidthMap[i] = el.getTextWidth(String.fromCharCode(i));
        }
    }, initCellTextWidth: function (el) {
        if (Pan.base.cellTextWidthMap) {
            return;
        }
        Pan.base.cellTextWidthMap = {};
        for (var i = 32; i < 127; i++) {
            Pan.base.cellTextWidthMap[i] = el.getTextWidth(String.fromCharCode(i));
        }
    }, stripDisplayNone: function (html) {
        if (Ext.isString(html)) {
            var end, start = html.indexOf('<span style="display:none">');
            if (start != -1) {
                end = html.indexOf('</span>', start);
                if (end != -1) {
                    html = html.substr(0, start) + html.substr(end);
                }
            }
        }
        return html;
    }, getHeaderTextWidth: function (text) {
        var width = 8 * 2;
        if (text) {
            for (var i = 0; i < text.length; i++) {
                var current = Pan.base.headerTextWidthMap[text.charCodeAt(i)];
                current = current || Pan.base.headerTextWidthMap[87];
                width += current;
            }
        }
        return width;
    }, getCellTextWidth: function (html) {
        if (!html) {
            return 0;
        }
        var width = 0;
        var text = Ext.util.Format.stripTags(this.stripDisplayNone(html));
        text = String(text).replace('&#160;', ' ');
        for (var i = 0; i < text.length; i++) {
            var current = Pan.base.cellTextWidthMap[text.charCodeAt(i)];
            current = current || Pan.base.headerTextWidthMap[87];
            width += current;
        }
        if (typeof(html) == 'string') {
            html.replace(/<img/, function () {
                width += 28;
                return '';
            });
        }
        return width;
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.AddGroupAction = Ext.extend(Pan.base.grid.AddRecordAction, {
    constructor: function (config) {
        Pan.base.grid.AddGroupAction.superclass.constructor.call(this, Ext.apply({
            text: config.scope.groupNamePrefix ? _T('Add') + ' ' + config.scope.groupNamePrefix : _T('Add Group'),
            groupText: 'Grouping',
            iconCls: 'icon-add',
            ref: '../addGroupAction'
        }, config));
    }, preAction: function (element, config, event) {
        if (config.grid) {
            config.grid.stopEditing();
            var colModel = config.grid.colModel;
            var colCount = colModel.getColumnCount();
            for (var index = 0; index < colCount; index++) {
                var column = colModel.getColumnAt(index);
                if (column.editor && column.editor.isARecordEditor && !(config.grid.store.groupField == column.dataIndex)) {
                    this.editor = column.editor;
                    break;
                }
            }
        }
        this.recstore = this.store || config.component.store;
        this.rec = this.recstore.beginAdd();
        var groupFieldName = this.getGroupFieldName(config);
        this.rec.data[this.recstore.groupField] = groupFieldName;
        if (config.grid.autoGenerateRecordName) {
            this.rec.data[config.grid.getGroupStarField().name + ".@name"] = config.grid.getNextGroupRecordName(groupFieldName);
        }
    }, getGroupFieldName: function (config) {
        return config.grid.getGroupFieldName();
    }, action: function (element, config, event) {
        Pan.base.grid.AddGroupAction.superclass.action.apply(this, arguments);
        config.grid.getSelectionModel().selectRow(this.recstore.getCount() - 1);
    }, createRecordConfig: function (config, opts) {
        var rec = this.rec;
        var grid = config.grid;
        opts = opts || {};
        Ext.applyIf(opts, {
            okCallback: function (recordForm) {
                recordForm.updateRecord();
                recordForm.onCancel();
                return false;
            }, afterUpdateRecord: function (record) {
                record.store.add(rec);
                var sm = grid.getSelectionModel();
                var idx = grid.store.indexOf(rec);
                sm.selectRow(idx);
            }
        });
        return Pan.base.grid.AddGroupAction.superclass.createRecordConfig.call(this, config, opts);
    }
});
Pan.areg("addGroupAction", Pan.base.grid.AddGroupAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.AddGroupRecordAction = Ext.extend(Pan.base.grid.AddGroupAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: config.scope.groupRecordNamePrefix ? _T('Add') + ' ' + config.scope.groupRecordNamePrefix : _T('Add Entry'),
            iconCls: 'icon-add',
            ref: '../addGroupRecordAction'
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray({
            type: 'GetSelectionAvail',
            count: 2
        }, newConfig.availConfig);
        Pan.base.grid.AddGroupRecordAction.superclass.constructor.call(this, newConfig);
    }, getGroupFieldName: function (config) {
        var selected = config.grid.getSelectionModel().getSelected();
        var grpFldName;
        var groupRow = config.grid.el.query('.x-grid-group-title.x-grid3-row-selected')[0];
        if (selected) {
            grpFldName = selected.data[this.recstore.groupField];
        }
        else if (groupRow) {
            grpFldName = groupRow.lastChild.data;
        }
        else {
            return Pan.base.grid.AddGroupRecordAction.superclass.getGroupFieldName.call(this, config);
        }
        return grpFldName;
    }, createRecordConfig: function (config, opts) {
        var rec = this.rec;
        var grid = config.grid;
        opts = opts || {};
        Ext.apply(opts, {
            afterUpdateRecord: function (record) {
                var groupRow = grid.el.query('.x-grid-group-title.x-grid3-row-selected')[0];
                var idx, lastIdx = -1;
                var sm = grid.getSelectionModel();
                if (groupRow) {
                    rec.store.getSnapshot().each(function (r) {
                        var data = record.data[rec.store.groupField];
                        lastIdx++;
                        if (r.data[rec.store.groupField] === groupRow.lastChild.data) {
                            idx = lastIdx + 1;
                        }
                    }, this);
                }
                else {
                    var selected = sm.getSelected();
                    idx = record.store.indexOf(selected) + 1;
                }
                record.store.insert(idx, rec);
                sm.selectRow(idx);
            }
        });
        return Pan.base.grid.AddGroupRecordAction.superclass.createRecordConfig.call(this, config, opts);
    }, action: function (element, config, event) {
        var selected = config.grid.getSelectionModel().getSelected();
        var groupRow = config.grid.el.query('.x-grid-group-title.x-grid3-row-selected')[0];
        if (!selected && !groupRow) {
            Pan.base.grid.AddGroupRecordAction.superclass.action.apply(this, arguments);
        }
        else {
            if (this.editor) {
                var recFormConfig = this.createRecordConfig(config);
                Pan.base.autorender.GridRecordForm.showRecordForm(recFormConfig, config.grid);
            }
            else {
                var idx, lastIdx = -1;
                if (selected) {
                    idx = this.recstore.indexOf(selected) + 1;
                }
                else if (groupRow) {
                    this.recstore.getSnapshot().each(function (r) {
                        var data = r.data[this.recstore.groupField];
                        lastIdx++;
                        if (r.data[this.recstore.groupField] === groupRow.lastChild.data) {
                            idx = lastIdx + 1;
                        }
                    }, this);
                }
                this.recstore.insert(idx, this.rec);
                if (config.grid) {
                    config.grid.getSelectionModel().selectRow(idx);
                    var columnCount = config.grid.colModel.getColumnCount();
                    for (var i = 0; i < columnCount; i++) {
                        if (!config.grid.colModel.isHidden(i) && config.grid.colModel.isCellEditable(i, idx)) {
                            config.grid.startEditing(idx, i);
                            break;
                        }
                    }
                }
            }
        }
    }
});
Pan.areg("addGroupRecordAction", Pan.base.grid.AddGroupRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.DeleteGroupRecordAction = Ext.extend(Pan.base.grid.DeleteRecordAction, {
    constructor: function (config) {
        Pan.base.grid.DeleteGroupRecordAction.superclass.constructor.call(this, Ext.apply({ref: '../deleteGroupRecordAction'}, config));
    }
});
Pan.areg("deleteGroupRecordAction", Pan.base.grid.DeleteGroupRecordAction);
Ext.ns('Pan.base.grid');
Pan.base.grid.ExpandAllColumnsAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.base.grid.ExpandAllColumnsAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Adjust Columns'),
            iconCls: 'icon-select',
            ref: '../expandAllColumnsAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
        this.action(element, config, event);
    }, preAction: function (element, config, event) {
    }, createRecordConfig: function (config, opts) {
    }, action: function (element, config, event) {
        if (config.grid) {
            config.grid.onAllByContentClick();
        }
    }
});
Pan.areg("expandAllColumnsAction", Pan.base.grid.ExpandAllColumnsAction);
Pan.base.grid.RowActions = Ext.extend(Ext.ux.grid.RowActions, {
    processActions: function (actions, template) {
        var acts = [];
        Ext.each(actions, function (a) {
            if (a.iconCls && typeof(a.callback || a.cb) === 'function') {
                this.callbacks = this.callbacks || {};
                this.callbacks[a.iconCls] = a.callback || a.cb;
            }
            var o = {
                cls: a.iconIndex ? '{' + a.iconIndex + '}' : (a.iconCls ? a.iconCls : ''),
                qtip: Pan.base.htmlEncode(a.qtipIndex ? '{' + a.qtipIndex + '}' : (a.tooltip || a.qtip ? a.tooltip || a.qtip : '')),
                text: a.textIndex ? '{' + a.textIndex + '}' : (a.text ? a.text : ''),
                hide: a.hideIndex ? '<tpl if="' + a.hideIndex + '===true">' + (this.hideMode === 'display' ? 'display:none' : 'visibility:hidden') + ';</tpl>' + '<tpl if="' + a.hideIndex + '===false">' + (this.hideMode === 'display' ? 'display:inline' : 'visibility:visible') + ';</tpl>' : (a.hide ? (this.hideMode === 'display' ? 'display:none' : 'visibility:hidden;') : ''),
                align: a.align || 'right',
                style: a.style ? a.style : ''
            };
            acts.push(o);
        }, this);
        var xt = new Ext.XTemplate(template || this.tplRow);
        return new Ext.XTemplate(xt.apply({actions: acts}), {
            processHideIndex: function (values) {
                var __hideAction = Ext.isDefined(values.__hideAction) ? values.__hideAction : values[0].__hideAction;
                if (__hideAction) {
                    return "visibility:hidden";
                }
                else {
                    return "visibility:visible";
                }
            }
        });
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.DragZone = Pan.base.util.cextend(Ext.ux.grid.livegrid.DragZone, "isLiveGrid", {});
Ext.ns('Pan.base.grid');
Pan.base.grid.DropZone = Ext.extend(Ext.dd.DropZone, {});
Ext.ns('Pan.base.grid');
Pan.base.grid.CellDropZone = Ext.extend(Pan.base.grid.DropZone, {
    containerScroll: true, constructor: function () {
    }, init: function (grid) {
        if (grid.rendered) {
            this.grid = grid;
            this.view = grid.getView();
            this.store = grid.getStore();
            Pan.base.grid.CellDropZone.superclass.constructor.call(this, this.grid.el);
            var ddGroups = [];
            if (this.grid.ddConfig) {
                ddGroups = this.grid.ddConfig.ddGroups;
            }
            Ext.each(ddGroups, function (dg) {
                this.addToGroup(dg);
            }, this);
        }
        else {
            grid.on('render', this.init, this);
        }
    }, getTargetFromEvent: function (e) {
        var target;
        var t = e.getTarget(this.view.cellSelector);
        if (t) {
            var rowIndex = this.view.findRowIndex(t);
            var colIndex = this.view.findCellIndex(t);
            if ((rowIndex !== false) && (colIndex !== false)) {
                target = {
                    node: t,
                    record: this.store.getAt(rowIndex),
                    rowIndex: rowIndex,
                    colIndex: colIndex,
                    fieldName: this.grid.getColumnModel().getDataIndex(colIndex)
                };
                return target;
            }
        }
        t = e.getTarget('input.pan-grid-filter');
        if (t) {
            target = {node: t, fieldName: 'pan-grid-filter'};
            return target;
        }
    }, onNodeEnter: function (target, dd, e, dragData) {
        delete this.dropOK;
        if (!target) {
            return false;
        }
        var record = target.record;
        if (record) {
            var info = record.json['@__recordInfo'];
            if (info) {
                var permission = info.permission;
                if (permission == 'readonly')
                    return false;
            }
        }
        var grid = this.grid;
        if (grid.ddConfig && grid.ddConfig.onNodeEnter) {
            grid.ddConfig.onNodeEnter.call(this, target, dd, e, dragData);
        }
        else {
            if (record && grid.ddConfig && grid.ddConfig.checkValidCellDrop) {
                var ret = grid.ddConfig.checkValidCellDrop.call(this, target, dd, e, dragData);
                if (!ret) {
                    return false;
                }
            }
            if (dragData.celldrag) {
                if (!grid.ddConfig || !grid.ddConfig.celldragMap) {
                    return false;
                }
                var map = Ext.apply({}, grid.celldragMapConfig, grid.ddConfig.celldragMap);
                var sf = dragData.fieldName;
                var df = target.fieldName;
                var dmap = map[sf];
                if (!dmap) {
                    return false;
                }
                if (dmap.indexOf(df) < 0) {
                    return false;
                }
            }
            else {
                var srcGrid = dragData.grid;
                var rows = dragData.selections;
                if (!srcGrid || !rows || Ext.isEmpty(rows)) {
                    return false;
                }
                var dropGroups = srcGrid.dropGroups;
                if (Ext.isEmpty(dropGroups)) {
                    return false;
                }
                var fieldName = target.fieldName;
                if (dropGroups.indexOf(fieldName) == -1) {
                    return false;
                }
            }
            this.dropOK = true;
            Ext.fly(target.node).addClass('x-drop-target-active');
        }
    }, onNodeOver: function (target, dd, e, dragData) {
        return this.dropOK ? this.dropAllowed : this.dropNotAllowed;
    }, onNodeOut: function (target, dd, e, dragData) {
        Ext.fly(target.node).removeClass('x-drop-target-active');
    }, onNodeDrop: function (target, dd, e, dragData) {
        if (this.dropOK) {
            var grid = this.grid;
            if (grid.ddConfig && grid.ddConfig.beforeNodeDrop) {
                var ret = grid.ddConfig.beforeNodeDrop.call(this, target, dd, e, dragData);
                if (!ret) {
                    return;
                }
            }
            if (grid.ddConfig && grid.ddConfig.onNodeDrop) {
                grid.ddConfig.onNodeDrop.call(this, target, dd, e, dragData);
            }
            else {
                target.record.beginEdit();
                var values = target.record.get(target.fieldName);
                if (!Ext.isArray(values)) {
                    values = [values];
                }
                if (dragData.celldrag) {
                    var info = dragData.cellInfo;
                    var v = info.record.get(dragData.fieldName);
                    if (Ext.isArray(v))
                        values = values.concat(v); else
                        values.push(v);
                }
                else {
                    var rows = dragData.selections;
                    Ext.each(rows, function (r) {
                        values.push(r.get('name'));
                    });
                }
                target.record.set(target.fieldName, values);
                target.record.endEdit();
                target.record.commit();
            }
            if (grid.ddConfig && grid.ddConfig.afterNodeDrop) {
                grid.ddConfig.afterNodeDrop.call(this, target, dd, e, dragData);
            }
            delete this.dropOK;
        }
        else {
            this.grid.ddConfig.lastSavedDragCellData = null;
        }
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.CellDragZone = Ext.extend(Ext.dd.DragZone, {
    scroll: false, constructor: function () {
    }, init: function (grid) {
        if (grid.nodeType) {
            Pan.base.grid.CellDragZone.superclass.init.apply(this, arguments);
        }
        else {
            if (grid.rendered) {
                this.grid = grid;
                this.view = grid.getView();
                this.store = grid.getStore();
                Pan.base.grid.CellDragZone.superclass.constructor.call(this, this.view.mainBody);
                var ddGroups = [];
                if (this.grid.ddConfig) {
                    ddGroups = this.grid.ddConfig.ddGroups;
                }
                Ext.each(ddGroups, function (dg) {
                    this.addToGroup(dg);
                }, this);
                if (this.view.dragZone) {
                    this.view.dragZone.getDragData = Pan.base.util.createExtension(function (event) {
                        if (this.stopEvent) {
                            return false;
                        }
                        return arguments.callee.superFunction.call(this.view.dragZone, event);
                    }, this.view.dragZone.getDragData, this);
                }
            }
            else {
                grid.on('render', this.init, this);
            }
        }
    }, getDragData: function (e) {
        this.stopEvent = false;
        var t = e.getTarget('span.x-draggable', 10);
        if (t) {
            var rowIndex = this.view.findRowIndex(t);
            var colIndex = this.view.findCellIndex(t);
            if (this.grid.getColumnModel().getDataIndex(colIndex) == 'name')
                return;
            this.stopEvent = true;
            e.stopEvent();
            e.preventDefault();
            e.stopPropagation();
            if ((rowIndex !== false) && (colIndex !== false)) {
                var info = this.grid.getCellEventInfo(rowIndex, colIndex, e);
                var node = t.cloneNode(true);
                node.id = Ext.id();
                return {
                    ddel: node,
                    repairXY: Ext.fly(t).getXY(),
                    celldrag: true,
                    cellInfo: info,
                    fieldName: this.grid.getColumnModel().getDataIndex(colIndex)
                };
            }
        }
    }, getRepairXY: function () {
        return this.dragData.repairXY;
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.GridDropTarget = Ext.extend(Ext.dd.DropTarget, {
    containerScroll: true, constructor: function () {
    }, init: function (grid) {
        if (grid.rendered) {
            this.grid = grid;
            this.view = grid.getView();
            this.store = grid.getStore();
            this.ddGroup = this.grid.ddGroup;
            Pan.base.grid.GridDropTarget.superclass.constructor.call(this, this.view.scroller);
        }
        else {
            grid.on('render', this.init, this);
        }
    }, notifyOver: function (dd, e, dragData) {
        if (this.lastTarget && this.lastClass) {
            Ext.fly(this.lastTarget).removeClass(this.lastClass);
        }
        var t = e.getTarget(this.view.rowSelector);
        if (t) {
            if (!this.isTargetValid(t, dragData))
                return this.dropNotAllowed;
            var r = Ext.fly(t);
            var top = r.getTop(false);
            var bottom = r.getBottom(false);
            var current = e.getPageY();
            this.lastClass = ((current - top) < (bottom - current)) ? 'x-drop-target-top' : 'x-drop-target-bottom';
            this.lastTarget = t;
            r.addClass(this.lastClass);
            return this.dropAllowed;
        }
        return this.dropNotAllowed;
    }, notifyDrop: function (dd, e, dragData) {
        var t = e.getTarget(this.view.rowSelector);
        if (t) {
            if (!this.isTargetValid(t, dragData))
                return false;
        }
        if (!dragData)
            return false;
        if (this.grid.ddConfig && this.grid.ddConfig.notifyDrop) {
            this.grid.ddConfig.notifyDrop.call(this, dd, e, dragData);
        }
        else {
            var sm = this.grid.getSelectionModel();
            if (sm.hasSelection()) {
                var store = this.grid.store;
                var rows = sm.getSelections();
                rows.sort(function (a, b) {
                    return store.indexOf(a) < store.indexOf(b) ? -1 : 1;
                });
                var cindex = dd.getDragData(e).rowIndex;
                var moveBeforeRecord = store.getAt(cindex);
                if (!moveBeforeRecord)
                    return false;
                var useMove = Ext.isFunction(store.move);
                for (var i = 0; i < rows.length; i++) {
                    var r = store.getById(rows[i].id);
                    if (useMove) {
                        if (r == moveBeforeRecord)
                            continue;
                        var where = (this.lastClass == 'x-drop-target-top') ? 'before' : 'after';
                        store.move(r, where, moveBeforeRecord);
                    }
                    else {
                        store.remove(r);
                        store.insert(cindex, rows[i]);
                    }
                }
                if (!useMove) {
                    sm.selectRecords(rows);
                }
            }
        }
        if (this.lastTarget && this.lastClass) {
            Ext.fly(this.lastTarget).removeClass(this.lastClass);
        }
    }, isTargetValid: function (t, dragData) {
        var r = Ext.fly(t);
        if (r.hasClass('x-grid3-add-new-row')) {
            return false;
        }
        if (r.hasClass('x-pan-panorama-row')) {
            return false;
        }
        if (!dragData)
            return false;
        var i, rec, info;
        if (!Ext.isEmpty(dragData.selections)) {
            for (i = 0; i < dragData.selections.length; i++) {
                rec = dragData.selections[i];
                if (rec.json) {
                    info = rec.json['@__recordInfo'];
                    if (info) {
                        if (info.position == 'default-security-rule')
                            return false;
                    }
                }
            }
        }
        var sm = this.grid.getSelectionModel();
        if (sm.hasSelection()) {
            var rows = sm.getSelections();
            for (i = 0; i < rows.length; i++) {
                rec = rows[i];
                if (rec.json) {
                    info = rec.json['@__recordInfo'];
                    if (info) {
                        if (info.xpathId == 'panorama' || info.position == 'default-security-rule')
                            return false;
                    }
                }
            }
        }
        if (this.grid.ddConfig && this.grid.ddConfig.isTargetValid) {
            return this.grid.ddConfig.isTargetValid.call(this, t, dragData);
        }
        else {
            return true;
        }
    }
});
Ext.ns('Pan.base.grid');
Pan.base.grid.ActionCallout = Ext.extend(Ext.util.Observable, {
    init: function (grid) {
        if (grid.rendered) {
            this.grid = grid;
            this.view = grid.getView();
            this.store = grid.getStore();
            this.grid.tip = new Pan.base.component.ToolTip({
                hideDelay: 1000,
                dismissDelay: 2000,
                autoHide: true,
                layout: 'fit',
                title: _T('Action Toolbar'),
                target: this.view.mainBody,
                renderTo: document.body,
                anchor: 'left',
                closable: true,
                delegate: '.x-toolbar-trigger',
                listeners: {
                    scope: this, beforeshow: function (tip) {
                        if (this.grid.calloutVisible)
                            return false;
                        var colIndex = this.view.findCellIndex(tip.triggerElement);
                        var fieldName = this.grid.getColumnModel().getDataIndex(colIndex);
                        var acConfig = {};
                        if (this.grid.acConfig) {
                            acConfig = this.grid.acConfig;
                        }
                        var config = acConfig[fieldName];
                        if (Ext.isEmpty(config))
                            return false;
                        var w = config.width || 200;
                        var h = config.height || 100;
                        tip.setWidth(w);
                        tip.setHeight(h);
                        tip.removeAll(true);
                        tip.add(new Pan.base.container.Panel(config));
                        tip.doLayout();
                    }
                }
            });
        }
        else {
            grid.on('render', this.init, this);
        }
    }
});
Ext.ns('Pan.base.grid.action');
Pan.base.grid.action.DuplicateValueAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.base.grid.action.DuplicateValueAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Duplicate'),
            tooltip: _T('Duplicate value to all rows'),
            iconCls: '',
            ref: '../duplicateValueAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
        this.action(element, config, event);
    }, preAction: function (element, config, event) {
        if (config.grid) {
            config.grid.stopEditing();
        }
    }, action: function (element, config, event) {
        var fieldName = this.initialConfig.fieldName || config.grid.colModel.getColumnAt(config.col).dataIndex;
        var value = this.initialConfig.value;
        if (!Ext.isDefined(value)) {
            value = config.record.get(fieldName);
        }
        var store = config.grid.store;
        store.suspendEvents(false);
        var data = store.pagingSnapshot || store.data;
        data.each(function (r) {
            var editing = r.editing;
            r.editing = true;
            r.set(fieldName, value);
            r.editing = editing;
        }, store);
        store.resumeEvents();
        store.fireEvent('datachanged', store);
    }
});
Pan.areg("duplicateValueAction", Pan.base.grid.action.DuplicateValueAction);
Ext.ns('Pan.base.grid.action');
Pan.base.grid.action.DuplicateValueToSelectedAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.base.grid.action.DuplicateValueToSelectedAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Duplicate To Selected'),
            tooltip: _T('Duplicate value to selected rows'),
            iconCls: '',
            ref: '../duplicateValueToSelectedAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
        this.action(element, config, event);
    }, preAction: function (element, config, event) {
        if (config.grid) {
            config.grid.stopEditing();
        }
    }, action: function (element, config, event) {
        var fieldName = this.initialConfig.fieldName || config.grid.colModel.getColumnAt(config.col).dataIndex;
        var value = this.initialConfig.value;
        if (!Ext.isDefined(value)) {
            value = config.record.get(fieldName);
        }
        var store = config.grid.store;
        store.suspendEvents(false);
        var sm = config.grid.getSelectionModel();
        sm.each(function (r) {
            if (config.grid.isValidAction && !config.grid.isValidAction(value, r)) {
                return true;
            }
            var editing = r.editing;
            r.editing = true;
            r.set(fieldName, value);
            r.editing = editing;
        });
        store.resumeEvents();
        store.fireEvent('datachanged', store);
    }
});
Pan.areg("duplicateValueToSelectedAction", Pan.base.grid.action.DuplicateValueToSelectedAction);
Pan.base.grid.action.AddRecordWithHiddenKeyColumnAction = Ext.extend(Pan.base.grid.AddRecordAction, {
    preAction: function (element, config, event) {
        var colDataIndex = '';
        if (config.grid) {
            config.grid.stopEditing();
            var colModel = config.grid.colModel;
            var colCount = colModel.getColumnCount();
            for (var index = 0; index < colCount; index++) {
                var column = colModel.getColumnAt(index);
                if ((column.hidden && column.hideable === false) && column.editor && (column.editor.isARecordEditor || column.editor.isAnEditor)) {
                    if (this.initialConfig.copyRecordEditor) {
                        this.editor = column.editor;
                    }
                    colDataIndex = column.dataIndex;
                    break;
                }
            }
        }
        this.setupRecord(config);
        var fieldValue = 'rule';
        for (var c = this.recstore.getCount(); ; c++) {
            if (this.recstore.findExact(colDataIndex, 'rule' + c) == -1) {
                fieldValue = 'rule' + c;
                break;
            }
        }
        this.rec.data[colDataIndex] = fieldValue;
    }
});
Pan.areg("addRecordWithHiddenKeyColumnAction", Pan.base.grid.action.AddRecordWithHiddenKeyColumnAction);
Pan.base.grid.action.CloneRecordAction = Ext.extend(Pan.base.grid.AddRecordAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Clone'),
            iconCls: 'icon-clone',
            ref: '../cloneRecordAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray({
            type: 'HasSelectionAvail',
            hasSelectionMethod: config.hasSelectionMethod
        }, newConfig.availConfig);
        Pan.base.grid.action.CloneRecordAction.superclass.constructor.call(this, newConfig);
    }, setupRecord: function (config) {
        this.recstore = this.store || config.component.store;
        if (this.recstore.beginAdd) {
            this.rec = this.recstore.beginAdd(config.record[0]);
            this.indexOfOriginalRecord = this.recstore.indexOf(config.record[0]);
            var idProperty = this.recstore.idProperty;
            if (idProperty) {
                delete this.rec[idProperty];
            }
        }
    }, addRecord: function (recstore, rec, skipFilter) {
        recstore.insert(this.indexOfOriginalRecord + 1, rec, skipFilter);
        return this.indexOfOriginalRecord + 1;
    }
});
Pan.areg("cloneRecordAction", Pan.base.grid.action.CloneRecordAction);
(function () {
    var Action = Pan.base.action.Action;
    var ExportGridAction = Ext.extend(Action, {
        constructor: function (config) {
            var newConfig = Ext.apply({
                iconCls: "icon-export-pdv-csv",
                tooltip: _T('Export table'),
                text: _T('PDF/CSV'),
                ref: '../exportGridAction',
                handler: this.action.createDelegate(this)
            }, config);
            ExportGridAction.superclass.constructor.call(this, newConfig);
        }, action: function (_element, config) {
            var panExportWindow = Pan.common.exporter.view.ExportWindow;
            panExportWindow.createGridExportWindow(config);
        }
    });
    Pan.areg('exportGridAction', ExportGridAction);
})();
(function () {
    PanEnvironment.ns('Pan.common.exporter');
    PanEnvironment.ns('Pan.common.exporter.view');
    PanEnvironment.ns('Pan.common.exporter.csv');
    PanEnvironment.ns('Pan.common.exporter.pdf');
    PanEnvironment.ns('Pan.common.exporter.pdf.templates');
}());
(function () {
    Pan.common.exporter.renderers = {
        connected: function (value) {
            return value === '' ? 'unknown' : value;
        }, bool: function (value) {
            return (value) ? 'Yes' : 'No';
        }
    };
}());
(function () {
    var renderers = Pan.common.exporter.renderers;
    Pan.common.exporter.PanTypeExportRenderer = {'panbooleancolumn': renderers.bool};
})();
(function () {
    var exportUtil = (function () {
        return {
            getExtraHeaders: function (grid) {
                var extraHeaders = [];
                if (grid.headers && grid.headers.rows) {
                    _.forEach(grid.headers.rows[0], function (header) {
                        if (header.header) {
                            for (var i = 0; i < header.colspan; i++) {
                                extraHeaders.push(header.header + ' ');
                            }
                        } else {
                            extraHeaders.push('');
                        }
                    });
                }
                return extraHeaders;
            }, getTargetExportColumns: function (grid, ignoreList) {
                var cols = [];
                var store = grid.store;
                var extraHeaders = this.getExtraHeaders(grid);
                var columnHideStatus = this.getColumnHideStatus(grid);
                var panTypeExportRenderer = Pan.common.exporter.PanTypeExportRenderer;
                _.forEach(grid.colModel.config, function (column, i) {
                    if (columnHideStatus[i].hidden === false && (_.indexOf(ignoreList, column.dataIndex) == -1) && (_.indexOf(ignoreList, column.id) == -1)) {
                        var targetColumn = _.find(store.fields.items, function (field) {
                            return field.name === (column.dataIndex || column.id);
                        });
                        var colToBeExported = (targetColumn) ? targetColumn.name : columnHideStatus[i].name;
                        if (colToBeExported) {
                            var pushObj = {
                                name: colToBeExported,
                                header: (extraHeaders[i] || '') + (column.header || '')
                            };
                            if (column.exportRenderer) {
                                pushObj.renderer = column.exportRenderer;
                            } else if (column.xtype in panTypeExportRenderer) {
                                pushObj.renderer = panTypeExportRenderer[column.xtype];
                            }
                            else if (column.renderer && column.spanCellRenderer) {
                                pushObj.renderer = column.renderer;
                                pushObj.spanCellRenderer = column.spanCellRenderer;
                            }
                            else if (column.renderer) {
                                pushObj.renderer = column.renderer;
                            } else if (column.spanCellRenderer) {
                                pushObj.renderer = column.spanCellRenderer;
                            }
                            if (column.spanCellMapping) {
                                pushObj.spanCellMapping = column.spanCellMapping;
                            }
                            cols.push(pushObj);
                        }
                    }
                });
                return cols;
            }, getColumnHideStatus: function (grid) {
                var columnHideStatus = [];
                _.forEach(grid.colModel.config, function (colConfig) {
                    columnHideStatus.push({name: colConfig.dataIndex, hidden: !!(colConfig.hidden)});
                });
                return columnHideStatus;
            }, generateSysLog: function (exportOptions, callback) {
                try {
                    var log = Pan.base.escapeHTML('User ' +
                        Pan.global.ContextVariables.get('username') + ' exported the ' + exportOptions.reportTitle + ' configuration data via the UI to a ' +
                        exportOptions.exportType + ' file.');
                    PanDirect.run('ExportDirect.generateSysLogs', [log], callback);
                } catch (e) {
                    console.error(e);
                }
            }, checkIfInternetExplorer: function () {
                var isInternetExplorer = false;
                try {
                    isInternetExplorer = (navigator.appName == 'Microsoft Internet Explorer' || !!(navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/rv:11/)) || (typeof $.browser !== "undefined" && $.browser.msie == 1));
                }
                catch (e) {
                    console.error(e);
                }
                return isInternetExplorer;
            }, getBase64Image: function (logoType) {
                return new Promise(function (resolve, reject) {
                    try {
                        var params = {
                            logoType: logoType,
                            date: (new Date().format('U')),
                            template: Pan.global.getTemplate() || ''
                        };
                        var url = "/php/device/get_image.php?" + Ext.urlEncode(params);
                        var img = new Image();
                        img.onload = function () {
                            var canvas = document.createElement('CANVAS');
                            var ctx = canvas.getContext('2d');
                            canvas.height = this.height;
                            canvas.width = this.width;
                            ctx.drawImage(this, 0, 0);
                            var dataURL = canvas.toDataURL('image/png');
                            resolve({imageData: dataURL, height: canvas.height, width: canvas.width});
                        };
                        img.src = url;
                    }
                    catch (e) {
                        console.error(e);
                        resolve({
                            imageData: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=',
                            height: 1,
                            width: 1
                        });
                    }
                });
            }, getTitleFromLocationBar: function () {
                var reportTitle = '';
                try {
                    reportTitle = window.location.hash.slice(window.location.hash.lastIndexOf('::') + 2);
                }
                catch (e) {
                    console.error(e);
                }
                return reportTitle;
            }
        };
    })();
    Pan.common.exporter.ExportUtil = exportUtil;
})();
(function () {
    var cellFormatter = function () {
        var convertToElement = function (value) {
            var span = document.createElement('span');
            span.innerHTML = value;
            return span;
        };
        var isCheckbox = function (element) {
            return element.className.indexOf('-check-col') >= 0;
        };
        var getCheckboxValue = function (element) {
            return element.className.indexOf('-check-col-on') >= 0;
        };
        var isHtml = function (value) {
            return _.isString(value) && (value.startsWith('<') || value.startsWith('&#') || value.indexOf('&nbsp;') > -1);
        };
        var isDisabled = function (value) {
            return (_.isString(value) && value.indexOf('x-pan-disabled') >= 0);
        };
        var isNegate = function (value) {
            return (_.isString(value) && value.indexOf('x-pan-negate') >= 0);
        };
        var extractValueInHtml = function (val) {
            var disabled = isDisabled(val);
            var negate = isNegate(val);
            var e = convertToElement(val);
            var returnValue = '';
            var text = e.textContent || e.innerText;
            if (text) {
                returnValue = text;
            }
            if (isCheckbox(e)) {
                returnValue = getCheckboxValue(e) ? 'Yes' : 'No';
            }
            if (disabled) {
                returnValue = '[Disabled] ' + returnValue;
            }
            if (negate) {
                returnValue = '[Negate] ' + returnValue;
            }
            return returnValue;
        };
        var trimSpaces = function (val) {
            return val.trim();
        };
        var convertToString = function (val) {
            val = _.toString(val);
            return val;
        };
        return {
            formatIfUndefined: function (val) {
                if (typeof val == 'undefined' || val == null) {
                    val = '';
                }
                return val;
            }, formatIfHtml: function (val) {
                if (isHtml(val)) {
                    return extractValueInHtml(val);
                }
                return val;
            }, formatIfArray: function (val) {
                if (_.isArray(val)) {
                    val = val.toString();
                }
                return val;
            }, formatIfObject: function (val) {
                if (_.isObject(val)) {
                    val = JSON.stringify(val);
                }
                return val;
            }, formatData: function (val) {
                var scope = this;
                val = scope.formatIfUndefined(val);
                val = scope.formatIfArray(val);
                val = scope.formatIfObject(val);
                val = convertToString(val);
                val = scope.formatIfHtml(val);
                val = trimSpaces(val);
                return val;
            }
        };
    }();
    Pan.common.exporter.FormatterUtil = cellFormatter;
})();
(function () {
    var pdfFormatter = (function () {
        var largeMultiRecordsDelimiter = '\n';
        var smallMultiRecordsDelimiter = '\n';
        var largeMultiRecordThreshold = 12;
        var cellFormatterHelper = Pan.common.exporter.FormatterUtil;
        var formatCell = function (val) {
            return cellFormatterHelper.formatData(val);
        };
        var getFormattedMultiRecordsColumn = function (column) {
            var len = column.length;
            var multiRecordsDelimiter = (len > largeMultiRecordThreshold) ? largeMultiRecordsDelimiter : smallMultiRecordsDelimiter;
            var formattedColumn = '';
            for (var counter = 0; counter < len; counter++) {
                formattedColumn = formattedColumn + formatCell(column[counter]);
                if (counter !== len - 1) {
                    formattedColumn = formattedColumn + multiRecordsDelimiter;
                }
            }
            return formattedColumn;
        };
        var getFormattedRow = function (row) {
            var len = row.length;
            for (var counter = 0; counter < len; counter++) {
                var column = row[counter];
                if (_.isArray(column)) {
                    row[counter] = getFormattedMultiRecordsColumn(column);
                } else {
                    row[counter] = formatCell(column);
                }
            }
            return row;
        };
        var getFormattedRows = function (rows) {
            var len = rows.length;
            for (var counter = 0; counter < len; counter++) {
                rows[counter] = getFormattedRow(rows[counter]);
            }
            return rows;
        };

        function capitalize(entries) {
            return entries.map(function (e) {
                return _TC(e);
            });
        }

        var getMultiLineHeaders = function (headers) {
            var len = headers.length;
            for (var counter = 0; counter < len; counter++) {
                headers[counter] = headers[counter].split(' ').join('\n');
            }
            return headers;
        };
        return {
            getFormattedData: function (inputData) {
                var headers = [];
                var rows = [];
                if (_.isArray(inputData.headers)) {
                    headers = getMultiLineHeaders(getFormattedRow(capitalize(inputData.headers)));
                }
                if (_.isArray(inputData.rows)) {
                    rows = getFormattedRows(inputData.rows);
                }
                return {headers: headers, rows: rows};
            }
        };
    }());
    Pan.common.exporter.pdf.PDFFormatter = pdfFormatter;
})();
(function () {
    var printWidthCalculator = (function () {
        var widthCalculator;
        var getMaxByColumn = function (rows, colIndex) {
            var maxOfRows = getMaxByIndex(rows, colIndex);
            return Math.ceil(maxOfRows);
        };
        var getTotalCharactersSpace = function (val, delimiter) {
            var arr = val.split(delimiter);
            var max = 0;
            var len = arr.length;
            for (var i = 0; i < len; i++) {
                var spaceRequired = Math.ceil(widthCalculator(arr[i]));
                if (spaceRequired > max) {
                    max = spaceRequired;
                }
            }
            return max;
        };
        var getMaxByIndex = function (rows, colIndex) {
            var total = 0;
            var len = rows.length;
            var max = 0;
            for (var counter = 0; counter < len; counter++) {
                var space = getTotalCharactersSpace(rows[counter][colIndex], '\n');
                if (space > max) {
                    max = space;
                }
                total += space;
            }
            return max;
        };
        var getWidthForColumns = function (rows) {
            var colMeans = [];
            var totalColumns = rows[0].length;
            for (var counter = 0; counter < totalColumns; counter++) {
                var colMeanByIndex = getMaxByColumn(rows, counter);
                colMeans.push(colMeanByIndex);
            }
            return colMeans;
        };
        var getOptimalColWidth = function (colMeans, headerWidths, maxColWidth, minColWidth) {
            var colLen = colMeans.length;
            for (var counter = 0; counter < colLen; counter++) {
                var colWidth = Math.max(colMeans[counter], headerWidths[counter], minColWidth);
                colMeans[counter] = Math.min(colWidth, maxColWidth);
            }
            return colMeans;
        };
        var getFormattedColumnWidths = function (optimalColumnWidths) {
            var formattedColWidths = {};
            var len = optimalColumnWidths.length;
            for (var counter = 0; counter < len; counter++) {
                formattedColWidths[counter] = {columnWidth: optimalColumnWidths[counter]};
            }
            return formattedColWidths;
        };
        var getOptimalPageColumnWidths = function (optimalColumnWidths, pageWidth, margin) {
            var optimalPageSize = (margin * 2);
            var colLen = optimalColumnWidths.length;
            for (var counter = 0; counter < colLen; counter++) {
                optimalPageSize = optimalPageSize + optimalColumnWidths[counter];
            }
            if (optimalPageSize < pageWidth) {
                var diff = Math.ceil((pageWidth - optimalPageSize) / colLen);
                for (counter = 0; counter < colLen; counter++) {
                    optimalColumnWidths[counter] = optimalColumnWidths[counter] + diff;
                }
                optimalPageSize = pageWidth;
            }
            return {columnWidths: getFormattedColumnWidths(optimalColumnWidths), pageWidth: optimalPageSize};
        };
        var getWidthForHeaders = function (headers) {
            var headerWidths = [];
            var len = headers.length;
            for (var counter = 0; counter < len; counter++) {
                var totalCharsOfHeader = Math.floor(getTotalCharactersSpace(headers[counter], '\n'));
                headerWidths.push(totalCharsOfHeader);
            }
            return headerWidths;
        };
        return {
            getPrintWidths: function (tableData, minPageWidth, widthCalFn, maxColWidth, margin) {
                var optimalWidths = {};
                if (_.isArray(tableData.rows) && _.isArray(tableData.headers) && !_.isUndefined(tableData.rows[0])) {
                    widthCalculator = widthCalFn;
                    var rows = tableData.rows;
                    var headers = tableData.headers;
                    var minColWidth = widthCalculator('AAA');
                    var headerWidths = getWidthForHeaders(headers);
                    var columnMeans = getWidthForColumns(rows);
                    var optimalColWidths = getOptimalColWidth(columnMeans, headerWidths, maxColWidth, minColWidth);
                    optimalWidths = getOptimalPageColumnWidths(optimalColWidths, minPageWidth, margin);
                }
                return optimalWidths;
            }
        };
    }());
    Pan.common.exporter.pdf.PrintWidthCalculator = printWidthCalculator;
}());
(function () {
    var coverPage = (function () {
        var exportUtil = Pan.common.exporter.ExportUtil;
        var defaultPageConfig = {
            pageStartY: 90,
            pageMargin: 70,
            coverPageTitleFontStyle: 'bold',
            coverPageTitleFontSize: 18,
            coverPageTitleFontColor1: {R: 147, G: 186, B: 68},
            coverPageTitleFontColor2: {R: 60, G: 60, B: 60},
            coverPageContentFontStyle: 'normal',
            coverPageContentFontSize: 14,
            logo: {
                imageData: undefined,
                height: undefined,
                width: undefined,
                customLogoType: 'pdf-report-header',
                logoMaxWidth: 90
            }
        };
        var injectLogo = function (pageConfig) {
            return new Promise(function (resolve) {
                exportUtil.getBase64Image(pageConfig.logo.customLogoType).then(function (logo) {
                    while (logo.width > pageConfig.logo.logoMaxWidth) {
                        logo.width = parseInt(logo.width / 2);
                        logo.height = parseInt(logo.height / 2);
                    }
                    _.merge(pageConfig.logo, logo);
                    resolve();
                });
            });
        };
        var getCoverBottomInfo = function (exportParameters) {
            var getFilterString = function () {
                var filterString = '';
                try {
                    filterString = 'Filter Criteria: ' + ((exportParameters.filterString === undefined || exportParameters.filterString.length < 1) ? 'None' : exportParameters.filterString);
                }
                catch (e) {
                    console.error(e);
                }
                return filterString;
            };
            var getSystem = function () {
                var system = '';
                try {
                    system = (Pan.global.getDevice().toUpperCase() === 'PANORAMA') ? 'Panorama' : 'Firewall';
                    system = system + ': ' + window.location.hostname;
                }
                catch (e) {
                    console.error(e);
                }
                return system;
            };
            var getInfo = function () {
                var info = '';
                try {
                    if (Pan.global.getDevice().toUpperCase() === 'PANORAMA') {
                        info = (!Pan.global.getTemplate()) ? 'Device Group' : 'Template';
                        if (info === 'Device Group') {
                            info = info + ': ' + Pan.global.getLocVal();
                        }
                        else {
                            info = info + ': ' + Pan.global.getTemplate() + '; ' + 'Mode: ' + ((Pan.global.isMultiVsys()) ? 'Multi VSYS' : 'Single VSYS' + (Pan.global.getCurrentTemplateDefaultVsys()) ? '' : '(no default)') + '; ' + 'Device: ' + (Ext.getCmp('template-mode').ownerCt.findByItemId('device-mode').getValue() || 'None') + '; ' +
                                Pan.global.getSettingsForCurrentTemplate().deviceOperationalMode.toUpperCase() + ' Mode; ' +
                                ((Pan.global.isVPNDisabled()) ? 'VPN Disabled' : 'VPN Enabled');
                        }
                    }
                    else {
                        info = 'Virtual System:';
                        if (Pan.global.isMultiVsys()) {
                            var currentTab = window.location.hash.slice(window.location.hash.lastIndexOf('::') + 2).split('/')[0].toUpperCase();
                            if (currentTab === 'NETWORK' || currentTab === 'DEVICE') {
                                info = info + ' Multi VSYS';
                            } else {
                                info = info + ' ' + Pan.global.getLocVal();
                            }
                        } else {
                            info = info + ' Single VSYS';
                        }
                    }
                }
                catch (e) {
                    console.error(e);
                }
                return info;
            };
            var bottomInfo = [];
            bottomInfo.push(getFilterString());
            bottomInfo.push(getSystem());
            bottomInfo.push(getInfo());
            return bottomInfo;
        };
        var getTitle = function (exportParameters) {
            var title = '';
            try {
                title = exportParameters.reportTitle;
                title = title.split('/');
            }
            catch (e) {
                console.error(e);
            }
            return title;
        };
        var getReportTime = function () {
            var temp = '';
            try {
                var weekday = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                var date = new Date();
                temp = date.toString();
                temp = temp.split(' ');
                temp[0] = weekday[date.getDay()];
                temp = temp.join(' ');
                if (!exportUtil.checkIfInternetExplorer()) {
                    temp = temp.split('GMT');
                    temp[1] = (temp[1].split(' '))[1];
                    temp = (temp[0] + temp[1]).replace(/["'()]/g, '');
                }
            }
            catch (e) {
                console.error(e);
            }
            return temp;
        };
        var getCoverPageDescription = function (exportParameters) {
            var description = '';
            try {
                description = (exportParameters.description.length > 1) ? exportParameters.description.split('\n').join('') : 'None';
            }
            catch (e) {
                console.error(e);
            }
            return description;
        };
        var getCoverPageData = function (exportParameters) {
            return {
                reportTitle: getTitle(exportParameters),
                reportBottomInfo: getCoverBottomInfo(exportParameters),
                exportDate: getReportTime(),
                description: getCoverPageDescription(exportParameters)
            };
        };
        var buildCoverPage = function (doc, coverPageData, pageConfig, reportPartFooter) {
            doc.setLineWidth(2);
            doc.setDrawColor(229, 231, 233);
            doc.line(pageConfig.pageMargin - 20, pageConfig.pageStartY - 70, pageConfig.pageMargin - 15, doc.internal.pageSize.height - 10);
            doc.setFontType(pageConfig.coverPageTitleFontStyle);
            doc.setFontSize(pageConfig.coverPageTitleFontSize);
            doc.setTextColor(pageConfig.coverPageTitleFontColor1.R, pageConfig.coverPageTitleFontColor1.G, pageConfig.coverPageTitleFontColor1.B);
            var currentYPos = pageConfig.pageStartY;
            doc.text(pageConfig.pageMargin, currentYPos, coverPageData.reportTitle[0].toUpperCase());
            var currentX = pageConfig.pageMargin + doc.getStringUnitWidth(coverPageData.reportTitle[0].toUpperCase()) * pageConfig.coverPageTitleFontSize;
            var titleWrapped = false;
            for (var counter = 1; counter < coverPageData.reportTitle.length; counter++) {
                doc.setTextColor(169, 169, 169);
                doc.setFontType('normal');
                doc.text(currentX, currentYPos, ' > ');
                currentX = currentX + doc.getStringUnitWidth(' > ') * pageConfig.coverPageTitleFontSize;
                doc.setFontType(pageConfig.coverPageTitleFontStyle);
                doc.setTextColor(pageConfig.coverPageTitleFontColor1.R, pageConfig.coverPageTitleFontColor1.G, pageConfig.coverPageTitleFontColor1.B);
                var calculatedX = doc.getStringUnitWidth(coverPageData.reportTitle[counter]) * pageConfig.coverPageTitleFontSize;
                if ((currentX + calculatedX) > (doc.internal.pageSize.width - pageConfig.pageMargin)) {
                    currentX = pageConfig.pageMargin;
                    currentYPos = currentYPos + pageConfig.coverPageTitleFontSize + 5;
                    titleWrapped = true;
                }
                doc.text(currentX, currentYPos, coverPageData.reportTitle[counter].toUpperCase());
                currentX = currentX + doc.getStringUnitWidth(coverPageData.reportTitle[counter].toUpperCase()) * pageConfig.coverPageTitleFontSize;
            }
            var titlePostFix = 'CONFIGURATION REPORT';
            if (titleWrapped) {
                currentX = pageConfig.pageMargin;
                currentYPos = currentYPos + pageConfig.coverPageTitleFontSize + 5;
            } else {
                calculatedX = doc.getStringUnitWidth(titlePostFix) * pageConfig.coverPageTitleFontSize;
                if ((currentX + calculatedX) > (doc.internal.pageSize.width - pageConfig.pageMargin)) {
                    currentX = pageConfig.pageMargin;
                    currentYPos = currentYPos + pageConfig.coverPageTitleFontSize + 5;
                } else {
                    titlePostFix = '  ' + titlePostFix;
                }
            }
            doc.setTextColor(pageConfig.coverPageTitleFontColor2.R, pageConfig.coverPageTitleFontColor2.G, pageConfig.coverPageTitleFontColor2.B);
            doc.text(currentX, currentYPos, titlePostFix);
            doc.setFontType(pageConfig.coverPageContentFontStyle);
            doc.setFontSize(pageConfig.coverPageContentFontSize);
            currentYPos = currentYPos + 27;
            doc.text(pageConfig.pageMargin, currentYPos, coverPageData.exportDate);
            currentYPos = currentYPos + (27 * 6);
            doc.text(pageConfig.pageMargin, currentYPos, 'Description:');
            currentYPos = currentYPos + 27;
            var longText = doc.splitTextToSize(coverPageData.description, doc.internal.pageSize.width - 80, {});
            doc.text(pageConfig.pageMargin, currentYPos, longText);
            var bottomCounter = (coverPageData.reportBottomInfo.length * 30) + 80;
            for (counter = 0; counter < coverPageData.reportBottomInfo.length; counter++) {
                longText = doc.splitTextToSize(coverPageData.reportBottomInfo[counter], doc.internal.pageSize.width - 80, {});
                doc.text(pageConfig.pageMargin, doc.internal.pageSize.height - (bottomCounter - (counter * 30)), longText);
            }
            if (reportPartFooter) {
                doc.text(pageConfig.pageMargin, doc.internal.pageSize.height - 50, reportPartFooter);
            }
            if (pageConfig.logo.imageData) {
                doc.addImage(pageConfig.logo.imageData, 'PNG', doc.internal.pageSize.width - pageConfig.logo.width - 20, (doc.internal.pageSize.height - pageConfig.logo.height) - 35, pageConfig.logo.width, pageConfig.logo.height);
            }
        };
        return {
            addCoverPage: function (doc, exportParameters, reportPartFooter) {
                return new Promise(function (resolve) {
                    var pageConfig = _.clone(defaultPageConfig);
                    var coverPageData = getCoverPageData(exportParameters);
                    injectLogo(pageConfig).then(function () {
                        buildCoverPage(doc, coverPageData, pageConfig, reportPartFooter);
                        resolve();
                    });
                });
            }
        };
    }());
    Pan.common.exporter.pdf.templates.CoverPage = coverPage;
}());
(function () {
    var mixedDataTypePages = (function () {
        var defaultPageConfig = {
            reportFontSize: 11,
            pageTitle: {titlePositionX: 40, titlePositionY: 40, titleFontSize: 20},
            imageRenderStyle: {plotX: 40, plotY: 55},
            tableRenderStyle: {
                startY: 55,
                styles: {overflow: 'linebreak', fontSize: 11, tableWidth: 'auto', columnWidth: 'auto'},
                columnStyles: {},
                theme: 'grid',
                alternateRowStyles: {fillColor: [244, 244, 245]},
                headerStyles: {fillColor: [0, 109, 145], fontSize: 11, textColor: [245, 245, 245], fontStyle: 'normal'}
            }
        };
        var buildImagePage = function (doc, imageData, pageConfig) {
            doc.addImage(imageData.imageData, imageData.imageFormat, pageConfig.imageRenderStyle.plotX, pageConfig.imageRenderStyle.plotY, imageData.imageWidth, imageData.imageHeight);
        };
        var buildReportPage = function (doc, gridData, pageConfig) {
            doc.setFontSize(pageConfig.reportFontSize);
            doc.autoTable(gridData.headers, gridData.rows, pageConfig.tableRenderStyle);
        };
        var injectPageTitle = function (doc, pageTitle, pageConfig) {
            doc.setFontSize(pageConfig.pageTitle.titleFontSize);
            doc.text(pageConfig.pageTitle.titlePositionX, pageConfig.pageTitle.titlePositionY, pageTitle);
        };
        var buildPage = function (doc, page, pageConfig) {
            injectPageTitle(doc, page.title, pageConfig);
            switch (page.dataType) {
                case'image':
                    buildImagePage(doc, page.exportData, pageConfig);
                    break;
                case'grid':
                    buildReportPage(doc, page.exportData, pageConfig);
                    break;
                default:
                    return;
            }
        };
        return {
            addMMixedDataTypePages: function (doc, pages, pageSize) {
                return new Promise(function (resolve, reject) {
                    var pageConfig = _.clone(defaultPageConfig);
                    var noOfPages = pages.length;
                    _.forEach(pages, function (page) {
                        noOfPages--;
                        buildPage(doc, page, pageConfig);
                        if (noOfPages > 0) {
                            doc.addPage(pageSize.width, pageSize.height);
                        }
                    });
                    resolve();
                });
            }
        };
    }());
    Pan.common.exporter.pdf.templates.MixedDataTypePages = mixedDataTypePages;
}());
(function () {
    var reportPage = (function () {
        var exportUtil = Pan.common.exporter.ExportUtil;
        var pdfFormatter = Pan.common.exporter.pdf.PDFFormatter;
        var printWidthCalculator = Pan.common.exporter.pdf.PrintWidthCalculator;
        var defaultPageConfig = {
            includeFooter: true,
            reportFontSize: 11,
            shrinkToFit: false,
            pageStartY: 40,
            tableRenderStyle: {
                styles: {overflow: 'linebreak', fontSize: 11, tableWidth: 'auto', columnWidth: 'auto'},
                columnStyles: {},
                theme: 'grid',
                alternateRowStyles: {fillColor: [244, 244, 245]},
                headerStyles: {fillColor: [0, 109, 145], fontSize: 11, textColor: [245, 245, 245], fontStyle: 'normal'}
            },
            logo: {
                imageData: undefined,
                height: undefined,
                width: undefined,
                customLogoType: 'pdf-report-footer',
                logoMaxHeight: 28
            }
        };
        var injectLogo = function (pageConfig) {
            return new Promise(function (resolve) {
                exportUtil.getBase64Image(pageConfig.logo.customLogoType).then(function (logo) {
                    while (logo.height > pageConfig.logo.logoMaxHeight) {
                        logo.width = parseInt(logo.width / 2);
                        logo.height = parseInt(logo.height / 2);
                    }
                    _.merge(pageConfig.logo, logo);
                    resolve();
                });
            });
        };
        var getReportPageData = function (exportData) {
            return pdfFormatter.getFormattedData(exportData);
        };
        var buildReportPages = function (doc, reportPageData, pageConfig) {
            doc.setFontSize(pageConfig.reportFontSize);
            pageConfig.tableRenderStyle.startY = pageConfig.pageStartY;
            if (pageConfig.includeFooter) {
                pageConfig.tableRenderStyle.addPageContent = function (data) {
                    var pageNumber = _T('Page') + " " + _T(data.pageCount.toString());
                    doc.text(pageNumber, data.settings.margin.left, doc.internal.pageSize.height - 30);
                    if (pageConfig.logo.imageData) {
                        doc.addImage(pageConfig.logo.imageData, 'PNG', doc.internal.pageSize.width - pageConfig.logo.width - 20, (doc.internal.pageSize.height - pageConfig.logo.height) - 18, pageConfig.logo.width, pageConfig.logo.height);
                    }
                };
            }
            doc.autoTable(reportPageData.headers, reportPageData.rows, pageConfig.tableRenderStyle);
        };
        var getWidthCalculatorFn = function (doc, fontSize) {
            var internalDoc = doc;
            var padding = Math.ceil(internalDoc.getStringUnitWidth('WW')) * 2;
            var internalFontSize = fontSize + 2;
            return function (str) {
                return Math.ceil(internalDoc.getStringUnitWidth(str)) * internalFontSize + padding;
            };
        };
        return {
            addReportPages: function (doc, exportData, exportParameters, pageSize) {
                return new Promise(function (resolve) {
                    var pageConfig = _.clone(defaultPageConfig);
                    var reportPageData = getReportPageData(exportData);
                    if (!exportParameters.shrinkToFit) {
                        var widthCalFn = getWidthCalculatorFn(doc, pageConfig.reportFontSize);
                        var calculatedWidths = printWidthCalculator.getPrintWidths(reportPageData, pageSize.width, widthCalFn, pageSize.maxColumnWidth, pageConfig.pageStartY);
                        pageConfig.tableRenderStyle.columnStyles = calculatedWidths.columnWidths;
                        pageSize.width = calculatedWidths.pageWidth;
                    }
                    injectLogo(pageConfig).then(function () {
                        doc.addPage(pageSize.width, pageSize.height);
                        buildReportPages(doc, reportPageData, pageConfig);
                        resolve();
                    });
                });
            }, addReportPagesCollection: function (doc, exportDataCollection, pageSize) {
                return new Promise(function (resolve) {
                    var pageConfig = _.clone(defaultPageConfig);
                    var noOfReports = exportDataCollection.length;
                    pageConfig.includeFooter = false;
                    _.forEach(exportDataCollection, function (exportData) {
                        noOfReports--;
                        var reportPageData = getReportPageData(exportData);
                        buildReportPages(doc, reportPageData, pageConfig);
                        if (noOfReports > 0) {
                            doc.addPage(pageSize.width, pageSize.height);
                        }
                    });
                    resolve();
                });
            }
        };
    }());
    Pan.common.exporter.pdf.templates.ReportPage = reportPage;
}());
(function () {
    var pdfExporter = (function () {
        var exportConfig = {
            printMode: 'l',
            reportPages: {maximumRows: 11000},
            pageUnit: 'pt',
            pageSize: {
                'LETTER': {height: 792, width: 612, maxColumnWidth: 200},
                'A0': {height: 3370, width: 2384, maxColumnWidth: 600},
                'A1': {height: 2384, width: 1684, maxColumnWidth: 400},
                'A2': {height: 1684, width: 1190, maxColumnWidth: 300},
                'A3': {height: 1190, width: 842, maxColumnWidth: 80},
                'A4': {height: 842, width: 595, maxColumnWidth: 200},
                'A5': {height: 595, width: 420, maxColumnWidth: 200},
                'A6': {height: 420, width: 298, maxColumnWidth: 200}
            },
            getPageSize: function (inputPageSize, printMode) {
                var scope = this;
                var width = (scope.pageSize[inputPageSize][(printMode == 'l') ? 'height' : 'width']);
                var height = (scope.pageSize[inputPageSize][(printMode == 'l') ? 'width' : 'height']);
                return {width: width, height: height, maxColumnWidth: scope.pageSize[inputPageSize].maxColumnWidth};
            }
        };
        var saveAsPDFFile = function (doc, filename) {
            return new Promise(function (resolve, reject) {
                try {
                    doc.output('save', filename);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        var requiresSplit = function (exportData) {
            return (exportData.rows.length > exportConfig.reportPages.maximumRows);
        };
        var splitExportData = function (exportData) {
            var splits = [];
            var rowChunks = _.chunk(exportData.rows, exportConfig.reportPages.maximumRows);
            for (var counter = 0; counter < rowChunks.length; counter++) {
                splits.push({headers: _.clone(exportData.headers), rows: _.clone(rowChunks[counter])});
            }
            return splits;
        };
        var getExportChunks = function (exportData) {
            var exportChunks = [];
            if (requiresSplit(exportData)) {
                exportChunks = splitExportData(exportData);
            } else {
                exportChunks.push(exportData);
            }
            return exportChunks;
        };
        return {
            createDocument: function (exportData, exportParameters) {
                return new Promise(function (resolve, reject) {
                    var doc;
                    var pageSizeAbbr = _.toUpper(exportParameters.pageSize) || 'LETTER';
                    var printMode = exportParameters.printMode || exportConfig.printMode;
                    var pageUnit = exportConfig.pageUnit;
                    var coverPage = Pan.common.exporter.pdf.templates.CoverPage;
                    var reportPage = Pan.common.exporter.pdf.templates.ReportPage;
                    var pageSize = exportConfig.getPageSize(pageSizeAbbr, printMode);
                    var exportChunks = getExportChunks(exportData);
                    exportData = {};
                    var noOfChunks = exportChunks.length;
                    var currentChunk = 0;
                    var saveReport = function (doc, exportData, exportFileName, reportPartFooter) {
                        return new Promise(function (resolve, reject) {
                            coverPage.addCoverPage(doc, exportParameters, reportPartFooter).then(function () {
                                reportPage.addReportPages(doc, exportData, exportParameters, pageSize).then(function () {
                                    saveAsPDFFile(doc, exportFileName).then(resolve, reject);
                                });
                            });
                        });
                    };
                    var getSplitFileName = function (chunkId, filename) {
                        var temp = filename.split('.');
                        return temp[0] + '_part' + chunkId + '.' + temp[1];
                    };
                    var processChunk = function (resolve, reject) {
                        doc = new jsPDF(printMode, pageUnit, [pageSize.width, pageSize.height]);
                        var reportPartFooter = 'Report Part ' + (currentChunk + 1) + ' of ' + noOfChunks;
                        var exportFilename = getSplitFileName((currentChunk + 1), exportParameters.filename);
                        saveReport(doc, exportChunks[currentChunk], exportFilename, reportPartFooter).then(function () {
                            exportChunks[currentChunk] = {};
                            currentChunk++;
                            if (currentChunk < noOfChunks) {
                                processChunk(resolve, reject);
                            } else {
                                resolve();
                            }
                        }, reject);
                    };
                    if (noOfChunks > 1) {
                        processChunk(resolve, reject);
                    } else {
                        doc = new jsPDF(printMode, pageUnit, [pageSize.width, pageSize.height]);
                        saveReport(doc, exportChunks[currentChunk], exportParameters.filename).then(resolve, reject);
                    }
                });
            }, createMixedDataTypeDocument: function (pages, exportParameters) {
                return new Promise(function (resolve, reject) {
                    var pageSizeAbbr = _.toUpper(exportParameters.pageSize) || 'LETTER';
                    var printMode = exportParameters.printMode || exportConfig.printMode;
                    var pageUnit = exportConfig.pageUnit;
                    var fileName = exportParameters.filename;
                    var pageSize = exportConfig.getPageSize(pageSizeAbbr, printMode);
                    var mixedDataTypePages = Pan.common.exporter.pdf.templates.MixedDataTypePages;
                    var doc = new jsPDF('l', pageUnit, [pageSize.width, pageSize.height]);
                    mixedDataTypePages.addMMixedDataTypePages(doc, pages, pageSize).then(function () {
                        saveAsPDFFile(doc, fileName).then(resolve, reject);
                    });
                });
            }
        };
    }());
    Pan.common.exporter.pdf.PDFExporter = pdfExporter;
}());
(function () {
    var csvFormatter = (function () {
        var multiRecordsDelimiter = ';';
        var rowDelimiter = '\n';
        var columnDelimiter = ',';
        var cellFormatterHelper = Pan.common.exporter.FormatterUtil;
        var csvEscape = function (val) {
            val = val.replace(/'/g, '""');
            return val;
        };
        var formatCell = function (val) {
            val = cellFormatterHelper.formatData(val);
            val = csvEscape(val);
            return val;
        };
        var getFormattedMultiRecordsColumn = function (column) {
            var formattedColumn = '';
            var len = column.length;
            for (var counter = 0; counter < len; counter++) {
                formattedColumn = formattedColumn + formatCell(column[counter]);
                if (counter !== len - 1) {
                    formattedColumn = formattedColumn + multiRecordsDelimiter;
                }
            }
            return formattedColumn;
        };
        var getFormattedRow = function (row) {
            var formattedRow = '';
            var len = row.length;
            for (var counter = 0; counter < len; counter++) {
                var column = row[counter];
                if (_.isArray(column)) {
                    column = getFormattedMultiRecordsColumn(column);
                }
                else {
                    column = formatCell(column);
                }
                formattedRow = formattedRow + '"' + column + '"';
                if (counter !== len - 1) {
                    formattedRow = formattedRow + columnDelimiter;
                }
                else {
                    formattedRow = formattedRow + rowDelimiter;
                }
            }
            return formattedRow;
        };
        var getFormattedRows = function (rows) {
            var formattedRows = '';
            var len = rows.length;
            for (var counter = 0; counter < len; counter++) {
                formattedRows = formattedRows + getFormattedRow(rows[counter]);
            }
            return formattedRows;
        };

        function capitalize(entries) {
            return entries.map(function (e) {
                return _TC(e);
            });
        }

        return {
            getFormattedData: function (inputData) {
                var csvOutput = '';
                if (_.isArray(inputData.headers)) {
                    var headers = capitalize(inputData.headers);
                    csvOutput = getFormattedRow(headers);
                }
                if (_.isArray(inputData.rows)) {
                    csvOutput = csvOutput + getFormattedRows(inputData.rows);
                }
                return csvOutput;
            }
        };
    }());
    Pan.common.exporter.csv.CSVFormatter = csvFormatter;
})();
(function () {
    var csvExporter = function () {
        var csvFormatter = Pan.common.exporter.csv.CSVFormatter;
        var saveAsCSVFile = function (exportData, filename) {
            return new Promise(function (resolve, reject) {
                try {
                    var data = new Blob([exportData], {type: "text/csv;charset=utf-8,%EF%BB%BF"});
                    saveAs(data, filename);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            });
        };
        return {
            createDocument: function (exportData, exportOptions) {
                var fileName = exportOptions.filename;
                var formattedData = csvFormatter.getFormattedData(exportData);
                return new Promise(function (resolve, reject) {
                    saveAsCSVFile(formattedData, fileName).then(resolve, reject);
                });
            }
        };
    }();
    Pan.common.exporter.csv.CSVExporter = csvExporter;
})();
(function () {
    var dataExtractor = (function () {
        var getHeaders = function (columns) {
            var headers = [];
            var title = '';
            _.forEach(columns, function (col) {
                if (!_.isUndefined(col.text)) {
                    title = col.text;
                }
                else if (!_.isUndefined(col.header)) {
                    title = col.header;
                }
                else if (!_.isUndefined(col.name)) {
                    title = col.name.replace(/_/g, ' ');
                }
                else {
                    title = '';
                }
                title = title.replace(/<br>/g, ' ');
                headers.push(title);
            });
            return headers;
        };
        var getRows = function (columns, grid, batchLimit) {
            var store = grid.store;
            var rows = [];
            var currentRecord = 0;
            store.each(function (record, index) {
                if (currentRecord < batchLimit) {
                    rows.push(getCells(columns, record, grid, index)[0]);
                }
                currentRecord++;
            });
            return rows;
        };
        var addEmptyRow = function (arr, columns) {
            var tempArr = [];
            for (var counter = 0; counter < columns.length; counter++) {
                tempArr.push('');
            }
            arr.push(tempArr);
            return arr;
        };
        var processArray = function (sourceArray, spanCellMapping) {
            var processedObject = [];
            _.forEach(sourceArray, function (entry) {
                if (_.isUndefined(entry) || entry === null || (_.isString(entry) && entry !== '') || _.isNumber(entry)) {
                    processedObject.push(entry);
                }
                else if (entry.value && entry.value !== '') {
                    processedObject.push(entry.value);
                }
                else if (spanCellMapping && entry[spanCellMapping] !== '') {
                    processedObject.push(entry[spanCellMapping]);
                }
                else if (_.isArray(entry)) {
                    processedObject.push(entry);
                }
            });
            if (sourceArray.length > 0 && processedObject.length === 0) {
                _.forEach(sourceArray, function (entry) {
                    if (_.isObject(entry)) {
                        processedObject.push(_.keys(entry));
                    }
                });
            }
            return processedObject;
        };

        function isMultiLevelArray(value) {
            return _.isArray(value) && value.length > 0 && _.isArray(value[0]);
        }

        var getCells = function (columns, record, grid, index) {
            var cells = [];
            cells = addEmptyRow(cells, columns);
            _.forEach(columns, function (col, iCol) {
                var name = col.name || col.dataIndex;
                var value = '';
                if (_.isFunction(col.renderer) && _.isFunction(col.spanCellRenderer)) {
                    value = col.renderer(record.get(name), {grid: grid}, record, index, iCol, record.store, grid);
                    if (_.isArray(value)) {
                        var spanCellValues = [];
                        for (var i = 0; i < value.length; i++) {
                            var vv = value[i];
                            spanCellValues.push(col.spanCellRenderer(vv, {grid: grid}, record, index, iCol, record.store, grid));
                        }
                        value = spanCellValues;
                    }
                }
                else if (_.isFunction(col.renderer)) {
                    value = col.renderer(record.get(name), {grid: grid}, record, index, iCol, record.store, grid);
                }
                else {
                    value = record.get(name);
                }
                if (isMultiLevelArray(value)) {
                    cells[0][iCol] = [];
                    _.forEach(value, function (val) {
                        cells[0][iCol].push(extractValue(val, col));
                    });
                }
                else {
                    cells[0][iCol] = extractValue(value, col);
                }
            });
            return cells;
        };
        var extractValue = function (value, col) {
            if (_.isArray(value)) {
                value = processArray(value, col.spanCellMapping);
            }
            return value;
        };
        return {
            extractData: function (grid, columns, batchLimit) {
                var store = grid.store;
                var targetColumns = columns || (store.fields ? store.fields.items : store.model.prototype.fields.items);
                var headers = getHeaders(targetColumns);
                var rows = getRows(targetColumns, grid, batchLimit);
                return {headers: headers, rows: rows};
            }
        };
    })();
    Pan.common.exporter.GridDataExtractor = dataExtractor;
})();
(function () {
    var dataExtractor = (function () {
        return {
            extractData: function (store, columns) {
                var rows = [];
                store.each(function (record, _index) {
                    var row = [];
                    _.forEach(columns, function (columnIndex) {
                        row.push(record.get(columnIndex));
                    });
                    rows.push(row);
                });
                return {rows: rows};
            }
        };
    })();
    Pan.common.exporter.StoreDataExtractor = dataExtractor;
})();
(function () {
    var dataLoader = (function () {
        var dataExtractor = Pan.common.exporter.GridDataExtractor;
        var exportUtil = Pan.common.exporter.ExportUtil;
        var loadBatch = function (dataStore, loadParameters, exportLoadListener) {
            return new Promise(function (resolve, reject) {
                dataStore.addListener(exportLoadListener, resolve, this, {scope: this, single: true});
                dataStore.addListener('exception', reject, this, {scope: this, single: true});
                dataStore.reload(loadParameters);
            });
        };
        var getExtractedData = function (grid, columns, batchLimit) {
            return dataExtractor.extractData(grid, columns, batchLimit);
        };
        return {
            load: function (options) {
                return new Promise(function (resolve, reject) {
                    var exportGrid = options.exportGrid;
                    var maxLimit = options.maxLimit;
                    var batchLimit = options.batchLimit || 800;
                    var exportCancelled = options.exportCancelled;
                    var exportIgnoreList = options.exportIgnoreList;
                    var exportFilter = options.exportFilter;
                    var subString = options.subString;
                    var lastOptions = options.lastOptions;
                    var progressHandler = options.progressHandler;
                    var exportLoadListener = (exportGrid.exportGridOptions && exportGrid.exportGridOptions.exportGridEvent) ? exportGrid.exportGridOptions.exportGridEvent : 'afterload';
                    var headers;
                    var rows = [];
                    var dataStore = exportGrid.store;
                    var exportColumns = exportUtil.getTargetExportColumns(exportGrid, exportIgnoreList);
                    var currentRecord = 0;
                    var totalRecords = dataStore.getTotalCount();
                    if (exportGrid.supportLocalPaging) {
                        batchLimit = 80000;
                    }
                    var exitDataLoaderAction = function () {
                        if (_.isFunction(exportGrid.setDisableLiveRowUpdate)) {
                            exportGrid.setDisableLiveRowUpdate(false);
                        }
                        dataStore.isExportLoad = false;
                        dataStore.reload();
                    };
                    var preDataLoaderAction = function () {
                        if (_.isFunction(exportGrid.setDisableLiveRowUpdate)) {
                            exportGrid.setDisableLiveRowUpdate(true);
                        }
                        exportGrid.setDisableLiveRowUpdate(true);
                        dataStore.isExportLoad = true;
                    };
                    var getLoadParams = function (start, end) {
                        if (_.isUndefined(lastOptions) || _.isUndefined(lastOptions.params)) {
                            return {params: {limit: end, start: start, filter: exportFilter, substring: subString}};
                        } else {
                            var storeInputs = _.clone(lastOptions.storeInputs);
                            if (storeInputs && storeInputs.bufferSize && storeInputs.bufferSize < (end - start)) {
                                storeInputs.bufferSize = (end - start) + 100;
                            }
                            var params = _.clone(lastOptions.params);
                            params.start = start;
                            params.limit = end;
                            return {storeInputs: storeInputs, params: params};
                        }
                    };
                    var processLoad = function () {
                        if (currentRecord < totalRecords && !exportCancelled() && currentRecord < maxLimit) {
                            if (currentRecord + batchLimit > totalRecords) {
                                batchLimit = totalRecords - currentRecord;
                            }
                            if (dataStore.localPagingParams) {
                                dataStore.localPagingParams.limit = batchLimit;
                                dataStore.localPagingParams.start = currentRecord;
                            }
                            var loadParams = getLoadParams(currentRecord, batchLimit);
                            loadBatch(dataStore, loadParams, exportLoadListener).then(function () {
                                currentRecord = currentRecord + batchLimit;
                                try {
                                    var processedRecord = getExtractedData(exportGrid, exportColumns, batchLimit);
                                    if (!headers) {
                                        headers = processedRecord.headers;
                                    }
                                    rows.push(processedRecord.rows);
                                    var progress = Math.min(parseInt(((currentRecord / totalRecords)) * 100), 100);
                                    if (progress === 100) {
                                        progress = 99;
                                    }
                                    progressHandler(progress);
                                    processLoad();
                                }
                                catch (e) {
                                    exitDataLoaderAction();
                                    reject();
                                }
                            }, function () {
                                exitDataLoaderAction();
                                reject();
                            });
                        }
                        else if (!exportCancelled()) {
                            exitDataLoaderAction();
                            resolve({headers: headers, rows: _.flatten(rows)});
                        } else if (exportCancelled()) {
                            exitDataLoaderAction();
                            reject(_T('Export Cancelled'));
                        } else {
                            exitDataLoaderAction();
                            reject();
                        }
                    };
                    preDataLoaderAction();
                    processLoad();
                });
            }
        };
    })();
    Pan.common.exporter.GridDataLoader = dataLoader;
})();
(function () {
    var dataLoader = (function () {
        var dataExtractor = Pan.common.exporter.StoreDataExtractor;
        var loadBatch = function (dataStore, loadParameters) {
            return new Promise(function (resolve, reject) {
                dataStore.addListener('datachanged', function () {
                    dataStore.removeListener('datachanged');
                    resolve();
                });
                dataStore.addListener('exception', reject);
                dataStore.reload(loadParameters);
            });
        };
        var getStore = function (storeName) {
            return Ext.StoreMgr.get(storeName);
        };
        var getExtractedData = function (store, columns) {
            return dataExtractor.extractData(store, columns);
        };
        return {
            load: function (options) {
                return new Promise(function (resolve, reject) {
                    var dataStore = (_.isString(options.sourceStore)) ? getStore(options.sourceStore) : options.sourceStore;
                    var batchLimit = options.batchLimit || 500;
                    var maxLimit = options.maxLimit;
                    var progressHandler = options.progressHandler;
                    var exportCancelled = options.exportCancelled;
                    var headers = options.headers;
                    var columns = options.columns;
                    var dataLoaded = !!options.dataLoaded;
                    var resetStorePosition = !!options.resetStorePosition;
                    var rows = [];
                    var currentRecord = 0;
                    var resetStart = dataStore.start;
                    var resetLimit = dataStore.limit;
                    var totalRecords = dataStore.getTotalCount();
                    var processLoad = function () {
                        if (!exportCancelled() && currentRecord < totalRecords && currentRecord < maxLimit) {
                            if (currentRecord + batchLimit > totalRecords) {
                                batchLimit = totalRecords - currentRecord;
                            }
                            if (dataStore.localPagingParams) {
                                dataStore.localPagingParams.limit = batchLimit;
                                dataStore.localPagingParams.start = currentRecord;
                            }
                            loadBatch(dataStore, {params: {limit: batchLimit, start: currentRecord}}).then(function () {
                                currentRecord = currentRecord + batchLimit;
                                var processedRecord = getExtractedData(dataStore, columns);
                                rows.push(processedRecord.rows);
                                var progress = Math.min(parseInt(((currentRecord / totalRecords)) * 100), 100);
                                if (progress === 100) {
                                    progress = 99;
                                }
                                progressHandler(progress);
                                processLoad();
                            }, reject);
                        }
                        else if (!exportCancelled()) {
                            var op = {headers: headers, rows: _.flatten(rows)};
                            if (resetStorePosition) {
                                loadBatch(dataStore, {
                                    params: {
                                        limit: resetLimit,
                                        start: resetStart
                                    }
                                }).then(function () {
                                    resolve(op);
                                });
                            }
                            else {
                                resolve(op);
                            }
                        }
                        else if (exportCancelled()) {
                            if (resetStorePosition) {
                                loadBatch(dataStore, {
                                    params: {
                                        limit: resetLimit,
                                        start: resetStart
                                    }
                                }).then(function () {
                                    reject(_T('Export Cancelled'));
                                });
                            }
                        } else {
                            reject();
                        }
                    };
                    if (!dataLoaded && !exportCancelled()) {
                        processLoad();
                    } else if (!exportCancelled()) {
                        var processedRecord = getExtractedData(dataStore, columns);
                        rows.push(processedRecord.rows);
                        var progress = Math.min(parseInt(((99 / 100)) * 100), 100);
                        progressHandler(progress);
                        resolve({headers: headers, rows: _.flatten(rows)});
                    } else if (exportCancelled()) {
                        reject(_T('Export Cancelled'));
                    } else {
                        reject();
                    }
                });
            }
        };
    })();
    Pan.common.exporter.StoreDataLoader = dataLoader;
})();
(function () {
    var readOnlyPreview = true;
    var previewBuilder = (function () {
        var removeLinks = function (grid) {
            try {
                var griDomID = '#' + grid.getView().el.id;
                $(griDomID).addClass('disable-x-hyperlink');
            }
            catch (e) {
                console.error(e);
            }
        };
        var hideExpanderCheckerCol = function (grid) {
            var cm = grid.view.cm;
            var count = cm.getColumnCount() - 1;
            (function delayedRenderer(i) {
                setTimeout(function () {
                    if (cm.config[i].id && ((cm.config[i].id === 'checker' || cm.config[i].id === 'expander'))) {
                        cm.setHidden(i, true);
                    }
                    if (i > 0) {
                        i--;
                        delayedRenderer(i);
                    }
                }, 50);
            })(count);
        };
        var isPanTreeView = function (grid) {
            return (grid.treePath && grid.getState() && grid.rbaPath);
        };
        var buildPanTreePreview = function (parentGrid) {
            return Pan.create({
                treePath: parentGrid.treePath,
                useToolbar: false,
                rbaPath: parentGrid.rbaPath,
                autoAdjustColumnWidth: true,
                useToolbarExportGridAction: false,
                itemId: 'exportGrid',
                stateful: false,
                viewConfig: {forceFit: false},
                listeners: {
                    'beforerender': {
                        fn: function (comp) {
                            comp.applyState(parentGrid.getState());
                        }
                    }, 'viewready': {
                        fn: function (grid) {
                            if (readOnlyPreview) {
                                removeLinks(grid);
                                hideExpanderCheckerCol(grid);
                            }
                        }
                    }, 'cellclick': {
                        fn: function (_grid, _rowIndex, _columnIndex, e) {
                            if (readOnlyPreview) {
                                e.stopEvent();
                                return false;
                            }
                        }
                    }
                }
            });
        };
        return {
            getPreview: function (grid) {
                var preview;
                if (isPanTreeView(grid)) {
                    preview = buildPanTreePreview(grid);
                }
                return preview;
            }
        };
    })();
    Pan.common.exporter.view.PreviewBuilder = previewBuilder;
})();
(function () {
    var panExportWindow = (function () {
        var window = Pan.base.container.Window;
        var getNewExportWindow = function (formType, parentParameters) {
            return new window({
                itemId: 'exportWindow',
                title: _T('Export'),
                helpTopic: 'configuration_table_export',
                border: true,
                layout: 'fit',
                modal: true,
                items: {xtype: formType, cls: 'darkblue', parentParameters: parentParameters},
                width: 792,
                autoHeight: true,
                showLoadingIndication: true,
                resizable: false,
                closeAction: 'close'
            });
        };
        return {
            createGridExportWindow: function (parentParameters) {
                var windowObj = getNewExportWindow('pan-grid-export-form', parentParameters);
                windowObj.items.items[0].window = windowObj;
                windowObj.show();
            }, createStoreExportWindow: function (parentParameters) {
                var windowObj = getNewExportWindow('pan-store-export-form', parentParameters);
                windowObj.items.items[0].window = windowObj;
                windowObj.show();
            }
        };
    })();
    Ext.ns('Pan.common.exporter.view');
    Pan.common.exporter.view.ExportWindow = panExportWindow;
})();
(function () {
    var FormPanel = Pan.base.container.FormPanel;
    var dataLoader = Pan.common.exporter.GridDataLoader;
    var pdfExporter = Pan.common.exporter.pdf.PDFExporter;
    var csvExporter = Pan.common.exporter.csv.CSVExporter;
    var exportUtil = Pan.common.exporter.ExportUtil;
    var previewBuilder = Pan.common.exporter.view.PreviewBuilder;
    var ExportForm = Ext.extend(FormPanel, {
        itemId: 'exportForm',
        autoHeight: true,
        bodyPadding: 10,
        defaultType: 'pan-container',
        labelAlign: 'left',
        buttonAlign: 'left',
        exportCancelled: false,
        constructor: function (config) {
            Ext.apply(this, config || {});
            ExportForm.superclass.constructor.apply(this, arguments);
        },
        initComponent: function () {
            var scope = this;
            var exportSupportedFormats = ['CSV'];
            var parentConfig = scope.parentParameters;
            var parentGrid = parentConfig.grid;
            var isLocaleEnglish = (Pan.locale.mapping.locale == 'en');
            if (isLocaleEnglish) {
                exportSupportedFormats.push('PDF');
            }
            scope.items = [];
            scope.buttons = [];
            scope.items.push({
                layout: 'column', border: false, items: [{
                    columnWidth: .42, border: false, items: {
                        layout: 'form', border: false, items: [{
                            xtype: 'pan-textfield',
                            fieldLabel: _T('File Name'),
                            name: 'fileName',
                            allowBlank: false,
                            width: 235,
                            maxLength: 200,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            value: (function () {
                                var dateObj = new Date();
                                var tempName = 'export.csv';
                                try {
                                    tempName = 'export_' + exportUtil.getTitleFromLocationBar().split('/').join('_').replace('-', '_')
                                        + '_'
                                        + ("0" + (dateObj.getMonth() + 1)).slice(-2)
                                        + ("0" + dateObj.getDate()).slice(-2)
                                        + dateObj.getFullYear()
                                        + '_'
                                        + ('0' + dateObj.getHours()).substr(-2) + ('0' + dateObj.getMinutes()).substr(-2) + ('0' + dateObj.getSeconds()).substr(-2)
                                        + (dateObj.toLocaleTimeString('en-us', {timeZoneName: 'short'}).split(' ')[2] || '')
                                        + '.csv';
                                }
                                catch (e) {
                                    console.error(e);
                                }
                                return tempName.toLowerCase();
                            })()
                        }, {
                            xtype: 'pan-combo',
                            fieldLabel: _T('File Type'),
                            name: 'fileType',
                            editable: false,
                            allowBlank: false,
                            width: 235,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            store: exportSupportedFormats,
                            value: 'CSV',
                            listeners: {
                                beforequery: function (qe) {
                                    qe.query = '';
                                }, select: function (cb) {
                                    var form = scope.findByItemId('exportForm').getForm();
                                    var filename = form.findField('fileName').getValue();
                                    if (!Ext.isDefined(filename)) {
                                        filename = '';
                                    }
                                    else {
                                        filename = filename.substring(0, filename.length - 4);
                                    }
                                    form.findField('fileName').setValue(filename + '.' + cb.fieldValue.toLowerCase());
                                    switch (cb.fieldValue) {
                                        case'CSV':
                                            form.findField('description').disable();
                                            form.findField('pageSize').disable();
                                            break;
                                        case'PDF':
                                            form.findField('description').enable();
                                            form.findField('pageSize').enable();
                                            break;
                                    }
                                }
                            }
                        }, {
                            xtype: 'pan-combo',
                            fieldLabel: _T('Page Size'),
                            name: 'pageSize',
                            editable: false,
                            allowBlank: false,
                            width: 235,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            store: ['Letter', 'A0', 'A1', 'A2', 'A3', 'A4'],
                            value: 'Letter',
                            disabled: true
                        }]
                    }
                }, {
                    columnWidth: .58,
                    border: false,
                    items: {
                        layout: 'form',
                        border: false,
                        items: [{
                            fieldLabel: _T('Description'),
                            name: 'description',
                            xtype: 'textarea',
                            emptyText: 'Enter Report Description...',
                            allowBlank: true,
                            maxLength: 255,
                            width: 345,
                            height: 90,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            value: '',
                            disabled: true
                        }]
                    }
                }]
            });
            if (!isLocaleEnglish) {
                scope.items.push({
                    style: 'margin:10 0px 0px 75px;',
                    html: '<span style="color:#E50000">' + _T("PDF export is only supported in English") + '</span>',
                    xtype: 'label'
                });
            }
            if (parentGrid.exportGridOptions && parentGrid.exportGridOptions.disablePreview === true) {
                scope.parentGrid = parentGrid;
            } else {
                var previewGrid = previewBuilder.getPreview(parentGrid);
                if (previewGrid) {
                    scope.items.push({
                        style: 'margin:10px 0px 0px 0px;',
                        title: _T('Export Preview'),
                        layout: 'fit',
                        items: previewGrid,
                        itemId: 'exportPreviewGrid'
                    });
                    scope.previewGrid = previewGrid;
                    scope.buttons.push([{
                        text: '<span class="pan-link-button-text">' + _T('Show All Columns') + '</span>',
                        scope: this,
                        xtype: 'pan-button',
                        handler: this.showAllColumnHandler,
                        cls: 'pan-link-button'
                    }]);
                } else {
                    scope.parentGrid = parentGrid;
                }
            }
            scope.buttons.push([{xtype: 'tbfill'}, {
                formBind: true,
                text: _T('Export'),
                xtype: 'pan-button',
                cls: 'default-btn',
                scope: this,
                handler: this.exportButtonHandler
            }, {
                text: _T('Cancel'),
                cls: 'default-btn',
                scope: this,
                xtype: 'pan-button',
                handler: this.cancelButtonHandler
            }]);
            scope.addExportListenersOnGrid();
            ExportForm.superclass.initComponent.apply(this, arguments);
        },
        showAllColumnHandler: function () {
            var scope = this;
            var exportGrid = scope.getExportPreviewGrid();
            exportGrid.view.showLoadMask(true);
            scope.showAllColumnsAction(function () {
                exportGrid.view.showLoadMask(false);
            });
        },
        showAllColumnsAction: function (callback) {
            var scope = this;
            var exportGrid = scope.getExportPreviewGrid();
            var cm = exportGrid.view.cm;
            var count = cm.getColumnCount() - 1;
            (function delayedRenderer(i) {
                setTimeout(function () {
                    if (cm.config[i].id && ((cm.config[i].id === 'checker' || cm.config[i].id === 'expander'))) {
                        cm.setHidden(i, true);
                    }
                    else if (!(_.isFunction(cm.config[i].columnAvail)) || (cm.config[i].columnAvail(exportGrid))) {
                        cm.setHidden(i, false);
                    }
                    if (i > 0) {
                        i--;
                        delayedRenderer(i);
                    } else {
                        callback();
                    }
                }, 100);
            })(count);
        },
        cancelButtonHandler: function () {
            var scope = this;
            scope.exportCancelled = true;
            scope.closeAction();
        },
        exportButtonHandler: function () {
            var scope = this;
            try {
                if (scope.isValid()) {
                    scope.showExportControls();
                    var exportParameters = scope.getExportParameters();
                    var createExportDocument = function (data) {
                        var exporter = scope.getExporter(exportParameters.exportType);
                        return exporter.createDocument(data, exportParameters);
                    };
                    var errorCloseAction = function (e) {
                        scope.showExportError(e);
                    };
                    var graceFulCloseAction = function () {
                        scope.closeAction();
                    };
                    var generateSysLogAction = function () {
                        if (!exportParameters.exportCancelled()) {
                            exportUtil.generateSysLog(exportParameters, graceFulCloseAction);
                        } else {
                            graceFulCloseAction();
                        }
                    };
                    dataLoader.load(exportParameters).then(createExportDocument, errorCloseAction).catch(errorCloseAction).then(generateSysLogAction, errorCloseAction).catch(errorCloseAction);
                }
                else {
                    scope.showError(_T('Please correct form errors.'));
                }
            }
            catch (e) {
                console.error(e);
                scope.closeAction();
                scope.showError(_T('Error while exporting'));
            }
        },
        showExportError: function (e) {
            var scope = this;
            console.error(e);
            scope.closeAction();
            scope.showError(_T('Error while exporting'));
        },
        getExportFormFieldValue: function (fieldName) {
            var scope = this;
            var exportForm = scope.getExportForm();
            return exportForm.findField(fieldName).getValue();
        },
        getExportForm: function () {
            var scope = this;
            return scope.findByItemId('exportForm').getForm();
        },
        getExportPreviewGrid: function () {
            var scope = this;
            return scope.previewGrid;
        },
        getExportGrid: function () {
            var scope = this;
            return scope.previewGrid || scope.parentGrid;
        },
        getExporter: function (exportType) {
            var exporter;
            switch (exportType) {
                case'PDF':
                    exporter = pdfExporter;
                    break;
                case'CSV':
                    exporter = csvExporter;
                    break;
            }
            return exporter;
        },
        getFilterString: function (grid) {
            var filterString = '';
            try {
                if (grid.__filterField) {
                    filterString = grid.__filterField.getValue();
                }
            }
            catch (e) {
                console.error(e);
            }
            return filterString;
        },
        getPDFReportTitle: function (grid) {
            var pdfReportTitle = '';
            try {
                if (grid.exportGridOptions && grid.exportGridOptions.reportTitle) {
                    if (_.isFunction(grid.exportGridOptions.reportTitle)) {
                        pdfReportTitle = grid.exportGridOptions.reportTitle(exportUtil.getTitleFromLocationBar());
                    } else {
                        pdfReportTitle = grid.exportGridOptions.reportTitle;
                    }
                } else {
                    pdfReportTitle = exportUtil.getTitleFromLocationBar();
                }
            }
            catch (e) {
                console.error(e);
            }
            return pdfReportTitle;
        },
        getIgnoreColumnsList: function (grid) {
            var ignoreList = [];
            try {
                if (grid.exportGridOptions && grid.exportGridOptions.ignoreColumns) {
                    ignoreList = grid.exportGridOptions.ignoreColumns;
                }
            }
            catch (e) {
                console.error(e);
            }
            return ignoreList;
        },
        getExportParameters: function () {
            var scope = this;
            var targetExportGrid = scope.getExportGrid();
            var storeParams = scope.getStoreParams(targetExportGrid);
            return {
                batchLimit: 500,
                maxLimit: 80000,
                printMode: 'l',
                shrinkToFit: false,
                filename: scope.getExportFormFieldValue('fileName'),
                exportType: scope.getExportFormFieldValue('fileType'),
                description: scope.getExportFormFieldValue('description'),
                pageSize: scope.getExportFormFieldValue('pageSize'),
                exportCancelled: (function () {
                    var exportFormScope = scope;
                    return function () {
                        return exportFormScope.exportCancelled;
                    };
                })(),
                exportGrid: targetExportGrid,
                reportTitle: scope.getPDFReportTitle(targetExportGrid),
                exportIgnoreList: scope.getIgnoreColumnsList(targetExportGrid),
                filterString: scope.getFilterString(targetExportGrid),
                exportFilter: storeParams.exportFilter,
                subString: storeParams.subString,
                lastOptions: storeParams.lastOptions,
                progressHandler: (function () {
                    var exportFormScope = scope;
                    return function (progress) {
                        exportFormScope.updateProgress(progress);
                    };
                })()
            };
        },
        getStoreParams: function (grid) {
            var exportFilter = '';
            var subString = '';
            var lastOptions = grid.store.lastOptions;
            if (grid.plugins && grid.plugins.length > 0) {
                _.forEach(grid.plugins, function (plugin) {
                    if (_.isFunction(plugin.filterHandler)) {
                        exportFilter = (function () {
                            var _plugin = plugin;
                            return function () {
                                _plugin.filterHandler.call(_plugin.parent, _plugin.filterField.startValue || "");
                            };
                        })();
                        subString = plugin.filterField.startValue;
                    }
                });
            }
            return {exportFilter: exportFilter, subString: subString, lastOptions: lastOptions};
        },
        isValid: function () {
            var scope = this;
            return scope.getForm().isValid();
        },
        showProgressBar: function () {
            var scope = this;
            scope.add({name: 'progress', xtype: 'progress', style: 'margin:10px 10px 10px 10px;', width: 370});
            scope.doLayout();
        },
        updateProgress: function (progress) {
            var scope = this;
            var progressBar = scope.getExportForm().formPanel.findByType('progress');
            if (progressBar && progressBar[0] && _.isNumber(progress)) {
                var progressText = progress + '%';
                progressBar[0].updateProgress(progress / 100, progressText);
            }
        },
        closeAction: function () {
            var scope = this;
            scope.window.close();
        },
        showError: function (e) {
            Ext.Msg.alert(_T('Export Error'), e);
        },
        fitAllColumns: function () {
            var scope = this;
            scope.getExportPreviewGrid().getView().fitColumns();
        },
        showExportControls: function () {
            var scope = this;
            scope.hideComponents();
            scope.window.setWidth(400);
            scope.window.center();
            scope.showProgressBar();
        },
        addExportListenersOnGrid: function () {
            var scope = this;
            var exportGrid = scope.getExportGrid();
            var exportLoadListener = (exportGrid.exportGridOptions && exportGrid.exportGridOptions.exportGridEvent) ? exportGrid.exportGridOptions.exportGridEvent : 'afterload';
            exportGrid.store.addListener('beforeload', scope.disableExportButton, this);
            if (exportGrid.isLiveGrid) {
                exportGrid.view.addListener('beforebufferload', scope.disableExportButton, this);
            }
            exportGrid.store.addListener(exportLoadListener, scope.enableExportButton, this);
        },
        disableExportButton: function () {
            var scope = this;
            if (scope.getExportButton()) {
                scope.getExportButton().disable();
            }
        },
        enableExportButton: function () {
            var scope = this;
            if (scope.getExportButton()) {
                scope.getExportButton().enable();
            }
        },
        getExportButton: function () {
            var scope = this;
            if (scope.buttons.length === 4) {
                return scope.buttons[2];
            } else {
                return scope.buttons[1];
            }
        },
        hideComponents: function () {
            var scope = this;
            scope.items.each(function (item) {
                if (item.getEl().up('.x-form-item')) {
                    item.getEl().up('.x-form-item').setDisplayed(false);
                }
                item.hide();
            });
            if (scope.buttons.length === 4) {
                scope.buttons[0].setVisible(false);
                scope.buttons[2].setVisible(false);
            } else {
                scope.buttons[1].setVisible(false);
            }
            scope.doLayout();
        }
    });
    Ext.reg('pan-grid-export-form', ExportForm);
})();
(function () {
    var FormPanel = Pan.base.container.FormPanel;
    var dataLoader = Pan.common.exporter.StoreDataLoader;
    var pdfExporter = Pan.common.exporter.pdf.PDFExporter;
    var csvExporter = Pan.common.exporter.csv.CSVExporter;
    var exportUtil = Pan.common.exporter.ExportUtil;
    var ExportForm = Ext.extend(FormPanel, {
        itemId: 'exportForm',
        autoHeight: true,
        bodyPadding: 10,
        defaultType: 'pan-container',
        labelAlign: 'left',
        buttonAlign: 'right',
        exportCancelled: false,
        constructor: function (config) {
            Ext.apply(this, config || {});
            ExportForm.superclass.constructor.apply(this, arguments);
        },
        initComponent: function () {
            var scope = this;
            var isLocaleEnglish = (Pan.locale.mapping.locale == 'en');
            var exportSupportedFormats = ['CSV'];
            if (isLocaleEnglish) {
                exportSupportedFormats.push('PDF');
            }
            scope.items = [];
            scope.items.push({
                layout: 'column', border: false, items: [{
                    columnWidth: .42, border: false, items: {
                        layout: 'form', border: false, items: [{
                            xtype: 'pan-textfield',
                            fieldLabel: _T('File Name'),
                            name: 'fileName',
                            allowBlank: false,
                            width: 235,
                            maxLength: 200,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            value: (function () {
                                var dateObj = new Date();
                                var tempName = 'export.csv';
                                try {
                                    tempName = 'export_' + exportUtil.getTitleFromLocationBar().split('/').join('_').replace('-', '_')
                                        + '_'
                                        + ("0" + (dateObj.getMonth() + 1)).slice(-2)
                                        + ("0" + dateObj.getDate()).slice(-2)
                                        + dateObj.getFullYear()
                                        + '_'
                                        + ('0' + dateObj.getHours()).substr(-2) + ('0' + dateObj.getMinutes()).substr(-2) + ('0' + dateObj.getSeconds()).substr(-2)
                                        + (dateObj.toLocaleTimeString('en-us', {timeZoneName: 'short'}).split(' ')[2] || '')
                                        + '.csv';
                                }
                                catch (e) {
                                    console.error(e);
                                }
                                return tempName.toLowerCase();
                            })()
                        }, {
                            xtype: 'pan-combo',
                            fieldLabel: _T('File Type'),
                            name: 'fileType',
                            editable: false,
                            allowBlank: false,
                            width: 235,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            store: exportSupportedFormats,
                            value: 'CSV',
                            listeners: {
                                beforequery: function (qe) {
                                    qe.query = '';
                                }, select: function (cb) {
                                    var form = scope.findByItemId('exportForm').getForm();
                                    var filename = form.findField('fileName').getValue();
                                    if (!Ext.isDefined(filename)) {
                                        filename = '';
                                    }
                                    else {
                                        filename = filename.substring(0, filename.length - 4);
                                    }
                                    form.findField('fileName').setValue(filename + '.' + cb.fieldValue.toLowerCase());
                                    switch (cb.fieldValue) {
                                        case'CSV':
                                            form.findField('description').disable();
                                            form.findField('pageSize').disable();
                                            break;
                                        case'PDF':
                                            form.findField('description').enable();
                                            form.findField('pageSize').enable();
                                            break;
                                    }
                                }
                            }
                        }, {
                            xtype: 'pan-combo',
                            fieldLabel: _T('Page Size'),
                            name: 'pageSize',
                            editable: false,
                            allowBlank: false,
                            width: 235,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            triggerClass: 'export-form-trigger',
                            store: ['Letter', 'A0', 'A1', 'A2', 'A3', 'A4'],
                            value: 'Letter',
                            disabled: true
                        }]
                    }
                }, {
                    columnWidth: .58,
                    border: false,
                    items: {
                        layout: 'form',
                        border: false,
                        items: [{
                            fieldLabel: _T('Description'),
                            name: 'description',
                            xtype: 'textarea',
                            maxLength: 255,
                            emptyText: 'Enter Report Description...',
                            allowBlank: true,
                            width: 345,
                            height: 90,
                            labelStyle: 'width:70px;margin:10px 0px 0px 0px;',
                            style: 'margin:10px 0px 0px -30px;',
                            value: '',
                            disabled: true
                        }]
                    }
                }]
            });
            if (!isLocaleEnglish) {
                scope.items.push({
                    style: 'margin:10 0px 0px 75px;',
                    html: '<span style="color:#E50000">' + _T("PDF export is only supported in English") + '</span>',
                    xtype: 'label'
                });
            }
            scope.buttons = [{
                formBind: true,
                text: _T('Export'),
                xtype: 'pan-button',
                cls: 'default-btn',
                scope: this,
                handler: this.exportButtonHandler
            }, {
                text: _T('Cancel'),
                cls: 'default-btn',
                scope: this,
                xtype: 'pan-button',
                handler: this.cancelButtonHandler
            }];
            ExportForm.superclass.initComponent.apply(this, arguments);
        },
        getPDFReportTitle: function (exportOptions) {
            var pdfReportTitle = '';
            try {
                if (exportOptions.reportTitle) {
                    if (_.isFunction(exportOptions.reportTitle)) {
                        pdfReportTitle = exportOptions.reportTitle(exportUtil.getTitleFromLocationBar());
                    } else {
                        pdfReportTitle = exportOptions.reportTitle;
                    }
                } else {
                    pdfReportTitle = exportUtil.getTitleFromLocationBar();
                }
            }
            catch (e) {
                console.error(e);
            }
            return pdfReportTitle;
        },
        cancelButtonHandler: function () {
            var scope = this;
            scope.exportCancelled = true;
            scope.closeAction();
        },
        exportButtonHandler: function () {
            var scope = this;
            try {
                if (scope.isValid()) {
                    scope.showExportControls();
                    var exportParameters = scope.getExportParameters();
                    var createExportDocument = function (data) {
                        var exporter = scope.getExporter(exportParameters.exportType);
                        return exporter.createDocument(data, exportParameters);
                    };
                    var errorCloseAction = function (e) {
                        scope.showExportError(e);
                    };
                    var graceFulCloseAction = function () {
                        scope.closeAction();
                    };
                    var generateSysLogAction = function () {
                        if (!exportParameters.exportCancelled()) {
                            exportUtil.generateSysLog(exportParameters, graceFulCloseAction);
                        } else {
                            graceFulCloseAction();
                        }
                    };
                    dataLoader.load(exportParameters).then(createExportDocument, errorCloseAction).catch(errorCloseAction).then(generateSysLogAction, errorCloseAction).catch(errorCloseAction);
                }
                else {
                    scope.showError(_T('Please correct form errors.'));
                }
            }
            catch (e) {
                console.error(e);
                scope.closeAction();
                scope.showError(_T('Error while exporting'));
            }
        },
        showExportError: function (e) {
            var scope = this;
            console.error(e);
            scope.closeAction();
            scope.showError(_T('Error while exporting'));
        },
        getExportFormFieldValue: function (fieldName) {
            var scope = this;
            var exportForm = scope.getExportForm();
            return exportForm.findField(fieldName).getValue();
        },
        getExportForm: function () {
            var scope = this;
            return scope.findByItemId('exportForm').getForm();
        },
        getExportPreviewGrid: function () {
            var scope = this;
            return scope.findByItemId('exportPreviewGrid').items.items[0];
        },
        getExporter: function (exportType) {
            var exporter;
            switch (exportType) {
                case'PDF':
                    exporter = pdfExporter;
                    break;
                case'CSV':
                    exporter = csvExporter;
                    break;
            }
            return exporter;
        },
        getExportParameters: function () {
            var scope = this;
            return {
                batchLimit: 500,
                maxLimit: scope.parentParameters.maxLimit || 80000,
                printMode: 'l',
                shrinkToFit: false,
                filename: scope.getExportFormFieldValue('fileName'),
                exportType: scope.getExportFormFieldValue('fileType'),
                description: scope.getExportFormFieldValue('description'),
                pageSize: scope.getExportFormFieldValue('pageSize'),
                exportCancelled: (function () {
                    var exportFormScope = scope;
                    return function () {
                        return exportFormScope.exportCancelled;
                    };
                })(),
                sourceStore: scope.parentParameters.sourceStore,
                headers: scope.parentParameters.headers,
                columns: scope.parentParameters.columns,
                dataLoaded: scope.parentParameters.dataLoaded,
                resetStorePosition: scope.parentParameters.resetStorePosition,
                reportTitle: scope.getPDFReportTitle(scope.parentParameters),
                filterString: scope.parentParameters.filterString,
                progressHandler: (function () {
                    var exportFormScope = scope;
                    return function (progress) {
                        exportFormScope.updateProgress(progress);
                    };
                })()
            };
        },
        isValid: function () {
            var scope = this;
            return scope.getForm().isValid();
        },
        showProgressBar: function () {
            var scope = this;
            scope.add({name: 'progress', xtype: 'progress', style: 'margin:10px 10px 10px 10px;', width: 370});
            scope.doLayout();
        },
        updateProgress: function (progress) {
            var scope = this;
            var progressBar = scope.getExportForm().formPanel.findByType('progress');
            if (progressBar && progressBar[0] && _.isNumber(progress)) {
                var progressText = progress + '%';
                progressBar[0].updateProgress(progress / 100, progressText);
            }
        },
        closeAction: function () {
            var scope = this;
            scope.window.close();
        },
        showError: function (e) {
            Ext.Msg.alert(_T('Export Error'), e);
        },
        showExportControls: function () {
            var scope = this;
            scope.hideComponents();
            scope.window.setWidth(400);
            scope.window.center();
            scope.showProgressBar();
        },
        hideComponents: function () {
            var scope = this;
            scope.items.each(function (item) {
                if (item.getEl().up('.x-form-item')) {
                    item.getEl().up('.x-form-item').setDisplayed(false);
                }
                item.hide();
            });
            scope.buttons[0].setVisible(false);
            scope.doLayout();
        }
    });
    Ext.reg('pan-store-export-form', ExportForm);
})();
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertyStore = Ext.extend(Pan.base.autorender.GridRecordStore, {
    firstTimeSetValue: true, constructor: function (config) {
        if (!config.fields) {
            config = Ext.apply({}, config, this.createDefaultFieldsAndData(config.baseField, config));
        }
        if (config.doNotInitializeValueFieldToDefaultValue) {
            for (var i = 0; i < config.data.length; i++) {
                var r = config.data[i];
                r['valuefield'] = "";
            }
        }
        Pan.base.propertygrid.PropertyStore.superclass.constructor.call(this, config);
    }, createDefaultFieldsAndData: function (baseField) {
        var rv = {};
        rv.fields = [{
            name: 'metafield',
            uiHint: {hidden: true, hideable: false, renderer: Ext.emptyFn}
        }, {name: 'namefield', uiHint: {hidden: true, hideable: false, renderer: Ext.emptyFn}}, {
            name: 'titlefield',
            uiHint: {
                isKeyField: true,
                fieldLabel: baseField.uiHint.fieldLabel,
                editor: {builder: 'PanEditorDialogBuilder', recordFormField: baseField}
            }
        }, {name: 'valuefield', uiHint: {fieldLabel: _T("Value")}}];
        rv.data = [];
        var columnsMap = {};
        var rowChildren = baseField.children;
        for (var i = 0; i < rowChildren.length; i++) {
            var rowData = {};
            var rowChild = rowChildren[i];
            if (rowChild.children) {
                rowChild.visit(function (field) {
                    if (!field.children || field.isCollection) {
                        if (!columnsMap[field.name]) {
                            columnsMap[field.name] = field;
                            rv.fields.push(field.clone());
                            return false;
                        }
                        rowData[field.name] = field.defaultValue;
                    }
                }, this);
            } else {
                rowData['valuefield'] = rowChild.defaultValue;
            }
            rowData['titlefield'] = rowChild.uiHint.fieldLabel;
            rowData['metafield'] = rowChild;
            rowData['namefield'] = rowChild.name;
            rv.data.push(rowData);
        }
        Ext.apply(rv, {localStore: true, idProperty: 'namefield'});
        return rv;
    }, endEdit: function (r, config) {
        if (this.localStore) {
            var values = config && config.values || r.data;
            for (var m in values) {
                if (values.hasOwnProperty(m)) {
                    var originalRecordField = this.record.fields.get(m);
                    var localRecord = this.getById(originalRecordField.name);
                    localRecord.beginEdit();
                    this.setRecordValue(localRecord, values[m]);
                    localRecord.endEdit();
                    localRecord.commit();
                }
            }
        }
    }, setValue: function (v) {
        if (v) {
            if (v['@__recordInfo'] && !v['@__recordInfo'].id) {
                return;
            }
            var record = this.__pdefaults && this.__pdefaults.__recordFormRecord;
            this.data.each(function (r) {
                var value;
                var realField = r.data['metafield'];
                if (record && Ext.isDefined(record.get(realField.name))) {
                    value = record.get(realField.name);
                } else {
                    value = realField.accessor(v, this.baseField.level);
                }
                if (realField.nodetype === 'choice') {
                    for (var i = 0; i < realField.children.length; i++) {
                        var childField = realField.children[i];
                        if (childField.attrName === value) {
                            r.data[childField.name] = record.get(childField.name);
                        } else {
                            delete r.data[childField.name];
                        }
                    }
                }
                if (this.firstTimeSetValue) {
                    this.createRecord(r, value);
                    r.afterEdit();
                } else {
                    this.setRecordValue(r, value);
                    if (realField.nodetype === 'choice') {
                        r.afterEdit();
                    }
                }
            }, this);
        }
        this.firstTimeSetValue = false;
    }, getValue: function () {
        var results = {};
        this.data.each(function (r) {
            var realField = r.data['metafield'];
            var value = this.getRecordValue(r);
            realField.mutator(results, value, false, this.baseField.level);
            if (this.__recordFormRecord) {
                this.__recordFormRecord.data[realField.name] = value;
            }
            if (realField.nodetype === 'choice') {
                for (var i = 0; i < realField.children.length; i++) {
                    var childField = realField.children[i];
                    if (childField.attrName === value) {
                        var childData = r.data[childField.name];
                        if (childData === undefined) {
                            if (childField.nodetype === 'sequence') {
                                childData = {};
                            }
                        }
                        childField.mutator(results, childData, false, this.baseField.level);
                        break;
                    }
                }
            }
        }, this);
        if (!Ext.isDefined(this.baseField.level)) {
            results.__defaultSaveMap = Pan.base.propertygrid.PropertySaveMap;
        }
        return results;
    }, getRecordValue: function (r) {
        var realField = r.data['metafield'];
        var rv = r.data['valuefield'];
        if (realField.type.rconvert) {
            rv = realField.type.rconvert(rv);
        }
        return rv;
    }, createRecord: function (r, v) {
        r.data['valuefield'] = v;
    }, setRecordValue: function (r, v) {
        r.set('valuefield', v);
    }
});
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertyGrid = Ext.extend(Pan.base.grid.EditorGridPanel, {
    unselectable: "off",
    supportFastRender: false,
    hasGridFilter: false,
    useCheckBoxSelection: false,
    showSelectedCount: false,
    customSave: true,
    disableAutoVflex: true,
    testValueChangedWithoutVerify: function (config) {
        this.__valueChanged = true;
        var realFieldName = this.colModel.getRealFieldName(this.store.getAt(config.row), this, config.column);
        if (realFieldName) {
            var realField = this.store.fields.get(realFieldName);
            if (realField) {
                this.__valueChanged = realField;
            }
        }
    },
    validateEdit: function (event) {
        var error = false;
        var eventVal = undefined;
        var eventRow = -1;
        var eventColumn = this.colModel.findColumnIndex('valuefield');
        if (event) {
            eventVal = event.value;
            eventRow = event.row;
            eventColumn = event.column;
        }
        var store = this.store;
        var column = this.colModel.getColumnAt(eventColumn);
        for (var r = 0; r < store.data.length; r++) {
            error = false;
            var rec = store.getAt(r);
            var fieldValue = rec.get("valuefield");
            if (eventRow === r) {
                fieldValue = eventVal;
            }
            var ed = column.getCellEditor(r);
            if (ed && ed.field && ed.field.setValue) {
                if (eventRow !== r) {
                    ed.field.setValue(fieldValue);
                }
                if (ed.field.getErrors) {
                    var fieldError = ed.field.getErrors();
                    if (Ext.isArray(fieldError) && fieldError.length > 0) {
                        error = fieldError[0];
                    }
                }
            }
            var fireEvent = false;
            var fieldName = this.colModel.getRealFieldName(rec, this, eventColumn);
            if (error) {
                rec.error = rec.error || {};
                rec.error[fieldName] = error;
                rec.error['valuefield'] = error;
                fireEvent = true;
            } else {
                if (rec.error) {
                    delete rec.error[fieldName];
                    delete rec.error['valuefield'];
                    if (Pan.base.isEmpty(rec.error)) {
                        rec.clearError();
                    }
                    fireEvent = true;
                }
            }
            if (fireEvent) {
                store.fireEvent('update', store, rec, Ext.data.Record.EDIT);
            }
        }
    },
    setValue: function (v) {
        if (!v) {
            v = {};
        }
        this.fieldValue = v;
        this.store.setValue(this.fieldValue);
    },
    getRecordFormField: function (field) {
        return field;
    },
    preEditValue: function (r, field) {
        var rv = Pan.base.propertygrid.PropertyGrid.superclass.preEditValue.apply(this, arguments);
        if (rv === r) {
            var cindex = this.colModel.findColumnIndex(field);
            var editor = this.colModel.getCellEditor(cindex, 0);
            if (editor && Ext.isFunction(editor.setRecordFormOverride)) {
                editor.setRecordFormOverride({
                    localStore: this.store.localStore,
                    items: [{itemId: r.data['namefield']}]
                });
            }
            var originalRecord = this.store.record || (this.store.__pdefaults && this.store.__pdefaults.__recordFormRecord);
            rv = originalRecord.store.beginAdd(originalRecord);
            var originalField = r.data['metafield'];
            rv.data[originalField.name] = this.store.getRecordValue(r);
            rv.store = this.store;
            Ext.applyIf(rv.store, {__extraInfo: originalRecord.store.__extraInfo, __ptpl: originalRecord.store.__ptpl});
        }
        return rv;
    },
    defaultColumnIsUsingDialogEditor: function (field) {
        return field.uiHint.isKeyField && !field.isStar;
    },
    setupView: function () {
        this.addListener("mouseover", this.mouseover, this);
        var rv = Pan.base.propertygrid.PropertyGrid.superclass.setupView.apply(this, arguments);
        if (!this.cm && !this.colModel && Ext.isArray(this.columns)) {
            this.colModel = new Pan.base.propertygrid.PropertyGridColumnModel({columns: this.columns, grid: this});
            delete this.columns;
        }
        return rv;
    },
    mouseover: function (e) {
        var cell = this.view.findCell(e.getTarget());
        if (cell) {
            var columnIndex = this.view.findCellIndex(e.target);
            var column = this.colModel.getColumnAt(columnIndex);
            if (column.dataIndex === 'valuefield') {
                var rowIndex = this.view.findRowIndex(e.target);
                var realField;
                if (Ext.isNumber(rowIndex)) {
                    var realFieldName = this.colModel.getRealFieldName(this.store.getAt(rowIndex), this, column);
                    if (realFieldName) {
                        realField = this.store.fields.get(realFieldName);
                    }
                }
                if (realField) {
                    var xy = undefined;
                    var helpTip = Pan.base.genHelpTip(realField.uiHint, false);
                    if (helpTip) {
                        if (!this.cellWindow) {
                            this.cellWindow = Ext.create({
                                xtype: "menu",
                                shadow: false,
                                cls: "x-toolbar-grid-cell-hint",
                                items: {xtype: 'box', autoEl: {html: helpTip}}
                            });
                        }
                        if (!this.cellWindow.el) {
                            this.cellWindow.render();
                        }
                        xy = this.cellWindow.el.getAlignToXY(cell, 'tr-tr');
                        if (!this.view.isIntersectingVerticalScroll(xy[0], this.cellWindow.getBox().width)) {
                            this.cellWindow.showAt(xy);
                        }
                    } else if (this.supportsColumnActions(rowIndex, columnIndex, e) && !this.isColumnActionMenuVisible()) {
                        var realColumnIndex = this.colModel.findColumnIndex(realField.name);
                        column = this.colModel.getColumnAt(realColumnIndex);
                        this.cleanupColumnAction();
                        this.cellEventInfo = this.getCellEventInfo(rowIndex, columnIndex, e);
                        if (column.toolbar && !this.cellWindow) {
                            this.cellWindow = Ext.create({
                                xtype: "menu",
                                shadow: false,
                                cls: column.toolbar.cls,
                                items: column.toolbar,
                                scope: this
                            });
                            if (!this.cellWindow.el) {
                                this.cellWindow.render();
                            }
                            var width = (column.toolbar.items.length || 1) * 30;
                            this.cellWindow.el.setWidth(width);
                            xy = this.cellWindow.el.getAlignToXY(cell, 'tr-tr');
                            if (!this.view.isIntersectingVerticalScroll(xy[0], this.cellWindow.getBox().width)) {
                                this.cellWindow.showAt(xy);
                            }
                        }
                    }
                    else {
                        if (this.cellWindow) {
                            this.cellWindow.setVisible(false);
                        }
                    }
                }
            } else {
                if (this.cellWindow) {
                    this.cellWindow.setVisible(false);
                }
            }
        }
    },
    extractCompleteText: function (record, dataIndex) {
        return record.get("valuefield");
    }
});
Ext.reg("pan-propertygrid", Pan.base.propertygrid.PropertyGrid);
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertySaveMap = function (config) {
    var children = config.__field.children;
    for (var j = 0; j < children.length; j++) {
        var child = children[j];
        var value = child.accessor(config.__v, config.__field.level);
        if (child.nodetype === 'choice') {
            for (var i = 0; i < child.children.length; i++) {
                var childField = child.children[i];
                if (childField.attrName === value) {
                    if (!child.doNothingWhenSavingPropertyChildren) {
                        var childData = childField.accessor(config.__v, config.__field.level);
                        if (childData === undefined) {
                            if (childField.nodetype === 'sequence') {
                                childData = {};
                            }
                        }
                        childField.mutator(config.__record, childData);
                    }
                } else {
                    childField.mutator(config.__record, undefined);
                }
            }
        } else {
            child.mutator(config.__record, value);
        }
    }
};
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.MultiPropertyStore = Ext.extend(Pan.base.propertygrid.PropertyStore, {
    createDefaultFieldsAndData: function (baseField, config) {
        var rv = {};
        rv.fields = [{
            name: 'metafield',
            uiHint: {columnConfig: {hidden: true, hideable: false, renderer: Ext.emptyFn}}
        }, {
            name: 'namefield',
            uiHint: {columnConfig: {hidden: true, hideable: false, renderer: Ext.emptyFn}}
        }, {
            name: 'titlefield',
            uiHint: {
                isKeyField: true,
                fieldLabel: baseField.uiHint.fieldLabel,
                columnConfig: Ext.apply({editor: {}}, config ? config.titleColumnConfig : {}, baseField.uiHint.columnConfig)
            }
        }];
        rv.data = [];
        var columnsMap = {};
        var useColumnsMap = {};
        var useColumns = undefined;
        if (baseField.uiHint && Ext.isArray(baseField.uiHint.useColumns)) {
            useColumns = baseField.uiHint.useColumns.slice(0);
            baseField.uiHint.useColumns = useColumns;
            for (var j = 0; j < baseField.uiHint.useColumns.length; j++) {
                useColumnsMap[baseField.uiHint.useColumns[j]] = true;
            }
        }
        var rowChildren = baseField.children;
        for (var i = 0; i < rowChildren.length; i++) {
            var rowData = {};
            var rowChild = rowChildren[i];
            if (rowChild.children) {
                rowChild.visit(function (field) {
                    if (!field.children || field.isCollection || field.nodetype === 'union' || field.nodetype === 'choice') {
                        var proxySelectionCommonName = Pan.base.autorender.builder.getDefaultProxySelectionCommonName(rowChild, field, undefined);
                        if (useColumnsMap[proxySelectionCommonName] && !useColumnsMap[field.name]) {
                            useColumns.push(field.name);
                        }
                        var fieldInMap = columnsMap[proxySelectionCommonName];
                        if (fieldInMap && field.uiHint && !field.uiHint.fieldLabelAutoGen && field.uiHint.fieldLabel) {
                            fieldInMap.uiHint.fieldLabel = field.uiHint.fieldLabel;
                        }
                        if (!fieldInMap) {
                            var uiHint = field.uiHint;
                            var fieldAvailable = true;
                            if (uiHint && uiHint.columnConfig && uiHint.columnConfig.columnAvail) {
                                fieldAvailable = uiHint.columnConfig.columnAvail();
                            }
                            columnsMap[proxySelectionCommonName] = fieldInMap = {
                                name: proxySelectionCommonName, type: field.type, slevel: field.slevel, uiHint: {
                                    fieldLabel: uiHint.fieldLabel || _TC(proxySelectionCommonName),
                                    columnConfig: Ext.applyIf({
                                        hideable: fieldAvailable,
                                        hidden: !fieldAvailable,
                                        renderer: function (v, meta, record, row, column, store, grid) {
                                            this.rendererGrid = grid;
                                            var fields = grid.store.fields;
                                            var proxyField = fields.get(this.dataIndex);
                                            var proxyFieldMapping = proxyField.proxyFieldMapping;
                                            var realField = proxyFieldMapping[record.get('namefield')];
                                            if (realField) {
                                                var realFieldName = realField.name;
                                                if (realFieldName) {
                                                    var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                                    var realColumn = undefined;
                                                    if (realColumnIndex >= 0) {
                                                        realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                                    }
                                                    if (realColumn && realColumn.renderer) {
                                                        if (realColumn.doHTMLEncode !== false && Ext.isString(v)) {
                                                            v = Pan.base.htmlEncode(v);
                                                        }
                                                        return realColumn.renderer.call(this, v, meta, record, row, realColumnIndex, store, grid);
                                                    }
                                                }
                                            }
                                            meta.css += " ux-grid3-disabled-row";
                                            return v;
                                        },
                                        spanCellRenderer: function (v, meta, record, row, column, store, grid) {
                                            grid = grid || this.rendererGrid;
                                            var fields = grid.store.fields;
                                            var proxyField = fields.get(this.dataIndex);
                                            var proxyFieldMapping = proxyField.proxyFieldMapping;
                                            var realFieldName = proxyFieldMapping[record.get('namefield')].name;
                                            if (realFieldName) {
                                                var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                                var realColumn = undefined;
                                                if (realColumnIndex >= 0) {
                                                    realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                                }
                                                if (realColumn && realColumn.spanCellRenderer) {
                                                    return realColumn.spanCellRenderer.call(this, v, meta, record, row, realColumnIndex, store, grid);
                                                }
                                            }
                                            return v;
                                        },
                                        getCellEditor: function (row) {
                                            if (Ext.isDefined(row)) {
                                                var grid = this.rendererGrid;
                                                var record = grid.store.getAt(row);
                                                var fields = grid.store.fields;
                                                var proxyField = fields.get(this.dataIndex);
                                                var proxyFieldMapping = proxyField.proxyFieldMapping;
                                                var realField = proxyFieldMapping[record.get('namefield')];
                                                if (realField) {
                                                    var realFieldName = realField.name;
                                                    if (realFieldName) {
                                                        var realColumnIndex = grid.colModel.findColumnIndex(realFieldName);
                                                        var realColumn = undefined;
                                                        if (realColumnIndex >= 0) {
                                                            realColumn = grid.colModel.getColumnAt(realColumnIndex);
                                                        }
                                                        if (realColumn && realColumn.getCellEditor) {
                                                            return realColumn.getCellEditor.call(realColumn, 0);
                                                        }
                                                    }
                                                } else {
                                                    return undefined;
                                                }
                                            }
                                            return this.getEditor(row);
                                        }
                                    }, uiHint.columnConfig)
                                }, proxyFieldMapping: {}
                            };
                            rv.fields.push(fieldInMap);
                        }
                        field = field.clone();
                        field.uiHint = field.uiHint || {};
                        field.uiHint.columnConfig = Ext.apply({}, field.uiHint.columnConfig);
                        Ext.applyIf(field.uiHint.columnConfig, {hideOnMultiPropertyGrid: true});
                        fieldInMap.proxyFieldMapping[rowChild.name] = field;
                        rowData[proxySelectionCommonName] = field.defaultValue;
                    }
                    rv.fields.push(field);
                }, this);
            }
            rowChild = rowChild.clone();
            Ext.applyIf(rowChild, {isTerminalForDisplay: true, includeTerminalChildrenForDisplay: false});
            rowChild.uiHint = rowChild.uiHint || {};
            rowChild.uiHint.columnConfig = rowChild.uiHint.columnConfig || {};
            Ext.applyIf(rowChild.uiHint.columnConfig, {hidden: true, hideable: false, renderer: Ext.emptyFn});
            rv.fields.push(rowChild);
            rowData['titlefield'] = rowChild.uiHint.fieldLabel;
            rowData['metafield'] = rowChild;
            rowData['namefield'] = rowChild.name;
            rv.data.push(rowData);
        }
        rv.fields = Ext.data.Field.prototype.orderFields(rv.fields);
        var fieldsByPath = new Ext.util.MixedCollection(false, function (field) {
            return field.attrPath;
        });
        for (var k = 0; k < rv.fields.length; k++) {
            fieldsByPath.add(rv.fields[k]);
        }
        Ext.apply(rv, {fieldsByPath: fieldsByPath, localStore: true, idProperty: 'namefield'});
        return rv;
    }, getValue: function () {
        var results = {};
        this.data.each(function (r) {
            var metafield = r.data['metafield'];
            metafield.mutator(results, this.getRecordValue(r), false, this.baseField.level, (this.baseField.attrPath === metafield.attrPath));
        }, this);
        results.__defaultSaveMap = Pan.base.propertygrid.PropertySaveMap;
        return results;
    }, getRecordValue: function (r) {
        var values = r.data;
        var oldJson = r.json;
        r.json = {};
        var metaField = r.data['metafield'];
        this.fields.each(function (field) {
            var value = values[field.name];
            var proxyFieldMapping = field.proxyFieldMapping;
            if (proxyFieldMapping) {
                var realField = proxyFieldMapping[metaField.name];
                if (realField && Ext.isDefined(realField.level)) {
                    value = !Ext.isEmpty(value) ? value : values[realField.name];
                    this.recordBinder.writeField(r, realField.name, value, values);
                }
            } else {
                var fieldName = Pan.base.autorender.builder.getDefaultProxySelectionCommonName(metaField, field, undefined);
                if (fieldName && !this.fields.get(fieldName)) {
                    this.recordBinder.writeField(r, field.name, value, values);
                }
            }
        }, this);
        var data = r.data['metafield'].accessor(r.json);
        r.json = oldJson;
        return data;
    }, setValue: function (v) {
        if (v) {
            if (v['@__recordInfo'] && !v['@__recordInfo'].id) {
                return;
            }
            this.data.each(function (r) {
                var value = r.data['metafield'].accessor(v, this.baseField.level);
                this.setRecordValue(r, value, this.firstTimeSetValue);
                if (!r.store.writer) {
                    try {
                        r.afterEdit();
                    } catch (ex) {
                    }
                }
            }, this);
            if (this.writer) {
                this.fireEvent('datachanged');
            }
        }
        this.firstTimeSetValue = false;
    }, setRecordValue: function (r, v, firstTimeSetValue) {
        var metaField = r.data['metafield'];
        for (var i = 0; i < this.fields.length; i++) {
            var field = this.fields.get(i);
            var realField = undefined;
            if (field.proxyFieldMapping) {
                realField = field.proxyFieldMapping[metaField.name];
            } else {
                if (field.name === metaField.name) {
                    realField = field;
                }
            }
            if (realField) {
                var value = undefined;
                if (realField.choiceParentAttr) {
                    value = this.__pdefaults.__fieldsByPath.get(realField.choiceParentAttr.attrPath).accessor(v, metaField.level);
                    if (Ext.isObject(value)) {
                        for (var key in value) {
                            if (value.hasOwnProperty(key)) {
                                value = key;
                                break;
                            }
                        }
                    }
                    if (!firstTimeSetValue || Ext.isDefined(value)) {
                        r.data[field.name] = r.data[realField.name] = value;
                    }
                } else {
                    value = realField.accessor(v, metaField.level);
                    if (!firstTimeSetValue || Ext.isDefined(value)) {
                        if (realField.convert) {
                            value = realField.convert(value, {});
                        }
                        r.data[field.name] = r.data[realField.name] = value;
                    }
                }
            }
        }
    }, endEdit: function (r, config) {
        if (this.localStore && config && config.values && r && r.data) {
            for (var key in config.values) {
                if (config.values.hasOwnProperty(key)) {
                    var realField = this.fields.get(key);
                    var proxySelectionCommonName = Pan.base.autorender.builder.getDefaultProxySelectionCommonName(r.data['metafield'], realField, undefined);
                    r.data[proxySelectionCommonName] = config.values[key];
                }
            }
            Ext.apply(r.data, config.values);
        }
        Pan.base.propertygrid.PropertyStore.superclass.endEdit.apply(this, arguments);
    }
});
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.MultiPropertyGrid = Ext.extend(Pan.base.grid.EditorGridPanel, {
    hasGridFilter: false,
    useCheckBoxSelection: false,
    autoHeight: true,
    hasAdjustColumnMenu: false,
    miniCellRowLines: false,
    disableAutoVflex: true,
    setupColumn: function (col, index, registerClickHandler) {
        if (col.hideOnMultiPropertyGrid) {
            Ext.applyIf(col, {hideable: false, hidden: true});
        } else {
            Pan.base.propertygrid.MultiPropertyGrid.superclass.setupColumn.apply(this, arguments);
        }
    },
    setupStore: function () {
        if (!this.store || !this.store.addEvents) {
            this.store = this.store || {};
            this.store.ztype = this.store.ztype || Pan.base.propertygrid.MultiPropertyStore;
            this.store.zconfig = this.store.zconfig || {};
            Ext.applyIf(this.store.zconfig, {baseField: this.__field, localStore: true});
        }
        Pan.base.propertygrid.MultiPropertyGrid.superclass.setupStore.apply(this, arguments);
    },
    preEditValue: function (r, field) {
        var rv = Pan.base.propertygrid.MultiPropertyGrid.superclass.preEditValue.apply(this, arguments);
        if (rv === r) {
            var cindex = this.colModel.findColumnIndex(field);
            var editor = this.colModel.getCellEditor(cindex, 0);
            if (editor && Ext.isFunction(editor.setRecordFormOverride)) {
                editor.setRecordFormOverride({
                    localStore: this.store.localStore,
                    items: [{itemId: r.data['namefield']}]
                });
            }
            if (!this.store.localStore) {
                rv = this.getRecord();
            }
        }
        return rv;
    },
    createDefaultColumnConfig: function (field, index) {
        var col = Pan.base.propertygrid.MultiPropertyGrid.superclass.createDefaultColumnConfig.apply(this, arguments);
        if (this.inlineEditing === false) {
            if (!field.uiHint.isKeyField) {
                delete col.editor;
            }
        }
        return col;
    },
    addSelection: function (selection, config) {
        var r = this.lastActiveEditor.record;
        if (r) {
            if (config.recordFieldName) {
                r.set(config.recordFieldName, selection[0]);
                r.afterEdit();
            } else if (config.replaceSelection) {
                if (this.lastActiveEditor.field && this.lastActiveEditor.field.__field) {
                    var realField = this.lastActiveEditor.field.__field;
                    var proxySelectionCommonName = Pan.base.autorender.builder.getDefaultProxySelectionCommonName(r.data['metafield'], realField, undefined);
                    r.set(proxySelectionCommonName, selection[0]);
                    r.afterEdit();
                }
            }
        }
    },
    getRecordFormField: function () {
        return this.__field;
    }
});
Ext.reg("pan-multipropertygrid", Pan.base.propertygrid.MultiPropertyGrid);
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertyGridLinkEditor = Ext.extend(Ext.Component, {
    initComponent: function () {
        Pan.base.propertygrid.PropertyGridLinkEditor.superclass.initComponent.call(this);
        this.addEvents("beforestartedit", "startedit", "beforecomplete", "complete", "canceledit");
    }, startEdit: function (el, value) {
        this.onValueClick(this, el, value);
    }, onValueClick: Ext.emptyFn, completeEdit: function (remainVisible) {
        var a;
    }, cancelEdit: function (remainVisible) {
    }, setValue: function (v) {
    }, getValue: function () {
        return undefined;
    }
});
Ext.reg('propertygridlinkeditor', Pan.base.propertygrid.PropertyGridLinkEditor);
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertyGridColumnModel = Ext.extend(Ext.grid.ColumnModel, {
    isCellEditable: function (colIndex, rowIndex) {
        if (this.grid) {
            return this.getCellEditor(colIndex, rowIndex);
        } else {
            return Pan.base.propertygrid.PropertyGridColumnModel.superclass.isCellEditable.apply(this, arguments);
        }
    }, getRealFieldName: function (record, grid, column) {
        var fields = grid.store.fields;
        var realFieldName;
        var namefield = fields.get("namefield");
        if (namefield) {
            realFieldName = record.get("namefield");
        } else {
            var proxyField = fields.get(column.dataIndex);
            var proxySelectionData = record.get(proxyField.proxySelectionFieldName);
            realFieldName = proxyField.proxyFieldMapping[proxySelectionData];
        }
        return realFieldName;
    }, getRealColumn: function (record, grid, column) {
        var realFieldName = this.getRealFieldName(record, grid, column);
        var index = grid.colModel.findColumnIndex(realFieldName);
        return grid.colModel.getColumnAt(index);
    }
});
Ext.ns('Pan.base.propertygrid');
Pan.base.propertygrid.PropertyList = Ext.extend(Pan.base.list.ListPanel, {
    setupList: function (config) {
        Ext.applyIf(config, {
            tpl: new Ext.XTemplate('<tpl for="rows">', '<dl>', '<tpl for="parent.columns">', '<dt style="width:{[values.width*100]}%;text-align:{align};">', '<em id="{[Ext.id()]}" unselectable="on">', '{[values.tpl.apply(parent)]}', '</em>', '</dt>', '</tpl>', '<div class="x-clear"></div>', '</dl>', '</tpl>'),
            multiSelect: false,
            singleSelect: false,
            overClass: '',
            propertyList: this,
            onUpdate: function (ds, record) {
                var index = this.store.indexOf(record);
                if (index > -1) {
                    var sel = this.isSelected(index);
                    var original = this.all.elements[index];
                    var node = this.bufferRender([record], index)[0];
                    this.all.replaceElement(index, node, true);
                    if (sel) {
                        this.selected.replaceElement(original, node);
                        this.all.item(index).addClass(this.selectedClass);
                    }
                    this.updateIndexes(index, index);
                }
            },
            prepareData: function (data, index, record) {
                data = Ext.apply({}, data);
                var field = this.propertyList.colModel.getRealColumn(record, this.propertyList, this.propertyList.colModel.getColumnById('valuefield'));
                if (this.__pdefaults.__recordFormRecord && this.__pdefaults.__recordFormRecord.store.__ptpl) {
                    var source = this.__pdefaults.__recordFormRecord.store.__ptpl;
                    if (data['metafield']) {
                        data['metafield']['inTemplate'] = false;
                        var attrPath = field.dataIndex;
                        if (attrPath) {
                            if (attrPath === '$') {
                                data['metafield']['inTemplate'] = jsonPath(source, '$..result.*');
                            } else {
                                if (attrPath.startsWith('$.')) {
                                    attrPath = attrPath.substring(2);
                                }
                                if (attrPath.endsWith('.entry')) {
                                    attrPath = attrPath.substring(0, attrPath.lastIndexOf('.entry')) + '.*';
                                }
                                data['metafield']['inTemplate'] = jsonPath(source, '$..' + attrPath);
                            }
                            if (data['metafield']['inTemplate']) {
                                data['metafield']['inTemplate'] = Ext.isString(data['metafield']['inTemplate'][0]) ? data['metafield']['inTemplate'][0] : data['metafield']['inTemplate'][0]['@ptpl'];
                            }
                        }
                    }
                }
                if (field.propertyRenderer) {
                    var values = this.store.getValue();
                    var value = Pan.base.json.path(values, field.dataIndex);
                    var arr = field.propertyRenderer(value, values, this.store);
                    var tmp = [];
                    for (var j = 1; j < arr.length; j++, j++) {
                        tmp.push(arr[j]);
                    }
                    data['valuefield'] = tmp;
                } else if (field.renderer) {
                    data['valuefield'] = field.renderer(data['valuefield'], {}, record, 1, index, this.store, this.propertyList);
                }
                if (Ext.isArray(data['valuefield'])) {
                    var v = '';
                    var a = data['valuefield'];
                    for (var i = 0; i < a.length; i++) {
                        if (i > 0) {
                            v += '<br>';
                        }
                        if (field.doHTMLEncode !== false && Ext.isString(a[i]) && a[i] !== "&#160;") {
                            a[i] = Pan.base.htmlEncode(a[i]);
                        }
                        v += a[i];
                    }
                    data['valuefield'] = v;
                } else {
                    if (field.doHTMLEncode !== false && Ext.isString(data['valuefield']) && data['valuefield'] !== "&#160;") {
                        data['valuefield'] = Pan.base.htmlEncode(data['valuefield']);
                    }
                }
                if (this.__pdefaults) {
                    var dataField = this.__pdefaults.__fields.get(field.dataIndex);
                    if (dataField) {
                        data['titlefield'] = Pan.base.genLabel(dataField.uiHint, data['titlefield']);
                    }
                }
                return data;
            }
        });
        Pan.base.propertygrid.PropertyList.superclass.setupList.apply(this, arguments);
        this.colModel = new Pan.base.propertygrid.PropertyGridColumnModel({columns: this.allConfigColumns, grid: this});
    }, setValue: function (v) {
        if (!v) {
            v = {};
        }
        this.fieldValue = v;
        this.store.setValue(this.fieldValue);
        var availableFieldNames = {};
        var hasColumnAvail = false;
        for (var i = 0; i < this.colModel.columns.length; i++) {
            var col = this.colModel.columns[i];
            var available = true;
            if (col.columnAvail) {
                hasColumnAvail = true;
                available = col.columnAvail(this);
            }
            if (available) {
                availableFieldNames[col.dataIndex] = true;
            }
        }
        if (hasColumnAvail) {
            this.store.filter([{
                fn: function (record) {
                    return availableFieldNames[record.get("namefield")] === true;
                }
            }]);
        }
        if (this.el) {
            Ext.get(this.el.select('.x-list-body').elements[0]).setHeight('auto');
        }
        if (Ext.isWebKit && this.ownerCt) {
            this.ownerCt.doLayout();
        }
    }
});
Ext.reg('pan-propertylist', Pan.base.propertygrid.PropertyList);
Ext.ns("Pan.base.map");
Pan.base.map.PanMapael = Ext.extend(Pan.base.container.BoxComponent, {
    title: 'Map Data',
    displayLegend: false,
    animDuration: 100,
    mapElemNameTpl: '<span style="font-weight:bold;">{name}</span>',
    mapElemValueTpl: '<br/>Value: {value}',
    preserveAspectRatio: "xMidYMid",
    constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.map.PanMapael.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        Ext.apply(this, {
            updateOptions: {animDuration: this.animDuration},
            autoEl: {html: "<div class='map'></div><div class='areaLegend'></div>"}
        });
        this.mapElemTooltipTemplate = new Ext.XTemplate(this.mapElemNameTpl + this.mapElemValueTpl);
        Pan.base.map.PanMapael.superclass.initComponent.apply(this, arguments);
        this.addEvents('areaclicked', 'plotclicked');
    },
    getMapael: function () {
        return $("#" + this.container.id);
    },
    getDefaultMap: function () {
        return {
            name: "world_countries",
            zoom: {enabled: true, mousewheel: false, maxLevel: 30},
            defaultPlot: {
                clickHandler: this.plotClickHandler,
                scope: this,
                size: 10,
                attrs: {fill: "#e5e5e5", stroke: "#fff", "stroke-width": 0.5},
                attrsHover: {fill: "#f38a03", animDuration: 300, stroke: "#fff", "stroke-width": 0.5}
            },
            defaultArea: {
                clickHandler: this.areaClickHandler,
                scope: this,
                attrs: {fill: "#e5e5e5", stroke: "#fff", "stroke-width": 0.5}
            }
        };
    },
    getDefaultAreas: function () {
        return window.worldmap.attrs;
    },
    onRender: function (ct, position) {
        Pan.base.map.PanMapael.superclass.onRender.apply(this, arguments);
        this.getMapael().mapael({map: this.getDefaultMap(), areas: this.getDefaultAreas()});
    },
    onResize: function (w, h) {
        if (this.oldHeight !== h || this.oldWidth !== w) {
            this.getEl().first().first().setSize(w, h);
            this.oldHeight = h;
            this.oldWidth = w;
        }
    },
    areaClickHandler: function (eventData, event) {
        var log = PanLogging.getLogger('base:map:PanMapael');
        var data = this.getAreaData(eventData.id);
        if (data) {
            data.name = window.worldmap.names[eventData.id];
        }
        log.info('Selected', eventData.id, 'with value ' + (data ? data.value : 'undefined'));
        this.fireEvent('areaclicked', this, data, eventData);
    },
    plotClickHandler: function (eventData, event) {
        var log = PanLogging.getLogger('base:map:PanMapael');
        var data = this.getPlotData(eventData.id);
        log.info('Selected', eventData.id, 'with value ' + (data ? data.value : 'undefined'));
        this.fireEvent('plotclicked', this, data, eventData);
    },
    getAreaData: function (id) {
        var value = this.getValue();
        return value && value.areas[id];
    },
    getPlotData: function (id) {
        var value = this.getValue();
        return value && value.plots[id];
    },
    replaceLegend: function (legend) {
        this.slices = legend.slices;
        this.plotSlices = legend.plotSlices;
    },
    clearValue: function () {
        var deletedPlots = [];
        if (this.value && this.value.plots) {
            for (var plot in this.value.plots) {
                if (this.value.plots.hasOwnProperty(plot)) {
                    deletedPlots.push(plot);
                }
            }
        }
        this.getMapael().trigger("update", [{areas: this.getDefaultAreas()}, {}, deletedPlots, {
            resetAreas: true,
            resetPlots: true
        }]);
        this.value = undefined;
    },
    setValue: function (value) {
        this.clearValue();
        if (Ext.isEmpty(value)) {
            return;
        }
        this.value = value;
        var areas = this.value.areas;
        for (var areaId in areas) {
            if (areas.hasOwnProperty(areaId)) {
                var anArea = areas[areaId];
                if (!anArea.tooltip) {
                    anArea.tooltip = {
                        "content": this.mapElemTooltipTemplate.apply({
                            value: this.getTooltipValue(anArea['value']),
                            name: window.worldmap.names[areaId]
                        })
                    };
                }
                anArea.attrs = {opacity: 1};
            }
        }
        var plots = this.value.plots;
        for (var plotId in plots) {
            if (plots.hasOwnProperty(plotId)) {
                var aPlot = plots[plotId];
                if (!aPlot.tooltip) {
                    aPlot.text = {"content": ""};
                    aPlot.tooltip = {
                        "content": this.mapElemTooltipTemplate.apply(Ext.applyIf({
                            value: this.getTooltipValue(aPlot['value']),
                            name: plotId
                        }, aPlot))
                    };
                }
            }
        }
        if (Ext.isObject(value)) {
            value = [Ext.apply({
                legend: {
                    area: {display: this.displayLegend, title: this.title, slices: this.slices},
                    plot: {display: this.displayLegend, title: this.title, slices: this.plotSlices || this.slices}
                }
            }, value)];
        }
        if (Ext.isArray(value)) {
            value[0] = value[0] || {};
            value[1] = value[0].plots || {};
            value[2] = {};
            value[3] = {};
            Ext.apply(value[3], this.updateOptions);
            this.getMapael().trigger("update", value);
        }
    },
    getTooltipValue: function (value) {
        return Pan.base.htmlEncode(value);
    },
    getValue: function () {
        return this.value;
    },
    setValue1: function () {
        this.setValue({
            areas: {"AF": {"value": 52466800}, "ZA": {"value": 26108826}},
            plots: {
                "Paris": {"latitude": 48.86, "longitude": 2.3444, "value": 100},
                "New York": {"latitude": 40.667, "longitude": -73.833, "value": 200},
                "Sydney": {"latitude": -33.917, "longitude": 151.167, "value": 300},
                "Brasilia": {"latitude": -15.781682, "longitude": -47.924195, "value": 400},
                "Tokyo": {"latitude": 35.687418, "longitude": 139.692306, "value": 500}
            }
        });
    },
    setValue2: function () {
        this.setValue({
            areas: {
                "ZA": {
                    "value": 43635718,
                    "tooltip": {"content": "<span style=\"font-weight:bold;\">South Africa</span><br />Population : 43635718"}
                },
                "AL": {
                    "value": 28472433,
                    "tooltip": {"content": "<span style=\"font-weight:bold;\">Albania</span><br />Population : 28472433"}
                },
                "DZ": {
                    "value": 7013507,
                    "tooltip": {"content": "<span style=\"font-weight:bold;\">Algeria</span><br />Population : 7013507"}
                }
            }
        });
    }
});
Ext.reg('pan-mapael', Pan.base.map.PanMapael);
$.fn.mapael.updateElem = Pan.base.util.createExtension(function (elemOptions, elem, $tooltip, animDuration) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    if (!elemOptions.tooltip || typeof elemOptions.tooltip.content == 'undefined') {
        if (elem.mapElem) {
            delete elem.mapElem.tooltipContent;
            if (elem.mapElem.node) {
                elem.mapElem.node.setAttribute("pointer-events", "none");
            }
        }
    } else if (elem && elem.mapElem && elem.mapElem.attrs && elem.mapElem.attrs.opacity === 0 && elemOptions.attrs && elemOptions.attrs.opacity !== 0) {
        elem.mapElem.toFront();
        if (elem.mapElem.node) {
            elem.mapElem.node.setAttribute("pointer-events", "auto");
        }
    }
    return rv;
}, $.fn.mapael.updateElem);
$.fn.mapael.initElem = Pan.base.util.createExtension(function (paper, elem, options, $tooltip, id) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    if (elem.mapElem) {
        if (options.clickHandler) {
            elem.mapElem.attr({cursor: 'pointer'});
            $(elem.mapElem.node).bind('click', Ext.apply({id: id}, options), function (event) {
                if (!$.fn.mapael.panning) {
                    event.data.clickHandler.call(event.data.scope || this, event.data, event);
                }
            });
        }
    }
    return rv;
}, $.fn.mapael.initElem);
$.fn.mapael.initZoom = Pan.base.util.createExtension(function ($container, paper, mapWidth, mapHeight, options) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    var $parentContainer = $container.parent();
    var $zoomFit = $("<div>").addClass("zoomFit").html("F");
    $container.append($zoomFit);
    $zoomFit.on("click", function () {
        $parentContainer.trigger("zoom", 0);
    });
    return rv;
}, $.fn.mapael.initZoom);
Raphael._engine.setViewBox = Pan.base.util.createExtension(function (x, y, w, h, fit) {
    var rv = arguments.callee.superFunction.apply(this, arguments);
    var parentNode = this.canvas.parentNode;
    while (parentNode) {
        var cmp = Ext.getCmp(parentNode.id);
        if (cmp) {
            if (Ext.isString(cmp.preserveAspectRatio)) {
                cmp.getEl().select("svg").set({"preserveAspectRatio": cmp.preserveAspectRatio});
            }
            break;
        }
        parentNode = parentNode.parentNode;
    }
    return rv;
}, Raphael._engine.setViewBox);
Ext.ns("Pan.base.menu");
Pan.base.menu.SortedMenu = Ext.extend(Ext.menu.Menu, {
    initComponent: function () {
        this.sort();
        Pan.base.menu.SortedMenu.superclass.initComponent.call(this);
    }, sort: function () {
        var arr = this.items ? (this.items.items ? this.items.items : this.items) : null;
        if (arr && arr.sort) {
            Pan.base.util.naturalSortObjectArray(arr, this.sortProperty ? this.sortProperty : 'text');
            this.doLayout();
        }
    }, handleFixedPosition: function () {
        var i, fixedPositionInt, fixedPositions = [], fixedPositionsIndex = 0, hasFixedPosition = false;
        for (i = 0; i < this.items.length; i++) {
            fixedPositions.push(i);
        }
        for (i = 0; i < this.items.length; i++) {
            fixedPositionInt = parseInt(this.items[i].fixedPosition, 10);
            if (!isNaN(fixedPositionInt)) {
                hasFixedPosition = true;
                fixedPositions.remove(fixedPositionInt);
            }
        }
        if (hasFixedPosition) {
            for (i = 0; i < this.items.length; i++) {
                fixedPositionInt = parseInt(this.items[i].fixedPosition, 10);
                if (isNaN(fixedPositionInt)) this.items[i].fixedPosition = fixedPositions[fixedPositionsIndex++];
            }
            Pan.base.util.naturalSortObjectArray(this.items, 'fixedPosition');
        }
    }
});
Ext.reg('sorted-menu', Pan.base.menu.SortedMenu);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanChart = Ext.extend(Pan.base.container.BoxComponent, {
    height: 220, highChart: undefined, chartType: undefined, animation: false, constructor: function (config) {
        Ext.applyIf(this, Pan.base.autorender.GridRecordField.prototype);
        Pan.base.chart.PanChart.superclass.constructor.call(this, config);
    }, initComponent: function () {
        Ext.apply(this, {
            autoEl: {tag: 'div'},
            hideLabel: true,
            value2: this.applyOptionsAndTransform({
                "xAxis": {"categories": ["2015/05/20 16:15:00", "2015/05/20 16:30:00", "2015/05/20 16:45:00", "2015/05/20 17:00:00"]},
                "series": [{
                    "name": "bytes_sent",
                    "data": [115453565, 112888220, 120989693, 105555836]
                }, {"name": "bytes_received", "data": [116314832, 109890635, 129210396, 109427810]}]
            }),
            value1: this.applyOptionsAndTransform({
                "title": {"text": ""},
                "subtitle": {"text": ""},
                "exporting": {"enabled": false},
                "chart": {
                    "zoomType": "x",
                    "events": {},
                    "resetZoomButton": {"theme": {"display": "none"}},
                    "type": "line",
                    "animation": false
                },
                "credits": {"enabled": false},
                "xAxis": {
                    "categories": ["2015/05/20 16:15:00", "2015/05/20 16:30:00", "2015/05/20 16:45:00", "2015/05/20 17:00:00"],
                    "tickInterval": 1,
                    "labels": {}
                },
                "tooltip": {
                    "useHTML": true,
                    "shared": true,
                    "crosshairs": {"width": 2, "color": "gray", "dashStyle": "shortdot"}
                },
                "plotOptions": {"line": {"animation": false}},
                "yAxis": {
                    "min": 0,
                    "labels": {},
                    "title": {"text": ""},
                    "plotLines": [{"value": 0, "width": 1, "color": "#808080"}]
                },
                "series": [{
                    "name": "bytes_sent",
                    "data": [115453565, 112888220, 120989693, 105555836],
                    "color": "#A4C451"
                }, {"name": "bytes_received", "data": [116314832, 109890635, 129210396, 109427810], "color": "#346A88"}]
            })
        });
        Pan.base.chart.PanChart.superclass.initComponent.apply(this, arguments);
    }, onResize: function (w, h) {
        Pan.base.chart.PanChart.superclass.onResize.apply(this, arguments);
        if (this.highChart) {
            this.highChart.setSize(w || this.width, h || this.height, false);
        }
    }, onDestroy: function () {
        if (this.highChart) {
            this.highChart.destroy();
            delete this.highChart;
        }
        Pan.base.chart.PanChart.superclass.onDestroy.apply(this, arguments);
    }, afterRender: function () {
        Pan.base.chart.PanChart.superclass.afterRender.apply(this, arguments);
        this.populate();
    }, applyOptionsAndTransform: function (value) {
        value.title = Ext.apply({"text": this.fieldLabel}, value.title);
        value.chart = Ext.apply({renderTo: this.getId(), type: this.chartType, animation: this.animation}, value.chart);
        value.credits = Ext.apply({enabled: false}, value.credits);
        value.exporting = Ext.apply({enabled: false}, value.exporting);
        value.plotOptions = value.plotOptions || {};
        if (this.urlTemplate) {
            var urlTemplate = this.urlTemplate;
            value.plotOptions.series = value.plotOptions.series || {
                cursor: 'pointer',
                point: {
                    events: {
                        click: function () {
                            var url = Pan.base.Evaluation.evaluate(urlTemplate, Ext.apply({}, this.options, this));
                            if (url) {
                                window.open(url);
                            }
                        }
                    }
                }
            };
        }
        return value;
    }, setValue: function (value) {
        if (value) {
            this.value = this.applyOptionsAndTransform(Ext.apply({}, value));
        }
        if (this.rendered) {
            this.populate();
        }
    }, populate: function () {
        var log = PanLogging.getLogger('base:chart:PanChart');
        if (this.highChart) {
            this.highChart.destroy();
        }
        if (this.value) {
            try {
                this.highChart = new Highcharts.Chart(this.value);
            } catch (ex) {
                log.error(ex);
            }
        }
    }
});
Ext.reg('pan-chart', Pan.base.chart.PanChart);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanLineChart = Ext.extend(Pan.base.chart.PanChart, {
    chartType: 'line',
    applyOptionsAndTransform: function (value) {
        value = Pan.base.chart.PanLineChart.superclass.applyOptionsAndTransform.apply(this, arguments);
        value.plotOptions.line = Ext.apply({animation: this.animation}, value.plotOptions.line);
        return value;
    }
});
Ext.reg('pan-linechart', Pan.base.chart.PanLineChart);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanBarChart = Ext.extend(Pan.base.chart.PanChart, {
    chartType: 'bar',
    applyOptionsAndTransform: function (value) {
        value = Pan.base.chart.PanBarChart.superclass.applyOptionsAndTransform.apply(this, arguments);
        value.plotOptions.bar = Ext.apply({animation: this.animation}, value.plotOptions.bar);
        return value;
    }
});
Ext.reg('pan-barchart', Pan.base.chart.PanBarChart);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanAreaChart = Ext.extend(Pan.base.chart.PanChart, {
    chartType: 'area',
    applyOptionsAndTransform: function (value) {
        value = Pan.base.chart.PanAreaChart.superclass.applyOptionsAndTransform.apply(this, arguments);
        value.plotOptions.area = Ext.apply({animation: this.animation}, value.plotOptions.area);
        return value;
    }
});
Ext.reg('pan-areachart', Pan.base.chart.PanAreaChart);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanColumnChart = Ext.extend(Pan.base.chart.PanChart, {
    chartType: 'column',
    applyOptionsAndTransform: function (value) {
        value = Pan.base.chart.PanColumnChart.superclass.applyOptionsAndTransform.apply(this, arguments);
        value.plotOptions.column = Ext.apply({animation: this.animation}, value.plotOptions.column);
        return value;
    }
});
Ext.reg('pan-columnchart', Pan.base.chart.PanColumnChart);
Ext.ns('Pan.base.chart');
Pan.base.chart.PanPieChart = Ext.extend(Pan.base.chart.PanChart, {
    chartType: 'pie', applyOptionsAndTransform: function (value) {
        value = Pan.base.chart.PanPieChart.superclass.applyOptionsAndTransform.apply(this, arguments);
        value.plotOptions.pie = Ext.apply({animation: this.animation}, value.plotOptions.pie);
        return this.transformFromLineToPie(value);
    }, twoDimArrayGet: function (twoDimArray, oneDimIndex) {
        for (var i = 0; i < twoDimArray.length; i++) {
            if (oneDimIndex - twoDimArray[i].length < 0) {
                return {
                    firstLevelIndex: i,
                    firstLevelLength: twoDimArray.length,
                    secondLevelIndex: oneDimIndex,
                    secondLevelLength: twoDimArray[i].length,
                    value: twoDimArray[i][oneDimIndex]
                };
            } else {
                oneDimIndex -= twoDimArray[i].length;
            }
        }
    }, twoDimArrayFirstLevelIndex: function (twoDimArray, oneDimIndex) {
        for (var i = 0; i < twoDimArray.length; i++) {
            if (oneDimIndex - twoDimArray[i].length < 0) {
                return i;
            } else {
                oneDimIndex -= twoDimArray[i].length;
            }
        }
    }, twoDimArrayCount: function (twoDimArray) {
        var count = 0;
        for (var i = 0; i < twoDimArray.length; i++) {
            count += twoDimArray[i].length;
        }
        return count;
    }, transformFromLineToPie: function (value) {
        if (value.xAxis && value.xAxis.categories && value.series) {
            if (value.series.length > 0) {
                var colors = Highcharts.getOptions().colors;
                var firstColor = 0;
                var colorIndex = firstColor;
                var categories = value.xAxis.categories;
                var data = value.series[0].data;
                if (data) {
                    for (var j = 0; j < data.length; j++) {
                        if (Ext.isNumber(data[j])) {
                            data[j] = {name: categories[j], y: data[j], color: colors[colorIndex++]};
                            if (colorIndex >= colors.length) {
                                colorIndex = firstColor;
                            }
                        } else if (Ext.isObject(data[j])) {
                            Ext.applyIf(data[j], {name: categories[j], color: colors[colorIndex++]});
                        }
                    }
                }
                if (value.xAxis.subcategories && value.series.length > 1) {
                    var subcategories = value.xAxis.subcategories;
                    var subcategoryData = value.series[1].data;
                    for (var k = 0; k < subcategoryData.length; k++) {
                        var obj = this.twoDimArrayGet(subcategories, k);
                        var brightness = 0.2 - (obj.secondLevelIndex / obj.secondLevelLength) / 5;
                        if (Ext.isNumber(subcategoryData[k])) {
                            subcategoryData[k] = {
                                name: obj.value,
                                y: subcategoryData[k],
                                color: Highcharts.Color(data[obj.firstLevelIndex].color).brighten(brightness).get()
                            };
                        } else if (Ext.isObject(subcategoryData[k])) {
                            Ext.applyIf(subcategoryData[k], {
                                name: obj.value,
                                color: Highcharts.Color(data[obj.firstLevelIndex].color).brighten(brightness).get()
                            });
                        }
                    }
                }
            }
        }
        return value;
    }
});
Ext.reg('pan-piechart', Pan.base.chart.PanPieChart);
(function () {
    function getCompletionParams(location, topLevelObjectPath, fieldPath) {
        var vsys = location.vsys;
        var fieldXPath = fieldPath.slice(2).replace(/\./g, '/');
        return create({
            xpathId: (!vsys || vsys === 'shared') ? 'shared' : 'vsys',
            vsysName: vsys,
            xpath: "/config/devices/entry[@name='localhost.localdomain']/" + topLevelObjectPath + "/entry/" + fieldXPath,
            argumentsAreJSON: true,
            useCache: true,
            query: ''
        });
    }

    function getCompletionParamsPano(location, topLevelObjectPath, fieldPath) {
        var vsys = location.vsys, template = location.template;
        var fieldXPath = fieldPath.slice(2).replace(/\./g, '/');
        return create({
            xpathId: (!vsys || vsys === 'shared') ? 'shared' : 'vsys',
            vsysName: vsys,
            xpath: "/config/devices/entry[@name='localhost.localdomain']/template/entry[@name='" + template + "']/config/devices/entry[@name='localhost.localdomain']/" + topLevelObjectPath + "/entry/" + fieldXPath,
            argumentsAreJSON: true,
            useCache: true,
            query: ''
        });
    }

    function create(_a) {
        var xpathId = _a.xpathId, vsysName = _a.vsysName, xpath = _a.xpath, argumentsAreJSON = _a.argumentsAreJSON,
            useCache = _a.useCache, query = _a.query;
        return {
            params: {
                action: 'complete',
                arguments: ['execute', [{
                    xpathId: xpathId,
                    vsysName: vsysName,
                    xpath: xpath,
                    argumentsAreJSON: argumentsAreJSON,
                    useCache: useCache,
                    query: query
                }]]
            }
        };
    }

    PanEnvironment.ns('Pan.appframework.modelview');
    Pan.appframework.modelview.getCompletionParams = getCompletionParams;
    Pan.appframework.modelview.getCompletionParamsPano = getCompletionParamsPano;
})();
Ext.ns('Pan.appframework.errorhandling');
Pan.appframework.errorhandling.PanStatusReporter = (function (config) {
    config = config || {};
    Ext.applyIf(config, {
        setStatus: function (config) {
            if (config.error) {
                var content = config.error.message;
                if (content instanceof Array) {
                    content = content.join("<br>");
                }
                if (config.error.resizableAlert) {
                    Pan.Msg.resizableAlert(config.error.title, content);
                }
                else {
                    Pan.Msg.alert(config.error.title, content);
                }
            }
        }
    });
    var observable = new Ext.util.Observable();
    return Ext.apply(observable, config);
})();
Pan.appframework.errorhandling.reportStatus = function (notSuccess) {
    notSuccess = notSuccess.error ? notSuccess : (notSuccess instanceof Array ? notSuccess[0] : notSuccess);
    var msg = Pan.base.json.paths(notSuccess, "$.msg.line.line").join('') || Pan.base.json.paths(notSuccess, "$.msg.line").join('') || Pan.base.json.paths(notSuccess, "$.msg.*").join('') || Pan.base.json.paths(notSuccess, "$.msg").join('');
    Pan.appframework.errorhandling.PanStatusReporter.setStatus(notSuccess.error ? notSuccess : {
        error: {
            title: _T("Operation Failed"),
            message: msg ? msg : ""
        }
    });
};
Ext.ns('Pan.appframework.schema');
Ext.apply(Pan.appframework.schema, {
    cmsPushedPrefix: function (vsys) {
        var xpath = '/config/panorama/vsys/entry[@name=\'' + vsys + '\']';
        for (var i = 1; i < arguments.length; i++) {
            xpath += arguments[i];
        }
        return xpath;
    }, sharedPrefix: function () {
        var xpath = '/config/shared';
        for (var i = 0; i < arguments.length; i++) {
            xpath += arguments[i];
        }
        return xpath;
    }, predefinedPrefix: function () {
        var xpath = '/config/predefined';
        for (var i = 0; i < arguments.length; i++) {
            xpath += arguments[i];
        }
        return xpath;
    }, devicesPrefix: function () {
        var xpath = '/config/devices/entry';
        for (var i = 0; i < arguments.length; i++) {
            xpath += arguments[i];
        }
        return xpath;
    }, getSharedSchema: function (type) {
        return '$.config.shared.' + type + '.entry';
    }, getPoliciesSchema: function (type, position) {
        return {
            device: {
                defaultPath: 'vsys',
                vsys: '$.config.devices.entry.vsys.entry.rulebase.' + type + '.rules.entry',
                sg: '$.config.devices.entry.network.shared-gateway.entry.rulebase.' + type + '.rules.entry'
            },
            cms: {
                defaultPath: 'dg',
                dg: '$.config.devices.entry.device-group.entry.' + (position === 'post' ? 'post' : 'pre') + '-rulebase.' + type + '.rules.entry',
                shared: '$.config.shared.' + (position === 'post' ? 'post' : 'pre') + '-rulebase.' + type + '.rules.entry'
            }
        };
    }, getNetworkSchema: function (type, additional) {
        return Ext.apply({
            device: '$.config.devices.entry.network.' + type + '.entry',
            'cms': Pan.common.Constants.templatePath + '.config.devices.entry.network.' + type + '.entry'
        }, additional);
    }, getVsysOrDgSchema: function (xpath, devicePath, cmsPath) {
        if (devicePath === undefined) {
            devicePath = 'vsys';
        }
        var deviceVsysPath = '$.config.devices.entry.vsys.entry.' + xpath + '.entry';
        var deviceSharedPath = '$.config.shared.' + xpath + '.entry';
        var deviceSgPath = '$.config.devices.entry.network.shared-gateway.entry.' + xpath + '.entry';
        if (Pan._schema) {
            if (!jsonPath(Pan._schema, deviceVsysPath)) {
                if (jsonPath(Pan._schema, deviceSharedPath)) {
                    devicePath = 'shared';
                }
            }
        }
        if (cmsPath === undefined) {
            cmsPath = 'dg';
        }
        var cmsDgPath = Pan.common.Constants.dgPath + '.' + xpath + '.entry';
        var cmsSharedPath = '$.config.shared.' + xpath + '.entry';
        var cmsPanoramaPath = '$.config.panorama.' + xpath + '.entry';
        if (Pan._schema) {
            if (!jsonPath(Pan._schema, cmsDgPath)) {
                if (jsonPath(Pan._schema, cmsPanoramaPath)) {
                    cmsPath = 'cms-private';
                }
            }
        }
        return {
            'device': {
                defaultPath: devicePath,
                'vsys': deviceVsysPath,
                'shared': deviceSharedPath,
                'sg': deviceSgPath
            }, 'cms': {defaultPath: cmsPath, 'cms-private': cmsPanoramaPath, 'dg': cmsDgPath, 'shared': cmsSharedPath}
        };
    }
});
Pan.appframework.schema.getObjectSchema = Pan.appframework.schema.getVsysOrDgSchema;
(function () {
    var util = Pan.base.util;
    var defaultTypes = [{
        type: 'auto', fieldHint: {
            type: Ext.applyIf({
                sortType: function (s) {
                    if (Ext.isString(s)) {
                        return Pan.base.util.stringSortTypeFunction(s);
                    }
                    return s;
                }
            }, Ext.data.Types['AUTO'])
        }, uiHint: {uitype: 'pan-textfield'}
    }, {
        type: 'bool', fieldHint: {
            type: {
                convert: function (v) {
                    return v === true || v === 'true' || v == 1 || v === 'yes';
                }, rconvert: function (v) {
                    return v === true ? 'yes' : (v === false ? 'no' : v);
                }, sortType: Ext.data.SortTypes['none'], type: 'bool'
            }
        }, uiHint: {uitype: 'pan-checkbox', renderer: 'panbooleancolumn', editor: {xtype: 'panbooleancolumneditor'}}
    }, {
        type: 'reverseBool', fieldHint: {
            type: {
                convert: function (v) {
                    return !(v === true || v === 'true' || v == 1 || v === 'yes');
                }, rconvert: function (v) {
                    if (Ext.isDefined(v)) {
                        return v !== true ? 'yes' : (v !== false ? 'no' : v);
                    }
                    return v;
                }, sortType: Ext.data.SortTypes['none'], type: 'reverseBool'
            }
        }, uiHint: {uitype: 'pan-checkbox', renderer: 'panbooleancolumn', editor: {xtype: 'panbooleancolumneditor'}}
    }, {type: 'date', fieldHint: {type: Ext.data.Types['DATE']}, uiHint: {uitype: 'pan-datefield'}}, {
        type: 'float',
        fieldHint: {
            type: Ext.applyIf({
                convert: function (v) {
                    return v !== undefined && v !== null && v !== '' ? parseFloat(String(v).replace(Ext.data.Types.stripRe, ''), 10) : v;
                }
            }, Ext.data.Types['FLOAT'])
        },
        uiHint: {uitype: 'pan-numberfield', decimalPrecision: 3},
        defaults: {max: 1000000, min: 0}
    }, {
        type: 'int', fieldHint: {
            type: Ext.applyIf({
                convert: function (v) {
                    return v !== undefined && v !== null && v !== '' ? parseInt(String(v).replace(Ext.data.Types.stripRe, ''), 10) : v;
                }
            }, Ext.data.Types['INT'])
        }, uiHint: {uitype: 'pan-numberfield', allowDecimals: false}
    }, {
        type: 'string', fieldHint: {
            type: Ext.applyIf({
                sortType: util.stringSortTypeFunction, convert: function (v) {
                    if (typeof v === "object") {
                        return '';
                    }
                    else if (!Ext.isString(v)) {
                        v = '' + v;
                    }
                    return v;
                }
            }, Ext.data.Types['STRING'])
        }, uiHint: {uitype: 'pan-textfield'}, defaults: {maxlen: 31, minlen: 1}
    }, {
        type: 'array', fieldHint: {
            defaultValue: undefined, type: {
                convert: function (v) {
                    return v;
                }, sortType: Ext.data.SortTypes['none'], type: 'array'
            }, isNonleaf: true
        }, uiHint: {
            builder: function (comp, config) {
                var builder = 'EditorGridBuilder';
                if (config.field.autoComplete) {
                    builder = 'PanCompletionBuilder';
                }
                return Pan.base.autorender.builder.BuilderMgr.get(builder).apply(this, arguments);
            }
        }
    }, {
        type: 'union', fieldHint: {
            isAnAncestorTLO: true, saveLast: true, type: {
                convert: function (v) {
                    return v;
                }, sortType: Ext.data.SortTypes['none'], type: 'union'
            }, isNonleaf: true, supportsFindInLeafField: true, dataMap: function (config) {
                var o = config.__v || config.__field.accessor(config.__record);
                if (!Ext.isObject(o)) {
                    return o;
                }
                for (var i = 0; i < config.__field.children.length; i++) {
                    var child = config.__field.children[i];
                    if (child.nodetype != undefined && child.nodetype != "attr-req") {
                        if (o[child.attrName]) {
                            return child.attrName;
                        }
                    }
                }
            }, saveMap: function (config) {
                var v = config.__v;
                if (v === undefined) {
                    config.__field.mutator(config.__record, undefined);
                    return;
                }
                var o = config.__field.accessor(config.__record);
                if (!Ext.isObject(o)) {
                    o = {};
                    config.__field.mutator(config.__record, o);
                }
                var data = config.__field.getData(config.__record);
                if (data) {
                    for (var key in data) {
                        if (!key.startsWith("@") && data.hasOwnProperty(key)) {
                            var found = jsonPath(config.__field.children, "$[?(@.attrName=='" + key + "')]");
                            if (!found) {
                                throw new Pan.base.autorender.SaveError({
                                    saveRecovery: "extra data node found",
                                    recoveryDetail: _T("This field was configured in a different mode.") + "<br>" + _T("Do you wish to change this field to comply with current mode?"),
                                    field: config.__field,
                                    data: key,
                                    config: config
                                });
                            }
                        }
                    }
                }
                for (var i = 0; i < config.__field.children.length; i++) {
                    var child = config.__field.children[i];
                    if (child.nodetype != undefined && child.nodetype != "attr-req") {
                        if (child.attrName != v) {
                            delete o[child.attrName];
                        }
                        else {
                            if (o[child.attrName] === undefined) {
                                if (child.nodetype === 'sequence') {
                                    child.mutator(config.__record, {});
                                }
                            }
                        }
                    }
                }
            }, saveRecovery: {
                "extra data node found": function (error) {
                    var config = error.config;
                    var data = error.data;
                    delete config.__field.getData(config.__record)[data];
                }
            }
        }, uiHint: {builder: 'RadioCardBuilder', allowBlankValidation: true}
    }, {
        type: 'sequence', fieldHint: {
            saveLast: true, type: {
                convert: function (v) {
                    if (Ext.isArray(v) && v.length == 0) {
                        v = {};
                    }
                    return v;
                }, sortType: Ext.data.SortTypes['none'], type: 'sequence'
            }, isNonleaf: true, dataMap: function (config) {
                if (Ext.isArray(config.__v) && config.__v.length == 0) {
                    config.__v = {};
                    config.__field.mutator(config.__record, config.__v);
                }
                return config.__v;
            }, saveMap: function (config) {
                if (Ext.isBoolean(config.__v)) {
                    if (config.__v === false) {
                        var saveEmptyObject = false;
                        if (Pan.global.getTemplate() && config.__field.children) {
                            var allChildrenAreOptionalOrHasDefault = true;
                            for (var i = 0; i < config.__field.children.length; i++) {
                                var child = config.__field.children[i];
                                if (!child.allowBlank && (child.defaultValue === '' || child.defaultValue === undefined)) {
                                    allChildrenAreOptionalOrHasDefault = false;
                                    break;
                                }
                            }
                            saveEmptyObject = allChildrenAreOptionalOrHasDefault;
                        }
                        if (saveEmptyObject && config.__store && config.__store.hasFieldChanged && config.__store.hasFieldChanged(config.__field.name)) {
                            config.__field.mutator(config.__record, {});
                        }
                        else {
                            config.__field.mutator(config.__record, undefined);
                        }
                    }
                }
                else if (config.__additionalInput && config.__additionalInput.isCustomSave) {
                    return "default";
                }
                else if (!config.__field.childrenNames) {
                    config.__field.mutator(config.__record, config.__v);
                }
                else if (config.__field.allowBlank && (config.__v === undefined)) {
                    config.__field.mutator(config.__record, undefined);
                }
                else if (config.__v === '' && config.__field.trimChildrenIfEmpty) {
                    config.__field.mutator(config.__record, undefined);
                }
            }
        }, uiHint: {
            builder: function (comp, config) {
                var builder = 'ContainerBuilder';
                if (comp.allowBlank) {
                    if (!config || (config.field && config.field.children && config.field.children.length > 0)) {
                        builder = 'FieldSetBuilder';
                    }
                    else {
                        comp.xtype = 'pan-sequencecheckbox';
                        builder = undefined;
                    }
                }
                if (builder) {
                    return Pan.base.autorender.builder.BuilderMgr.get(builder).apply(this, arguments);
                }
            }
        }
    }, {
        type: 'choice', fieldHint: {
            saveLast: true, type: {
                convert: function (v) {
                    if (Ext.isArray(v)) {
                        return '';
                    }
                    return v;
                }, sortType: Ext.data.SortTypes['none'], type: 'choice'
            }, isNonleaf: true, supportsFindInLeafField: true, dataMap: function (config) {
                var o = config.__field.choiceParentAttr.getData(config.__record);
                if (!Ext.isObject(o)) {
                    if (Ext.isDefined(config.__v) && config.__v === config.__field.defaultValue) {
                        return config.__v;
                    }
                    return o;
                }
                for (var i = 0; i < config.__field.children.length; i++) {
                    var child = config.__field.children[i];
                    if (o[child.attrName]) {
                        return child.attrName;
                    }
                }
                if (Ext.isDefined(config.__v) && config.__v === config.__field.defaultValue) {
                    return config.__v;
                }
            }, saveMap: function (config) {
                var field = config.__fieldsByPath.get(config.__field.choiceParentAttr.attrPath);
                var v = config.__v;
                var o = config.__field.choiceParentAttr.getData(config.__record);
                if (v === undefined && Pan.base.isEmpty(o)) {
                    field.mutator(config.__record, undefined);
                    return;
                }
                if (!Ext.isObject(o)) {
                    o = {};
                    field.mutator(config.__record, o);
                }
                for (var i = 0; i < config.__field.children.length; i++) {
                    var child = config.__field.children[i];
                    if (child.attrName != v) {
                        delete o[child.attrName];
                    }
                    else {
                        if (o[child.attrName] === undefined) {
                            if (child.nodetype === 'sequence') {
                                child.mutator(config.__record, {});
                            }
                        }
                    }
                }
                if (Pan.base.isEmpty(o)) {
                    field.mutator(config.__record, undefined);
                }
            }
        }, uiHint: {builder: 'RadioCardBuilder', allowBlankValidation: true}
    }, {
        type: 'enum', uiHint: {
            builder: 'PanCompletionBuilder',
            editable: true,
            mode: 'local',
            renderer: function (value, meta, record, row, column, store, grid) {
                if (store && store.fields) {
                    var field = (grid.colModel.getRealFieldName) ? store.fields.get(grid.colModel.getRealFieldName(record, grid, column)) : store.fields.get(this.dataIndex);
                    if (field && field.uiHint && field.uiHint.useHelpStringAsDisplay) {
                        for (i = 0; i < field.uiHint['enum'].length; i++) {
                            if (field.uiHint['enum'][i][0] == value) {
                                return field.uiHint['enum'][i][1];
                            }
                        }
                    }
                }
                return (typeof value == "undefined" ? Pan.base.Constants.nonestr : value);
            }
        }
    }, {
        type: 'multiple', uiHint: {
            builder: 'PanCompletionBuilder',
            editable: true,
            renderer: function (value, meta, record, row, column, store) {
                var field;
                if (store && store.fields) {
                    field = store.fields.get(this.dataIndex);
                }
                return (typeof value == "undefined" ? ((field && !Ext.isEmpty(field.defaultValue)) ? field.defaultValue : Pan.base.Constants.nonestr) : value);
            }
        }
    }, {type: 'password', uiHint: {builder: 'PasswordBuilder'}}, {
        type: "rangedint",
        fieldHint: {type: Ext.data.Types['INT']},
        uiHint: {uitype: 'pan-numberfield', allowDecimals: false, vtype: 'rangedInt'},
        defaults: {max: 65535, min: 1}
    }, {
        type: 'ipspec', fieldHint: {
            type: {
                convert: Ext.data.Types['STRING'].convert, type: Ext.data.Types['STRING'].type, sortType: function (s) {
                    if (s) {
                        var i = 0;
                        var ipParts = s.split("/");
                        var addressSplitChar = ".";
                        var a = ipParts[0].split(addressSplitChar);
                        if (a.length > 1) {
                            for (i = 0; i < a.length; i++) {
                                a[i] = Pan.base.util.padLeadingString(a[i], 3, "000");
                            }
                            ipParts[0] = a.join(addressSplitChar);
                        }
                        else {
                            addressSplitChar = ":";
                            a = ipParts[0].split(addressSplitChar);
                            if (a.length > 1) {
                                for (i = 0; i < a.length; i++) {
                                    a[i] = Pan.base.util.padLeadingString(a[i], 4, "0000");
                                }
                                ipParts[0] = a.join(addressSplitChar);
                            }
                        }
                        s = ipParts.join("/");
                    }
                    return s;
                }
            }
        }, uiHint: {
            uitype: 'pan-textfield', vtype: function (field) {
                if (Pan.global.SDBGENERAL['cfg.policy.skip-addr-check'] == 'True') {
                    return undefined;
                }
                var multicastOnly = field['multicast-only'] === 'yes' || field['multicast-only'] === true;
                var unicastWithMask = field['unicast-with-mask'];
                var ipv4Only = field['ipv4-only'] === 'yes' || field['ipv4-only'] === true;
                var ipv6Only = field['ipv6-only'] === 'yes' || field['ipv6-only'] === true;
                var vtype = 'ipAndIntegerSubnetMaskV4orV6';
                if (multicastOnly && ipv4Only) {
                    vtype = 'multicast';
                }
                else if (ipv4Only) {
                    vtype = 'ipAndIntegerSubnetMaskV4';
                }
                if (unicastWithMask) {
                    vtype = 'ipAndIntegerSubnetMaskV4orV6SubnetMaskRequired';
                }
                if (ipv6Only) {
                    vtype = 'ipAndIntegerSubnetMaskV6';
                }
                return vtype;
            }
        }
    }, {
        type: 'iprangespec',
        fieldHint: {type: Ext.data.Types['STRING']},
        uiHint: {uitype: 'pan-textfield', vtype: 'ipRange'}
    }, {
        type: 'mac',
        fieldHint: {type: Ext.data.Types['STRING']},
        uiHint: {uitype: 'pan-textfield', vtype: 'macAddress'}
    }, {
        type: 'rangelistspec', fieldHint: {
            type: {
                convert: Ext.data.Types['STRING'].convert, type: Ext.data.Types['STRING'].type, sortType: function (s) {
                    if (s) {
                        s = s.split(/[-,]+/)[0];
                        s = parseInt(s, 10);
                    }
                    return s;
                }
            }
        }, uiHint: {uitype: 'pan-textfield', vtype: 'rangeList'}
    }, {
        type: 'tag',
        fieldHint: {
            type: {
                convert: Ext.data.Types['AUTO'].convert,
                type: 'tag',
                sortType: Ext.data.Types['AUTO'].sortType
            }
        },
        uiHint: {
            builder: function (comp) {
                if (comp.xtype) {
                    return;
                }
                return Pan.base.util.createExtension(function (comp) {
                    if (!Pan.global.getTemplate()) {
                        comp.xtype = 'pan-multiselect-combo';
                        delete comp.height;
                        if (comp.readOnly) {
                            comp.mode = 'local';
                        }
                    }
                    comp = arguments.callee.superFunction.apply(this, arguments);
                }, Pan.appframework.builder.PanCompletionBuilder).apply(this, arguments);
            }
        }
    }, {
        type: 'adminrole', uiHint: {
            builder: function (comp) {
                comp.xtype = 'pan-device-adminrole-editor';
            }
        }
    }];
    var typeMap = {};
    var type2XTypeMap = {};

    function registerType(type, config) {
        if (Ext.isObject(type)) {
            config = arguments[0];
            type = config.type;
        }
        if (Ext.isString(config.likeType)) {
            typeMap[type] = typeMap[config.likeType];
        }
        else {
            typeMap[type] = config;
            var TYPE = type.toUpperCase();
            if (config.fieldHint && config.fieldHint.type && config.fieldHint.type !== Ext.data.Types[TYPE]) {
                config.fieldHint.extType = Ext.data.Types[TYPE] = Ext.data.Types[TYPE] || {};
                Ext.apply(Ext.data.Types[TYPE], config.fieldHint.type);
            }
        }
        type2XTypeMap[type] = typeMap[type].uiHint && typeMap[type].uiHint.uitype;
    }

    for (var i = 0; i < defaultTypes.length; i++) {
        var defaultType = defaultTypes[i];
        registerType(defaultType.type, defaultType);
    }
    var PanType = {
        getType2XTypeMap: function () {
            return type2XTypeMap;
        }, getTypeMap: function () {
            return typeMap;
        }, getTypeInfo: function (type, attrName) {
            var result = typeMap[type];
            if (Ext.isFunction(result)) {
                result = result(attrName);
            }
            return result;
        }, getExtType: function (type) {
            return Ext.isObject(type) ? type : Ext.data.Types[type.toUpperCase()];
        }, register: registerType, treg: registerType, deregister: function (type) {
            if (typeMap[type]) {
                delete typeMap[type];
            }
            var TYPE = type.toUpperCase();
            if (Ext.data.Types[TYPE]) {
                delete Ext.data.Types[TYPE];
            }
            if (type2XTypeMap[type]) {
                delete type2XTypeMap[type];
            }
        }, getRegisteredType: function (type) {
            if (Ext.isObject(type)) {
                type = type.type;
            }
            return type ? typeMap[type] : undefined;
        }
    };
    Ext.ns('Pan.appframework.schema');
    Pan.appframework.schema.PanType = PanType;
}());
(function () {
    var global = Pan.global;
    var base = Pan.base;
    var PanDecode = Pan.base.PanDecode;
    var util = Pan.base.util;
    var PanType = Pan.appframework.schema.PanType;
    var log = PanLogging.getLogger('PanSchema');
    var PanSchema = Ext.extend(Ext.util.Observable, {
        defaultNameRegExp: new RegExp('^[0-9a-zA-Z][ 0-9a-zA-Z._-]*$'),
        constructor: function (config) {
            this.initialConfig = Ext.apply({}, config);
            var json = this.initialConfig.json;
            if (!Ext.isObject(json) || !json['@attr'] || !json['@attr'].attrPath) {
                if (config.cloneJSONBeforeUse) {
                    json = base.clone(json);
                }
                var len = PanSchema.schemaProcessors.length;
                for (i = 0; i < len; i++) {
                    PanSchema.schemaProcessors[i](json);
                }
                this.schemaPruneOn = global.schemaPruneOn();
                json = this.visitInternal(json, null, null, this.processPruneOn);
                var exclusionArray = this.initialConfig.exclusionArray;
                var i;
                if (exclusionArray) {
                    for (i = 0; i < exclusionArray.length; i++) {
                        var exclusion = exclusionArray[i];
                        var parent = exclusion.replace(/\.[^.]*$/g, '');
                        if (parent !== exclusion) {
                            var exclusionAttrName = exclusion.substring(parent.length + 1);
                            var exclusionParentNodes = jsonPath(json, '$.' + parent);
                            if (exclusionParentNodes) {
                                for (var j = 0; j < exclusionParentNodes.length; j++) {
                                    var exclusionParentNode = exclusionParentNodes[j];
                                    exclusionParentNode['@attr'].exclusionMap = exclusionParentNode['@attr'].exclusionMap || {};
                                    exclusionParentNode['@attr'].exclusionMap[exclusionAttrName] = true;
                                }
                            }
                        }
                        else {
                            json['@attr'].exclusionMap = json['@attr'].exclusionMap || {};
                            json['@attr'].exclusionMap[exclusion] = true;
                        }
                    }
                }
                PanSchema.transformSchema(json);
                this.schema = this.visitInternal(json, null, null, this.postprocessSchema, this, this.postprocessPostVisitFn, false);
            }
            else {
                this.schema = json;
            }
        },
        convertEnum: function (enumValues, valueOnly) {
            var values = [];
            var helpStrings = {};
            var helpTips = {};
            for (var i = 0; i < enumValues.length; i++) {
                var struct = enumValues[i];
                var pruneOn = struct['prune-on'];
                var pruneOnSDB = (struct['prune-on-sdb'] && Pan.global.getTemplate() !== undefined) ? undefined : struct['prune-on-sdb'];
                if (pruneOn || pruneOnSDB) {
                    if ((pruneOn && this.pruneSchemaNode(pruneOn)) || (pruneOnSDB && this.pruneSDBSchemaNode(pruneOnSDB))) {
                        continue;
                    }
                    else {
                        struct['value'] = struct['value'].replace(/__[0-9]+$/, '');
                    }
                }
                var valueString, displayString;
                displayString = valueString = struct['value'];
                if (!valueOnly) {
                    var helpString = struct['help-string'];
                    if (helpString && helpString !== displayString) {
                        displayString = helpString;
                    }
                }
                values.push([valueString, displayString]);
                helpStrings[valueString] = struct['help-string'];
                helpTips[valueString] = struct['show-help-tip'];
            }
            return {values: values, helpStrings: helpStrings, helpTips: helpTips};
        },
        conversionProperties: [{
            property: 'optional', tag: 'allowBlank', type: 'uiHint', fn: function (value, attrs) {
                value = util.yes2TrueFn(value);
                attrs.allowBlank = value;
                attrs.fieldHint = attrs.fieldHint || {};
                attrs.fieldHint.allowBlank = value;
                return value;
            }, 'default': 'no'
        }, {
            property: 'regex', tag: 'regex', type: 'uiHint', fn: function (value) {
                value = value.replace(/\[:cntrl:\]/g, '\x01-\x1F\x7F');
                return new RegExp(value);
            }
        }, {
            property: 'subtype', tag: 'type', type: 'fieldHint', fn: function (value) {
                return value === 'mac-address' ? 'mac' : value;
            }
        }, {property: 'help-string', tag: 'helpstring', type: 'uiHint'}, {
            property: 'show-help-tip',
            tag: 'helpTip',
            type: 'uiHint',
            fn: function (value) {
                return value === 'yes' ? true : undefined;
            }
        }, {property: 'ipv4-only', tag: 'ipv4-only', type: 'fieldHint'}, {
            property: 'ipv6-only',
            tag: 'ipv6-only',
            type: 'fieldHint'
        }, {property: 'multicast-only', tag: 'multicast-only', type: 'fieldHint'}, {
            property: 'unicast-with-mask',
            tag: 'unicast-with-mask',
            type: 'fieldHint',
            fn: util.yes2TrueFn
        }, {
            property: 'encrypt', tag: 'type', type: 'fieldHint', fn: function (value) {
                return value === 'yes' ? 'password' : undefined;
            }
        }, {
            property: 'enum', tag: 'enum', type: 'uiHint', fn: function (value, attrs) {
                var result = this.convertEnum(value, false);
                attrs.uiHint['helpStrings'] = result.helpStrings;
                attrs.uiHint['helpTips'] = result.helpTips;
                return result.values;
            }
        }, {
            property: 'ui-hint', tag: 'uiHint', type: 'uiHint', fn: function (value, attrs) {
                var schemaHints;
                if (Ext.isString(value)) {
                    try {
                        if (!value.match(/^ *\{.*\} *$/)) {
                            value = '{' + value + '}';
                        }
                        schemaHints = Ext.util.JSON.decode(value);
                    }
                    catch (ex) {
                        log.error('Unable to parse ui-hint ' + value);
                    }
                }
                else if (Ext.isObject(value)) {
                    schemaHints = value;
                }
                Ext.apply(attrs.uiHint, schemaHints);
                return undefined;
            }
        }, {property: 'uiHint-fieldLabel', tag: 'fieldLabel', type: 'uiHint'}, {
            property: 'autocomplete',
            tag: 'autoComplete',
            type: 'fieldHint',
            fn: util.yes2TrueFn
        }, {
            property: 'loose-membership',
            tag: 'looseMembership',
            type: 'fieldHint',
            fn: util.yes2TrueFn
        }, {property: 'max-count', tag: 'maxCount', type: 'fieldHint'}, {
            property: 'min',
            tag: 'minValue',
            type: 'uiHint'
        }, {property: 'max', tag: 'maxValue', type: 'uiHint'}, {
            property: 'tlo',
            tag: 'tlo',
            type: 'fieldHint',
            fn: util.yes2TrueFn
        }, {
            property: 'ui-field-hint', tag: 'fieldHint', type: 'fieldHint', fn: function (value, attrs) {
                var schemaHints;
                if (Ext.isString(value)) {
                    try {
                        if (!value.match(/^ *\{.*\} *$/)) {
                            value = '{' + value + '}';
                        }
                        schemaHints = Ext.util.JSON.decode(value);
                    }
                    catch (ex) {
                        log.error('Unable to parse ui-field-hint ' + value);
                    }
                }
                else if (Ext.isObject(value)) {
                    schemaHints = value;
                }
                Ext.apply(attrs.fieldHint, schemaHints);
                return undefined;
            }
        }, {property: 'isStar', tag: 'isStar', type: 'fieldHint'}, {
            property: 'isCollection',
            tag: 'isCollection',
            type: 'fieldHint'
        }, {property: 'choices', tag: 'choices', type: 'fieldHint'}, {
            property: 'choiceAttr',
            tag: 'choiceAttr',
            type: 'fieldHint'
        }, {property: 'choiceParentAttr', tag: 'choiceParentAttr', type: 'fieldHint'}],
        postConversionProperties: [{property: 'maxlen', tag: 'maxLength', type: 'uiHint'}, {
            property: 'minlen', tag: 'minLength', type: 'uiHint', fn: function (value, attrs) {
                if (attrs.uiHint && attrs.uiHint.allowBlank) {
                    value = undefined;
                }
                return value;
            }
        }, {
            property: 'platform-max', tag: 'maxValue', type: 'uiHint', fn: function (value, attrs) {
                var rv = global.SDBGENERAL[value];
                if (!Ext.isEmpty(rv)) {
                    return rv;
                }
                return attrs['maxValue'];
            }
        }, {
            property: 'default', tag: 'defaultValue', type: 'fieldHint', fn: function (value, attrs) {
                var extType = attrs.fieldHint && attrs.fieldHint.extType;
                if (extType) {
                    return extType.convert(value);
                }
                return value;
            }
        }, {
            property: 'multi-types', tag: 'multitypes', type: 'fieldHint', fn: function (value, attrs) {
                var log = PanLogging.getLogger('appframework:schema:PanSchema');
                if (value['enum']) {
                    value = Ext.apply({}, value);
                    var result = this.convertEnum(value['enum'], true);
                    value['enum'] = result.values;
                    attrs.uiHint = attrs.uiHint || {};
                    if (result.helpStrings) {
                        attrs.uiHint['helpStrings'] = result.helpStrings;
                    }
                    if (result.helpTips) {
                        attrs.uiHint['helpTips'] = result.helpTips;
                    }
                }
                var multiValidationInfo = false;
                var looseMembership = false;
                for (var m in value) {
                    if (value.hasOwnProperty(m)) {
                        var info = value[m];
                        switch (m) {
                            case'enum':
                                break;
                            case'string':
                                var currentIsLooseMembership = false;
                                if (info['loose-membership']) {
                                    currentIsLooseMembership = util.yes2TrueFn(info['loose-membership']);
                                }
                                looseMembership = looseMembership || currentIsLooseMembership;
                                if (attrs['autocomplete'] && (!info['regex'] || !currentIsLooseMembership)) {
                                    break;
                                }
                            default:
                                var validationInfo = {};
                                var panType = PanType.getTypeInfo(m);
                                if (Ext.isObject(info) && panType) {
                                    Ext.apply(validationInfo, info);
                                    this.convertAllAttrs(validationInfo, panType.defaults);
                                    validationInfo = validationInfo.uiHint || validationInfo;
                                }
                                if (panType) {
                                    var uiHint = panType.uiHint;
                                    if (uiHint) {
                                        Ext.applyIf(validationInfo, {vtype: uiHint.vtype});
                                        if (Ext.isFunction(validationInfo.vtype)) {
                                            validationInfo.vtype = validationInfo.vtype(info);
                                        }
                                        if (uiHint.regex) {
                                            Ext.applyIf(validationInfo, {regex: new RegExp(uiHint.regex)});
                                        }
                                    }
                                }
                                else {
                                    log.warn('Unrecognized type: ' + m);
                                }
                                if (!multiValidationInfo) {
                                    multiValidationInfo = [];
                                }
                                multiValidationInfo.push(validationInfo);
                                break;
                        }
                    }
                }
                if (looseMembership) {
                    attrs.fieldHint.looseMembership = true;
                }
                else if (multiValidationInfo) {
                    attrs.uiHint.vtype = 'multiVtype';
                    attrs.uiHint.multiValidationInfo = multiValidationInfo;
                }
                return value;
            }
        }],
        printPruneOnPaths: function (json) {
            this.visitInternal(json, null, null, this.processPrintPruneOn);
        },
        processPrintPruneOn: function (attrs, node, attrName, parentNode) {
            var log = PanLogging.getLogger('appframework:schema:PanSchema');
            var rv;
            if (parentNode) {
                var pruneOn = attrs['prune-on'];
                var pruneOnSDB = (attrs['prune-on-sdb'] && Pan.global.getTemplate() !== undefined) ? undefined : attrs['prune-on-sdb'];
                var attrPath;
                if (pruneOn || pruneOnSDB) {
                    var oldAttrName = attrName;
                    attrName = attrName.replace(/__[0-9]+$/, '');
                    if (oldAttrName !== attrName) {
                        parentNode[attrName] = node;
                        attrs.oldAttrName = oldAttrName;
                        delete parentNode[oldAttrName];
                        rv = {'renamed': attrName};
                    }
                    attrPath = (parentNode['@attr'] && parentNode['@attr'].attrPath) ? parentNode['@attr'].attrPath + '/' + attrName : '/' + attrName;
                    log.info(attrPath + ' ; reason: ' + (pruneOn || '') + (pruneOnSDB ? pruneOn ? ',' + pruneOnSDB : pruneOnSDB : ''));
                }
                node['@attr'].attrPath = attrPath || (parentNode && parentNode['@attr'] && parentNode['@attr'].attrPath) ? parentNode['@attr'].attrPath + '/' + attrName : '/' + attrName;
            }
            return rv;
        },
        pruneSchemaNode: function (pruneOnString) {
            var a = pruneOnString.split(/[ ,]/);
            if (this.schemaPruneOn.length > 0) {
                for (var i = 0; i < a.length; i++) {
                    if (this.schemaPruneOn.indexOf(a[i]) >= 0) {
                        return true;
                    }
                }
            }
            return false;
        },
        pruneSDBSchemaNode: function (pruneOnString) {
            var a = pruneOnString.split(/[ ,]/);
            for (var i = 0; i < a.length; i++) {
                var aa = a[i].split(/[=]/);
                if (aa.length >= 2) {
                    if (global.SDBGENERAL[aa[0].trim()] === aa[1].trim()) {
                        return true;
                    }
                }
                else if (global.SDBGENERAL[a[i].trim()] === 'True') {
                    return true;
                }
            }
            return false;
        },
        postprocessSchema: function (attrs, node, attrName, parentNode) {
            var fieldHint = attrs.fieldHint;
            if (!fieldHint) {
                fieldHint = attrs.fieldHint = {};
            }
            var uiHint = attrs.uiHint;
            if (!uiHint) {
                uiHint = attrs.uiHint = {};
            }
            this.convertAttrs(this.conversionProperties, attrs);
            Ext.applyIf(fieldHint, {
                nodetype: attrs['node-type'],
                type: (attrs.fieldHint && attrs.fieldHint['type']) || attrs['type']
            });
            var typeInfo = PanType.getTypeInfo(fieldHint.type || fieldHint['nodetype']);
            if (!typeInfo) {
                typeInfo = PanType.getTypeInfo('auto');
            }
            Ext.applyIf(fieldHint, typeInfo.fieldHint);
            Ext.applyIf(uiHint, typeInfo.uiHint);
            this.convertAttrs(this.postConversionProperties, attrs, typeInfo.defaults);
            if (!parentNode || !parentNode['@attr']) {
                attrs.attrPath = '$';
                attrs.attrName = '$';
                uiHint.fieldLabel = '';
                Ext.apply(fieldHint, {
                    accessor: function (record) {
                        return record;
                    }, mutator: function (dest, src) {
                        if (dest !== src) {
                            var recordInfo = dest['@__recordInfo'];
                            PanDecode.deleteAllChildren(dest);
                            Ext.apply(dest, src);
                            Ext.applyIf(dest, {'@__recordInfo': recordInfo});
                        }
                    }
                });
                var rootJSONPath = this.initialConfig.rootJSONPath;
                var rootJSONName;
                if (rootJSONPath) {
                    rootJSONName = rootJSONPath.replace(/^.*\./g, '');
                }
                Ext.applyIf(fieldHint, {
                    level: 0,
                    slevel: 0,
                    rootSchemaNode: node,
                    rootJSONPath: rootJSONPath,
                    rootJSONName: rootJSONName,
                    rootPathInfo: this.initialConfig.rootPathInfo,
                    saveMap: undefined,
                    dataMap: function (config) {
                        return config.__record;
                    }
                });
            }
            else {
                var pattrs = parentNode['@attr'];
                attrs.attrPath = pattrs.attrPath + '.' + attrName;
                var parentMapping = pattrs.fieldHint.mapping;
                Pan.setValue(attrs, 'fieldHint.mapping', parentMapping ? (parentMapping + '[\'' + attrName + '\']') : ('[\'' + attrName + '\']'));
                Pan.setValue(attrs, 'fieldHint.level', pattrs.fieldHint.level + 1);
                var slevel = pattrs.fieldHint.slevel + 1;
                if (attrs.slevel) {
                    slevel += attrs.slevel;
                }
                Pan.setValue(attrs, 'fieldHint.slevel', slevel);
                attrs.attrName = attrName;
                attrs.parentNode = parentNode;
            }
            var nodeAttr = String(attrs.attrPath).split('.');
            attrs.getChildData = (function (nodeAttr) {
                return function (o, childPath) {
                    var i;
                    var attr = String(childPath).split('.');
                    if (attr.length < nodeAttr.length) {
                        return undefined;
                    }
                    for (i = 0; i < nodeAttr.length; i++) {
                        if (nodeAttr[i] !== attr[i]) {
                            return undefined;
                        }
                    }
                    if (attr.length === nodeAttr.length) {
                        return o;
                    }
                    else {
                        for (i = nodeAttr.length; i < attr.length; i++) {
                            if (!o) {
                                return undefined;
                            }
                            o = o[attr[i]];
                        }
                        return o;
                    }
                };
            }(nodeAttr));
            attrs.setChildData = (function (nodeAttr) {
                return function (o, childPath, value) {
                    var i;
                    var attr = String(childPath).split('.');
                    if (attr.length < nodeAttr.length) {
                        return;
                    }
                    for (i = 0; i < nodeAttr.length; i++) {
                        if (nodeAttr[i] !== attr[i]) {
                            return;
                        }
                    }
                    if (attr.length !== nodeAttr.length) {
                        for (i = nodeAttr.length; i < attr.length - 1; i++) {
                            if (!o[attr[i]]) {
                                o[attr[i]] = {};
                            }
                            o = o[attr[i]];
                        }
                        o[attr[i]] = value;
                    }
                };
            }(nodeAttr));
            attrs.getData = (function (expr) {
                if (Ext.isEmpty(expr)) {
                    return Ext.emptyFn;
                }
                if (Ext.isFunction(expr)) {
                    return expr;
                }
                if (expr === '$') {
                    return function (obj) {
                        return obj;
                    };
                }
                return function (obj) {
                    var result = jsonPath(obj, expr, undefined);
                    if (result) {
                        return result[0];
                    }
                    return undefined;
                };
            }(attrs.attrPath));
            attrs.setData = (function (expr) {
                if (Ext.isEmpty(expr)) {
                    return Ext.emptyFn;
                }
                if (Ext.isFunction(expr)) {
                    return expr;
                }
                var attr = String(expr).split('.');
                return function (o, value) {
                    for (var i = 1; i < attr.length - 1; i++) {
                        if (!o[attr[i]]) {
                            o[attr[i]] = {};
                        }
                        o = o[attr[i]];
                    }
                    o[attr[i]] = value;
                };
            }(attrs.attrPath));
            return attrs.skipChildHintProcessing;
        },
        postprocessPostVisitFn: function (attrs, node) {
            var childrenPaths = [];
            var childrenNames = [];
            for (var m in node) {
                if (node.hasOwnProperty(m)) {
                    switch (m) {
                        case'@attr':
                            break;
                        default:
                            var nodeMAttr = node[m]['@attr'];
                            if (nodeMAttr) {
                                if (nodeMAttr['choiceAttr']) {
                                    var choiceAttr = nodeMAttr['choiceAttr'];
                                    choiceAttr.childrenPaths = choiceAttr.childrenPaths || [];
                                    choiceAttr.childrenNames = choiceAttr.childrenNames || [];
                                    choiceAttr.childrenPaths.push(nodeMAttr.attrPath);
                                    choiceAttr.childrenNames.push(nodeMAttr.attrName);
                                }
                                else if (nodeMAttr.attrPath) {
                                    childrenPaths.push(nodeMAttr.attrPath);
                                    childrenNames.push(nodeMAttr.attrName);
                                }
                            }
                            break;
                    }
                }
            }
            if (childrenPaths.length > 0) {
                attrs.childrenPaths = childrenPaths;
                attrs.childrenNames = childrenNames;
            }
        },
        convertAllAttrs: function (attrs, defaults) {
            this.convertAttrs(this.conversionProperties, attrs);
            this.convertAttrs(this.postConversionProperties, attrs, defaults);
        },
        convertAttrs: function (conversionProperties, attrs, defaults) {
            for (var i = 0; i < conversionProperties.length; i++) {
                var prop = conversionProperties[i];
                var attrValue = attrs[prop.property];
                if (attrValue === undefined) {
                    attrValue = defaults && defaults[prop.property];
                    if (attrValue === undefined) {
                        attrValue = prop['default'];
                    }
                }
                if (attrValue !== undefined && Ext.isFunction(prop.fn)) {
                    attrValue = prop.fn.call(this, attrValue, attrs);
                }
                if (attrValue !== undefined) {
                    PanDecode.setValue(attrs, prop.type + '.' + prop.tag, attrValue);
                }
            }
        },
        mapping2Path: function (expr) {
            if (expr) {
                expr = String(expr).replace(/['"]*[\]][\[]['"]*|['"]*[\]][.]*|[.]*[\[]['"]*/g, '.');
                expr = expr.replace(/^[.]*|[.]*$/g, '');
            }
            return expr;
        },
        getSchemaInfo: function (attrPath) {
            var result = jsonPath(this.schema, attrPath + '.@attr', undefined);
            if (result) {
                return result[0];
            }
            return undefined;
        },
        visit: function (fn, scope) {
            return this.visitInternal(this.schema, null, null, fn, scope, false);
        },
        fieldVisit: function (fn, scope, field, fieldMap) {
            var result = fn.call(scope || this, field);
            if (result !== false && result.childrenNames) {
                for (var i = 0; i < result.childrenNames.length; i++) {
                    var childField = fieldMap[result.childrenNames[i]];
                    if (childField) {
                        this.fieldVisit(fn, scope, childField, fieldMap);
                    }
                }
            }
        },
        visitInternal: function (json, member, parentJson, fn, scope, postVisitFunction, visitExclusion) {
            if (Ext.isObject(json)) {
                var stopChildProcessing;
                if (json['@attr']) {
                    var rv = fn.call(scope || this, json['@attr'], json, member, parentJson);
                    if (Ext.isObject(rv) && rv.renamed) {
                        member = rv.renamed;
                    }
                    else {
                        stopChildProcessing = rv;
                    }
                }
                if (!(stopChildProcessing)) {
                    for (var m in json) {
                        if (json.hasOwnProperty(m)) {
                            switch (m) {
                                case'@attr':
                                    break;
                                default:
                                    if (visitExclusion || !(json['@attr'] && json['@attr'].exclusionMap && json['@attr'].exclusionMap[m])) {
                                        this.visitInternal(json[m], m, json, fn, scope, postVisitFunction, visitExclusion);
                                    }
                                    break;
                            }
                        }
                    }
                }
                if (postVisitFunction && json['@attr']) {
                    postVisitFunction.call(scope || this, json['@attr'], json, member, parentJson);
                }
            }
            return json;
        },
        populateFields: function (fields, doNotAutoGenerateFields) {
            var log = PanLogging.getLogger('appframework:schema:PanSchema');
            if (this.fields) {
                return this.fields;
            }
            else {
                fields = fields.slice(0);
            }
            var fieldMap = {};
            var fieldMapByPath = {};
            var attachmentFields = {};
            var pruneFieldMap = {};
            var pruneIfNoChildMap = {};
            for (var i = 0, n = fields.length; i < n; i++) {
                var field = fields[i];
                if (Ext.isString(field)) {
                    field = {name: field};
                    fields[i] = field;
                }
                else {
                    field = fields[i] = Ext.apply({}, field);
                    if (field.childrenNames) {
                        field.childrenNames = field.childrenNames.slice(0);
                    }
                    if (field.uiHint) {
                        field.uiHint = Ext.apply({}, field.uiHint);
                    }
                }
                if (!field.initialFieldConfig) {
                    var initialFieldConfig = Ext.apply({}, field);
                    field.initialFieldConfig = initialFieldConfig;
                    if (initialFieldConfig.uiHint) {
                        initialFieldConfig.uiHint = Ext.apply({}, initialFieldConfig.uiHint);
                    }
                }
                var attrPath = field.attrPath || (field.mapping && this.mapping2Path(field.mapping)) || field.name;
                var schemaInfo = this.getSchemaInfo(attrPath);
                if (schemaInfo) {
                    if (!field.children && schemaInfo.childrenPaths) {
                        field.childrenPaths = base.clone(schemaInfo.childrenPaths);
                    }
                    fieldMap[field.name] = fieldMapByPath[schemaInfo.attrPath] = field;
                }
                else {
                    if (field.pruneIfNoChild) {
                        pruneIfNoChildMap[field.name] = field;
                    }
                    if (field.pruneIfNotInSchema) {
                        pruneFieldMap[field.name] = field;
                    }
                    else if (field.parentFieldPath) {
                        attachmentFields[field.parentFieldPath] = attachmentFields[field.parentFieldPath] || [];
                        attachmentFields[field.parentFieldPath].push(field.name);
                        fieldMap[field.name] = field;
                    }
                    else {
                        fieldMap[field.name] = field;
                    }
                }
                this.setField(field, schemaInfo, false);
            }
            if (!doNotAutoGenerateFields) {
                this.visit(function (attr) {
                    var generatedField = false;
                    var field = fieldMapByPath[attr.attrPath];
                    if (!field) {
                        generatedField = true;
                        field = {};
                        if (attr.childrenPaths) {
                            field.childrenPaths = base.clone(attr.childrenPaths);
                        }
                        this.setField(field, attr, true);
                    }
                    if (generatedField) {
                        fields.push(field);
                        fieldMap[field.name] = fieldMapByPath[attr.attrPath] = field;
                    }
                }, this);
            }
            for (var k = fields.length - 1; k >= 0; k--) {
                var f = fields[k];
                if (pruneFieldMap[f.name]) {
                    fields.splice(k, 1);
                }
                if (!f.childrenNames) {
                    if (attachmentFields[f.attrPath]) {
                        f.childrenNames = attachmentFields[f.attrPath];
                    }
                    if (f.childrenPaths) {
                        f.childrenNames = f.childrenNames || [];
                        for (var l = 0; l < f.childrenPaths.length; l++) {
                            var childField = fieldMapByPath[f.childrenPaths[l]];
                            if (!childField || !childField.uiHint) {
                                log.warn('Missing: ' + f.childrenPaths[l]);
                            }
                            if (childField.uiHint.isKeyField) {
                                f.childrenNames.unshift(childField.name);
                            }
                            else {
                                f.childrenNames.push(childField.name);
                            }
                        }
                        if (f.prependChildrenNames) {
                            for (var po = f.prependChildrenNames.length - 1; po >= 0; po--) {
                                f.childrenNames.unshift(f.prependChildrenNames[po]);
                            }
                            delete f.prependChildrenNames;
                        }
                        if (f.additionalChildrenNames) {
                            for (var o = 0; o < f.additionalChildrenNames.length; o++) {
                                f.childrenNames.push(f.additionalChildrenNames[o]);
                            }
                            delete f.additionalChildrenNames;
                        }
                        if (f.appendChildrenAfterNamedField) {
                            var searchforIndex = -1;
                            var searchfor = f.appendChildrenAfterNamedField[0];
                            var toBeInserted = f.appendChildrenAfterNamedField[1];
                            for (var q = 0; q < f.childrenNames.length; q++) {
                                if (f.childrenNames[q] === searchfor) {
                                    searchforIndex = q;
                                    break;
                                }
                            }
                            if (searchforIndex !== -1) {
                                var args = [searchforIndex + 1, 0];
                                if (Ext.isArray(toBeInserted)) {
                                    Ext.each(toBeInserted, function (item) {
                                        args.push(item);
                                    });
                                }
                                else {
                                    args.push(toBeInserted);
                                }
                                f.childrenNames.splice.apply(f.childrenNames, args);
                            }
                            delete f.appendChildrenAfterNamedField;
                        }
                    }
                }
                else {
                    for (var p = f.childrenNames.length - 1; p >= 0; p--) {
                        if (!fieldMap[f.childrenNames[p]]) {
                            f.childrenNames.splice(p, 1);
                        }
                    }
                }
                if (Ext.isFunction(f.modifyChildrenNames)) {
                    f.childrenNames = f.modifyChildrenNames(f.childrenNames);
                }
                if (f.childrenPaths) {
                    delete f.childrenPaths;
                }
            }
            for (var r = fields.length - 1; r >= 0; r--) {
                var ff = fields[r];
                if (pruneIfNoChildMap[ff.name]) {
                    if (!ff.childrenNames || ff.childrenNames.length === 0) {
                        fields.splice(r, 1);
                    }
                    else {
                        for (var s = 0; s < ff.childrenNames.length; s++) {
                            if (!pruneFieldMap[ff.childrenNames[s]]) {
                                break;
                            }
                        }
                        if (s === ff.childrenNames.length) {
                            fields.splice(r, 1);
                        }
                    }
                }
            }
            for (var m = 0; m < fields.length; m++) {
                var fi = fields[m];
                this.fieldVisit(function (ff) {
                    if (ff.type && ff.type.type === 'sequence' && ff.uiHint.allowBlank && ff.childrenNames) {
                        var showAsContainer = !(ff.initialFieldConfig && ff.initialFieldConfig.uiHint && Ext.isDefined(ff.initialFieldConfig.uiHint.allowBlank));
                        if (showAsContainer) {
                            for (var n = 0; n < ff.childrenNames.length; n++) {
                                var childField = fieldMap[ff.childrenNames[n]];
                                if (!childField || !childField.type) continue;
                                if (childField.type && childField.type.type === 'sequence' && childField.schemaAllowBlank) {
                                    showAsContainer = true;
                                    break;
                                }
                                if (!childField.uiHint.allowBlank && childField.type.type !== 'array') {
                                    if (ff.childrenNames.length === 1) {
                                        showAsContainer = true;
                                        Ext.apply(childField.uiHint, {allowBlank: true});
                                        Ext.apply(childField, {allowBlank: true});
                                        if (childField.uiHint.fieldLabelAutoGen) {
                                            Ext.apply(childField.uiHint, {fieldLabel: ff.uiHint.fieldLabel || ff.name});
                                        }
                                        if (!Ext.isDefined(childField.defaultValue)) {
                                            Ext.applyIf(childField.uiHint, {noneString: base.Constants.nonestr});
                                        }
                                        Ext.apply(ff.uiHint, {fieldLabel: ''});
                                    }
                                    else {
                                        showAsContainer = false;
                                    }
                                }
                            }
                        }
                        if (showAsContainer) {
                            Ext.apply(ff.uiHint, {allowBlank: false});
                            Ext.apply(ff, {allowBlank: ff.uiHint.allowBlank});
                        }
                        return ff;
                    }
                    else {
                        return false;
                    }
                }, this, fi, fieldMap);
            }
            return this.fields = Ext.data.Field.prototype.orderFields(fields);
        },
        setField: function (field, attr) {
            var hasTypeOverride = Ext.isDefined(field.type);
            var hasDefaultOverride = Ext.isDefined(field.defaultValue);
            if (attr) {
                Ext.applyIf(field, {
                    name: attr.attrPath,
                    attrPath: attr.attrPath,
                    attrName: attr.attrName,
                    getChildData: attr.getChildData,
                    setChildData: attr.setChildData,
                    getData: attr.getData,
                    setData: attr.setData,
                    schemaAllowBlank: attr.allowBlank
                });
                Ext.applyIf(field, attr.fieldHint);
            }
            var uiHint = field.uiHint = field.uiHint || {};
            if (attr) {
                if ((field.isStar && !field.childrenPaths) || (field.attrName === '@name')) {
                    Ext.applyIf(uiHint, {isKeyField: true, allowBlank: false});
                    if (uiHint.allowBlank !== field.allowBlank) {
                        field.allowBlank = uiHint.allowBlank;
                    }
                }
            }
            if (attr) {
                Ext.applyIf(uiHint, attr.uiHint);
                if (field.attrName === '@name') {
                    if (uiHint.regex) {
                        if (base.validation.objectNameValidationMap[uiHint.regex.source]) {
                            Ext.applyIf(uiHint, {vtype: base.validation.objectNameValidationMap[uiHint.regex.source]});
                        }
                        else if (attr.subtype === 'object-name') {
                            Ext.applyIf(uiHint, {regexText: uiHint.helpstring});
                        }
                    }
                    else if (attr.subtype === 'object-name') {
                        Ext.applyIf(uiHint, {vtype: 'objectName', maxLength: 31});
                    }
                }
            }
            if (field.autoComplete) {
                Ext.applyIf(uiHint, {builder: 'PanCompletionBuilder'});
            }
            if (hasTypeOverride && !hasDefaultOverride && !Ext.isDefined(field.overrideDefault)) {
                var extType = Pan.appframework.schema.PanType.getExtType(field.type);
                if (extType) {
                    field.overrideDefault = extType.defaultValue;
                    var schemaDefault = attr && attr['default'];
                    if (Ext.isDefined(schemaDefault)) {
                        if (extType.convert) {
                            field.overrideDefault = extType.convert(schemaDefault);
                        }
                        else {
                            field.overrideDefault = schemaDefault;
                        }
                    }
                }
            }
            if (uiHint.allowBlank && (!Ext.isDefined(field.defaultValue))) {
                Ext.applyIf(uiHint, {noneString: base.Constants.nonestr});
            }
            if (Ext.isFunction(uiHint.vtype)) {
                uiHint.vtype = uiHint.vtype(field);
            }
            if (uiHint.fieldLabel === undefined) {
                var parentNodeAttr, label;
                if (field.isCollection) {
                    parentNodeAttr = attr.parentNode['@attr'];
                    label = (parentNodeAttr.uiHint.fieldLabel !== undefined) ? parentNodeAttr.uiHint.fieldLabel : parentNodeAttr.attrName;
                }
                else if (field.isStar) {
                    parentNodeAttr = attr.parentNode['@attr'].parentNode['@attr'];
                    label = (parentNodeAttr.uiHint.fieldLabel !== undefined) ? parentNodeAttr.uiHint.fieldLabel : parentNodeAttr.attrName;
                    if (label === '') {
                        label = attr.parentNode['@attr'].attrName;
                    }
                }
                else if (field.attrName === '@name' && attr.parentNode['@attr'].isStar) {
                    var collectionParent = attr.parentNode['@attr'].parentNode['@attr'];
                    label = (collectionParent.parentNode['@attr'].uiHint.fieldLabel !== undefined) ? collectionParent.parentNode['@attr'].uiHint.fieldLabel : collectionParent.parentNode['@attr'].attrName;
                }
                else {
                    label = field.name;
                    if (attr && attr.attrPath === field.name) {
                        label = attr.attrName;
                    }
                }
                uiHint.fieldLabel = _TC(label);
                uiHint.fieldLabelAutoGen = uiHint.fieldLabel;
            }
        },
        processPruneOn: function (attrs, node, attrName, parentNode) {
            var rv;
            if (parentNode) {
                var pruneOn = attrs['prune-on'];
                var pruneOnSDB = (attrs['prune-on-sdb'] && Pan.global.getTemplate() !== undefined) ? undefined : attrs['prune-on-sdb'];
                if (pruneOn || pruneOnSDB) {
                    if ((pruneOn && this.pruneSchemaNode(pruneOn)) || (pruneOnSDB && this.pruneSDBSchemaNode(pruneOnSDB))) {
                        delete parentNode[attrName];
                        return true;
                    }
                    else {
                        var oldAttrName = attrName;
                        attrName = attrName.replace(/__[0-9]+$/, '');
                        if (oldAttrName !== attrName) {
                            parentNode[attrName] = node;
                            attrs.oldAttrName = oldAttrName;
                            delete parentNode[oldAttrName];
                            rv = {'renamed': attrName};
                        }
                    }
                }
            }
            return rv;
        }
    });
    PanSchema._preProcessPruneOn = function (schema) {
        schema.config = PanSchema.transverse(schema.config, function (attrs, node, attrName, parentNode) {
            var result;
            if (parentNode && !attrs.oldAttrName) {
                var pruneOn = attrs['prune-on'];
                if (pruneOn) {
                    var oldAttrName = attrName;
                    attrName = attrName.replace(/__[0-9]+$/, '');
                    if (oldAttrName !== attrName) {
                        if (!parentNode[attrName]) {
                            parentNode[attrName] = node;
                            attrs.oldAttrName = oldAttrName;
                            delete parentNode[oldAttrName];
                            result = {'renamed': attrName};
                        }
                    }
                }
            }
            return result;
        });
        return schema;
    };
    PanSchema.transformSchema = function (schema) {
        return PanSchema.transverse(schema, function (attrs, node, attrName, parentNode) {
            if (attrName === '*') {
                return;
            }
            if (parentNode && parentNode['@attr']) {
                var parentAttrs = parentNode['@attr'];
                if (parentAttrs['node-type'] === 'array' && attrName.indexOf('@') !== 0) {
                    var star = {'@attr': {isStar: true}};
                    if (attrName === 'entry' || attrName === 'member') {
                        Ext.applyIf(star, node);
                        Ext.applyIf(star['@attr'], node['@attr']);
                        PanDecode.deleteAllChildren(node);
                        node['@attr'] = Ext.applyIf({'isCollection': true}, parentAttrs);
                        node['@attr']['max-count'] = star['@attr']['max-count'];
                        delete star['@attr']['max-count'];
                        parentAttrs['node-type'] = 'sequence';
                        delete parentAttrs['tlo'];
                        delete parentAttrs['ui-field-hint'];
                        delete parentAttrs['uiHint-fieldLabel'];
                        if (star['@attr'].autocomplete) {
                            node['@attr'].autocomplete = star['@attr'].autocomplete;
                        }
                        if (star['@attr'].memberof) {
                            node['@attr'].memberof = star['@attr'].memberof;
                        }
                        if (star['@attr']['multi-types']) {
                            var defaultValue = star['@attr']['default'];
                            if (defaultValue) {
                                node['@attr']['default'] = [defaultValue];
                            }
                        }
                        node['*'] = star;
                    }
                    else {
                        if (!parentNode['*']) {
                            Ext.applyIf(star, parentNode);
                            star['@attr']['node-type'] = 'sequence';
                            var parentNodeAttr = parentNode['@attr'];
                            PanDecode.deleteAllChildren(parentNode);
                            parentNode['@attr'] = parentNodeAttr;
                            Ext.applyIf(parentNode['@attr'], {'isCollection': true});
                            parentNode['*'] = star;
                        }
                    }
                }
            }
        }, function (attrs, node, attrName, parentNode) {
            if (parentNode) {
                if (attrs['disabled'] === 'yes') {
                    delete parentNode[attrName];
                }
                else if (attrs['node-type'] === 'choice') {
                    var parentAttrs = parentNode['@attr'];
                    attrs['choices'] = [];
                    for (var m in node) {
                        if (node.hasOwnProperty(m) && m.indexOf('@') !== 0) {
                            parentNode[m] = node[m];
                            attrs['choices'].push(m);
                            attrs['choiceParentAttr'] = parentAttrs;
                            node[m]['@attr']['choiceAttr'] = attrs;
                            node[m]['@attr'].slevel = 1;
                            delete node[m];
                        }
                    }
                }
            }
        });
    };
    PanSchema.transverse = function (rootNode, preChildCallback, postChildCallback, thisArg) {
        return PanSchema.prototype.visitInternal(rootNode, null, null, preChildCallback, thisArg, postChildCallback);
    };
    PanSchema.initialize = function () {
        for (var i = 0, len = PanSchema.initialize.handlers.length; i < len; i++) {
            var handler = PanSchema.initialize.handlers[i];
            Pan._schema = handler(Pan._schema);
        }
    };
    PanSchema.initialize.handlers = [];
    PanSchema.initialize.addHandler = function (handler) {
        PanSchema.initialize.handlers.push(handler);
    };
    PanSchema.initialize.removeHandler = function (handler) {
        var i = PanSchema.initialize.handlers.indexOf(handler);
        if (i >= 0) {
            PanSchema.initialize.handlers.splice(i, 1);
        }
    };
    PanSchema.schemaProcessors = [];
    if (Pan._schema) {
        Pan._schema = PanSchema._preProcessPruneOn(Pan._schema);
    }
    Ext.data.Field.prototype.isFromSchema = function () {
        return !!this.getChildData;
    };
    Ext.data.Field.prototype.visit = function (fn, scope) {
        var result = fn.call(scope, this);
        if (result !== false && this.children) {
            for (var i = 0; i < this.children.length; i++) {
                this.children[i].visit(fn, scope);
            }
        }
    };
    Ext.data.Field.prototype.clone = function () {
        return this;
    };
    Ext.data.Field.prototype.orderFields = function (fields) {
        var saveFirst = {};
        var saveLast = {};
        var map;
        var i, field;
        for (i = 0; i < fields.length; i++) {
            field = fields[i];
            var slevel = Ext.isNumber(field.slevel) ? field.slevel : 0;
            map = field.saveLast ? saveLast : saveFirst;
            if (!map[slevel]) {
                map[slevel] = [];
                if (Ext.isNumber(map.max)) {
                    if (slevel > map.max) {
                        map.max = slevel;
                    }
                }
                else {
                    map.max = slevel;
                }
            }
            map[slevel].push(field);
        }
        var index = 0;
        var a;
        var j;
        map = saveFirst;
        var max = map.max;
        if (Ext.isNumber(max)) {
            for (i = max; i >= 0; i--) {
                if (map[i]) {
                    a = map[i];
                    for (j = 0; j < a.length; j++) {
                        fields[index++] = a[j];
                    }
                }
            }
        }
        map = saveLast;
        max = map.max;
        if (Ext.isNumber(max)) {
            for (i = max; i >= 0; i--) {
                if (map[i]) {
                    a = map[i];
                    for (j = 0; j < a.length; j++) {
                        fields[index++] = a[j];
                    }
                }
            }
        }
        return fields;
    };
    Ext.data.Field.prototype.__cloneable__ = false;
    Ext.ns('Pan.appframework.schema');
    Pan.appframework.schema.PanSchema = PanSchema;
}());
umd(function (define) {
    define(function (require) {
        var Ext = require('Ext');
        var Pan = require('Pan');
        var repository = {};
        var repositoryT = {};
        var readSchemaRegistry = {};
        var lastSchemaPruneOn;
        var put = function (type, isTemplate, json, rootJSONPath, rootPathInfo, exclusionArray) {
            var repo = isTemplate ? repositoryT : repository;
            repo[type] = new Pan.appframework.schema.PanSchema({
                type: type,
                isTemplate: isTemplate,
                json: json,
                rootJSONPath: rootJSONPath,
                rootPathInfo: rootPathInfo,
                exclusionArray: exclusionArray,
                cloneJSONBeforeUse: true
            });
        };
        var RepositoryClass = Ext.extend(Ext.util.Observable, {
            hasNode: function (type, attrPath) {
                var schema = this.readSchema(type);
                return !!jsonPath(schema.schema, attrPath);
            }, clearEntry: function (type) {
                if (type instanceof RegExp) {
                    var key;
                    for (key in repository) {
                        if (repository.hasOwnProperty(key)) {
                            if (type.test(key)) {
                                delete repository[key];
                            }
                        }
                    }
                    for (key in repositoryT) {
                        if (repositoryT.hasOwnProperty(key)) {
                            if (type.test(key)) {
                                delete repositoryT[key];
                            }
                        }
                    }
                }
                else {
                    delete repository[type];
                    delete repositoryT[type];
                }
            }, get: function (type, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                if (isTemplate) {
                    var schemaPruneOn = Pan.global.schemaPruneOn();
                    if (schemaPruneOn.toString() != lastSchemaPruneOn) {
                        lastSchemaPruneOn = schemaPruneOn;
                        repositoryT = {};
                    }
                    return repositoryT[type];
                }
                else {
                    return repository[type];
                }
            }, readSchema: function (type, callback, scope, callbackConfig, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                var schema = this.get(type, isTemplate);
                var readSchema = readSchemaRegistry[type];
                if (!schema && readSchema) {
                    if (Ext.isFunction(readSchema) && readSchema.directCfg) {
                        readSchema(this.afterDataReceived, {
                            callback: callback,
                            scope: scope,
                            config: callbackConfig,
                            type: type,
                            isTemplate: isTemplate
                        });
                        return;
                    }
                    else if (Pan._schema) {
                        if (Ext.isFunction(readSchema)) {
                            readSchema = readSchema();
                        }
                        if (!readSchema) {
                            return null;
                        }
                        var rootPathInfo, exclusionArray;
                        if (!Ext.isString(readSchema)) {
                            if (readSchema['injectedSchema']) {
                                readSchema['injectedSchema'](type, isTemplate);
                            }
                            if (Pan.global.isCmsSelected() && !isTemplate) {
                                rootPathInfo = readSchema['cms'];
                            }
                            else {
                                rootPathInfo = readSchema['device'];
                            }
                            if (!rootPathInfo) {
                                return null;
                            }
                            exclusionArray = readSchema['exclude'];
                            if (!Ext.isString(rootPathInfo)) {
                                readSchema = rootPathInfo[rootPathInfo['defaultPath']];
                            }
                            else {
                                readSchema = rootPathInfo;
                            }
                        }
                        var json;
                        if (isTemplate) {
                            var templateReadSchema = readSchema.replace(/^\$/, Pan.common.Constants.templatePath);
                            json = jsonPath(Pan._schema, templateReadSchema);
                            if (!json) {
                                templateReadSchema = templateReadSchema.replace('.choice', '');
                                json = jsonPath(Pan._schema, templateReadSchema);
                            }
                            if (json) {
                                readSchema = templateReadSchema;
                            }
                        }
                        if (!json) {
                            json = jsonPath(Pan._schema, readSchema);
                            if (!json) {
                                readSchema = readSchema.replace('.choice', '');
                                json = jsonPath(Pan._schema, readSchema);
                            }
                        }
                        put(type, isTemplate, json[0], readSchema, rootPathInfo, exclusionArray);
                        schema = this.get(type, isTemplate);
                    }
                }
                if (callback) {
                    callback.call(scope, callbackConfig);
                }
                else {
                    return schema;
                }
            }, getRegisteredPaths: function (schemaPath) {
                if (!Ext.isDefined(schemaPath)) {
                    return _.keys(readSchemaRegistry);
                }
                var matchingPaths = [];
                var doPathsMatch = function (findItIn, searchFor) {
                    if (findItIn && searchFor && Ext.isString(searchFor) && Ext.isString(findItIn)) {
                        if (findItIn.substring(0, searchFor.length) === searchFor) {
                            if (findItIn.length > searchFor.length) {
                                return findItIn.charAt(searchFor.length) === '.' && findItIn.substring(searchFor.length).indexOf('entry') === -1;
                            }
                            else {
                                return true;
                            }
                        }
                    }
                    else {
                        return searchFor == findItIn;
                    }
                };
                var isTemplate = schemaPath.startsWith('$.config.devices.entry.template.entry') && schemaPath !== '$.config.devices.entry.template.entry';
                for (var registeredPath in readSchemaRegistry) {
                    if (Pan.global.isCmsSelected()) {
                        var isTemplatePath = registeredPath.indexOf('Network/') === 0 || registeredPath.indexOf('Device/') === 0;
                        if (isTemplate !== isTemplatePath) {
                            continue;
                        }
                    }
                    var schema = this.readSchema(registeredPath, undefined, undefined, undefined, isTemplate);
                    if (schema && schema.initialConfig) {
                        if (isTemplate === true && !schema.initialConfig.isTemplate) {
                            continue;
                        }
                        if (schema.initialConfig && Ext.isString(schema.initialConfig.rootJSONPath) && doPathsMatch(schema.initialConfig.rootJSONPath, schemaPath)) {
                            matchingPaths.push(registeredPath);
                        }
                        else if (schema.initialConfig.rootPathInfo) {
                            if (Ext.isString(schema.initialConfig.rootPathInfo)) {
                                if (doPathsMatch(schema.initialConfig.rootPathInfo, schemaPath)) {
                                    matchingPaths.push(registeredPath);
                                }
                            }
                            else if (Ext.isObject(schema.initialConfig.rootPathInfo)) {
                                var pathToFind = schemaPath;
                                if (isTemplate) {
                                    pathToFind = '$' + schemaPath.substring(Pan.common.Constants.templatePath.length);
                                }
                                Ext.each(['shared', 'sg', 'vsys', 'cms-private', 'dg'], function (scope) {
                                    if (Ext.isString(schema.initialConfig.rootPathInfo[scope])) {
                                        if (doPathsMatch(schema.initialConfig.rootPathInfo[scope], pathToFind)) {
                                            matchingPaths.push(registeredPath);
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                return matchingPaths;
            }, afterDataReceived: function (result) {
                put(this.type, result.isTemplate, result.entry);
                var callbackPackage = this;
                callbackPackage.callback.call(callbackPackage.scope, callbackPackage.config);
            }, sreg: function (type, fn) {
                return readSchemaRegistry[type] = fn;
            }, schemaRmNode: function (path, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                if (Pan.appframework.PanAppInterface.isInitialized() && isTemplate) {
                    path = path.replace(/^\$/, Pan.common.Constants.templatePath);
                }
                var parentNode = jsonPath(Pan._schema, path)[0];
                if (parentNode) {
                    Pan.setValue(Pan._schema, path.substring(2), undefined);
                }
            }, schemaMkNode: function (path, config, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                if (Pan.appframework.PanAppInterface.isInitialized() && isTemplate) {
                    path = path.replace(/^\$/, Pan.common.Constants.templatePath);
                }
                var parentNode = jsonPath(Pan._schema, path)[0];
                if (!parentNode) {
                    Pan.setValue(Pan._schema, path.substring(2), config);
                }
            }, schemaMkLink: function (path, linkPath, supportStarField, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                if (Pan.appframework.PanAppInterface.isInitialized() && isTemplate) {
                    path = path.replace(/^\$/, Pan.common.Constants.templatePath);
                    linkPath = linkPath.replace(/^\$/, Pan.common.Constants.templatePath);
                }
                var link;
                var parentNode = jsonPath(Pan._schema, path)[0];
                if (!parentNode) {
                    link = jsonPath(Pan._schema, linkPath)[0];
                    if (link) {
                        Pan.setValue(Pan._schema, path.substring(2), link);
                        Pan._schema['linkMapping'] = Pan._schema['linkMapping'] || {};
                        if (supportStarField) {
                            var pathArray = path.split('.');
                            var linkPathArray = linkPath.split('.');
                            var pathIndex = pathArray.length - 1;
                            var linkPathIndex = linkPathArray.length - 1;
                            while (pathIndex >= 0 && linkPathIndex >= 0) {
                                if (pathArray[pathIndex] === linkPathArray[linkPathIndex]) {
                                    pathIndex--;
                                    linkPathIndex--;
                                }
                                else {
                                    break;
                                }
                            }
                            var i;
                            var newPath = '';
                            for (i = 0; i <= pathIndex; i++) {
                                newPath += pathArray[i];
                                if (i < pathIndex) {
                                    newPath += '.';
                                }
                            }
                            var newLinkPath = '';
                            for (i = 0; i <= linkPathIndex; i++) {
                                newLinkPath += linkPathArray[i];
                                if (i < linkPathIndex) {
                                    newLinkPath += '.';
                                }
                            }
                            if (newPath === '$.injected') {
                                Pan._schema['linkMapping'][path] = linkPath;
                            }
                            else {
                                Pan._schema['linkMapping'][newPath] = newLinkPath;
                            }
                        }
                        else {
                            Pan._schema['linkMapping'][path] = linkPath;
                        }
                    }
                }
            }, schemaMkCopy: function (path, copyPath, isTemplate) {
                if (!Ext.isDefined(isTemplate)) {
                    isTemplate = Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
                if (Pan.appframework.PanAppInterface.isInitialized() && isTemplate) {
                    path = path.replace(/^\$/, Pan.common.Constants.templatePath);
                    copyPath = copyPath.replace(/^\$/, Pan.common.Constants.templatePath);
                }
                var copy;
                var parentNode = jsonPath(Pan._schema, path)[0];
                if (!parentNode) {
                    copy = jsonPath(Pan._schema, copyPath)[0];
                    if (copy) {
                        copy = Pan.base.clone(copy);
                        Pan.setValue(Pan._schema, path.substring(2), copy);
                        Pan._schema['linkMapping'] = Pan._schema['linkMapping'] || {};
                        Pan._schema['linkMapping'][path] = copyPath;
                    }
                }
            }, schemaLinkLookup: function (path) {
                return Pan._schema['linkMapping'][path];
            }, schemaLinkReplace: function (path) {
                var linkMapping = Pan._schema['linkMapping'];
                for (var m in linkMapping) {
                    if (linkMapping.hasOwnProperty(m)) {
                        if (path.indexOf(m) === 0) {
                            return path.replace(m, linkMapping[m]);
                        }
                    }
                }
            }
        });
        var result = new RepositoryClass();
        Pan.sreg = result.sreg;
        Pan.schemaRmNode = result.schemaRmNode;
        Pan.schemaMkNode = result.schemaMkNode;
        Pan.schemaMkLink = result.schemaMkLink;
        Pan.schemaMkCopy = result.schemaMkCopy;
        Pan.schemaLinkReplace = result.schemaLinkReplace;
        return result;
    });
}, 'Pan.appframework.schema.PanSchemaRepository', require, exports, module);
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanViewer = Ext.extend(Ext.util.Observable, {
    configStates: {isSupportingCmsPrivate: true, isSupportingShared: true, defaultSingleVsysModeLocation: 'shared'},
    functionFields: ['fields', 'commonFields', 'columns', 'recordFormOverride', 'headers'],
    panViewerInit: function () {
        for (var i = 0; i < this.functionFields.length; i++) {
            var functionField = this.functionFields[i];
            if (Ext.isFunction(this[functionField])) {
                this[functionField] = this[functionField]();
            }
        }
        if (this.defaultConfigStates) {
            this.configStates = Ext.apply({}, this.configStates, this.defaultConfigStates);
        }
        this.addEvents('afterinit');
        var nHandler = new Pan.appframework.PanNotificationHandler();
        nHandler.addListener(PanNotificationHandler.nConstants.Events.Config_Change, this.onNTConfigChange, this);
    },
    panViewerOnDestroy: function () {
        var nHandler = new Pan.appframework.PanNotificationHandler();
        nHandler.removeListener(PanNotificationHandler.nConstants.Events.Config_Change, this.onNTConfigChange, this);
    },
    onNTConfigChange: function (nts) {
        if (!nts || !Ext.isArray(nts))
            return;
        var handleNotificationForViewer = function (nts, readSchema, objectNames) {
            if (!readSchema) {
                return false;
            }
            var pathMatch = function (categoryPath, path) {
                if (Ext.isString(categoryPath) && Ext.isString(path)) {
                    return categoryPath && path && (path + '.').startsWith(categoryPath.replace(/\.entry$/, "") + '.');
                } else {
                    return false;
                }
            };
            var checkTemplatePath = function (dPaths, path) {
                if (!dPaths)
                    return false;
                var devicePathVsys = Ext.isObject(dPaths) ? dPaths.vsys : dPaths;
                var devicePathShared = Ext.isObject(dPaths) ? dPaths.shared : dPaths;
                var devicePathSg = Ext.isObject(dPaths) ? dPaths.sg : dPaths;
                if (pathMatch(devicePathVsys, path) || pathMatch(devicePathShared, path) || pathMatch(devicePathSg, path)) {
                    return true;
                } else {
                    return false;
                }
            };
            var checkDGPath = function (dPaths, path) {
                if (!dPaths)
                    return false;
                var devicePathVsys = Ext.isObject(dPaths) ? dPaths.vsys : dPaths;
                var devicePathShared = Ext.isObject(dPaths) ? dPaths.shared : dPaths;
                var devicePathSg = Ext.isObject(dPaths) ? dPaths.sg : dPaths;
                if (pathMatch(devicePathVsys, path) || pathMatch(devicePathShared, path) || pathMatch(devicePathSg, path)) {
                    return true;
                } else {
                    return false;
                }
            };
            var getValue = function (pattern, target) {
                var result = target.match(pattern);
                if (result && Ext.isArray(result) && result[1]) {
                    return result[1];
                } else {
                    return null;
                }
            };
            try {
                var name = undefined;
                var refresh = false;
                var cmsPaths = readSchema.cms;
                var devicePaths = readSchema.device;
                var relatedPathes = readSchema.relatedPathes;
                var i, _item, _cmsPaths;
                for (var k = 0; k < nts.length; k++) {
                    var key = nts[k].detail.key;
                    if (key.indexOf("obj=") >= 0) {
                        var dg = null;
                        var path = key.replace(/.*obj=["]/g, "").replace(/["].*$/g, "");
                        path = path.replace(/\[\@name=[']localhost\.localdomain[']\]/g, "");
                        if (path.indexOf("/config/devices/entry/template/entry") >= 0) {
                            var template = getValue(/\/config\/devices\/entry\/template\/entry\[@name='([^']*)'\]/, path);
                            if (Pan.global.getTemplate() === template) {
                                path = path.replace(/\/config\/devices\/entry\/template\/entry\[\@name\=['][^']*[']\]/g, "");
                                name = path.match(/[^\/]*\/.*\[\@name\=\'(.*?)\'/);
                                path = path.replace(/\[\@name=['][^']*[']\]/g, "");
                                path = "$" + path.replace(/\//g, ".");
                                refresh = checkTemplatePath(devicePaths, path);
                                if (!refresh) {
                                    if (relatedPathes && Ext.isArray(relatedPathes)) {
                                        for (i = 0; i < relatedPathes.length; i++) {
                                            _item = relatedPathes[i];
                                            var _devicePaths = _item.device;
                                            if (!_devicePaths)
                                                continue;
                                            if (checkTemplatePath(_devicePaths, path)) {
                                                refresh = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (refresh)
                                    break;
                            }
                        } else if (path.indexOf("/entry/device-group/") >= 0) {
                            dg = getValue(/entry\/device\-group\/entry\[@name='([^']*)'\]/, path);
                            name = path.match(/[^\/]*\/.*\[\@name\=\'(.*?)\'/);
                            path = path.replace(/\[\@name=['][^']*[']\]/g, "");
                            path = "$" + path.replace(/\//g, ".");
                            var cmsPathDg = Ext.isObject(cmsPaths) ? cmsPaths.dg : cmsPaths;
                            var locVal = Pan.global.getLocVal();
                            if (locVal === dg) {
                                if (pathMatch(cmsPathDg, path)) {
                                    refresh = true;
                                    break;
                                } else {
                                    if (relatedPathes && Ext.isArray(relatedPathes)) {
                                        for (i = 0; i < relatedPathes.length; i++) {
                                            _item = relatedPathes[i];
                                            _cmsPaths = _item.cms;
                                            if (!_cmsPaths)
                                                continue;
                                            cmsPathDg = Ext.isObject(_cmsPaths) ? _cmsPaths.dg : _cmsPaths;
                                            if (pathMatch(cmsPathDg, path)) {
                                                refresh = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (refresh)
                                        break;
                                }
                            }
                        } else if (path.indexOf("/config/shared/") >= 0) {
                            name = path.match(/[^\/]*\/.*\[\@name\=\'(.*?)\'/);
                            path = path.replace(/\[\@name=['][^']*[']\]/g, "");
                            path = "$" + path.replace(/\//g, ".");
                            var cmsPathShared = Ext.isObject(cmsPaths) ? cmsPaths.shared : cmsPaths;
                            if (pathMatch(cmsPathShared, path)) {
                                refresh = true;
                                break;
                            } else {
                                if (relatedPathes && Ext.isArray(relatedPathes)) {
                                    for (i = 0; i < relatedPathes.length; i++) {
                                        _item = relatedPathes[i];
                                        _cmsPaths = _item.cms;
                                        if (!_cmsPaths)
                                            continue;
                                        cmsPathShared = Ext.isObject(_cmsPaths) ? _cmsPaths.shared : _cmsPaths;
                                        if (pathMatch(cmsPathShared, path)) {
                                            refresh = true;
                                            break;
                                        }
                                    }
                                }
                                if (refresh)
                                    break;
                            }
                        } else if (path.indexOf("/config/panorama/") >= 0) {
                            name = path.match(/[^\/]*\/.*\[\@name\=\'(.*?)\'/);
                            path = path.replace(/\[\@name=['][^']*[']\]/g, "");
                            path = "$" + path.replace(/\//g, ".");
                            var cmsPathPanorama = Ext.isObject(cmsPaths) ? cmsPaths['cms-private'] : cmsPaths;
                            if (pathMatch(cmsPathPanorama, path)) {
                                refresh = true;
                                break;
                            } else {
                                if (relatedPathes && Ext.isArray(relatedPathes)) {
                                    for (i = 0; i < relatedPathes.length; i++) {
                                        _item = relatedPathes[i];
                                        _cmsPaths = _item.cms;
                                        if (!_cmsPaths)
                                            continue;
                                        cmsPathPanorama = Ext.isObject(_cmsPaths) ? _cmsPaths['cms-private'] : _cmsPaths;
                                        if (pathMatch(cmsPathPanorama, path)) {
                                            refresh = true;
                                            break;
                                        }
                                    }
                                }
                                if (refresh)
                                    break;
                            }
                        } else if (path.indexOf("/config/mgt-config/devices") >= 0) {
                            name = path.match(/[^\/]*\/.*\[\@name\=\'(.*?)\'/);
                            path = path.replace(/\[\@name=['][^']*[']\]/g, "");
                            path = "$" + path.replace(/\//g, ".");
                            var mgtDevicesPath = Ext.isString(readSchema.devices) ? readSchema.devices : "";
                            if (pathMatch(mgtDevicesPath, path)) {
                                refresh = true;
                                break;
                            } else {
                                if (relatedPathes && Ext.isArray(relatedPathes)) {
                                    for (i = 0; i < relatedPathes.length; i++) {
                                        _item = relatedPathes[i];
                                        var _dssPaths = _item.devices;
                                        if (!_dssPaths)
                                            continue;
                                        var dssPath = Ext.isString(_dssPaths) ? _dssPaths : "";
                                        if (pathMatch(dssPath, path)) {
                                            refresh = true;
                                            break;
                                        }
                                    }
                                }
                                if (refresh)
                                    break;
                            }
                        }
                    }
                }
                if (Ext.isArray(objectNames) && Ext.isArray(name)) {
                    objectNames.push(name[name.length - 1]);
                }
                return refresh;
            } catch (ex) {
            }
        };
        var readSchema = null;
        if (this.NotificationPathes) {
            readSchema = this.NotificationPathes;
        } else if (this.store && this.store.recordBinderOverride && this.store.recordBinderOverride.dataProxyAPI && this.store.recordBinderOverride.dataProxyAPI.api) {
            readSchema = this.store.recordBinderOverride.dataProxyAPI.api.readSchema;
        }
        var objectNames = [];
        if (handleNotificationForViewer(nts, readSchema, objectNames)) {
            if (this.store) {
                if (this.store.hasEvent("receivednotification")) {
                    this.store.fireEvent("receivednotification", this.store, objectNames);
                }
            }
            if (this instanceof Ext.grid.GridPanel) {
                this.store.reload();
            } else {
                this.onNTRefresh();
            }
        }
    },
    onNTRefresh: function () {
        var nHandler = new Pan.appframework.PanNotificationHandler();
        if (nHandler.refreshTask)
            nHandler.refreshTask.delay(500);
    },
    panViewerPostInit: function () {
        this.afterinitCompleted = true;
        this.fireEvent('afterinit', this);
    },
    fireAfterLoaded: function () {
        this.fireEvent('afterload', this);
    },
    storeSetup: function () {
        if (this.storeConfigOverride) {
            this.storeConfig = Ext.apply({}, this.storeConfigOverride, this.storeConfig);
        }
        this.store = this.createStore(this.applyStoreConfig({
            isLiveGrid: this.isLiveGrid,
            totalProperty: this.storeInputs.totalProperty || "@total-count",
            root: this.storeInputs.root || "entry",
            fields: this.fields,
            storeInputs: this.storeInputs,
            recordBinderOverride: this.recordBinderOverride,
            treePath: this.treePath,
            isWithinATemplate: (this.configStates && this.configStates.template === true) || Ext.isDefined(Pan.global.getTemplate()),
            getTemplate: this.configStates && this.configStates.template === true ? (Ext.isFunction(this.getTemplate) ? this.getTemplate.bind(this) : function () {
                return Pan.global.ContextVariables.get("template");
            }) : ""
        }));
        this.fields = this.store.fields;
        this.addListener({
            afterrender: {
                fn: function () {
                    if (Ext.isFunction(this.customInitialStoreLoader)) {
                        this.customInitialStoreLoader();
                    } else {
                        if (this.autoLoad !== false && this.store.autoLoad !== false) {
                            this.store.reload.defer(1, this.store);
                        }
                    }
                }, scope: this
            }
        });
    },
    getRecordFormTemplate: function (form) {
        if (form) {
            if (!form.items) {
                form.items = form.fields;
            }
            if (form.items) {
                for (var i = 0; i < form.items.length; i++) {
                    var item = form.items[i];
                    if (item.config) {
                        var itemConfig = item.config;
                        delete item.config;
                        Ext.apply(item, itemConfig);
                    }
                    if (item.dataIndex) {
                        Ext.applyIf(item, {itemId: item.dataIndex});
                        delete item.dataIndex;
                    }
                    if (item.action) {
                        form.actions = form.actions || [];
                        form.actions.push({field: item.itemId, action: item.action});
                    }
                }
                form.columnCount = form.columnCount || 1;
            }
        }
        return {
            rbaPath: this.rbaPath,
            configStates: this.configStates,
            recordForm: form,
            scope: form.scope,
            okIconCls: undefined,
            cancelIconCls: undefined,
            windowConfig: Ext.apply({title: form.recordFormTitle}, (form ? form.windowConfig : undefined))
        };
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanCompositeViewer = Ext.extend(Pan.base.container.Container, {
    layout: 'fit', autoRealignBottom: true, initComponent: function () {
        this.addListener('render', function () {
            Ext.get(this.getEl().dom.parentNode).addClass('x-no-padding');
        }, this);
        Pan.appframework.modelview.PanCompositeViewer.superclass.initComponent.apply(this, arguments);
        this.recreatePortal();
    }, recreatePortal: function (viewerConfigs) {
        var log = PanLogging.getLogger('appframework:modelview:PanCompositeViewer');
        if (this.portal) {
            this.remove(this.portal);
        }
        if (viewerConfigs) {
            this.viewerConfigs = viewerConfigs;
        }
        var portalColumnCls = 'x-portal-column';
        var portalConfig = {};
        if (Ext.isDefined(this.portalConfig)) {
            portalConfig = Ext.apply(portalConfig, this.portalConfig);
        }
        portalConfig = Ext.applyIf(portalConfig, {
            autoScroll: "y",
            border: false,
            dropConfig: {ddGroup: Pan.common.Constants.portalDDGroup},
            defaults: {cls: portalColumnCls},
            items: []
        });
        if (this.viewerConfigs) {
            var columnWidth = 1 / this.viewerConfigs.length;
            for (var c = 0; c < this.viewerConfigs.length; c++) {
                var viewerColumnConfig = this.viewerConfigs[c];
                var portalColumnConfig = {columnWidth: columnWidth, items: []};
                if (c === 0) {
                    portalColumnConfig.cls = portalColumnCls + ' x-first-column';
                    if (c === (this.viewerConfigs.length - 1)) {
                        portalColumnConfig.cls = portalColumnConfig.cls + ' x-last-column';
                    }
                }
                if (c === (this.viewerConfigs.length - 1) && c != 0) {
                    portalColumnConfig.cls = portalColumnCls + ' x-last-column';
                }
                for (var r = 0; r < viewerColumnConfig.length; r++) {
                    var viewerConfig = Ext.apply({
                        compositeViewer: true,
                        anchor: '100%',
                        isPortlet: true
                    }, viewerColumnConfig[r]);
                    if (viewerConfig.isPortlet) {
                        Ext.applyIf(viewerConfig, {draggable: {ddGroup: Pan.common.Constants.portalDDGroup}});
                    }
                    var viewer;
                    if (viewerConfig.treePath && !viewerConfig.render) {
                        if (Pan.mainui.ContentMgr.isRegistered(viewerConfig.treePath)) {
                            viewer = Pan.create(viewerConfig);
                        }
                        else {
                            log.warn("Unable to find " + viewerConfig.treePath);
                        }
                    }
                    else if (!viewerConfig.render) {
                        viewerConfig.cls = viewerConfig.cls || "";
                        viewerConfig.cls += ' x-portlet';
                        viewer = Ext.create(viewerConfig);
                    }
                    else {
                        viewer = viewerConfig;
                    }
                    if (viewer) {
                        portalColumnConfig.items.push(viewer);
                    }
                }
                portalConfig.items.push(portalColumnConfig);
            }
        }
        this.portal = new Ext.ux.Portal(portalConfig);
        this.add(this.portal);
        this.doLayout();
    }, setToLongestHeight: function (portalContainer) {
        var column = undefined;
        var longestHeight = 0;
        var i = 0, len = portalContainer.items.length;
        for (i = 0; i < len; i++) {
            column = portalContainer.get(i);
            if (column.rendered) {
                longestHeight = Math.max(longestHeight, column.getHeight());
            }
        }
        var heightChanged = false;
        for (i = 0; i < len; i++) {
            column = portalContainer.get(i);
            if (column.rendered) {
                var columnHeight = column.getHeight();
                var heightDifference = longestHeight - columnHeight;
                if (heightDifference > 0 && column.items.length > 0) {
                    var heightDelta = heightDifference / column.items.length;
                    for (var j = 0; j < column.items.length; j++) {
                        var child = column.items.get(j);
                        if (child) {
                            var el = Ext.fly(child.el.select(".x-panel.pan_widget .x-panel-bwrap").elements[0]);
                            if (!el) {
                                el = Ext.fly(child.el.select(".x-panel .x-panel-bwrap .x-panel-body").elements[0]);
                                if (!el) {
                                    el = child;
                                }
                            }
                            el.setHeight(el.getHeight() + heightDelta);
                            heightChanged = true;
                        }
                    }
                }
            }
        }
        if (heightChanged || portalContainer.longestHeight !== longestHeight) {
            portalContainer.longestHeight = longestHeight;
            this.fireEvent('heightChanged', this, longestHeight);
        }
    }, setToAutoHeight: function (portalContainer) {
        var column = undefined;
        for (var i = 0; i < portalContainer.items.length; i++) {
            column = portalContainer.get(i);
            if (column.rendered) {
                for (var j = 0; j < column.items.length; j++) {
                    var child = column.items.get(j);
                    if (child) {
                        var el = Ext.fly(child.el.select(".x-panel.pan_widget .x-panel-bwrap").elements[0]);
                        if (!el) {
                            el = Ext.fly(child.el.select(".x-panel .x-panel-bwrap .x-panel-body").elements[0]);
                            if (!el) {
                                el = child;
                            }
                        }
                        el.setHeight(undefined);
                    }
                }
            }
        }
    }, onLayout: function () {
        if (this.autoRealignBottom) {
            this.adjustPortHeight();
        }
        return Pan.appframework.modelview.PanCompositeViewer.superclass.onLayout.apply(this, arguments);
    }, adjustPortHeight: function () {
        if (!this.resizeTask) {
            this.resizeTask = new Ext.util.TaskRunner();
            this.resizeTask.start({
                run: function () {
                    if (this.isVisible()) {
                        this.setToAutoHeight(this.items.items[0].items);
                        this.setToLongestHeight(this.items.items[0].items);
                    }
                }, interval: 1000, repeat: 5, scope: this
            });
        }
    }, beforeDestroy: function () {
        if (this.resizeTask) {
            this.resizeTask.stopAll();
            this.resizeTask = null;
        }
        Pan.appframework.modelview.PanCompositeViewer.superclass.beforeDestroy.call(this);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanGridStore = Ext.extend(Pan.base.autorender.GridRecordStore, {
    autoDestroy: true, schema: undefined, doNotAutoGenerateFields: false, recordBinderOverrideConfig: {
        commandXPathTemplate: {
            getObjects: [{
                vsysName: '${vsysName}',
                template: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplate) ? argumentHash.getTemplate(argumentHash) : Pan.global.getTemplate();
                },
                isCmsSelected: '${isCmsSelected}',
                isMultiVsys: '${isMultiVsys}',
                id: '${__id}',
                xpathId: '${__xpathId}',
                getTestXML: false,
                argumentsAreJSON: true
            }],
            getObject: [{
                id: '${__id}',
                xpathId: '${${__recordInfo}.xpathId}',
                vsysName: '${vsysName}',
                template: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplate) ? argumentHash.getTemplate(argumentHash) : Pan.global.getTemplate();
                },
                argumentsAreJSON: true
            }],
            setObject: [{
                id: '${__id}',
                type: '${${__recordInfo}.type}',
                xpathId: function (c) {
                    if (c['__recordInfo'].xpathId) {
                        return c['__recordInfo'].xpathId;
                    }
                    else {
                        return c['vsysName'] ? "vsys" : "shared";
                    }
                },
                newId: '${__newId}',
                newXpathId: '${${__newRecordInfo}.xpathId}',
                vsysName: function (c) {
                    var vsysName = c.__newRecordInfo.vsysName;
                    if (!c.supportEmptyVsys || vsysName !== "") {
                        vsysName = vsysName || c.vsysName;
                    }
                    return vsysName;
                },
                template: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplate) ? argumentHash.getTemplate(argumentHash) : Pan.global.getTemplate();
                },
                templateStack: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplateStack) ? argumentHash.getTemplateStack(argumentHash) : Pan.global.getTemplateStack();
                },
                data: '${__data}',
                oldData: '${__oldData}',
                subpath: '${subpath}',
                pathWrap: '${pathWrap}',
                fieldPath: '${fieldPath}',
                fieldPaths: '${fieldPaths}',
                supportEmptyVsys: '${supportEmptyVsys}',
                disableValidation: '${disableValidation}',
                argumentsAreJSON: true
            }],
            completeObject: [{
                id: '${__id}',
                xpathId: '${ "${${__recordInfo}.xpathId}" || ("${vsysName}" ? "vsys" : "shared") }',
                vsysName: '${vsysName}',
                template: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplate) ? argumentHash.getTemplate(argumentHash) : Pan.global.getTemplate();
                },
                templateStack: function (argumentHash) {
                    return argumentHash && argumentHash.isWithinATemplate && Ext.isFunction(argumentHash.getTemplateStack) ? argumentHash.getTemplateStack(argumentHash) : Pan.global.getTemplateStack();
                },
                path: '${path}',
                argumentsAreJSON: true
            }],
            readSchema: [{argumentsAreJSON: true}]
        },
        readCommandParts: ["getObjects", "isCmsSelected", "isMultiVsys", "id", "xpathId", "getTestXML", "vsysName", "template"],
        updateCommandParts: ["setObject", "id", "type", "data", "oldData", "xpathId", "vsysName", "subpath", "pathWrap", "fieldPath", "fieldPaths", "newId", "template", "templateStack", "disableValidation"],
        createCommandParts: ["setObject", "id", "type", "data", "xpathId", "pathWrap", "fieldPaths", "vsysName", "template", "templateStack"],
        destroyCommandParts: ["setObject", "id", "xpathId", "vsysName", "pathWrap", "template", "templateStack"],
        cloneCommandParts: ["setObject", "id", "xpathId", "newXpathId", "vsysName", "template", "templateStack", "newId", "data"],
        templateOverrideCommandParts: ["setObject", "id", "xpathId", "isMultiVsys", "vsysName", "template", "templateStack", "pathWrap", "data", "oldData"],
        dgOverrideCommandParts: ["setObject", "id", "xpathId", "vsysName", "pathWrap", "data"],
        completeCommandParts: ["completeObject", "id", "xpathId", "vsysName", "template", "templateStack", "path"],
        readSchemaCommandParts: ["readSchema"]
    }, constructor: function (config) {
        config.storeInputs = config.storeInputs || {};
        config.storeInputs.nameIdProperty = config.storeInputs.nameIdProperty || 'name';
        var storeConfig = {
            idProperty: "@__recordInfo.id",
            storeInputs: Ext.apply({
                objectType: undefined,
                vsysName: '${Pan.global.getLoc().val}',
                xsltFile: undefined,
                isCmsSelected: '${Pan.global.isCmsSelected()}',
                isMultiVsys: '${Pan.global.isMultiVsys()}',
                subpath: undefined,
                pathWrap: undefined,
                fieldPath: undefined,
                fieldPaths: undefined,
                supportEmptyVsys: false,
                resultObjectType: undefined,
                __id: undefined,
                __xpathId: undefined
            }, config.storeInputs)
        };
        delete config.storeInputs;
        config.fields = config.fields || [];
        config.fields = this.populateFields(config.fields, config.treePath, config);
        Pan.appframework.modelview.PanGridStore.superclass.constructor.call(this, Ext.apply(storeConfig, config));
        this.fieldsByPath = new Ext.util.MixedCollection(false, function (field) {
            return field.attrPath;
        });
        this.fields.each(function (field) {
            this.fieldsByPath.add(field);
        }, this);
        this.on("beforewrite", this.beforeWrite);
    }, createRecordBinder: function (config) {
        return new Pan.appframework.modelview.PanGridRecordBinder(Ext.apply({store: this}, config));
    }, getEditRecordJSON: function (originalRecord, config) {
        var originalRecordJson = originalRecord.json;
        if (!(config && config.readOnly) && this.templateRecord) {
            if (this.nonMergedRecord) {
                originalRecordJson = this.nonMergedRecord.json;
            }
            else {
                originalRecordJson = undefined;
            }
        }
        else if (this.nonMergedRecords && this.nonMergedRecords[originalRecord.id]) {
            originalRecordJson = this.nonMergedRecords[originalRecord.id].json;
        }
        else if (Pan.global.isCmsSelected() && this.templateRecords && this.templateRecords[originalRecord.id]) {
            originalRecordJson = {'@__recordInfo': {}};
            originalRecordJson[Pan.common.Constants.attrPtpl] = originalRecord.json[Pan.common.Constants.attrPtpl];
        }
        return originalRecordJson;
    }, willAlwaysWriteRecord: function (r, config) {
        if (Pan.global.isCmsSelected() && config && config.additionalInput && config.additionalInput.templateOverride) {
            return true;
        }
        else {
            return Pan.appframework.modelview.PanGridStore.superclass.willAlwaysWriteRecord.apply(this, arguments);
        }
    }, willAlwaysWriteField: function (r, _field) {
        if (Pan.global.isCmsSelected() && !r.phantom && this.templateRecords && this.templateRecords[r.id] && this.storeInputs && this.storeInputs.alwaysWriteRecord !== true && _field.alwaysWriteField !== true) {
            return false;
        }
        else {
            return Pan.appframework.modelview.PanGridStore.superclass.willAlwaysWriteField.apply(this, arguments);
        }
    }, doPermanentFilter: function (_o) {
        delete this.templateRecord;
        delete this.nonMergedRecord;
        delete this.mergedRecord;
        delete this.templateRecords;
        delete this.nonMergedRecords;
        delete this.mergedRecords;
        var rv = Pan.appframework.modelview.PanGridStore.superclass.doPermanentFilter.apply(this, arguments);
        if (this.nonPairedRecordMap && this.templateRecords) {
            for (var m in this.nonPairedRecordMap) {
                if (this.nonPairedRecordMap.hasOwnProperty(m)) {
                    var r = this.nonPairedRecordMap[m];
                    if (this.templateRecords[r.id]) {
                        var copy = this.cloneRecord(r);
                        delete copy.json['@__recordInfo'].template;
                        delete copy.data['$']['@__recordInfo'].template;
                        copy.json['@__recordInfo'].permission = copy.data['$']['@__recordInfo'].permission = "readwrite";
                        copy.json[Pan.common.Constants.attrSrc] = copy.data['$'][Pan.common.Constants.attrSrc] = Pan.common.Constants.srcTemplate;
                        rv.records.push(copy);
                        rv.totalRecords++;
                    }
                }
            }
            delete this.nonPairedRecordMap;
        }
        return rv;
    }, internalPermanentFilterFn: function (r, recordIndex, totalRecordCount) {
        if (this.storeInputs && this.storeInputs.supportTemplateFieldLevelFetch && totalRecordCount > 1) {
            if (!this.templateRecord) {
                this.templateRecord = r;
                return false;
            }
            else if (!this.nonMergedRecord) {
                this.nonMergedRecord = r;
                return false;
            }
            else {
                this.mergedRecord = r;
                return true;
            }
        }
        else if (Pan.global.isCmsSelected()) {
            if (r.json && r.json['@__recordInfo']) {
                if (r.json['@__recordInfo'].template) {
                    if (!this.templateRecords) {
                        this.templateRecords = {};
                    }
                    this.templateRecords[r.id] = r;
                    return false;
                }
                else if (r.json['@__recordInfo'].nonMerged) {
                    if (!this.nonMergedRecords) {
                        this.nonMergedRecords = {};
                    }
                    this.nonMergedRecords[r.id] = r;
                    return false;
                }
                else {
                    if (!this.mergedRecords) {
                        this.mergedRecords = {};
                    }
                    this.mergedRecords[r.id] = r;
                    return true;
                }
            }
            return true;
        }
        else {
            if (!this.nonPairedRecordMap) {
                this.nonPairedRecordMap = {};
            }
            if (this.nonPairedRecordMap[r.id]) {
                delete this.nonPairedRecordMap[r.id];
            }
            else {
                this.nonPairedRecordMap[r.id] = r;
            }
            if (r.json && r.json['@__recordInfo'] && r.json['@__recordInfo'].template) {
                if (!this.templateRecords) {
                    this.templateRecords = {};
                }
                this.templateRecords[r.id] = r;
                return false;
            }
            return true;
        }
    }, populateFields: function (fields, treePath, config) {
        var log = PanLogging.getLogger('appframework:modelview:PanGridStore');
        if (treePath && treePath.indexOf("Dashboard") !== 0) {
            var isTemplate = undefined;
            if (Pan.global.isCmsSelected()) {
                if (config && config.globalFindPreview === true) {
                    isTemplate = treePath.startsWith("Network/") || treePath.startsWith("Device/");
                }
                else if (config && config.isWithinATemplate === true) {
                    isTemplate = true;
                }
            }
            if (!this.schema) {
                this.schema = Pan.appframework.schema.PanSchemaRepository.get(treePath, isTemplate);
            }
            if (!this.schema) {
                this.schema = Pan.appframework.schema.PanSchemaRepository.readSchema(treePath, undefined, undefined, undefined, isTemplate);
            }
            if (this.schema) {
                Pan._currentschema = this.schema.schema;
                fields = this.schema.populateFields(fields, config && config.doNotAutoGenerateFields);
            }
            if (!this.schema || !this.schema.schema) {
                log.info("In PanGridStore: Missing schema for " + treePath);
            }
        }
        return fields;
    }, beforeWrite: function (store, action, rs, options) {
        var additionalInput;
        if (Ext.isArray(rs)) {
            additionalInput = rs[0].toBeCommitted && rs[0].toBeCommitted.additionalInput;
            action = (rs[0].toBeCommitted && rs[0].toBeCommitted.action) || action;
        }
        else {
            additionalInput = rs.toBeCommitted && rs.toBeCommitted.additionalInput;
            action = rs.toBeCommitted ? (rs.toBeCommitted.action || action) : action;
        }
        var rv = this.recordBinder.getRemoteCommand(action, rs, additionalInput);
        if (rv) {
            options.params.jsonData = {'arguments': ["execute", rv.commands], action: rv.action};
            if (this.baseParams) {
                Ext.apply(options.params.jsonData['arguments'][1][0], this.baseParams);
            }
            return true;
        }
        else {
            Pan.appframework.errorhandling.PanStatusReporter.setStatus({
                error: {
                    title: _T("Error"),
                    message: _T("Unable to collect data for server call.")
                }
            });
            this.rejectChanges();
            return false;
        }
    }, load: function (options) {
        var rv = Ext.apply({}, options);
        if (this.localPagingParams && this.localPagingParams.fastFirstPage) {
            rv.params = rv.params || {};
            this.fastFirstPageLoad = !this.fastFirstPageLoad;
            Ext.apply(rv.params, {fastFirstPage: this.fastFirstPageLoad});
            if (this.fastFirstPageLoad) {
                this.addListener('afterload', function () {
                    if (this.totalLength > this.getTotalCount(true)) {
                        this.reload();
                    }
                    else {
                        delete this.fastFirstPageLoad;
                    }
                }, this, {single: true});
            }
        }
        rv = this.getLoadOptions(rv);
        Pan.appframework.modelview.PanGridStore.superclass.load.call(this, rv);
    }, getLoadOptions: function (options) {
        var paramsOptions = Ext.apply({}, this.baseParams);
        if (options && options.params) {
            Ext.apply(paramsOptions, options.params);
            delete paramsOptions['arguments'];
        }
        if (this.remoteSort && Ext.isObject(this.sortInfo)) {
            Ext.apply(paramsOptions, this.sortInfo);
        }
        var rv = this.recordBinder.getRemoteCommand("read", undefined, this.additionalInput);
        if (rv) {
            Ext.apply(rv.commands[0], paramsOptions);
            return Ext.applyIf({
                scope: (options && options.scope) || this,
                params: Ext.applyIf({'arguments': ["execute", rv.commands]}, paramsOptions),
                processedCommands: rv.processedCommands,
                storeInputs: this.storeInputs
            }, options);
        }
        else {
            Pan.appframework.errorhandling.PanStatusReporter.setStatus({
                error: {
                    title: _T("Error"),
                    message: "Unable to fetch data."
                }
            });
            return options;
        }
    }, reportStatus: function (notSuccess) {
        notSuccess = notSuccess.error ? notSuccess : (notSuccess instanceof Array ? notSuccess[0] : notSuccess);
        var msg = Pan.base.json.paths(notSuccess, "$.msg.line.line").join('') || Pan.base.json.paths(notSuccess, "$.msg.line").join('') || Pan.base.json.paths(notSuccess, "$.msg.*").join('') || Pan.base.json.paths(notSuccess, "$.msg").join('');
        if (msg) {
            msg = Pan.base.htmlEncode(msg);
        }
        Pan.appframework.errorhandling.PanStatusReporter.setStatus(notSuccess.error ? notSuccess : {
            error: {
                title: _T("Operation Failed"),
                message: msg ? msg.replace(/\n/g, "<br/>") : ""
            }
        });
    }, postWrite: function (success) {
        Pan.global.ContextVariables.retrieveConfigChangePending();
        if (this.postWriteCallback) {
            this.postWriteCallback(success);
        }
    }, isDefaultValue: function (path, value) {
        if (!Ext.isDefined(this.fieldsByPath))
            return false;
        var defValue = this.fieldsByPath.map[path].defaultValue;
        return value === defValue;
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanGridViewer = Ext.extend(Pan.base.grid.GridPanel, {
    showEllipsisEntryCount: 7,
    disableFocusRowOnRowSelectWhenRowHeightExceedsTableHeight: true,
    clicksToEdit: 1,
    enableCellEditing: false,
    useCheckBoxSelection: true,
    useToolbar: true,
    useToolbarAddAction: true,
    useToolbarDeleteAction: true,
    useToolbarCloneAction: true,
    useMultiCloneAction: false,
    useRowActions: false,
    bbStringOne: false,
    bbStringTwo: false,
    spanCellMapping: '@name',
    height: 300,
    hasGridFilter: true,
    theme: Pan.base.Constants.uiThemes[0],
    supportLocalPaging: true,
    alwaysShowCheckBox: false,
    highlightRowAfterInsert: true,
    columnTypeMapping: {"bool": "panbooleancolumn", 'date': 'datecolumn', "int": 'gridcolumn', "float": "numbercolumn"},
    defaultActionsCfg: undefined,
    extraActions: undefined,
    constructor: function (config) {
        Ext.applyIf(this, Pan.appframework.modelview.PanViewer.prototype);
        config = config || {};
        Ext.applyIf(config, {loadMask: {msg: _T('Loading...')}});
        Pan.appframework.modelview.PanGridViewer.superclass.constructor.call(this, config);
        if (this.gfFilter && this.setFilterFieldValue) {
            this.setFilterFieldValue(this.gfFilter);
        }
    },
    initComponent: function () {
        if (this.showLoadingIndication) {
            this.initLoadingIndication();
        }
        this.panViewerInit();
        Pan.appframework.modelview.PanGridViewer.superclass.initComponent.apply(this, arguments);
    },
    onDestroy: function () {
        Pan.appframework.modelview.PanGridViewer.superclass.onDestroy.apply(this, arguments);
        this.panViewerOnDestroy();
    },
    initEvents: function () {
        Pan.appframework.modelview.PanGridViewer.superclass.initEvents.apply(this, arguments);
        this.panViewerPostInit();
    },
    setupView: function () {
        this.localPagingParams.hideRefresh = true;
        if (this.useToolbar) {
            this.setupToolBar();
            this.setupToolBarStatus();
        }
        this.viewConfig = this.viewConfig || {};
        this.cls = this.cls || "";
        this.cls = 'x-pan-grid-viewer' + " " + this.cls;
        this.viewConfig.nearLimit = this.viewConfig.nearLimit || Pan.base.Constants.liveGridNearLimit;
        this.viewConfig.emptyText = this.viewConfig.emptyText || ' ';
        this.viewConfig.loadMask = this.initialConfig.loadMask;
        if (!Ext.isFunction(this.viewConfig.getRowClass)) {
            this.viewConfig.getRowClass = this.getRowClass.createDelegate(this);
        }
        if (this.useRowActions) {
            this.rowActions = this.rowActions || [];
            this.rowActions.push({
                iconCls: 'icon-edit',
                tooltip: _T('Edit') + ' {name}',
                handler: function (grid, config) {
                    grid.editForm(config.record, grid.recordFormOverride, config.row, config.col);
                },
                scope: this
            }, {
                iconCls: 'icon-clone', tooltip: _T('Clone') + ' {name}', handler: function (grid, config) {
                    grid.cloneRecord(config.record, config.row, config.col);
                }, scope: this
            }, {
                atype: 'deleteRecordAction', tooltip: _T('Delete') + ' {name}', handler: function (grid, config) {
                    grid.deleteRecord(config.record, config.row, config.col);
                }, scope: this
            });
        }
        var fields = this.store.fields;
        for (var i = 0; i < this.columns.length; i++) {
            var column = this.columns[i];
            if (column.dataIndex) {
                var field = fields.get(column.dataIndex);
                if (field) {
                    if (!column.xtype && !column.renderer) {
                        var xtype = this.columnTypeMapping[field.type.type];
                        if (xtype) {
                            column.xtype = xtype;
                        }
                    }
                    if (!column.tooltip && field['help-string']) {
                        column.tooltip = field['help-string'];
                    }
                    if (!column.header && field.uiHint && field.uiHint.fieldLabel) {
                        column.header = field.uiHint.fieldLabel;
                    }
                }
            }
        }
        Ext.apply(this, {itemId: this.treePath});
        Pan.appframework.modelview.PanGridViewer.superclass.setupView.apply(this, arguments);
    },
    setupSelectionModel: function () {
        if (this.useCheckBoxSelection && !this.isLiveGrid) {
            Ext.applyIf(this, {checkBoxSelectionModelConfig: {useHeaderChecker: true}});
        }
        Pan.appframework.modelview.PanGridViewer.superclass.setupSelectionModel.apply(this, arguments);
    },
    getRowClass: function (record, _rowIndex, _rp, _ds) {
        var rowCls = '';
        if ((!Pan.global.isCmsSelected() && record.json && record.json['@__recordInfo'] && record.json['@__recordInfo'].xpathId === 'panorama') || Pan.appframework.renderer.isParentDGRec(record)) {
            rowCls = 'x-pan-panorama-row';
        }
        return rowCls;
    },
    setupStore: function () {
        this.storeSetup();
        Pan.appframework.modelview.PanGridViewer.superclass.setupStore.apply(this, arguments);
        this.store.addListener({
            load: {fn: this.afterLoad, scope: this}, add: {
                fn: function (ds, records, _index) {
                    if (this.rendered && this.highlightRowAfterInsert) {
                        this.getSelectionModel().selectRecords(records);
                        this.view.addListener('rowsinserted', function () {
                            this.scrollToSelection();
                        }, this, {single: true});
                    }
                }, scope: this
            }
        });
    },
    afterLoad: function () {
        this.fireAfterLoaded();
        if (this.bottomToolbar) {
            if (this.bottomToolbar.rendered) {
                Pan.base.util.invokeLater(1, function () {
                    var hasVisibleItem = false;
                    this.bottomToolbar.items.each(function (c) {
                        if (c.isVisible()) {
                            hasVisibleItem = true;
                            return false;
                        }
                    });
                    if (this.store && !this.store.isDestroyed && hasVisibleItem != this.bottomToolbar.isVisible()) {
                        this.bottomToolbar.setVisible(hasVisibleItem);
                        this.ownerCt.doLayout();
                        this.ownerCt.syncFloatingShadow();
                        if (!hasVisibleItem && this.useCheckBoxSelection && !this.alwaysShowCheckBox) {
                            this.colModel.setHidden(0, true);
                        }
                    }
                }, this);
            }
        }
        else {
            if (this.useCheckBoxSelection && !this.alwaysShowCheckBox) {
                this.colModel.setHidden(0, true);
            }
        }
    },
    createToolbar: function (_tb, _options) {
        var rv = Pan.appframework.modelview.PanGridViewer.superclass.createToolbar.apply(this, arguments);
        rv.height = 28;
        return rv;
    },
    setupToolBar: function () {
        this.bbar = Pan.appframework.action.ActionMgr.setupToolbar(this, this.defaultActionsCfg, this.extraActions);
    },
    setupToolBarStatus: function () {
        this.bbarStrings = this.bbarStrings || [];
        if (this.bbStringOne) {
            this.bbarStrings.push({xtype: 'tbspacer', width: 30});
            this.bbarStrings.push({
                xtype: 'pan-store-status-field',
                cls: this.bbStringOne.cls || 'x-form-helptext',
                store: this.store,
                warning: this.bbStringOne.fn
            });
        }
        if (this.bbStringTwo) {
            this.bbarStrings.push({xtype: 'tbspacer', width: 30});
            this.bbarStrings.push({
                xtype: 'pan-displayfield',
                cls: this.bbStringTwo.cls || 'x-form-helptext',
                value: this.bbStringTwo.msg
            });
        }
    },
    createStore: function (config) {
        var store = new Pan.appframework.modelview.PanGridStore(config);
        store.storeInputs.resultObjectType = store.storeInputs.resultObjectType ? store.storeInputs.resultObjectType : store.storeInputs.objectType;
        return store;
    },
    applyStoreConfig: function (config) {
        config = Ext.apply(config, this.storeConfig, {
            supportLocalPaging: this.supportLocalPaging,
            localPagingParams: this.localPagingParams
        });
        if (this.commonFields) {
            config.fields = config.fields || [];
            config.fields = config.fields.slice(0);
            for (var i = 0; i < this.commonFields.length; i++) {
                var bFound = false;
                for (var j = 0; !bFound && j < config.fields.length; j++) {
                    bFound = (config.fields[j].name == this.commonFields[i].name);
                }
                if (!bFound)
                    config.fields.push(Pan.base.clone(this.commonFields[i]));
            }
        }
        if (config.recordBinderOverride && config.recordBinderOverride.commandXPathTemplate) {
            Ext.applyIf(config.recordBinderOverride.commandXPathTemplate, Pan.appframework.modelview.PanGridStore.prototype.recordBinderOverrideConfig.commandXPathTemplate);
        }
        return config;
    },
    addRecord: function (element, config, _event) {
        var rec = this.store.beginAdd();
        var recordForm = this.recordForm;
        var recordFormOverride = (config && config.recordFormOverride) || this.recordFormOverride;
        if (recordFormOverride) {
            recordForm = Ext.apply({}, recordFormOverride, recordForm);
        }
        this.showRecordForm(recordForm, {}, rec, element);
    },
    editForm: function (record, recordFormOverride, row, col) {
        var cell = (row && col) ? this.getView().getCell(row, col) : undefined;
        var recordForm = this.recordForm;
        recordFormOverride = recordFormOverride || this.recordFormOverride;
        if (recordFormOverride) {
            recordForm = Ext.apply({}, recordFormOverride, recordForm);
        }
        this.showRecordForm(recordForm, {}, record, cell);
    },
    deleteRecord: function (record, row, col) {
        var cell = (row && col) ? this.getView().getCell(row, col) : undefined;
        Pan.Msg.setDefaultButton(2);
        Pan.Msg.show({
            title: this.storeInputs.objectType,
            msg: _T('Do you really want to delete <b> {name} </b>?', {name: record.get(this.storeInputs.nameIdProperty)}),
            icon: Ext.Msg.QUESTION,
            buttons: Ext.Msg.YESNO,
            scope: this,
            fn: function (response) {
                if (response !== 'yes') {
                }
                else {
                    record.store.storeInputs.vsysName = record.json["@__recordInfo"].vsysName;
                    record.store.remove(record);
                }
            }
        }, cell);
    },
    cloneRecord: function (element, _config, _event) {
        var record = element.selModel.getSelected();
        var rec = this.store.beginAdd(record);
        record.store.storeInputs.vsysName = record.json["@__recordInfo"].vsysName;
        this.showRecordForm(this.cloneForm, {iconCls: 'icon-clone', action: 'clone'}, rec, element);
    },
    showRecordForm: function (form, config, record, element) {
        if (this.gridRecordForm) {
            this.gridRecordForm.onDestroy();
        }
        var template = this.getRecordFormTemplate(Ext.applyIf({
            scope: form.scope || this,
            recordFormTitle: this.recordFormTitle || (this.storeInputs && this.storeInputs.objectType)
        }, form));
        Ext.apply(template.windowConfig, {itemId: this.itemId + "-window"});
        var recordFormConfig = Ext.apply(template, config, {
            store: this.store,
            recordBinder: this.store.recordBinder,
            treePath: this.treePath,
            isInWindow: true,
            record: record,
            animateTarget: element,
            showButtons: typeof(form.showButtons) === 'undefined' ? true : form.showButtons
        });
        if (this.useNameInTitle && record.json && record.json["@name"]) {
            recordFormConfig.windowConfig.title += ' - ' + record.json["@name"];
        }
        this.gridRecordForm = Pan.base.autorender.GridRecordForm.showRecordForm(recordFormConfig, this);
    },
    setupColumn: function (col, index) {
        Ext.apply(col, {editor: {xtype: 'pan-morecomboeditor', grid: this, doHTMLEncode: col.doHTMLEncode}});
        Pan.appframework.modelview.PanGridViewer.superclass.setupColumn.call(this, col, index, true);
    },
    handleEllipsisClick: function (grid, config, _evt) {
        this.startEditing(config.row, config.col);
    },
    convertStringArray2Object: function (stringArray, value) {
        var o;
        if (stringArray) {
            o = {};
            for (var i = 0; i < stringArray.length; i++) {
                o[stringArray[i]] = value;
            }
        }
        return o;
    }
});
Pan.appframework.modelview.PanHLGridViewer = Ext.extend(Pan.appframework.modelview.PanGridViewer, {
    detailViewerTreePath: undefined, initComponent: function () {
        this.addEvents('afterupdaterecord');
        Pan.appframework.modelview.PanHLGridViewer.superclass.initComponent.apply(this, arguments);
    }, addRecord: function (element, config, event) {
        var detailViewerTreePath = Pan.base.json.path(config, "$.action.initialConfig.detailViewerTreePath") || this.detailViewerTreePath;
        var recStruct = {isAddRecord: true, treePath: detailViewerTreePath};
        if (config && config.recordFormOverride) {
            Ext.apply(recStruct, {recordFormOverride: config.recordFormOverride});
        }
        this.showDetailViewer(recStruct);
    }, editForm: function (record, recordFormOverride, row, col) {
        var recStruct = this.setupRecStruct(record);
        if (recordFormOverride) {
            Ext.applyIf(recStruct, {recordFormOverride: recordFormOverride});
        }
        this.showDetailViewer(recStruct, record);
    }, setupRecStruct: function (record) {
        var recStruct = {};
        if (record && record.store) {
            var nameProperty = record.store.storeInputs.nameIdProperty;
            Ext.apply(recStruct, {name: record.get(nameProperty), treePath: this.detailViewerTreePath});
        }
        return recStruct;
    }, showDetailViewer: function (recStruct, hlRecord) {
        if (recStruct.treePath) {
            var name = recStruct.name;
            var storeConfigOverride = {__hlRecord: hlRecord, additionalInput: {__id: name}};
            if (recStruct.phantom) {
                Ext.apply(storeConfigOverride, {autoLoad: false, allowMultipleRecords: true}, recStruct);
            } else if (recStruct.isAddRecord) {
                Ext.apply(storeConfigOverride, {autoLoad: false}, recStruct);
            }
            var actionConfig = {
                afterUpdateRecord: this.afterUpdateRecord.createDelegate(this),
                storeConfigOverride: storeConfigOverride,
                treePath: recStruct.treePath,
                hlViewer: this
            };
            if (recStruct.recordFormOverride) {
                actionConfig.recordFormOverride = recStruct.recordFormOverride;
            }
            var action = new Pan.appframework.action.PanViewerWindowAction(actionConfig);
            action.execute();
        }
    }, afterUpdateRecord: function (r) {
        if (r) {
            this.fireEvent('afterUpdateRecord', this.store, [r]);
        }
        this.store.reload();
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.getTargetVsys = function (rec) {
    if (rec["@__recordInfo"].xpathId === 'shared') {
        return undefined;
    }
    return rec["@__recordInfo"].xpathId === 'cms-private' ? 'panorama' : rec["@__recordInfo"].vsysName;
};
Pan.appframework.modelview.PanGridRecordBinder = Ext.extend(Pan.base.autorender.GridRecordBinder, {
    constructor: function () {
        Ext.apply(this, {
            dataProxyAPI: {
                directFn: undefined,
                api: {
                    read: 'get',
                    create: 'add',
                    update: 'set',
                    destroy: 'delete',
                    clone: 'klone',
                    move: 'move',
                    multiMove: 'multiMove',
                    multiClone: 'multiClone',
                    templateOverride: 'templateOverride',
                    dgOverride: 'dgOverride',
                    complete: 'complete'
                }
            }
        });
        Pan.appframework.modelview.PanGridRecordBinder.superclass.constructor.apply(this, arguments);
    }, isDefined: function (v) {
        return Ext.isDefined(v) && v !== "";
    }, makeFieldsValid: function (v, node, changedFieldPaths, alwaysPruneEmptyArray) {
        var visitOnlyExistingChildren = false;
        var visitChildren = false;
        var visitArray = false;
        var hasProperty, m;
        var attr = node['@attr'];
        if (attr['node-type'] === 'sequence') {
            if (Ext.isArray(v) && v.length == 0) {
                v = {};
            }
        }
        if (attr['node-type'] === 'attr-req') {
        }
        else if (!attr.allowBlank) {
            if (attr['node-type'] === 'array') {
                if (!Ext.isArray(v)) {
                    v = [];
                }
                else {
                    if (alwaysPruneEmptyArray && v.length == 0) {
                        v = undefined;
                    } else {
                        visitArray = true;
                    }
                }
            }
            else if (attr.childrenNames) {
                if (Ext.isObject(v)) {
                    visitChildren = true;
                    if (attr['node-type'] === 'union') {
                        visitOnlyExistingChildren = true;
                    }
                }
                else {
                }
            }
            else {
                if (!this.isDefined(v)) {
                    if (this.isDefined(attr['default'])) {
                        v = attr['default'];
                    }
                }
                if (v === "") {
                    v = undefined;
                }
            }
        }
        else {
            if (attr['node-type'] === 'array') {
                if (Ext.isArray(v) && v.length > 0) {
                    visitArray = true;
                }
                else {
                    v = undefined;
                }
            }
            else if (attr.type === 'dynamic') {
            }
            else if (attr.childrenNames) {
                if (Ext.isObject(v)) {
                    hasProperty = false;
                    for (m in v) {
                        if (v.hasOwnProperty(m)) {
                            hasProperty = true;
                            break;
                        }
                    }
                    if (!hasProperty && (!changedFieldPaths || !changedFieldPaths.get(attr['attrPath']))) {
                        v = undefined;
                    }
                    else {
                        visitChildren = true;
                        if (attr['node-type'] === 'union') {
                            visitOnlyExistingChildren = true;
                        }
                    }
                }
            }
            else {
                if (this.isDefined(v)) {
                }
                else {
                    v = undefined;
                }
            }
        }
        var i;
        if (visitChildren) {
            if (visitOnlyExistingChildren) {
                for (var childName in v) {
                    if (v.hasOwnProperty(childName)) {
                        this.makeChildFieldValid(v, node, childName, changedFieldPaths, alwaysPruneEmptyArray);
                    }
                }
            }
            else {
                for (i = 0; i < attr.childrenNames.length; i++) {
                    this.makeChildFieldValid(v, node, attr.childrenNames[i], changedFieldPaths, alwaysPruneEmptyArray);
                }
            }
        }
        else if (visitArray) {
            for (i = 0; i < v.length; i++) {
                this.makeFieldsValid(v[i], node['*']);
            }
        }
        if ((alwaysPruneEmptyArray || attr.allowBlank) && (!changedFieldPaths || !changedFieldPaths.get(node['@attr']['attrPath']))) {
            if (Ext.isObject(v) && attr.childrenNames) {
                hasProperty = false;
                for (m in v) {
                    if (v.hasOwnProperty(m) && this.isDefined(v[m])) {
                        hasProperty = true;
                        break;
                    }
                }
                if (!hasProperty) {
                    v = undefined;
                }
            }
        }
        return v;
    }, makeChildFieldValid: function (v, node, childName, changedFieldPaths, alwaysPruneEmptyArray) {
        if (childName === 'choice') {
            var childrenNames = node['choice']['@attr'].childrenNames;
            for (var i = 0; i < childrenNames.length; i++) {
                var child = v[childrenNames[i]];
                var rv = this.makeFieldsValid(child, node[childrenNames[i]], changedFieldPaths, alwaysPruneEmptyArray);
                if (Ext.isObject(rv) && Pan.base.isEmpty(rv) && Ext.isArray(child) && child.length == 0) {
                    v[childrenNames[i]] = rv;
                }
            }
        }
        else {
            var parentNodeType = node['@attr']["node-type"];
            node = node[childName];
            if (node) {
                var childData = v[childName];
                var cv = this.makeFieldsValid(childData, node, changedFieldPaths, alwaysPruneEmptyArray);
                if (childData !== cv) {
                    if (cv === undefined) {
                        if (parentNodeType !== "union") {
                            delete v[childName];
                        }
                    }
                    else {
                        v[childName] = cv;
                    }
                }
            }
        }
    }, writeRecord: function (record, originalNameId, options) {
        if (record.get('location') === 'shared') {
            delete record.json["disable-override"];
        }
        var xml;
        if (!options || !options.skipMakeFieldsValid) {
            this.makeFieldsValid(record.json, record.fields.get('$').rootSchemaNode, record.store.additionalInput && record.store.additionalInput.fieldPaths, record.store.isWithinATemplate);
        }
        if (record.store.allowMultipleRecords !== true && record.id === Pan.common.Constants.singletonId) {
            var root = record.fields.get('$');
            if (root && root.rootJSONName) {
                var json = {};
                json[root.rootJSONName] = record.json;
                xml = json2xml(json, null);
            }
            else {
                xml = json2xml(record.json, null);
            }
        }
        else if ((record.store && record.store.writeRecordWrap) || record.phantom || record.subpathJson) {
            xml = Pan.appframework.modelview.PanGridRecordBinder.superclass.writeRecord.call(this, record, originalNameId);
        }
        else {
            var nameIdProperty = this.store.storeInputs.nameIdProperty;
            var nameIdValue = originalNameId || record.get(this.store.storeInputs.nameIdProperty);
            var entry = Ext.applyIf({}, record.json);
            if (nameIdValue) {
                entry[this.nameIdField && this.nameIdField.attrName || nameIdProperty] = nameIdValue;
            }
            xml = json2xml({entry: entry}, null);
        }
        return xml;
    }, getIdFromPartsStatic: function (name, xpathId, vsysName) {
        if (xpathId === 'vsys' && vsysName) {
            name += "---" + vsysName;
        }
        else if (xpathId) {
            name += "---" + xpathId;
            if (xpathId === 'panorama' && vsysName) {
                name += "---" + vsysName;
            }
        }
        return name;
    }, getIdFromRecordStatic: function (record, name) {
        name = Ext.isDefined(name) ? name : record['@name'];
        var recordInfo = record['@__recordInfo'];
        if (Ext.isString(recordInfo)) {
            recordInfo = recordInfo ? Ext.util.JSON.decode(recordInfo) : {};
        }
        return Pan.appframework.modelview.PanGridRecordBinder.prototype.getIdFromPartsStatic(name, recordInfo.xpathId, recordInfo.vsysName);
    }, getId: function (record) {
        var name = this.getNameId(record);
        if (name) {
            name = Pan.appframework.modelview.PanGridRecordBinder.prototype.getIdFromRecordStatic(record, name);
        }
        else {
            name = Pan.common.Constants.singletonId;
        }
        return name;
    }, directFnOverride: function () {
        var args = Array.prototype.slice.call(arguments).slice(0);
        var config = args[args.length - 1];
        var directFunction = config.superFunction;
        var argPrepend = config.argPrepend;
        if (Ext.isArray(args[0]['arguments'])) {
            if (args[0].action) {
                if (config.argPrependMap) {
                    argPrepend = config.argPrependMap[args[0].action];
                }
                var alternateDirectFunction = this.getDataProxyAPI().api[args[0].action];
                if (Ext.isFunction(alternateDirectFunction) && alternateDirectFunction.directCfg !== directFunction.directCfg) {
                    directFunction = alternateDirectFunction;
                    argPrepend = undefined;
                }
                delete args[0].action;
            }
            var spliceArgs = [];
            spliceArgs.push(0);
            spliceArgs.push(1);
            var argLength = directFunction.directCfg.method.len;
            if (argLength > 0) {
                var a0 = arguments[0];
                var arg = a0['arguments'][1];
                if (arg) {
                    arg = arg[0];
                    var spliceIt = true;
                    if (Ext.isArray(arg)) {
                        for (var i = 1; i < arg.length; i++) {
                            spliceArgs.push(arg[i]);
                        }
                    }
                    else {
                        spliceArgs.push(arg);
                    }
                    if (spliceIt) {
                        args.splice.apply(args, spliceArgs);
                    }
                }
            }
        }
        if (argPrepend) {
            args.unshift(argPrepend);
        }
        directFunction.createDelegate(config.scope, null, true).apply(config.scope, args);
    }
});
Ext.BLANK_IMAGE_URL = '/images/s.gif';
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanCompletionStore = Ext.extend(Pan.appframework.modelview.PanGridStore, {
    minChars: 0,
    defaultFields: [{
        name: 'value',
        mapping: '@value',
        uiHint: {isKeyField: true, hidden: true, hideable: false}
    }, {
        name: 'display',
        mapping: '@display',
        uiHint: {
            isDisplayField: true,
            sortable: true,
            header: _T('Name'),
            width: 180,
            id: 'display',
            hideable: false,
            autoExpandColumn: true
        }
    }, {name: 'sortField', uiHint: {hidden: true, hideable: false}}, {
        name: 'type',
        mapping: '@type',
        uiHint: {sortable: true, header: _T('Type')}
    }, {name: 'help-string', mapping: '@help-string', uiHint: {hidden: true, hideable: false}}, {
        name: 'inuse',
        mapping: '@inuse',
        uiHint: {hidden: true, hideable: false}
    }, {name: 'current', mapping: '@current', uiHint: {hidden: true, hideable: false}}, {
        name: 'metaField',
        uiHint: {hidden: true, hideable: false}
    }],
    recordBinderOverrideConfig: {
        commandXPathTemplate: {
            completeObject: [{
                id: '${__id}',
                xpathId: '${ "${${__recordInfo}.xpathId}" || ("${vsysName}" ? "vsys" : "shared") }',
                vsysName: '${vsysName}',
                template: '${Pan.global.getTemplate()}',
                templateStack: '${Pan.global.getTemplateStack()}',
                path: '${path}',
                additional: '${additional}',
                remoteFilterHelpString: '${remoteFilterHelpString}',
                argumentsAreJSON: true,
                condition: '"${xpath}" === ""'
            }, {
                path: '${path}',
                xpathId: '${ "${${__recordInfo}.xpathId}" || ("${vsysName}" ? "vsys" : "shared") }',
                vsysName: '${vsysName}',
                template: '${Pan.global.getTemplate()}',
                templateStack: '${Pan.global.getTemplateStack()}',
                xpath: '${xpath}',
                additional: '${additional}',
                remoteFilterHelpString: '${remoteFilterHelpString}',
                argumentsAreJSON: true,
                condition: '"${xpath}" !== ""'
            }]
        },
        completeCommandParts: ['completeObject', 'id', 'xpathId', 'vsysName', 'template', 'templateStack', 'path', 'xpath', 'additional', 'remoteFilterHelpString', 'argumentsAreJSON']
    },
    constructor: function (config) {
        config = Ext.apply({
            getDisplayStrDefault: function (config, e) {
                var val = e['@value'];
                if (config.prepend || config.append) {
                    if (config.prepend) {
                        val = e[config.prepend] + ' ' + val;
                    }
                    if (config.append) {
                        val += ' (' + e[config.append] + ')';
                    }
                } else if (config.appendHelpString !== false) {
                    if (e['@help-string']) {
                        val += ' (' + e['@help-string'] + ')';
                    }
                }
                return val;
            }
        }, config);
        Ext.applyIf(config, {autoLoad: true, getDisplayStr: config.getDisplayStrDefault});
        if (config.sortable !== false) {
            Ext.applyIf(config, {sortInfo: {field: 'sortField', direction: 'ASC'}});
        }
        config.recordBinderOverride = Ext.apply({
            getSuccessData: function (result) {
                this.store.isLoading = false;
                var results;
                var allResults;
                var total;
                var i, j, e;
                if (result['@status']) {
                    results = (result['@status'] === 'success') ? (result.completions ? result.completions.completion || result.completions : result) : false;
                    allResults = results;
                    var sortType = function (val) {
                        if (Ext.isFunction(config.sortType)) {
                            return config.sortType(val);
                        }
                        return val;
                    };
                    if (Ext.isArray(results)) {
                        if (Ext.isFunction(config.resultMutator)) {
                            results = config.resultMutator(results);
                        }
                        var queries = [];
                        if (this.store.baseParams && this.store.baseParams.query) {
                            var queryString = this.store.baseParams.query.toLowerCase();
                            if (this.store.queryValuesDelimiter) {
                                queries = queryString.split(this.store.queryValuesDelimiter);
                            }
                            else {
                                queries.push(queryString);
                            }
                        }
                        var filteredResults = [];
                        for (i = 0; i < results.length; i++) {
                            e = results[i];
                            if (!e['@display']) {
                                e['@display'] = config.getDisplayStr(config, e) || e['@value'];
                            }
                            var isEntryIncludedInTheResult = false;
                            if (queries.length <= 0) {
                                isEntryIncludedInTheResult = true;
                            }
                            else {
                                for (j = 0; j < queries.length; j++) {
                                    if (!queries[j] || e['@display'].toLowerCase().indexOf(queries[j]) >= 0) {
                                        isEntryIncludedInTheResult = true;
                                        break;
                                    }
                                }
                            }
                            if (!e.sortField) {
                                e.sortField = sortType(e['@display'].toLowerCase());
                            }
                            var type = e['@type'];
                            if (type) {
                                type = e['@type'] = type.replace(/Panorama pushed |predefined |predefined-|shared-/, '');
                                if (this.store.typeReplacementMap) {
                                    e['@type'] = this.store.typeReplacementMap[type] || type;
                                }
                            }
                            if (isEntryIncludedInTheResult) {
                                filteredResults.push(e);
                            }
                        }
                        results = filteredResults;
                    }
                    if (this.store.preEntries || this.store.postEntries) {
                        if (!Ext.isArray(results)) {
                            results = [];
                            allResults = [];
                        }
                        if (this.store.preEntries) {
                            for (i = this.store.preEntries.length - 1; i >= 0; i--) {
                                e = Pan.base.clone(this.store.preEntries[i]);
                                if (!e['@display']) {
                                    e['@display'] = config.getDisplayStr(config, e) || e['@value'];
                                }
                                if (!e.sortField) {
                                    e.sortField = '     ' + sortType(e['@display'].toLowerCase());
                                }
                                results.unshift(e);
                                allResults.unshift(e);
                            }
                        }
                        if (this.store.postEntries) {
                            for (i = 0; i < this.store.postEntries.length; i++) {
                                e = Pan.base.clone(this.store.postEntries[i]);
                                if (!e['@display']) {
                                    e['@display'] = config.getDisplayStr(config, e) || e['@value'];
                                }
                                if (!e.sortField) {
                                    e.sortField = '~~~~~' + sortType(e['@display'].toLowerCase());
                                }
                                results.push(e);
                                allResults.push(e);
                            }
                        }
                    }
                    if (this.store.totalProperty && Ext.isArray(results)) {
                        total = result[this.store.totalProperty];
                    }
                }
                var extraInfo = result && result.__extraInfo;
                if (Ext.isDefined(this.store.displayCount) && Ext.isArray(results)) {
                    extraInfo = extraInfo || {};
                    extraInfo.allResults = allResults;
                    if (results.length > this.store.displayCount) {
                        this.store.hasExceededDisplayCount = true;
                    }
                    results = results.slice(0, this.store.displayCount);
                }
                return {extraInfo: extraInfo, total: total || (results && results.length), results: results};
            }
        }, config.recordBinderOverride);
        Ext.applyIf(config, {
            fields: config.fields || this.defaultFields,
            completionField: config.completionField,
            idProperty: '@value'
        });
        config.storeInputs = Ext.apply({
            objectType: undefined,
            vsysName: '${Pan.global.getLoc().val}',
            xsltFile: undefined,
            isCmsSelected: '${Pan.global.isCmsSelected()}',
            isMultiVsys: '${Pan.global.isMultiVsys()}',
            resultObjectType: undefined,
            path: config.path,
            xpath: config.xpath,
            nameIdProperty: 'value',
            preEntries: config.preEntries,
            postEntries: config.postEntries
        }, config.storeInputs);
        Pan.appframework.modelview.PanCompletionStore.superclass.constructor.call(this, config);
        if (config.sortable !== false && config.sortInfo && config.sortInfo.sortType && config.sortInfo.field) {
            this.fields.get(config.sortInfo.field).sortType = config.sortInfo.sortType;
        }
    },
    load: function (options) {
        if (!this.combineLocalRemoteData && this.localCompletionSource) {
            if (Ext.isFunction(this.localCompletionSource))
                this.loadData(this.localCompletionSource()); else
                this.loadLocalCompletion(options);
        }
        else if ((this.baseParams && this.baseParams.useCache) && this.isStoreLoaded && this.__extraInfo && this.__extraInfo.allResults) {
            this.hasExceededDisplayCount = false;
            var allResults = this.__extraInfo.allResults;
            var results = [];
            var len = allResults.length;
            if (Ext.isDefined(this.displayCount)) {
                len = Math.min(this.displayCount, len);
            }
            var query = '';
            if (this.baseParams && Ext.isDefined(this.baseParams.query)) {
                query = this.baseParams.query.toLowerCase();
            }
            if (!query) {
                results = allResults.slice(0, len);
            }
            else {
                for (var i = 0; i < allResults.length; i++) {
                    if (results.length >= len) {
                        this.hasExceededDisplayCount = true;
                        break;
                    }
                    var r = allResults[i];
                    if (r['sortField'].indexOf(query) >= 0) {
                        results.push(r);
                    }
                }
            }
            this.loadData(results, false);
        }
        else {
            if (!this.isLoading) {
                this.hasExceededDisplayCount = false;
                this.isLoading = true;
                Pan.appframework.modelview.PanCompletionStore.superclass.load.apply(this, arguments);
            }
        }
    },
    loadLocalCompletion: function () {
        var dataExtractor = this.__pdefaults.__dataExtractor;
        var fields = this.__pdefaults.__fields;
        var localCompletionField = fields.get(this.localCompletionSource);
        if (localCompletionField && localCompletionField.attrPath) {
            var data = [];
            var store = dataExtractor(this.localCompletionSource, 'getStore');
            if (Ext.isFunction(this.filterFn)) {
                store.filterBy(this.filterFn);
            }
            data = this.getLocalCompletionData();
            this.loadData(data);
            if (store && Ext.isFunction(this.filterFn)) {
                store.clearFilter();
            }
        }
    },
    getLocalCompletionData: function () {
        var log = PanLogging.getLogger('appframework:modelview:PanCompletionStore');
        var dataExtractor = this.__pdefaults.__dataExtractor;
        var fieldsByPath = this.__pdefaults.__fieldsByPath;
        var fields = this.__pdefaults.__fields;
        var localCompletionField = fields.get(this.localCompletionSource);
        var data = [];
        if (Ext.isFunction(this.localCompletionSource)) {
            data = this.localCompletionSource();
        }
        else if (localCompletionField && localCompletionField.attrPath) {
            var sourceFieldAttrPath = localCompletionField.attrPath;
            var store = dataExtractor(this.localCompletionSource, 'getStore');
            if (Ext.isFunction(this.filterFn)) {
                store.filterBy(this.filterFn);
            }
            var localCompletionSourceConnector = this.localCompletionSourceConnector;
            if (!store) {
                if (!localCompletionSourceConnector) {
                    localCompletionSourceConnector = sourceFieldAttrPath.replace(/\.\*[^*]*$/g, '');
                }
                var connField = fields.get(localCompletionSourceConnector);
                if (connField && connField.attrPath) {
                    var connFieldAttrPath = connField.attrPath;
                    var jsonValue = dataExtractor(localCompletionSourceConnector);
                    if (fieldsByPath.get(sourceFieldAttrPath + '.*.@name')) {
                        sourceFieldAttrPath += '.*.@name';
                    }
                    else if (fieldsByPath.get(sourceFieldAttrPath + '.*')) {
                        sourceFieldAttrPath += '.*';
                    }
                    var pathDiff = sourceFieldAttrPath.substring(connFieldAttrPath.length);
                    var value = jsonPath(jsonValue, '$' + pathDiff);
                    if (value) {
                        for (var i = 0; i < value.length; i++) {
                            data.push({'@value': value[i], '@display': value[i]});
                        }
                    }
                }
                else {
                    log.warn('Missing localCompletionSourceConnector for ' + localCompletionField);
                }
            }
            else {
                var idProperty = store.idProperty;
                var renderer, colModel, grid;
                grid = dataExtractor(this.localCompletionSource, '');
                if (grid) {
                    colModel = grid.colModel;
                    if (colModel) {
                        var colIndex = colModel.findColumnIndex(idProperty);
                        if (Ext.isNumber(colIndex) && colIndex >= 0) {
                            renderer = colModel.getColumnAt(colIndex).renderer;
                        }
                    }
                }
                store.each(function (r) {
                    var id = r.get(idProperty);
                    var display = id;
                    if (renderer) {
                        display = renderer.call(colModel, id, {}, r, 0, colIndex, store, grid);
                    }
                    data.push({'@value': id, '@display': display});
                }, this);
            }
        }
        return data;
    },
    loadRecords: function (o, options, success) {
        if (this.combineLocalRemoteData) {
            var data = this.getLocalCompletionData();
            if (data.length && o && success !== false) {
                var r = this.reader.readRecords(data);
                o.records = _.union(o.records, r.records);
            }
        }
        Pan.appframework.modelview.PanCompletionStore.superclass.loadRecords.call(this, o, options, success);
    },
    getLoadOptions: function (options) {
        var record = this.record || this.__pdefaults.__recordFormRecord;
        var rb = this.recordBinder;
        var id;
        if (record.store.recordBinder) {
            id = record.store.recordBinder.getNameId(record.json);
        }
        var dataExtractor = this.__pdefaults.__dataExtractor;
        var fieldsByPath = this.__pdefaults.__fieldsByPath;
        var rootJSONPath = this.rootJSONPath;
        var vsysName = dataExtractor('location');
        if (vsysName === 'cms-private') {
            vsysName = '';
            if (this.storeInputs.vsysName) {
                this.storeInputs.vsysName = '';
            }
        }
        else if (this.rootPathInfo) {
            var locationType = vsysName;
            if (!locationType) {
                locationType = Pan.global.getLoc().type;
            }
            rootJSONPath = Ext.isObject(this.rootPathInfo) ? this.rootPathInfo[locationType] || this.rootPathInfo[Pan.global.getLocTypeFromName(locationType)] || rootJSONPath : rootJSONPath;
        }
        var xpath = this.storeInputs.xpath || (Ext.isString(rootJSONPath) ? rootJSONPath.substring(1).replace(/\./g, '\/') : '');
        var nameField = fieldsByPath.get('$.@name');
        if (this.path === undefined && this.completionField !== nameField) {
            var field, nameid;
            var partsPath = this.completionField.attrPath.replace(/\.\*$|\.\*.\@name$/g, '');
            partsPath = partsPath.replace(/\.\*/g, '*');
            var parts = partsPath.split('*');
            var j = 0;
            var actualPath = '';
            if (parts.length > 1) {
                var testPath = '';
                for (; j < parts.length - 1; j++) {
                    actualPath += parts[j];
                    testPath += parts[j] + '.*';
                    field = fieldsByPath.get(testPath + '.@name');
                    if (field) {
                        nameid = dataExtractor(field.name);
                        if (Ext.isDefined(nameid)) {
                            nameid = Pan.base.escapeXML(nameid);
                        }
                        else {
                            nameid = '__noname__';
                        }
                        nameid = nameid.replace(/\./g, '&#46;');
                        actualPath += '[@name=\'' + nameid + '\']';
                    }
                    else {
                        actualPath += '[@name=\'__noname__\']';
                    }
                }
            }
            actualPath += parts[j];
            actualPath = actualPath.substring(2, actualPath.length).replace(/\.entry$/g, '');
            field = nameField;
            if (field) {
                nameid = dataExtractor(field.name);
                if (this.sendNoName && Pan.global.isCmsSelected()) {
                    this.__trimmedName = nameid;
                    nameid = '__noname__';
                }
                else if (Ext.isDefined(nameid)) {
                    nameid = Pan.base.escapeXML(nameid);
                }
                else {
                    nameid = '__noname__';
                }
                nameid = nameid.replace(/\./g, '&#46;');
                actualPath = '[@name=\'' + nameid + '\'].' + actualPath;
            }
            else {
                actualPath = '.' + actualPath;
            }
            var linkPath = Pan.schemaLinkReplace(rootJSONPath + actualPath);
            if (linkPath) {
                actualPath = linkPath.substring(1);
                xpath = '';
            }
            actualPath = actualPath.replace(/\./g, '\/');
            xpath = xpath.replace(/\/$/g, '');
            xpath = xpath + actualPath;
        }
        xpath = xpath.replace(/\/vsys\/entry/g, "/vsys/entry[@name='${vsysName}']");
        xpath = xpath.replace(/\/network\/shared-gateway\/entry/g, "/network/shared-gateway/entry[@name='${vsysName}']");
        xpath = xpath.replace(/\/device-group\/entry/g, "/device-group/entry[@name='${vsysName}']");
        xpath = xpath.replace(/\/config\/devices\/entry/g, "/config/devices/entry[@name='localhost.localdomain']");
        xpath = xpath.replace(/\/entry$/g, '');
        xpath = xpath.replace(/\/choice/g, '');
        var config = {
            xpath: xpath,
            path: Pan.base.Evaluation.evaluate(this.path, {
                '__record': record,
                '__recordInfo': record['@__recordInfo'],
                '__field': this.completionField,
                '__fields': this.__pdefaults.__fields
            }),
            __id: id,
            additional: undefined,
            remoteFilterHelpString: this.remoteFilterHelpString
        };
        if (this.additionalInput) {
            var allFields = this.__pdefaults.__fields;
            var additionalInputs = Ext.isArray(this.additionalInput) ? this.additionalInput : [this.additionalInput];
            var additional = {};
            for (var i = 0; i < additionalInputs.length; i++) {
                var additionalInput = additionalInputs[i];
                var name = '';
                var value = '';
                if (additionalInput.value) {
                    value = additionalInput.value;
                }
                else if (additionalInput.fn) {
                    value = additionalInput.fn.call(this);
                }
                else if (additionalInput.field) {
                    var fieldName = additionalInput.field;
                    if (Ext.isFunction(additionalInput.field)) {
                        fieldName = additionalInput.field.call(this);
                    }
                    name = allFields.get(fieldName).attrPath.substring(2).replace(/\./g, '\/');
                    value = dataExtractor(fieldName);
                }
                if (additionalInput.name) {
                    name = additionalInput.name;
                    if (Ext.isFunction(additionalInput.name)) {
                        name = additionalInput.name.call(this);
                    }
                }
                additional[name] = value;
            }
            if (additional) {
                config.additional = additional;
            }
        }
        if (!vsysName) {
            if (record.json['@__recordInfo'].vsysName) {
                vsysName = record.json['@__recordInfo'].vsysName;
            }
        }
        if (vsysName) {
            config.vsysName = vsysName;
        }
        var rv = rb.getRemoteCommand('complete', record, config);
        if (rv) {
            Ext.each(rv.commands, function (cmd) {
                if (cmd.path && cmd.path.match(/\/entry\/@name$/)) {
                    cmd.path = cmd.path.replace(/\/entry\/@name$/, '');
                }
            });
            Ext.apply(rv.commands[0], this.params, this.baseParams);
            return Ext.applyIf({
                scope: this,
                params: {
                    action: rv.action,
                    'arguments': ['execute', Ext.apply(rv.commands, (options && options.params))]
                }
            }, options);
        }
        else {
            Pan.appframework.errorhandling.PanStatusReporter.setStatus({
                error: {
                    title: _T('Error'),
                    message: _T('Unable to fetch data.')
                }
            });
            return options;
        }
    },
    permanentFilterFn: function (r) {
        var rv = true;
        var data = r.data;
        if (this.checkTypeExist && !data['type']) {
            return false;
        }
        if (!this.record || !this.record.phantom) {
            rv = data['value'] !== this.__trimmedName && (data['inuse'] !== 'yes' || data['current'] === 'yes');
        }
        else {
            rv = data['value'] !== this.__trimmedName && data['inuse'] !== 'yes';
        }
        if (rv) {
            rv = Pan.appframework.modelview.PanCompletionStore.superclass.permanentFilterFn.apply(this, arguments);
        }
        return rv;
    }
});
Pan.appframework.modelview.getCompleteStoreCfg = function (theAPI, path, rec, config) {
    var cfg = {
        recordBinderOverride: Ext.apply({dataProxyAPI: {api: {complete: theAPI}}}, Pan.appframework.modelview.PanCompletionStore.prototype.recordBinderOverrideConfig),
        path: path
    };
    if (rec) {
        Ext.apply(cfg, {record: rec});
    }
    return {ztype: Pan.appframework.modelview.PanCompletionStore, zconfig: Ext.applyIf(cfg, config)};
};
(function () {
    var getCompletionParams = Pan.appframework.modelview.getCompletionParams;
    var getPanoCompletionParamsPano = Pan.appframework.modelview.getCompletionParamsPano;
    var SimpleCompletionStore = Ext.extend(Pan.appframework.modelview.PanCompletionStore, {
        constructor: function (config) {
            SimpleCompletionStore.superclass.constructor.call(this, config);
        }, getLoadOptions: function (_options) {
            var vsys = Pan.global.getLoc().val;
            if (Pan.global.isCmsSelected()) {
                return getPanoCompletionParamsPano({
                    vsys: vsys,
                    template: Pan.global.getTemplate()
                }, this.objectPath, this.fieldPath);
            }
            else {
                return getCompletionParams({vsys: vsys}, this.objectPath, this.fieldPath);
            }
        }
    });
    Ext.ns('Pan.appframework.modelview');
    Pan.appframework.modelview.SimpleCompletionStore = SimpleCompletionStore;
})();
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanCompletionTreeGridStoreConfig = {
    fields: [{
        name: 'name',
        mapping: '@name',
        uiHint: {isKeyField: true, hidden: true, hideable: false}
    }, {name: 'value', mapping: '@value', uiHint: {isKeyField: true, hidden: true, hideable: false}}, {
        name: 'display',
        mapping: '@display',
        uiHint: {
            isDisplayField: true,
            sortable: false,
            header: _T("Name"),
            width: 180,
            id: 'display',
            hideable: false,
            autoExpandColumn: true
        }
    }, {name: 'sortField', uiHint: {hidden: true, hideable: false}}, {
        name: 'type',
        mapping: '@type',
        uiHint: {hidden: true}
    }, {name: 'help-string', mapping: '@help-string', uiHint: {hidden: true, hideable: false}}, {
        name: 'inuse',
        mapping: '@inuse',
        uiHint: {hidden: true, hideable: false}
    }, {name: 'parentIDField', uiHint: {hidden: true, hideable: false}}, {
        name: 'metaField',
        uiHint: {hidden: true, hideable: false}
    }]
};
Pan.appframework.modelview.PanCompletionTreeGridStore = Ext.extend(Pan.appframework.modelview.PanCompletionStore, {
    defaultFields: Pan.appframework.modelview.PanCompletionTreeGridStoreConfig.fields, constructor: function () {
        Ext.apply(this, Pan.appframework.modelview.TreeGridStoreConfig);
        Pan.appframework.modelview.PanCompletionTreeGridStore.superclass.constructor.apply(this, arguments);
    }, clearFilter: function (_suppressEvent) {
        delete this.queryByResultRootRecords;
        return Pan.appframework.modelview.PanCompletionTreeGridStore.superclass.clearFilter.apply(this, arguments);
    }, queryBy: function (fn, scope) {
        var queryByResultRootRecords = this.queryByResultRootRecords = new Ext.util.MixedCollection();
        var data = this.snapshot || this.data;
        var filterBy = function (fn, scope) {
            var r = new Ext.util.MixedCollection();
            r.getKey = this.getKey;
            var rowsToAdd = [];
            var k = this.keys, it = this.items;
            queryByResultRootRecords.clear();
            for (var i = 0, len = it.length; i < len; i++) {
                var insertLocation = rowsToAdd.length;
                if (fn.call(scope || this, it[i], k[i], i)) {
                    queryByResultRootRecords.add(k[i], it[i]);
                    var j, prevLevel = it[i].__treeLevel;
                    for (j = i - 1; j >= 0; j--) {
                        if (it[j].__treeLevel < prevLevel) {
                            rowsToAdd.splice(insertLocation, 0, j);
                            if (it[j].__treeLevel === 0) {
                                break;
                            }
                            prevLevel = it[j].__treeLevel;
                        }
                    }
                    rowsToAdd.push(i);
                    prevLevel = it[i].__treeLevel;
                    for (j = i + 1; j < len; j++) {
                        if (it[j].__treeLevel <= prevLevel) {
                            break;
                        }
                        rowsToAdd.push(j);
                    }
                    i = j - 1;
                }
            }
            for (var m = 0; m < rowsToAdd.length; m++) {
                var index = rowsToAdd[m];
                if (!r.key(k[index])) {
                    r.add(k[index], it[index]);
                }
            }
            return r;
        };
        return filterBy.call(data, fn, scope || this);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanRecordFormViewer = Ext.extend(Pan.base.autorender.GridRecordForm, {
    isPortlet: false, constructor: function (config) {
        Ext.applyIf(this, Pan.appframework.modelview.PanViewer.prototype);
        config = Ext.apply({}, config);
        Pan.appframework.modelview.PanRecordFormViewer.superclass.constructor.call(this, config);
    }, panViewerInit: function () {
        Pan.appframework.modelview.PanViewer.prototype.panViewerInit.call(this);
        this.addEvents('afterformload');
    }, initComponent: function () {
        if (this.isPortlet) {
            Ext.applyIf(this, {anchor: '100%', draggable: true});
            this.cls = this.cls || "";
            this.cls += ' x-portlet';
        }
        this.panViewerInit();
        this.isLiveGrid = undefined;
        this.storeSetup();
        var initFunction = function () {
            this.doLayout(false, true);
            this.populate();
            this.fireAfterLoaded();
            if (this.monitorValid) {
                this.startMonitoring();
            }
        };
        if (this.store.autoLoad !== false) {
            this.store.addListener({load: {fn: initFunction, scope: this}});
        }
        this.store.addListener({
            'update': {
                fn: function (store, record, action) {
                    if (action === 'commit' && this.isCheckAutoRefreshAfterWrite === true) {
                        this.populate();
                    }
                }, scope: this
            }
        });
        this.loadMaskObject = this.loadMask;
        this.initViewer();
        if (Pan.global.isCmsSelected() && Pan.global.getTemplate()) {
            Pan.common.CommonViewerConfig.insertVariableMenuAction(this);
        }
        this.setupRecordForm(this.recordForm, {}, this);
        Pan.appframework.modelview.PanRecordFormViewer.superclass.initComponent.apply(this, arguments);
        if (this.store.autoLoad === false) {
            this.loadMaskObject = null;
            this.loadMask = null;
            initFunction.call(this);
        }
    }, getXpathsForVariableMenuActions: function () {
        return [];
    }, loadMask: {msg: _T('Loading...')}, initEvents: function () {
        Pan.appframework.modelview.PanRecordFormViewer.superclass.initEvents.apply(this, arguments);
        this.startLoadMask();
        this.panViewerPostInit();
    }, startLoadMask: function () {
        if (this.loadMaskObject) {
            this.loadMask = new Pan.base.widgets.LoadMask(this.bwrap, Ext.apply({store: this.store}, this.loadMaskObject));
            this.loadMask.show();
        }
    }, stopLoadMask: function () {
        if (this.loadMask) {
            this.loadMask.hide();
            this.loadMask.destroy();
        }
    }, populate: function () {
        delete this.editRecord;
        if (this.store.data.items.length > 0) {
            this.record = this.store.data.items[0];
        } else {
            this.record = this.store.beginAdd();
            this.record.id = Pan.common.Constants.singletonId;
            if (this.isSingleton) {
                this.record.json = this.record.json || {'@__recordInfo': {id: this.record.id}};
            }
            if (this.store.__defaults) {
                Ext.apply(this.record.data, this.store.__defaults);
            }
        }
        this.setupRecord();
        this.loadRecord();
        this.fireEvent('afterformload', this);
        this.stopLoadMask();
    }, createStore: function (config) {
        if (config.ztype) {
            return new config.ztype(config);
        }
        return undefined;
    }, applyStoreConfig: function (config) {
        if (this.commonFields) {
            config.fields = config.fields || [];
            config.fields = config.fields.slice(0);
            for (var i = 0; i < this.commonFields.length; i++) {
                var bFound = false;
                for (var j = 0; !bFound && j < config.fields.length; j++) {
                    bFound = (config.fields[j].name == this.commonFields[i].name);
                }
                if (!bFound)
                    config.fields.push(Pan.base.clone(this.commonFields[i]));
            }
        }
        return Ext.apply(config, this.storeConfig);
    }, initViewer: function () {
    }, setupRecordForm: function (form, config, element) {
        var recordFormTitle = this.recordFormTitle || (this.storeInputs && this.storeInputs.objectType);
        if (this.recordFormTitle && Ext.isFunction(this.recordFormTitle)) {
            recordFormTitle = this.recordFormTitle(config);
        }
        var template = this.getRecordFormTemplate(Ext.applyIf({
            scope: form.scope || this,
            recordFormTitle: recordFormTitle
        }, form));
        var isInWindow = Ext.isDefined(this.isInWindow) ? this.isInWindow : false;
        Ext.apply(template, config, {store: this.store, recordBinder: this.store.recordBinder, isInWindow: isInWindow});
        Ext.apply(this, template);
        if (!isInWindow) {
            Ext.applyIf(this, {autoHeight: false});
            Ext.apply(this, {
                okText: 'Apply', cancelText: 'Discard', postCancelCallback: function () {
                    this.populate();
                    return true;
                }
            });
        }
    }, onDestroy: function () {
        if (this.store && this.store.autoDestroy) {
            this.store.destroy();
        }
        this.panViewerOnDestroy();
        return Pan.appframework.modelview.PanRecordFormViewer.superclass.onDestroy.apply(this, arguments);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanMultiRecordFormViewer = Ext.extend(Pan.appframework.modelview.PanRecordFormViewer, {
    useToolbar: true,
    useToolbarAddAction: true,
    useToolbarDeleteAction: true,
    useToolbarCloneAction: true,
    defaultActionsCfg: {},
    extraActions: [],
    theme: Pan.base.Constants.uiThemes[0],
    constructor: function (config) {
        config = Ext.apply({}, config);
        Pan.appframework.modelview.PanMultiRecordFormViewer.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        if (this.useToolbar) {
            var bar = this.setupToolBar();
            this.bbar = this.setupBar(bar);
        }
        Pan.appframework.modelview.PanMultiRecordFormViewer.superclass.initComponent.call(this);
    },
    setupBar: function (bar) {
        bar = bar.slice(0);
        var makeHandler = function (o, action) {
            o.handler = Pan.base.util.createExtension(function (element, event) {
                var config = {
                    grid: this,
                    component: this,
                    action: action,
                    event: event,
                    postSucceedAction: this.postSucceedAction,
                    postFailedAction: this.postFailedAction
                };
                config.record = this.getSelectedRecords();
                if (config.record) {
                    var firstRecord = config.record;
                    if (Ext.isArray(firstRecord)) {
                        firstRecord = firstRecord[0];
                    }
                    if (firstRecord) {
                        config.row = this.store.indexOfId(firstRecord.id);
                    }
                }
                arguments.callee.superFunction.call(this, this, config, event);
            }, o.handler, this);
        };
        for (var i = 0; i < bar.length; i++) {
            bar[i] = Pan.createAction(bar[i], this);
            if (bar[i].handler) {
                makeHandler.call(this, bar[i], bar[i]);
            } else if (bar[i].initialConfig && bar[i].initialConfig.handler) {
                makeHandler.call(this, bar[i].initialConfig, bar[i]);
            }
        }
        return bar;
    },
    getSelectedRecords: Ext.emptyFn,
    postSucceedAction: Ext.emptyFn,
    postFailedAction: Ext.emptyFn,
    afterUpdateRecord: Ext.emptyFn,
    addRecord: function () {
        var record = this.store.beginAdd();
        if (this.newWindow) {
            this.newWindow.onDestroy();
        }
        var form = this.newRecordForm;
        var template = this.getRecordFormTemplate(Ext.applyIf({
            scope: form.scope || this,
            recordFormTitle: this.recordFormTitle || (this.storeInputs && this.storeInputs.objectType)
        }, form));
        var recordFormConfig = Ext.apply(template, {}, {
            store: this.store,
            recordBinder: this.store.recordBinder,
            isInWindow: true,
            record: record,
            afterUpdateRecord: this.afterUpdateRecord.createDelegate(this)
        });
        this.newWindow = Pan.base.autorender.GridRecordForm.showRecordForm(recordFormConfig, this);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanToggleFieldViewer = Ext.extend(Pan.appframework.modelview.PanRecordFormViewer, {
    showButtons: false,
    storeConfig: {ztype: Pan.appframework.modelview.PanGridStore},
    recordForm: {hideLabels: true, items: [{itemId: "$", xtype: 'pan-togglefield', hideLabel: true}]},
    defaultFormConfig: {border: false, frame: false, autoHeight: true},
    initComponent: function () {
        if (this.toggleField) {
            this.recordForm.items[0].itemId = this.toggleField;
        }
        Pan.appframework.modelview.PanToggleFieldViewer.superclass.initComponent.apply(this, arguments);
    },
    onOKImp: function (key, event) {
        if (this.isValid()) {
            var okCallback = this.recordForm.okCallback || this.okCallback;
            if (Ext.isFunction(okCallback)) {
                var scope = this.scope || this;
                if (!okCallback.call(scope, this))
                    return;
            }
            this.updateRecord(function (success) {
                if (success) {
                    if (this.autoHide && this.isInWindow) {
                        this.window.close();
                    }
                    this.afterUpdateRecord();
                }
                return success;
            }.createDelegate(this));
        }
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanPortletViewer = Ext.extend(Pan.appframework.modelview.PanRecordFormViewer, {
    showButtons: false,
    showLoadingIndication: true,
    monitorValid: false,
    storeConfig: {ztype: Pan.appframework.modelview.PanGridStore},
    initComponent: function () {
        if (this.showLoadingIndication) {
            this.initLoadingIndication();
        }
        Pan.appframework.modelview.PanPortletViewer.superclass.initComponent.apply(this, arguments);
    },
    initViewer: function () {
        this.cls = this.cls || "";
        this.cls += " " + Pan.base.Constants.formThemes[1];
        var viewTitle = this.recordFormTitle || (this.storeInputs && this.storeInputs.objectType);
        Ext.apply(this, {title: viewTitle, recordForm: Ext.apply({noLastColumnAnchor: true}, this.recordForm)});
        Pan.appframework.modelview.PanPortletViewer.superclass.initViewer.apply(this, arguments);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanPropertyGridViewer = Ext.extend(Pan.appframework.modelview.PanPortletViewer, {
    isSingleton: true,
    editText: 'Edit',
    inlineEditing: false,
    titleColumnConfig: {},
    autoHeight: true,
    useList: false,
    editRecordForm: {items: [{itemId: '$', height: 300}]},
    initViewer: function () {
        var hasPermission = Pan.appframework.PanAppInterface.hasEditPermission(this.rbaPath, this.record);
        if (this.bbar) {
            this.cls += " " + "pan-propertygrid-with-bbar";
        }
        var item = {
            anchor: '100%',
            itemId: '$',
            builder: 'PropertyGridBuilder',
            useList: this.useList,
            inlineEditing: hasPermission && this.inlineEditing,
            isWidget: this.isWidget,
            titleColumnConfig: this.titleColumnConfig,
            propertyRootField: this.propertyRootField || '$',
            zconfig: {doNotInitializeValueFieldToDefaultValue: true}
        };
        if (Ext.isObject(this.initialConfig.propertyGridRecordFormConfig)) {
            Ext.applyIf(item, this.initialConfig.propertyGridRecordFormConfig);
        }
        this.recordForm = {readOnly: true, saveImmediately: this.inlineEditing, items: [item]};
        var onEditDelegate = this.onEdit.createDelegate(this);
        if (!this.inlineEditing) {
            if (this.configStates.supportTemplateOverride) {
                var templateOverrideAction = Pan.createAction({atype: 'templateOverrideAction', isPanelTool: true});
                var templateOverrideDelegate = function () {
                    var handler = this.store.templateRecord ? onEditDelegate : templateOverrideAction.initialConfig.handler;
                    handler.apply(this, arguments);
                }.createDelegate(this);
                if (Pan.global.getTemplate()) {
                    this.addTool({
                        id: 'hastemplateindication',
                        qtip: _T('Template Values Exist'),
                        hidden: true,
                        handler: this.configStates.supportTemplateAtFieldLevel ? onEditDelegate : templateOverrideAction.initialConfig.handler
                    });
                    if (Pan.global.isTemplateStackSelected()) {
                        this.addTool({
                            id: 'hasoverrideindication',
                            qtip: _T('Template Values Overriden'),
                            hidden: true,
                            handler: templateOverrideDelegate
                        });
                    }
                } else {
                    this.addTool({
                        id: 'hasoverrideindication',
                        qtip: _T('From Template Stack Override') + ": " + Pan.global.getTemplateName(),
                        hidden: true,
                        handler: templateOverrideDelegate
                    });
                    this.addTool({
                        id: 'hasnooverrideindication',
                        qtip: _T('From Template Stack') + ": " + Pan.global.getTemplateName(),
                        hidden: true,
                        handler: templateOverrideDelegate
                    });
                }
                this.addTool({
                    id: 'overrideindication',
                    qtip: Pan.global.getTemplate() ? _T('Edit') : _T('Template Override'),
                    hidden: true,
                    handler: templateOverrideAction.initialConfig.handler
                });
            }
            if (hasPermission) {
                this.addTool({id: 'gear', qtip: _T('Edit'), hidden: true, handler: onEditDelegate});
            }
        }
        Pan.appframework.modelview.PanPropertyGridViewer.superclass.initViewer.apply(this, arguments);
    },
    setupToolIconVisibility: function (record) {
        if (!this.header) {
            return;
        }
        if (this.configStates.supportTemplateOverride) {
            if (Pan.global.getTemplate()) {
                if (this.configStates.supportTemplateAtFieldLevel) {
                    if (this.tools.gear)
                        this.tools.gear.show();
                    this.tools.overrideindication.hide();
                } else {
                    if (this.tools.gear)
                        this.tools.gear.hide();
                    this.tools.overrideindication.show();
                }
                var result1 = record.store.findInLeafFields(record.json);
                if (!Pan.base.isEmpty(result1.inJson1Fields)) {
                    if (record.json && record.json['@ptpl']) {
                        this.tools.hastemplateindication.dom.qtip = _T('From Template:') + " " + record.json['@ptpl'];
                    } else {
                        this.tools.hastemplateindication.dom.qtip = _T('Template Values Exist');
                    }
                    this.tools.hastemplateindication.show();
                } else {
                    this.tools.hastemplateindication.hide();
                }
            } else {
                if (this.tools.gear)
                    this.tools.gear.show();
                this.tools.hasnooverrideindication.hide();
                this.tools.hasoverrideindication.hide();
                this.tools.overrideindication.hide();
            }
            if (record.store.templateRecord) {
                if (this.tools.gear)
                    this.tools.gear.show();
                var result = record.store.findInLeafFields(record.store.nonMergedRecord.json, record.store.templateRecord.json);
                if (!Pan.base.isEmpty(result.inBothFields)) {
                    this.tools.hasoverrideindication.show();
                    if (this.tools.hastemplateindication) {
                        this.tools.hastemplateindication.hide();
                    } else {
                        this.tools.hasnooverrideindication.hide();
                    }
                } else if (!Pan.base.isEmpty(result.inJson2Fields)) {
                    this.tools.hasoverrideindication.hide();
                    if (this.tools.hastemplateindication) {
                        this.tools.hastemplateindication.show();
                    } else {
                        this.tools.hasnooverrideindication.show();
                    }
                }
            } else {
                if (Pan.appframework.renderer.isTemplateRec(record)) {
                    if (this.tools.gear)
                        this.tools.gear.hide();
                    this.tools.hasnooverrideindication.show();
                    this.tools.hasoverrideindication.hide();
                    this.tools.overrideindication.show();
                } else if (Pan.appframework.renderer.isTSTemplateRec(record)) {
                    if (this.tools.gear)
                        this.tools.gear.hide();
                    this.tools.hastemplateindication.show();
                    this.tools.hasoverrideindication.hide();
                } else if (this.store.templateRecords && this.store.templateRecords[record.id]) {
                    if (this.tools.gear)
                        this.tools.gear.hide();
                    if (this.tools.hastemplateindication) {
                        this.tools.hastemplateindication.hide();
                    } else {
                        this.tools.hasnooverrideindication.hide();
                    }
                    this.tools.hasoverrideindication.show();
                    this.tools.overrideindication.show();
                }
            }
        } else if (this.tools.gear) {
            this.tools.gear.show();
        }
    },
    populate: function () {
        Pan.appframework.modelview.PanPropertyGridViewer.superclass.populate.apply(this, arguments);
        var propertyGrid = this.findByItemId('$');
        if (propertyGrid && propertyGrid.getView) {
            propertyGrid.getView().refresh();
        }
        this.setupToolIconVisibility(this.editRecord);
    },
    onEdit: function () {
        this.editForm(undefined, this.recordFormOverride);
    },
    editForm: function (record, recordFormOverride) {
        if (this.store.isStoreLoaded) {
            if (!record) {
                record = this.editRecord;
            }
            var editRecordForm = Ext.apply({}, this.editRecordForm);
            if (recordFormOverride) {
                Ext.apply(editRecordForm, recordFormOverride);
            }
            Ext.apply(editRecordForm, {
                afterUpdateRecord: function (record) {
                    this.setupToolIconVisibility(record);
                    this.afterUpdateRecord(record);
                }.createDelegate(this)
            });
            this.showRecordForm(editRecordForm, {}, record, this);
        }
    },
    showRecordForm: function (form, config, record, element) {
        var template = this.getRecordFormTemplate(Ext.applyIf({
            scope: form.scope || this,
            recordFormTitle: this.recordFormTitle || (this.storeInputs && this.storeInputs.objectType)
        }, form));
        Ext.apply(template.windowConfig, {itemId: this.treePath + "-window"});
        var recordFormConfig = Ext.apply(template, config, {
            store: this.store,
            recordBinder: this.store.recordBinder,
            treePath: this.treePath,
            isInWindow: true,
            record: record,
            animateTarget: element
        });
        this.gridRecordForm = Pan.base.autorender.GridRecordForm.showRecordForm(recordFormConfig, this);
    },
    afterUpdateRecord: Ext.emptyFn,
    afterUpdateFailure: function (r) {
        r.store.reload();
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanMultiPropertyGridViewer = Ext.extend(Pan.appframework.modelview.PanPortletViewer, {
    titleColumnConfig: {},
    autoHeight: true,
    editRecordForm: {items: [{itemId: '$', height: 300}]},
    initViewer: function () {
        var hasPermission = Pan.appframework.PanAppInterface.hasEditPermission(this.rbaPath, this.record);
        this.recordForm = {
            items: [{
                anchor: '100%',
                itemId: '$',
                builder: 'PropertyGridBuilder',
                isMultiProperty: true,
                titleColumnConfig: this.titleColumnConfig,
                propertyRootField: this.propertyRootField || '$'
            }]
        };
        Pan.appframework.modelview.PanMultiPropertyGridViewer.superclass.initViewer.apply(this, arguments);
    },
    setupRecordForm: function (form, config, element) {
        form.items[0].store = {
            zconfig: {
                localStore: false,
                titleColumnConfig: {
                    editor: {
                        builder: 'PanEditorDialogBuilder',
                        windowConfig: this.windowConfig,
                        afterUpdateRecord: this.afterUpdateRecord,
                        afterUpdateFailure: this.afterUpdateFailure
                    }
                }
            }
        };
        Pan.appframework.modelview.PanMultiPropertyGridViewer.superclass.setupRecordForm.apply(this, arguments);
    },
    afterUpdateRecord: function (r) {
        r.store.reload();
    },
    afterUpdateFailure: function (r) {
        r.store.reload();
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanGroupingGridStore = Ext.extend(Pan.appframework.modelview.PanGridStore, {
    allPossibleGroups: undefined, constructor: function (config) {
        config = config || {};
        this.hasMultiSort = true;
        this.multiSortInfo = this.multiSortInfo || {sorters: []};
        var sorters = this.multiSortInfo.sorters, groupField = config.groupField || this.groupField,
            sortInfo = config.sortInfo || this.sortInfo, groupDir = config.groupDir || this.groupDir;
        if (groupField) {
            sorters.push({field: groupField, direction: groupDir});
        }
        if (sortInfo) {
            sorters.push(sortInfo);
        }
        Pan.appframework.modelview.PanGroupingGridStore.superclass.constructor.call(this, config);
        this.addEvents('groupchange');
        this.applyGroupField();
    }, sort: function (fieldName, dir) {
        if (!Ext.isDefined(fieldName)) {
            if (!this.sortInfo) {
                return;
            }
        }
        return Ext.data.GroupingStore.prototype.sort.apply(this, arguments);
    }, getAllPossibleGroups: function () {
        return this.allPossibleGroups || [];
    }, getMissingGroups: function () {
        var allGroups = Ext.apply({}, this.getAllPossibleGroups());
        this.each(function (record) {
            var groupFieldValue = record.get(this.groupField);
            if (allGroups[groupFieldValue]) {
                delete allGroups[groupFieldValue];
            }
        }, this);
        var rv = [];
        for (var key in allGroups) {
            if (allGroups.hasOwnProperty(key)) {
                rv.push(allGroups[key]);
            }
        }
        return rv;
    }
});
Ext.applyIf(Pan.appframework.modelview.PanGroupingGridStore.prototype, Ext.data.GroupingStore.prototype);
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanGroupingGridViewer = Ext.extend(Pan.appframework.modelview.PanGridViewer, {
    stateful: true, stateEvents: ['groupclick'], supportFastRender: true, getState: function () {
        var state = Pan.appframework.modelview.PanGroupingGridViewer.superclass.getState.call(this) || {};
        var nodes = this.getCollapsedNodes();
        if (nodes === false) {
            return state;
        }
        if (Ext.isArray(nodes) && nodes.length > 0) {
            Ext.apply(state, {gpcollapsed: nodes});
            return state;
        }
        return state;
    }, afterLoad: function () {
        Pan.appframework.modelview.PanGroupingGridViewer.superclass.afterLoad.apply(this, arguments);
        var id = this.getStateId();
        if (id) {
            var state = Ext.state.Manager.get(id);
            if (state && state.gpcollapsed)
                this.collapseNodes(state.gpcollapsed);
        }
    }, collapseNodes: function (nodes) {
        if (Ext.isArray(nodes)) {
            for (var i = 0; i < nodes.length; i++) {
                var n = this.getView().el.query('.x-grid3-body [id$=' + nodes[i] + ']');
                if (n.length > 0) {
                    this.getView().toggleGroup(n[0], false);
                }
            }
        }
    }, getCollapsedNodes: function () {
        var view = this.getView();
        if (!view.el) return false;
        var groups = this.getView().el.query('.x-grid3-body .x-grid-group-collapsed');
        var ids = [];
        Ext.each(groups, function (group) {
            var a = group.id.split('-');
            for (var i = 0; i < a.length; i++) {
                if (a[i] == 'gp') {
                    ids.push(a.slice(i, a.length).join('-'));
                    break;
                }
            }
        });
        return ids;
    }, createStore: function (config) {
        var store = new Pan.appframework.modelview.PanGroupingGridStore(config);
        store.storeInputs.resultObjectType = store.storeInputs.resultObjectType ? store.storeInputs.resultObjectType : store.storeInputs.objectType;
        return store;
    }, createView: function () {
        return new Pan.base.grid.GroupingGridView(this.viewConfig);
    }
});
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanTreeGridStore = Ext.extend(Pan.appframework.modelview.PanGridStore, {
    constructor: function () {
        Ext.apply(this, Pan.appframework.modelview.TreeGridStoreConfig);
        Pan.appframework.modelview.PanTreeGridStore.superclass.constructor.apply(this, arguments);
    }
});
Pan.appframework.modelview.TreeGridStoreConfig = {
    doPermanentFilter: function (o) {
        o = Pan.appframework.modelview.PanGridStore.prototype.doPermanentFilter.apply(this, arguments);
        if (this.parentRecordField && Ext.isObject(o) && o.records && o.totalRecords) {
            var tempStore = new Pan.base.autorender.GridRecordStore({
                sortInfo: this.sortInfo || (this.initialConfig && this.initialConfig.sortInfo),
                multiSortInfo: this.multiSortInfo || (this.initialConfig && this.initialConfig.multiSortInfo),
                fields: this.initialConfig.fields
            });
            tempStore.loadRecords(o, {}, true);
            o.records = tempStore.data.items;
            tempStore.destroy();
            delete this.sortInfo;
            delete this.multiSortInfo;
            var length = o.records.length;
            var idMap = {}, i, r;
            for (i = 0; i < length; i++) {
                r = o.records[i];
                var treeRecordId = this.getTreeRecordId(r);
                idMap[treeRecordId] = true;
            }
            var recordMap = {};
            for (i = 0; i < length; i++) {
                r = o.records[i];
                var parentRecordId = r.get(this.parentRecordField);
                if (!parentRecordId || !Ext.isDefined(idMap[parentRecordId]) || this.getTreeRecordId(r) === parentRecordId) {
                    parentRecordId = "__root__";
                }
                if (!recordMap[parentRecordId]) {
                    recordMap[parentRecordId] = [];
                }
                recordMap[parentRecordId].push(r);
            }
            o = Ext.applyIf({records: []}, o);
            var rootNodes = recordMap["__root__"];
            this.createTreeRecords(rootNodes, o.records, recordMap, 0);
        }
        return o;
    }, createTreeRecords: function (records, allRecords, recordMap, level) {
        if (!Ext.isDefined(records)) {
            return;
        }
        for (var i = 0; i < records.length; i++) {
            var allRecordsIndex = allRecords.length;
            var r = allRecords[allRecordsIndex] = records[i];
            r.__treeLevel = level;
            r.__treeSnapshotIndex = allRecordsIndex;
            var rid = this.getTreeRecordId(r);
            var childRecords = recordMap[rid];
            if (childRecords) {
                r.__treeChildrenCount = childRecords.length;
                r.__treeChildFirst = childRecords[0].id;
                r.__treeChildLast = childRecords[childRecords.length - 1].id;
                this.createTreeRecords(childRecords, allRecords, recordMap, level + 1);
            }
        }
    }, getTreeRecordId: function (r) {
        if (this.treeRecordIdMainField && r.get(this.treeRecordIdMainField))
            return r.get(this.treeRecordIdMainField);
        if (this.treeRecordIdField) {
            if (Ext.isArray(this.treeRecordIdField)) {
                var result = [];
                for (var i = 0; i < this.treeRecordIdField.length; i++) {
                    result.push(r.get(this.treeRecordIdField[i]));
                }
                return result.join("/");
            } else {
                return r.get(this.treeRecordIdField);
            }
        } else {
            return r.id;
        }
    }, getStoreFilterCount: function (store) {
        var total = 0;
        var s = store.snapshot || store.data;
        s.each(function (r) {
            if (!r.__treeChildrenCount || r.store.includeParents) {
                if (r.store.excludeLeafDG) {
                    total += r.get("$.serial") || r.get("serial") ? 1 : 0;
                }
                else {
                    total++;
                }
            }
        });
        var inStoreTotal = total;
        if (store.snapshot !== store.data) {
            inStoreTotal = 0;
            s = store.data;
            s.each(function (r) {
                if (!r.__treeChildrenCount || r.store.includeParents) {
                    if (r.store.excludeLeafDG) {
                        inStoreTotal += r.get("$.serial") || r.get("serial") ? 1 : 0;
                    }
                    else {
                        inStoreTotal++;
                    }
                }
            });
        }
        return {totalCount: total, filteredCount: inStoreTotal};
    }
};
Ext.ns('Pan.appframework.modelview');
Pan.appframework.modelview.PanTreeGridViewer = Ext.extend(Pan.appframework.modelview.PanGridViewer, {
    useArrows: Pan.base.Constants.treeRendererUseArrows, createStore: function (config) {
        var store = new Pan.appframework.modelview.PanTreeGridStore(config);
        store.storeInputs.resultObjectType = store.storeInputs.resultObjectType ? store.storeInputs.resultObjectType : store.storeInputs.objectType;
        return store;
    }, collapseAll: function () {
        this.showAllChildren(true);
    }, expandAll: function () {
        this.showAllChildren(false);
    }, showAllChildren: function (hide) {
        var grid = this;
        var rows = grid.view.getRows();
        var length = rows.length;
        for (var i = 1; i < length; i++) {
            if (hide) {
                rows[i].style.display = "none";
            } else {
                rows[i].style.display = "";
            }
        }
        if (hide) {
            if (length > 0) {
                Ext.fly(rows[0]).select(".x-tree-elbow-minus").addClass("x-tree-elbow-plus");
                Ext.fly(rows[0]).select(".x-tree-elbow-minus").removeClass("x-tree-elbow-minus");
            }
        } else {
            this.el.select(".x-tree-elbow-plus").addClass("x-tree-elbow-minus");
            this.el.select(".x-tree-elbow-plus").removeClass("x-tree-elbow-plus");
        }
        if (hide && grid.supportFastRender) {
            grid.view.doFastRender();
        }
    }
});
Pan.appframework.modelview.PanHLTreeGridViewer = Ext.extend(Pan.appframework.modelview.PanTreeGridViewer, {
    detailViewerTreePath: undefined, initComponent: function () {
        this.addEvents('afterupdaterecord');
        Pan.appframework.modelview.PanHLTreeGridViewer.superclass.initComponent.apply(this, arguments);
    }, addRecord: function (element, config, event) {
        var detailViewerTreePath = Pan.base.json.path(config, "$.action.initialConfig.detailViewerTreePath") || this.detailViewerTreePath;
        var recStruct = {treePath: detailViewerTreePath};
        if (config && config.recordFormOverride) {
            Ext.apply(recStruct, {recordFormOverride: config.recordFormOverride});
        }
        this.showDetailViewer(recStruct);
    }, editForm: function (record, recordFormOverride, row, col) {
        var recStruct = this.setupRecStruct(record);
        if (recordFormOverride) {
            Ext.applyIf(recStruct, {recordFormOverride: recordFormOverride});
        }
        this.showDetailViewer(recStruct, record);
    }, setupRecStruct: function (record) {
        var recStruct = {};
        if (record && record.store) {
            var nameProperty = record.store.storeInputs.nameIdProperty;
            Ext.apply(recStruct, {name: record.get(nameProperty), treePath: this.detailViewerTreePath});
        }
        return recStruct;
    }, showDetailViewer: function (recStruct, record) {
        if (recStruct.treePath) {
            var name = recStruct.name;
            var storeConfigOverride = {additionalInput: {__id: name}};
            if (recStruct.phantom) {
                Ext.apply(storeConfigOverride, {autoLoad: false, allowMultipleRecords: true}, recStruct);
            }
            var actionConfig = {
                afterUpdateRecord: this.afterUpdateRecord.createDelegate(this),
                storeConfigOverride: storeConfigOverride,
                treePath: recStruct.treePath,
                hlViewer: this
            };
            if (recStruct.recordFormOverride) {
                actionConfig.recordFormOverride = recStruct.recordFormOverride;
            }
            var action = new Pan.appframework.action.PanViewerWindowAction(actionConfig);
            action.execute();
        }
    }, afterUpdateRecord: function (r) {
        if (r) {
            this.fireEvent('afterUpdateRecord', this.store, [r]);
        }
        this.store.reload();
    }
});
Pan.appframework.modelview.PanHLGroupingGridViewer = Ext.extend(Pan.appframework.modelview.PanGroupingGridViewer, {
    detailViewerTreePath: undefined, initComponent: function () {
        this.addEvents('afterupdaterecord');
        Pan.appframework.modelview.PanHLGroupingGridViewer.superclass.initComponent.apply(this, arguments);
    }, addRecord: function (element, config, event) {
        var detailViewerTreePath = Pan.base.json.path(config, "$.action.initialConfig.detailViewerTreePath") || this.detailViewerTreePath;
        var recStruct = {treePath: detailViewerTreePath};
        if (config && config.recordFormOverride) {
            Ext.apply(recStruct, {recordFormOverride: config.recordFormOverride});
        }
        this.showDetailViewer(recStruct);
    }, editForm: function (record, recordFormOverride, row, col) {
        var recStruct = this.setupRecStruct(record);
        if (recordFormOverride) {
            Ext.applyIf(recStruct, {recordFormOverride: recordFormOverride});
        }
        this.showDetailViewer(recStruct, record);
    }, setupRecStruct: function (record) {
        var recStruct = {};
        if (record && record.store) {
            var nameProperty = record.store.storeInputs.nameIdProperty;
            Ext.apply(recStruct, {name: record.get(nameProperty), treePath: this.detailViewerTreePath});
        }
        return recStruct;
    }, showDetailViewer: function (recStruct, hlRecord) {
        if (recStruct.treePath) {
            var name = recStruct.name;
            var storeConfigOverride = {__hlRecord: hlRecord, additionalInput: {__id: name}};
            if (recStruct.phantom) {
                Ext.apply(storeConfigOverride, {autoLoad: false, allowMultipleRecords: true}, recStruct);
            }
            var actionConfig = {
                afterUpdateRecord: this.afterUpdateRecord.createDelegate(this),
                storeConfigOverride: storeConfigOverride,
                treePath: recStruct.treePath,
                hlViewer: this
            };
            if (recStruct.recordFormOverride) {
                actionConfig.recordFormOverride = recStruct.recordFormOverride;
            }
            var action = new Pan.appframework.action.PanViewerWindowAction(actionConfig);
            action.execute();
        }
    }, afterUpdateRecord: function (r) {
        if (r) {
            this.fireEvent('afterUpdateRecord', this.store, [r]);
        }
        this.store.reload();
    }
});
Pan.appframework.modelview.PanDynamicFieldsViewer = Ext.extend(Pan.appframework.modelview.PanPortletViewer, {
    useToolbarAddAction: false,
    useToolbarDeleteAction: false,
    useToolbarCloneAction: false,
    useCheckBoxSelection: false,
    showButtons: false,
    loadMask: false,
    initComponent: function () {
        Ext.apply(this, {entries: this.initialConfig.data});
        this.addRootField();
        this.addFields();
        Pan.appframework.modelview.PanDynamicFieldsViewer.superclass.initComponent.apply(this, arguments);
    },
    afterRender: function () {
        Pan.appframework.modelview.PanDynamicFieldsViewer.superclass.afterRender.apply(this, arguments);
        this.populateData();
        this.doLayout();
    },
    setDataEntries: function (entries) {
        this.entries = entries;
    },
    populateData: function (_data) {
        var entries = this.entries;
        if (entries) {
            var rec = new this.store.recordType();
            rec.store = this.store;
            rec.data = entries;
            rec.store.data = entries;
            var basicForm = this.getForm();
            basicForm.loadRecord(rec);
        }
    },
    addRootField: function () {
        this.rootField = {name: '$', childrenNames: [], uiHint: {}};
        this.fields = [];
        this.fields.push(this.rootField);
    },
    addFields: function () {
        var entries = this.entries;
        var i = 1;
        while (entries[i]) {
            var fName = entries[i];
            this.fields.push({name: fName});
            this.rootField.childrenNames.push(fName);
            i++;
        }
    },
    recordForm: {cls: '', windowConfig: {width: 400}, items: [{itemId: '$'}]},
    storeConfig: {ztype: Pan.appframework.modelview.PanGridStore},
    onDestroy: function () {
        this.store = null;
        Pan.appframework.modelview.PanDynamicFieldsViewer.superclass.onDestroy.call(this);
    }
});
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MutableRemoteAction = Ext.extend(Pan.base.action.RemoteAction, {
    createHandleResponse: function (element, config, event) {
        return this.handleResponse.createDelegate(this, arguments, true);
    }, handleResponse: function (response, responseEvent, args) {
        var element = args && args[0];
        var config = args && args[1];
        var event = args && args[2];
        var failed = response['@status'] == 'error';
        if (failed) {
            this.postFailedAction(element, config, event, response, responseEvent);
        } else {
            this.postSucceedAction(element, config, event, response, responseEvent);
        }
        if (config.component.store && config.component.store.postWrite) {
            config.component.store.postWrite(!failed);
        } else {
            this.postWrite(!failed);
        }
    }, postSucceedAction: function (element, config, event, response, responseEvent) {
        if (Ext.isFunction(config.postSucceedAction)) {
            config.postSucceedAction.call(config.component, element, config, event, response, responseEvent);
        } else if (Ext.isFunction(this.initialConfig.postSucceedAction)) {
            this.initialConfig.postSucceedAction.call(config.component, element, config, event, response, responseEvent);
        } else {
            this.reload(config.component);
        }
    }, reload: function (component) {
        component.store.reload();
    }, postWrite: function (success) {
        Pan.global.ContextVariables.retrieveConfigChangePending();
    }
});
Pan.appframework.action.GridRemoteAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({handler: this.doAction.createDelegate(this)}, config);
        this.api = config.api;
        newConfig.availConfig = Pan.base.util.integrateArray({
            type: 'HasSelectionAvail', hasSelectionMethod: function () {
                if (this.__listenField) {
                    var selections = this.__listenField.getSelections();
                    if (selections.length > 0) {
                        for (var i = 0; i < selections.length; i++) {
                            var r = selections[i];
                            if (!Pan.appframework.PanAppInterface.isRecordEditable(r) && !newConfig.readOnlyEditable) {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                return false;
            }
        }, newConfig.availConfig);
        Pan.appframework.action.GridRemoteAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, preAction: function (element, config, event) {
        this.action(element, config, event);
    }, action: function (element, config, event) {
        var arrRec = new Array();
        for (var i = 0; i < config.record.length; i++) {
            var rec = config.record[i].json;
            arrRec.push({
                id: rec['@name'],
                vsysName: rec['@__recordInfo'].vsysName ? rec['@__recordInfo'].vsysName : Pan.global.getLoc().val,
                position: rec['@__recordInfo'].position ? rec['@__recordInfo'].position : 'main',
                type: config.component.storeInputs.type,
                xpathId: rec['@__recordInfo'].xpathId
            });
        }
        this.api({records: arrRec}, this.createHandleResponse(element, config, event));
    }, postFailedAction: function (element, config, event, response) {
        var combinedMsg = '';
        for (var i = 0; i < response.failedRecords.length; i++) {
            combinedMsg += '<b>' + response.failedRecords[i].id + ' </b>-- ' + response.failedRecords[i].msg.line;
            if (combinedMsg.length)
                combinedMsg += '<br>';
        }
        config.component.store.reportStatus({
            error: {
                title: _T('Error {type}', {type: config.component.storeInputs.objectType}),
                message: combinedMsg
            }
        });
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        } else {
            config.component.store.reload();
        }
    }, reload: function (component) {
        if (component.isLiveGrid) {
            component.view.updateLiveRows(component.view.rowIndex, true, true, {forceOutOfRange: true});
        } else {
            component.store.reload();
        }
    }
});
Pan.appframework.action.MoveRowAction = Ext.extend(Pan.appframework.action.GridRemoteAction, {
    action: function (element, config, event) {
        var log = PanLogging.getLogger('appframework:action:MutableRemoteAction');
        var parent = config.parent;
        if (parent) {
            parent.close();
        }
        var destinationRecord = config.destinationRecord;
        var whereTo = this.initialConfig.where;
        var store = config.grid.store;
        var record = config.record;
        if (!record) {
            log.error("Record is undefined or null");
            return;
        }
        record.sort(function (a, b) {
            return store.indexOf(a) < store.indexOf(b) ? -1 : 1;
        });
        var i, min = store.indexOf(record[0]), max = store.indexOf(record[record.length - 1]);
        min = store.getRealIndex(min);
        max = store.getRealIndex(max);
        switch (whereTo) {
            case'up':
                whereTo = 'before';
                destinationRecord = store.getAt(min - 1);
                break;
            case'down':
                whereTo = 'after';
                destinationRecord = store.getAt(max + 1);
                record.reverse();
                break;
            case'top':
                record.reverse();
                break;
            case'bottom':
                break;
            case'before':
                break;
            case'after':
                record.reverse();
                break;
            default:
                break;
        }
        if (whereTo == 'before' && (Ext.isEmpty(destinationRecord) || destinationRecord.unmoveable)) {
            Pan.Msg.alert('Move Up', _T('The selected {type}(s) is already at the top.', {type: config.component.storeInputs.objectType}));
            return;
        }
        if (whereTo == 'after' && (Ext.isEmpty(destinationRecord) || destinationRecord.unmoveable)) {
            Pan.Msg.alert('Move Down', _T('The selected {type}(s) is already at the bottom.', {type: config.component.storeInputs.objectType}));
            return;
        }
        var arrRec = new Array();
        for (i = 0; i < config.record.length; i++) {
            var rec = config.record[i].json;
            var recConfig = {
                id: rec['@name'],
                where: whereTo,
                vsysName: rec['@__recordInfo'].vsysName ? rec['@__recordInfo'].vsysName : Pan.global.getLoc().val,
                position: rec['@__recordInfo'].position ? rec['@__recordInfo'].position : 'main',
                type: config.component.storeInputs.type,
                xpathId: rec['@__recordInfo'].xpathId
            };
            if (destinationRecord) {
                var dst = Ext.isObject(destinationRecord) ? store.recordBinder.getNameId(destinationRecord.json) : destinationRecord;
                Ext.apply(recConfig, {dst: dst});
            }
            arrRec.push(recConfig);
        }
        this.api({
            records: arrRec,
            template: Pan.global.getTemplate()
        }, this.createHandleResponse(element, config, event));
    }
});
Pan.appframework.action.MoveBeforeRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move Before'),
            iconCls: 'icon-move-up',
            ref: '../moveBeforeRowAction',
            where: 'before'
        }, config);
        Pan.appframework.action.MoveBeforeRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.appframework.action.MoveAfterRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move After'),
            iconCls: 'icon-move-down',
            ref: '../moveAfterRowAction',
            where: 'after'
        }, config);
        Pan.appframework.action.MoveAfterRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.appframework.action.MoveUpRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move Up'),
            iconCls: 'icon-move-up',
            ref: '../moveUpRowAction',
            where: 'up'
        }, config);
        Pan.appframework.action.MoveUpRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.appframework.action.MoveDownRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move Down'),
            iconCls: 'icon-move-down',
            ref: '../moveDownRowAction',
            where: 'down'
        }, config);
        Pan.appframework.action.MoveDownRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.appframework.action.MoveTopRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move Top'),
            iconCls: 'icon-move-to-top',
            ref: '../moveTopRowAction',
            where: 'top'
        }, config);
        Pan.appframework.action.MoveTopRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.appframework.action.MoveBottomRowAction = Ext.extend(Pan.appframework.action.MoveRowAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Move Bottom'),
            iconCls: 'icon-move-to-bottom',
            ref: '../moveBottomRowAction',
            where: 'bottom'
        }, config);
        Pan.appframework.action.MoveBottomRowAction.superclass.constructor.call(this, cfg);
    }
});
Pan.areg("moveBeforeRowAction", Pan.appframework.action.MoveBeforeRowAction);
Pan.areg("moveAfterRowAction", Pan.appframework.action.MoveAfterRowAction);
Pan.areg("moveUpRowAction", Pan.appframework.action.MoveUpRowAction);
Pan.areg("moveDownRowAction", Pan.appframework.action.MoveDownRowAction);
Pan.areg("moveTopRowAction", Pan.appframework.action.MoveTopRowAction);
Pan.areg("moveBottomRowAction", Pan.appframework.action.MoveBottomRowAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.ActionMgr = (function () {
    var permissionAvail = {
        match: {
            evaluate: function () {
                var record, rbaPath;
                var ownerCt = this.__component;
                while (ownerCt) {
                    if (ownerCt.__pdefaults) {
                        record = ownerCt.__pdefaults.__recordFormRecord;
                        rbaPath = ownerCt.__pdefaults.__rbaPath;
                        break;
                    }
                    if (ownerCt.rbaPath) {
                        rbaPath = ownerCt.rbaPath;
                    }
                    ownerCt = ownerCt.ownerCt;
                }
                if (this.__component.permission === 'read') {
                    return Pan.appframework.PanAppInterface.hasReadPermission(rbaPath, record);
                }
                if (Pan.appframework.PanAppInterface.isSingleVsysNotDefaultVsys(rbaPath)) {
                    this.__component.baseAction.setTooltip(_T('You need to assign a default VSYS to current template first.'));
                }
                return Pan.appframework.PanAppInterface.hasEditPermission(rbaPath, record);
            }
        }
    };
    Pan.setActionAvail('addRecordAction', permissionAvail);
    Pan.setActionAvail('deleteRecordAction', permissionAvail);
    Pan.setActionAvail('cloneRecordAction', permissionAvail);
    Pan.setActionAvail('addGroupRecordAction', permissionAvail);
    Pan.setActionAvail('deleteGroupRecordAction', permissionAvail);
    Pan.setActionAvail('moveUpRecordAction', permissionAvail);
    Pan.setActionAvail('moveDownRecordAction', permissionAvail);
    Pan.setActionAvail('moveBeforeRowAction', permissionAvail);
    Pan.setActionAvail('moveAfterRowAction', permissionAvail);
    Pan.setActionAvail('moveUpRowAction', permissionAvail);
    Pan.setActionAvail('moveDownRowAction', permissionAvail);
    Pan.setActionAvail('moveTopRowAction', permissionAvail);
    Pan.setActionAvail('moveBottomRowAction', permissionAvail);
    return {
        getPermissionAvail: function (config) {
            var rv = permissionAvail;
            if (config) {
                rv = Ext.apply({}, config, rv);
            }
            return rv;
        }, setupToolbar: function (scope, defaultCfg, extraActions) {
            var cfg = defaultCfg || {};
            var defaultActions = {
                addAction: {atype: 'addRecordAction', handler: scope.addRecord},
                deleteAction: {atype: 'massDeleteAction'},
                cloneAction: {atype: 'massCloneAction'},
                cloneMultiAction: {atype: 'multiCloneAction'},
                importAction: {atype: 'importRecordAction'},
                exportAction: {atype: 'exportRecordAction'},
                exportGridAction: {atype: 'exportGridAction'}
            };
            var actions = Ext.apply(defaultActions, cfg);
            var toolbar = [];
            if (scope.useToolbarAddAction) {
                toolbar.push(actions.addAction);
            }
            if (scope.useToolbarDeleteAction) {
                toolbar.push(actions.deleteAction);
            }
            if (scope.useToolbarCloneAction) {
                if (scope.useMultiCloneAction)
                    toolbar.push(actions.cloneMultiAction); else
                    toolbar.push(actions.cloneAction);
            }
            if (scope.useToolbarImportAction) {
                toolbar.push(actions.importAction);
            }
            if (scope.useToolbarExportAction || scope.useToolbarExportGridAction) {
                if (scope.useToolbarExportAction) {
                    toolbar.push((actions.exportAction));
                }
                if (scope.useToolbarExportGridAction) {
                    toolbar.push((actions.exportGridAction));
                }
            }
            if (!Ext.isEmpty(extraActions)) {
                for (var i = 0; i < extraActions.length; i++) {
                    if (Ext.isDefined(extraActions[i].placement)) {
                        var j = -1;
                        if (extraActions[i].placement !== '') {
                            for (j = 0; j < toolbar.length; j++) {
                                if (toolbar[j].atype === extraActions[i].placement) {
                                    break;
                                }
                            }
                        }
                        toolbar.splice(j + 1, 0, extraActions[i]);
                    }
                    else {
                        toolbar.push(extraActions[i]);
                    }
                }
            }
            return toolbar;
        }
    };
}());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.AddRemoteRecordAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        var theTreePath = config.treePath;
        if (Ext.isFunction(theTreePath)) {
            theTreePath = theTreePath();
        }
        var isCrossRefBetweenDGandTemplate = theTreePath && ((Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop() && theTreePath.indexOf('Objects/') >= 0) || (Pan.common.PanConfigStates.prototype.isShowingVsysComboOnTop() && Pan.global.isCmsSelected() && theTreePath.indexOf('Device/') >= 0));
        if (isCrossRefBetweenDGandTemplate) {
            if (config.editorComponent && config.editorComponent.menuActions) {
                config.editorComponent.title = undefined;
                config.editorComponent.header = undefined;
                config.availConfig = {
                    processAfterRender: true, match: {
                        evaluate: function () {
                            return false;
                        }
                    }, availHide: true
                };
                Pan.appframework.action.AddRemoteRecordAction.superclass.constructor.call(this, config);
            }
        } else {
            if (Pan.global.isCmsSelected()) {
                if (config.editorComponent.title == undefined) {
                    config.editorComponent.title = _T("hasstuff");
                }
                if (config.editorComponent.header == undefined) {
                    var cls = 'x-combo-list';
                    config.editorComponent.header = config.editorComponent.list.createChild({cls: cls + '-hd'});
                }
            }
            Pan.appframework.action.AddRemoteRecordAction.superclass.constructor.call(this, Ext.apply({
                text: _T('New'),
                iconCls: undefined,
                ref: '../addRemoteRecordAction',
                handler: this.doAction.createDelegate(this)
            }, config));
        }
    }, doAction: function (element, config, event) {
        this.component = (config && config.component) || element.editorComponent;
        if (this.component.stopEditing) {
            this.component.stopEditing();
        }
        var theTreePath = this.initialConfig.treePath;
        if (Ext.isFunction(theTreePath)) {
            theTreePath = theTreePath();
        }
        var c = {
            treePath: theTreePath,
            detailViewerTreePath: this.initialConfig.detailViewerTreePath,
            element: element
        };
        if (this.initialConfig.recordFormPostLoadChangeConfig) {
            Ext.applyIf(c, this.initialConfig.componentConfig);
            Ext.apply(c, {
                recordFormOverride: {
                    recordFormPostLoadChangeConfig: this.initialConfig.recordFormPostLoadChangeConfig,
                    recordFormPostLoadChangeCopyFromDataExtractor: this.component.__pdefaults.__dataExtractor,
                    recordFormPostCreateCallback: this.initialConfig.recordFormPostCreateCallback,
                    sourceComponent: this,
                    recordFormPostLoadChangeCallback: function (gridRecordForm) {
                        var copyFromDataExtractor = gridRecordForm.recordForm.recordFormPostLoadChangeCopyFromDataExtractor;
                        var copyToDataExtractor = gridRecordForm.__pdefaults.__dataExtractor;
                        var changeConfigs = gridRecordForm.recordForm.recordFormPostLoadChangeConfig;
                        changeConfigs = Pan.base.util.integrateArray([], changeConfigs);
                        for (var i = 0; i < changeConfigs.length; i++) {
                            var changeConfig = changeConfigs[i];
                            var data;
                            if (changeConfig.copyFromPath) {
                                data = copyFromDataExtractor(changeConfig.copyFromPath);
                            }
                            if (changeConfig.copyFromData) {
                                if (Ext.isFunction(changeConfig.copyFromData)) {
                                    data = changeConfig.copyFromData(data, {
                                        copyToDataExtractor: copyToDataExtractor,
                                        copyFromDataExtractor: copyFromDataExtractor
                                    });
                                } else {
                                    data = changeConfig.copyFromData;
                                }
                            }
                            var field = copyToDataExtractor(changeConfig.copyToPath, "");
                            if (changeConfig.afterCopyProcessing) {
                                changeConfig.afterCopyProcessing.call(this.component, data, field, gridRecordForm);
                            }
                            field.setValue(data);
                            if (changeConfig.disabled) {
                                field.disabled = true;
                                field.initialConfig = field.initialConfig || {};
                                field.initialConfig.disabled = true;
                                field.setIsAvail(false);
                            }
                        }
                    }.createDelegate(this)
                }
            });
        }
        var rbaPath = this.rbaPath || this.initialConfig.rbaPath;
        if (rbaPath) {
            c.rbaPath = rbaPath;
        }
        Pan.appframework.schema.PanSchemaRepository.readSchema(theTreePath, this.displayUI, this, c);
    }, displayUI: function (config) {
        var panGridViewer = Pan.create(config);
        var addListener = function (viewerStore, records) {
            panGridViewer.purgeListeners();
            panGridViewer.store.purgeListeners();
            var addedRecordNameId = [];
            for (var i = 0; i < records.length; i++) {
                addedRecordNameId.push(viewerStore.recordBinder.getNameId(records[i].json));
            }
            var component = this.component;
            if (component.getRealField) {
                component = component.getRealField();
            }
            var store = component.store;
            var editorComponentStore;
            if (Ext.isFunction(component.addSelection)) {
                if (this.initialConfig.recordFieldName) {
                    component.addSelection(addedRecordNameId, {recordFieldName: this.initialConfig.recordFieldName});
                } else {
                    component.addSelection(addedRecordNameId, {replaceSelection: this.initialConfig.replaceSelection});
                }
                if (this.initialConfig.editorComponent && this.initialConfig.editorComponent.isAnEditor) {
                    this.initialConfig.editorComponent.clearValueEx(false, true);
                    editorComponentStore = this.initialConfig.editorComponent.store;
                }
            }
            if (Ext.isFunction(component.updateExtraInfo)) {
                component.updateExtraInfo(records, component);
            }
            var reloadingStore = !store.localStore && store.isStoreLoaded;
            if (component.scrollTo) {
                var firstRecordNameId = addedRecordNameId.length > 0 && addedRecordNameId[0];
                if (store.localStore) {
                    component.scrollTo(firstRecordNameId);
                } else {
                    if (reloadingStore) {
                        store.addListener("afterload", function (store, records) {
                            store.removeListener("afterload", arguments.callee, this);
                            Pan.base.util.invokeLater(100, component.scrollTo, component, [firstRecordNameId]);
                        }, this);
                    }
                }
            }
            if (config && config.recordFormOverride && config.recordFormOverride.recordFormPostCreateCallback) {
                config.recordFormOverride.recordFormPostCreateCallback.call(config.sourceComponent, component, records);
            }
            if (reloadingStore) {
                store.reload();
            } else if (editorComponentStore) {
                if (!editorComponentStore.localStore && editorComponentStore.isStoreLoaded) {
                    editorComponentStore.reload();
                }
            }
        };
        if (panGridViewer.hasEvent('afterupdaterecord')) {
            panGridViewer.addListener("afterupdaterecord", addListener, this);
        } else {
            panGridViewer.store.addListener("add", addListener, this);
        }
        panGridViewer.addRecord(config.element);
    }
});
Pan.areg("addRemoteRecordAction", Pan.appframework.action.AddRemoteRecordAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.EditRemoteRecordAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        Pan.appframework.action.EditRemoteRecordAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Edit'),
            iconCls: undefined,
            ref: '../EditRemoteRecordAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.component = config ? config.component : element.editorComponent;
        if (this.component.stopEditing) {
            this.component.stopEditing();
        }
        var c = {
            treePath: this.initialConfig.treePath,
            detailViewerTreePath: this.initialConfig.detailViewerTreePath,
            element: element,
            configInitial: config,
            recordFormOverride: {renameable: false}
        };
        var rbaPath = this.rbaPath || this.initialConfig.rbaPath;
        if (rbaPath) {
            c.rbaPath = rbaPath;
        }
        Pan.appframework.schema.PanSchemaRepository.readSchema(this.initialConfig.treePath, this.displayUI, this, c);
    }, displayUI: function (config) {
    }
});
Pan.areg("editRemoteRecordAction", Pan.appframework.action.EditRemoteRecordAction);
(function () {
    var createRowActionColumn = Pan.base.grid.createRowActionColumn;
    var SelectAction = Ext.extend(Pan.base.action.RemoteAction, {
        constructor: function (config) {
            config = _.merge({
                text: _T('Browse'),
                iconCls: 'icon-browse',
                drawerConfig: {side: 'w', animate: true, title: '', plain: true, layout: 'fit', closable: true},
                gridConfig: {
                    xtype: 'pan-grid', filterStateFul: false, preInit: function (gridPanel) {
                        var column = createRowActionColumn(gridPanel, {
                            width: 35, actions: [Pan.createAction({
                                iconCls: 'icon-select',
                                tooltip: _T('Select this object'),
                                callback: function (grid, record) {
                                    var targetStore = grid.target.store;
                                    var targetKeyFieldName = targetStore.fields.items[0].name;
                                    var selectedKeyValue = getSelectedRowKeyValue(grid, record);
                                    var targetId = lookupRowId(targetKeyFieldName, selectedKeyValue, targetStore) || addNewRecord(targetKeyFieldName, selectedKeyValue, targetStore);
                                    grid.target.scrollTo(targetId, true);

                                    function getSelectedRowKeyValue(grid, record) {
                                        var selectedIdName = grid.store.fields.items[0].name;
                                        return record.get(selectedIdName);
                                    }

                                    function lookupRowId(fieldName, value, store) {
                                        var id;
                                        store.each(function (r) {
                                            if (r.get(fieldName) === selectedKeyValue) {
                                                id = r.id;
                                                return false;
                                            }
                                        });
                                        return id;
                                    }

                                    function addNewRecord(keyFieldName, value, store) {
                                        var newRecord = store.beginAdd();
                                        newRecord.set(keyFieldName, value);
                                        store.add(newRecord);
                                        return newRecord.id;
                                    }
                                }
                            }, gridPanel)]
                        });
                        gridPanel.columns.push(column);
                    }, viewConfig: {scrollOffset: Pan.base.Constants.scrollOffset}
                },
                handler: this.doAction.createDelegate(this)
            }, config);
            SelectAction.superclass.constructor.call(this, config);
        }, doAction: function (container, context) {
            if (!this.browseWindow) {
                this.browseWindow = this.createBrowseWindow(container, context);
            }
            this.browseWindow.show();
        }, createBrowseWindow: function (grid, context) {
            this.initialConfig.gridConfig.__pdefaults = context.component.__pdefaults;
            var browseGrid = Ext.create(this.initialConfig.gridConfig);
            browseGrid.target = grid;
            var recordFormWindow = this.getRecordForm().window;
            var drawerConfig = this.initialConfig.drawerConfig;
            if (!drawerConfig.height) {
                drawerConfig.height = recordFormWindow.getBox().height;
            }
            var drawer = new Pan.base.container.Drawer(Ext.apply(drawerConfig, {items: [browseGrid]}));
            drawer.attachTo(recordFormWindow);
            return drawer;
        }, getRecordForm: function () {
            var ownerCt = this.items[0].ownerCt;
            while (ownerCt.ownerCt) {
                ownerCt = ownerCt.ownerCt;
            }
            return ownerCt.items.items[0];
        }
    });
    Pan.areg('selectAction', SelectAction);
}());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.CollapseAllAction = Ext.extend(Pan.base.action.Action, {
    expandAll: false, constructor: function (config) {
        if (Ext.isDefined(config.expandAll)) {
            this.expandAll = config.expandAll;
        }
        var newConfig = Ext.apply({
            text: config.expandAll ? _T('Expand All') : _T('Collapse All'),
            iconCls: config.expandAll ? 'icon-expand-all' : 'icon-collapse-all',
            ref: '../collapseAllAction',
            handler: this.doAction.createDelegate(this),
            avail: {
                listenToAfterInit: false, match: {
                    evaluate: '&&', operands: [{
                        evaluate: function () {
                            return this.__listenField.getCount() === this.__listenField.getSnapshot().getCount();
                        }
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: config.event || ['add', 'remove', 'datachanged'],
                            field: config.field,
                            observableCallChain: 'findParentByInstanceof(Ext.grid.GridPanel).store'
                        }]
                    }]
                }
            }
        }, config);
        Pan.appframework.action.CollapseAllAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        if (element) {
            if (this.expandAll && element.expandAll) {
                element.expandAll();
            } else if (element.collapseAll) {
                element.collapseAll();
            }
        }
    }
});
Pan.areg("collapseAllAction", Pan.appframework.action.CollapseAllAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.ExternalURLAddAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.appframework.action.ExternalURLAddAction.superclass.constructor.call(this, Ext.apply({
            text: _T('New'),
            iconCls: undefined,
            ref: '../externalURLAddAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.component = config ? config.component : element.editorComponent;
        if (this.component.stopEditing) {
            this.component.stopEditing();
        }
        if (this.component.collapse) {
            this.component.collapse();
        }
        this.modalWin();
    }, modalWin: function () {
        Pan.base.util.openModalWindow(this.initialConfig.showModalDialog, this.initialConfig.windowName, this.initialConfig.dialogWidth, this.initialConfig.dialogHeight);
        this.component.store.reload();
    }
});
Pan.areg("externalURLAddAction", Pan.appframework.action.ExternalURLAddAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.AddLocalRecordAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        Pan.appframework.action.AddLocalRecordAction.superclass.constructor.call(this, Ext.apply({
            text: _T('New'),
            iconCls: undefined,
            ref: '../addLocalRecordAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config, event) {
        this.component = config ? config.component : element.editorComponent;
        if (this.component.stopEditing) {
            this.component.stopEditing();
        }
        var c = {localFieldName: this.initialConfig.localFieldName, element: element};
        this.displayUI(c);
    }, displayUI: function (config) {
        var grid = this.component.__pdefaults.__dataExtractor(this.initialConfig.localFieldName, "");
        grid.store.addListener("add", function (viewerStore, records) {
            grid.store.removeListener("add", arguments.callee, this);
            var addedRecordNameId = [];
            for (var i = 0; i < records.length; i++) {
                addedRecordNameId.push(records[i].get(viewerStore.idProperty));
            }
            var component = this.component;
            if (component.getRealField) {
                component = component.getRealField();
            }
            var store = component.store;
            if (Ext.isFunction(component.addSelection)) {
                if (this.initialConfig.editorComponent) {
                    this.initialConfig.editorComponent.clearValueEx(false, true);
                }
                if (this.initialConfig.recordFieldName) {
                    component.addSelection(addedRecordNameId, {recordFieldName: this.initialConfig.recordFieldName});
                } else {
                    component.addSelection(addedRecordNameId, {replaceSelection: this.initialConfig.replaceSelection});
                }
            }
        }, this);
        var handler = grid.addRecordAction.handler;
        handler.call(this, handler, handler);
    }
});
Pan.areg("addLocalRecordAction", Pan.appframework.action.AddLocalRecordAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.AddHLRecordAction = Ext.extend(Pan.base.grid.AddRecordAction, {
    preAction: function (element, config, event) {
    }, action: function (element, config, event) {
        var grid = config.grid;
        if (this.initialConfig.recordFormPostLoadChangeConfig) {
            var selected = grid.getSelectionModel().getSelected();
            if (selected) {
                config = Ext.apply({}, {
                    recordFormOverride: {
                        recordFormPostLoadChangeConfig: this.initialConfig.recordFormPostLoadChangeConfig,
                        recordFormPostLoadChangeCallback: function (gridRecordForm) {
                            var copyToDataExtractor = gridRecordForm.__pdefaults.__dataExtractor;
                            var changeConfigs = gridRecordForm.recordForm.recordFormPostLoadChangeConfig;
                            changeConfigs = Pan.base.util.integrateArray([], changeConfigs);
                            for (var i = 0; i < changeConfigs.length; i++) {
                                var changeConfig = changeConfigs[i];
                                var data;
                                if (changeConfig.copyFromPath) {
                                    data = selected.get(changeConfig.copyFromPath);
                                }
                                if (changeConfig.copyFromData) {
                                    if (Ext.isFunction(changeConfig.copyFromData)) {
                                        data = changeConfig.copyFromData(data);
                                    } else {
                                        data = changeConfig.copyFromData;
                                    }
                                }
                                var field = copyToDataExtractor(changeConfig.copyToPath, "");
                                field.setValue(data);
                                if (changeConfig.disabled) {
                                    field.setIsAvail(false);
                                }
                            }
                        }
                    }
                }, config);
            }
        }
        config.grid.addRecord.call(config.grid, element, config, event);
    }
});
Pan.areg("addHLRecordAction", Pan.appframework.action.AddHLRecordAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.BrowseAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        config = config || {};
        this.addAvail({
            match: {
                evaluate: function () {
                    var supportBrowse = true;
                    var ownerCt = this.__component;
                    while (ownerCt) {
                        if (Ext.isDefined(ownerCt.supportBrowse)) {
                            supportBrowse = ownerCt.supportBrowse;
                            break;
                        }
                        ownerCt = ownerCt.ownerCt;
                    }
                    return supportBrowse;
                }
            }, availHide: true
        });
        if (config.scope.drawer && config.scope.drawer.avail) {
            config.availConfig = Pan.base.util.integrateArray(config.availConfig, config.scope.drawer.avail);
        }
        Pan.appframework.action.BrowseAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Browse'),
            iconCls: 'icon-browse',
            ref: '../browseAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    }, doAction: function (element, config) {
        if (!this.component) {
            this.component = config.component;
            var drawerCfg = this.component.drawer;
            Pan.appframework.schema.PanSchemaRepository.readSchema(drawerCfg.treePath, this.createDrawer, this, Ext.apply({
                target: this.component,
                element: element
            }, drawerCfg));
        }
        else if (this.component.drawer.multiDrawers) {
        }
        var drawerId = config.component.drawer.itemId || config.component.drawer.treePath ? (config.component.drawer.itemId || config.component.drawer.treePath) + "_Drawer" : 'w';
        var rf = this.getRecordForm();
        var wb = rf.window.getBox();
        var db = rf.window.drawers[drawerId].getBox();
        if (this.initialConfig.sameHeight) {
            rf.window.drawers[drawerId].setHeight(wb.height);
        }
        var ydelta = wb.y - (db.height - wb.height);
        if (ydelta > 0) {
            ydelta = 0;
        }
        var xdelta = wb.x - db.width;
        if (xdelta > 0) {
            xdelta = 0;
        }
        if (xdelta < 0 || ydelta < 0) {
            rf.window.setPosition(wb.x - xdelta, wb.y - ydelta);
            rf.window.drawers[drawerId].setPosition(db.x - xdelta, db.y - ydelta);
        }
        rf.window.drawers[drawerId].show();
    }, createDrawer: function (cfg) {
        cfg.theme = Pan.base.Constants.uiThemes[1];
        var notifier = cfg.notifier || function (config) {
            var target = cfg.target;
            var record = config.record;
            var name = record.get('name');
            var store = target.store;
            var rec = store.beginAdd();
            var fieldName = rec.fields.items[0].name;
            var existed = false;
            store.each(function (r) {
                if (r.get(fieldName) == name) {
                    existed = true;
                    target.scrollTo(r.id, true);
                    return false;
                }
            });
            if (!existed) {
                rec.set(fieldName, name);
                store.add(rec);
                target.scrollTo(rec.id, true);
            }
        };
        cfg.browseNotifier = {
            iconCls: 'icon-select',
            tooltip: _T('Select this object'),
            handler: function (grid, config) {
                config.target = cfg.target;
                notifier(config);
            },
            scope: this
        };
        var viewer = Pan.create(cfg);
        var itemId = cfg.itemId;
        if (!itemId) {
            itemId = viewer.treePath;
        }
        var drawer = new Pan.base.container.Drawer({
            width: cfg.width,
            height: cfg.height,
            side: cfg.side || 'w',
            animate: cfg.animate === undefined ? true : cfg.animate,
            plain: true,
            layout: 'fit',
            closable: true,
            title: cfg.title || '',
            id: itemId + '_Drawer',
            itemId: itemId + '_Drawer',
            items: viewer
        });
        var rf = this.getRecordForm();
        drawer.attachTo(rf.window);
    }, getRecordForm: function () {
        var ownerCt = this.component;
        while (ownerCt.ownerCt) {
            ownerCt = ownerCt.ownerCt;
        }
        return ownerCt.items.items[0];
    }
});
Pan.areg("browseAction", Pan.appframework.action.BrowseAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MultiRemoteAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    selectCurrentVsysOnInitialLoad: true, extraUIItems: undefined, displayUI: function (element, config) {
        var formItems = [];
        config.recordsInfo = {};
        config.submitInProgress = false;
        formItems.push({
            xtype: "pan-grid",
            sm: new Ext.grid.RowSelectionModel({singleSelect: true}),
            height: 150,
            supportFastRender: false,
            hasAdjustColumnMenu: false,
            id: 'multiSelectedRecordsGrid',
            forceFit: true,
            fieldLabel: _T('Selected') + " " + ((this.initialConfig.objectType) ? this.initialConfig.objectType : _T('Objects')),
            columns: [{dataIndex: 'name', header: _T("Name"), width: 60}, {
                dataIndex: 'location',
                header: _T("Location"),
                hidden: !(Pan.global.isCmsSelected() || Pan.global.isMultiVsys()),
                renderer: function (val) {
                    if (val.indexOf('Panorama') != -1) {
                        return "Panorama";
                    }
                    return val;
                },
                width: 60
            }],
            store: {
                ztype: Pan.base.autorender.GridRecordStore,
                zconfig: {
                    fields: [{name: 'name', type: 'string'}, {name: 'location', type: 'string'}, {
                        name: 'xpathId',
                        type: 'string'
                    }], localStore: true, reader: Ext.extend(Ext.data.JsonReader, {})
                }
            },
            hasGridFilter: false,
            miniCellRowLines: false,
            loadMask: true,
            stripeRows: true
        });
        if (Pan.global.isCmsSelected()) {
            formItems.push({
                xtype: 'Pan.common.component.DGComboRecordForm',
                id: 'destinationVsysMultiAction',
                fieldLabel: _T('Destination'),
                selectCurrentVsysOnInitialLoad: this.selectCurrentVsysOnInitialLoad,
                listeners: {
                    select: function (combo) {
                        var parentForm = combo.findParentByType('pan-window');
                        var destinationType = parentForm.findById('destinationType');
                        if (config.actionElement.atype === 'multiRuleMoveAction' && destinationType) {
                            if (Pan.global.getLocVal() !== combo.value) {
                            } else {
                                if (Pan.appframework.PanAppInterface.isSelectedTreeNode('pre-rules')) {
                                    destinationType.setValue('post', true);
                                } else if (Pan.appframework.PanAppInterface.isSelectedTreeNode('post-rules')) {
                                    destinationType.setValue('pre', true);
                                }
                            }
                        }
                    }
                }
            });
        } else if (Pan.global.isMultiVsys()) {
            formItems.push({
                xtype: 'pan-viewer-vsyscombo',
                id: 'destinationVsysMultiAction',
                fieldLabel: _T('Destination'),
                showShared: true,
                disableSwitchVsys: true,
                includeShared: config.includeShared,
                locationFilter: this.locationFilter,
                getData: function (treeMenuBranch) {
                    Ext.applyIf(this, new Pan.common.PanConfigStates().getVsysComboConfig());
                    return Pan.common.PanConfigStates.prototype.getVsysDataArray(this.showAllVsysAsOption, this.includeVsys, this.includeSharedGateway, this.includeDeviceGroup, this.includeShared, this.locationFilter, treeMenuBranch);
                }
            });
        }
        if (!Ext.isEmpty(this.extraUIItems)) {
            formItems = formItems.concat(this.extraUIItems);
        }
        formItems.push({
            xtype: 'pan-checkbox',
            fieldLabel: _T('Error out on first detected error in validation'),
            value: true
        });
        var formPanel = {
            xtype: 'pan-form',
            id: 'moveCloneForm',
            cls: 'darkblue',
            autoHeight: true,
            monitorValid: true,
            bodyStyle: 'padding:10px',
            defaults: {anchor: '100%'},
            items: formItems,
            buttons: [{
                text: _T('OK'), cls: 'default-btn', formBind: true, handler: function (btn) {
                    var win = btn.findParentByType('pan-window');
                    config.action.okCallback(element, config, win);
                }
            }, {
                text: _T('Cancel'), handler: function (btn) {
                    var win = btn.findParentByType('pan-window');
                    win.close();
                }
            }]
        };

        function loadRuleList(result, config, form) {
            var recordName;
            var ruleCardOrder = form.findByItemId('rule-order');
            var ruleListCombo = form.findById('ruleListCombo');
            if (result['@status'] == "success") {
                var entriesAr = result['result']['entry'];
                var ruleNameList = [];
                Ext.each(entriesAr, function (entry) {
                    ruleNameList.push([entry['@name']]);
                });
                var ruleListStore = ruleListCombo.getStore();
                ruleListStore.loadData(ruleNameList);
                var destinationVsysCombo = form.findById('destinationVsysMultiAction');
                var selectedVsys = destinationVsysCombo ? destinationVsysCombo.getValue() : 'vsys1';
                if (config.action.initialConfig.atype === "multiRuleCloneAction" && Pan.global.getLocVal() === selectedVsys) {
                    ruleCardOrder.setValue("after");
                    var lastSelectedRecord = (config.record) ? config.record[config.record.length - 1] : undefined;
                    if (lastSelectedRecord) {
                        if (lastSelectedRecord.json['@__recordInfo'].xpathId == 'panorama') {
                            ruleCardOrder.setValue("bottom");
                        } else {
                            if (ruleListStore.data.items.length === 0) {
                                ruleCardOrder.setValue("bottom");
                            } else {
                                recordName = ruleListStore.data.items[0].json[0];
                                ruleListCombo.setValue(recordName);
                                ruleListCombo.setRawValue(recordName);
                            }
                        }
                    }
                } else {
                    var firstVal = (ruleListStore.getAt(0)) ? ruleListStore.getAt(0).data['ruleName'] : '';
                    ruleListCombo.setValue(firstVal);
                    ruleListCombo.setRawValue(firstVal);
                    ruleListCombo.selectedIndex = 0;
                }
            }
        }

        var win = new Pan.base.container.Window({
            width: 450,
            title: this.actionText,
            layout: 'fit',
            autoHeight: true,
            border: false,
            modal: true,
            layoutConfig: {animate: true},
            items: [formPanel]
        });
        win.show();
        var selectedObjectsStore = win.findById('multiSelectedRecordsGrid').getStore();
        var ruleOrderComp = win.findByItemId('rule-order');
        if (ruleOrderComp)
            ruleOrderComp.setValue("");
        selectedObjectsStore.loadData(config.selectedRecords, true);
        selectedObjectsStore.commitChanges();
    }, okCallback: function (element, config, win) {
        if (config.submitInProgress)
            return;
        var parentForm = win.findByType('pan-form')[0];
        var selectedObjsByLoc = {};
        for (var i = 0; i < config.selectedRecords.length; i++) {
            var rec = config.selectedRecords[i];
            var loc = rec['location'];
            if (selectedObjsByLoc[loc]) {
                if (selectedObjsByLoc[loc]['members'])
                    selectedObjsByLoc[loc]['members'].push(rec['name']); else {
                    selectedObjsByLoc[loc]['members'] = [];
                    selectedObjsByLoc[loc]['members'].push(rec['name']);
                }
                selectedObjsByLoc[loc]['xpathId'] = rec['xpathId'];
            } else {
                selectedObjsByLoc[loc] = {};
                if (selectedObjsByLoc[loc]['members'])
                    selectedObjsByLoc[loc]['members'].push(rec['name']); else {
                    selectedObjsByLoc[loc]['members'] = [];
                    selectedObjsByLoc[loc]['members'].push(rec['name']);
                }
                selectedObjsByLoc[loc]['xpathId'] = rec['xpathId'];
            }
        }
        config.recordsInfo.selectedObjsByLoc = selectedObjsByLoc;
        if (Pan.global.isCmsSelected() || Pan.global.isMultiVsys()) {
            config.recordsInfo.toVsys = parentForm.findById('destinationVsysMultiAction').getValue();
        } else {
            config.recordsInfo.toVsys = Pan.global.getLocVal();
        }
        config.recordsInfo.errorOutFirst = parentForm.findByType('pan-checkbox')[0].getValue();
        config.submitInProgress = true;
        config.action.action(win, config);
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
        this.displayUI(element, config);
    }, postSucceedAction: function (element, config, event, response, responseEvent) {
        Pan.appframework.action.MultiRemoteAction.superclass.postSucceedAction.call(this, element, config, event, response, responseEvent);
        config.submitInProgress = false;
        element.close();
    }, postFailedAction: function (element, config, event, response) {
        var templateStr = '';
        var actionText = (config.action.initialConfig.text == "Move") ? "moving" : ((config.action.initialConfig.text == "Clone") ? "cloning" : "");
        config.submitInProgress = false;
        if (response.failedRecords) {
            if (response['pre-move-fail'] && response['post-move-fail'] && response['post-move-fail'] == "yes" && response['pre-move-fail'] == "yes")
                templateStr += config.action.initialConfig.text + ' failed due to references in both source and destination locations' + '<br>'; else if (response['post-move-fail'] && response['post-move-fail'] == "yes")
                templateStr += config.action.initialConfig.text + ' failed due to references in destination location' + '<br>'; else if (response['pre-move-fail'] && response['pre-move-fail'] == "yes")
                templateStr += config.action.initialConfig.text + ' failed due to references in current location' + '<br>';
            templateStr += 'Selected ' + config.component.storeInputs.objectType.toLowerCase() + '(s): ' + config.selectedRecords.length + '<br>';
            templateStr += 'Failed ' + config.component.storeInputs.objectType.toLowerCase() + '(s): ' + response['obj-failed-count'] + '<br><br>';
            templateStr += '<tpl for="failedRecords">';
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">\n<br>&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">\n{line}</tpl>\n';
            } else {
                templateStr += '{msg}\n';
            }
            templateStr += '</tpl>';
        } else {
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">{.}<br></tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">{line}</tpl>\n';
            } else {
                templateStr += '{msg}';
            }
            templateStr += '</tpl>';
        }
        var errResTemplate = new Ext.XTemplate(templateStr, {compiled: true});
        var msg = errResTemplate.apply(response);
        config.component.store.reportStatus({
            error: {
                title: _T("Error") + " " + actionText + " " + config.component.storeInputs.objectType + ' to ' + config.recordsInfo.toVsys,
                message: msg,
                resizableAlert: true
            }
        });
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        }
    }
});
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MassDeleteAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    actionText: _T('delete'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Delete'),
            iconCls: 'icon-delete',
            ref: '../massDeleteAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray([{
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.MassDeleteAction.superclass.constructor.call(this, newConfig);
        this.setupRecord = config.setupRecord || function (rec, recToSend, config) {
            var secondKeyPath = config.grid.storeInputs.secondKeyPath;
            if (secondKeyPath && rec[secondKeyPath] && rec[secondKeyPath]['@name'])
                recToSend.secondKey = rec[secondKeyPath]['@name'];
            var thirdKeyPath = config.grid.storeInputs.thirdKeyPath;
            if (thirdKeyPath && rec[thirdKeyPath] && rec[thirdKeyPath]['@name'])
                recToSend.thirdKey = rec[thirdKeyPath]['@name'];
        };
    }, availEvaluationAfterChange: function () {
        var selModel = undefined;
        try {
            if (this.__component.callChainPrepend) {
                selModel = Pan.callChain(this.__component, this.__component.callChainPrepend + ".getSelectionModel");
            }
            if (!selModel) {
                selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
            }
        } catch (ex) {
        }
        var available = false;
        var selected = selModel ? selModel.getSelections() : Pan.objects.app.AppViewer.prototype.getSelectedRecords();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (Pan.appframework.renderer.isTemplateRec(r) || Pan.appframework.renderer.isTemplateOverrideRec(r, r.store) || Pan.appframework.renderer.isTSTemplateRec(r) || Pan.appframework.renderer.isTSOverrideRec(r, r.store) || Pan.appframework.renderer.isDGOverrideRec(r) || Pan.appframework.renderer.isParentDGRec(r) || (Pan.objects.app.isDGOverrideRec(r) || Pan.objects.app.isParentDGRec(r))) {
                    available = false;
                    break;
                } else if (r.json && r.json['@__recordInfo'] && r.json['@__recordInfo'].permission === 'readonly') {
                    available = false;
                    break;
                }
                else if (r.__treeChildrenCount) {
                    available = false;
                    break;
                }
                else if (r.store && r.store.excludeLeafDG) {
                    if (!r.get("serial") && !r.get("$.serial")) {
                        available = false;
                        break;
                    }
                }
            }
        }
        return available;
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, getWarningMessage: function (element, config, event) {
        return _T("Do you really want to {actionText} {count} \"{type}\" {plural}?", {
            count: config.record.length,
            plural: config.record.length > 1 ? _T("entries") : _T("entry"),
            type: config.component.storeInputs.objectType,
            actionText: this.actionText
        });
    }, preAction: function (element, config, event) {
        Pan.Msg.setDefaultButton(2);
        var fnTitle = this.getTitle;
        var customTitle = Pan.base.json.path(config, "$.action.initialConfig.title") || fnTitle && Ext.isFunction(fnTitle) ? fnTitle(config) : undefined;
        Pan.Msg.show({
            title: customTitle || config.component.storeInputs.objectType,
            msg: this.getWarningMessage(element, config, event),
            icon: Ext.Msg.QUESTION,
            buttons: Ext.Msg.YESNO,
            closable: false,
            scope: this,
            fn: function (response) {
                if ('yes' === response)
                    this.action(element, config, event);
            }
        });
    }, action: function (element, config, event) {
        var arrRec = new Array();
        var baseParams = config.component.store.baseParams;
        for (var i = 0; i < config.record.length; i++) {
            var rec = config.record[i].json;
            var recToSend = {
                id: rec['@name'] || rec['alias'],
                vsysName: rec['@__recordInfo'].vsysName ? rec['@__recordInfo'].vsysName : Pan.global.getLoc().val,
                position: rec['@__recordInfo'].position ? rec['@__recordInfo'].position : 'main',
                xpathId: rec['@__recordInfo'].xpathId
            };
            if (config.grid.storeInputs.xpathSuffix) {
                recToSend.xpathSuffix = Pan.base.Evaluation.evaluate(config.grid.storeInputs.xpathSuffix, {
                    __record: rec,
                    __recordInfo: rec['@__recordInfo'],
                    __fields: config.record[i].store.fields
                });
            }
            if (config.grid.storeInputs.pathWrap) {
                recToSend.pathWrap = Pan.base.Evaluation.evaluate(config.grid.storeInputs.pathWrap, {
                    __record: rec,
                    __recordInfo: rec['@__recordInfo'],
                    __fields: config.record[i].store.fields
                });
            }
            this.setupRecord(rec, recToSend, config);
            arrRec.push(recToSend);
        }
        config.component.store.recordBinder.dataProxyAPI.api.destroy(Ext.apply({
            records: arrRec,
            template: Pan.global.getTemplate(),
            templateStack: Pan.global.getTemplateStack()
        }, baseParams), this.createHandleResponse(element, config, event));
    }, getFailedRecordsErrorTemplateStr: function (response, config) {
        return 'Number of failed record(s): ' + response.failedRecords.length + '<br>' + '<textarea rows="6" cols="100" readonly="readonly">' + '<tpl for="failedRecords">' + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{#}-&nbsp;Failed to ' + this.actionText + ' ' + config.component.storeInputs.objectType + ' - {id}. ' + '{0}</tpl></textarea>';
    }, getErrorTitle: function (config) {
        return _T("Error deleting") + " " + config.component.storeInputs.objectType;
    }, postFailedAction: function (element, config, event, response) {
        var templateStr = '';
        if (response.failedRecords) {
            templateStr = this.getFailedRecordsErrorTemplateStr(response, config);
            var msgBody = '';
            if (Ext.isArray(response.msg)) {
                msgBody = '<tpl for="msg">\n&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                msgBody = '<tpl for="msg">\n{line}</tpl>\n';
            } else {
                msgBody = '{msg}\n';
            }
            templateStr = String.format(templateStr, msgBody);
        } else {
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">{.}<br></tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">{line}</tpl>\n';
            } else {
                templateStr += '{msg}';
            }
            templateStr += '</tpl>';
        }
        var errResTemplate = new Ext.XTemplate(templateStr, {compiled: true});
        var msg = errResTemplate.apply(response);
        config.component.store.reportStatus({error: {title: this.getErrorTitle(config), message: msg}});
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        } else {
            config.component.store.reload();
        }
    }
});
Pan.areg("massDeleteAction", Pan.appframework.action.MassDeleteAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MultiMoveAction = Ext.extend(Pan.appframework.action.MultiRemoteAction, {
    actionText: _T('Move'), selectCurrentVsysOnInitialLoad: false, constructor: function (config) {
        var newConfig = Ext.apply({
            text: this.actionText,
            iconCls: 'icon-move-up',
            ref: '../multiMoveAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        this.api = config.api;
        newConfig.availConfig = Pan.base.util.integrateArray([{
            availHide: true, match: {
                evaluate: function () {
                    return Pan.global.isCmsSelected() || Pan.global.isMultiVsys();
                }
            }
        }, {
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.MultiMoveAction.superclass.constructor.call(this, newConfig);
    }, preAction: function (element, config, event) {
        if (config.record.length == 0)
            return;
        var selectedRecords = [];
        var loc;
        if (!Ext.isDefined(config.includeShared))
            config.includeShared = true;
        var uniqueLocations = {};
        for (var i = 0; i < config.record.length; i++) {
            loc = (config.record[i].json['@__recordInfo'].xpathId !== 'shared' && config.record[i].json['@__recordInfo'].xpathId !== 'panorama') ? config.record[i].json['@__recordInfo'].vsysName : Pan.base.util.capitalize(config.record[i].json['@__recordInfo'].xpathId);
            if (!loc && !Pan.global.isCms()) {
                loc = Pan.global.getLocVal();
            }
            if (config.includeShared == true && loc == "Shared") {
                config.includeShared = false;
            }
            selectedRecords.push({
                'name': config.record[i].json['@name'],
                'location': loc,
                'xpathId': config.record[i].json['@__recordInfo'].xpathId
            });
            if (!uniqueLocations[loc]) {
                uniqueLocations[loc] = loc;
            }
        }
        config.selectedRecords = selectedRecords;
        this.locationFilter = function (rec) {
            var locName;
            if (Pan.global.isCmsSelected()) {
                locName = rec[0];
            } else {
                locName = rec;
            }
            if (locName && locName.toLowerCase() === "shared" && !config.includeShared) {
                return false;
            }
            if (!uniqueLocations[locName]) {
                return true;
            }
            return false;
        };
    }, action: function (element, config, event) {
        var baseParams = config.component.store.baseParams;
        config.component.store.recordBinder.dataProxyAPI.api.multiMove(Ext.apply(config.recordsInfo, baseParams), this.createHandleResponse(element, config, event));
    }, availEvaluationAfterChange: function () {
        var grid = this.__component.scope;
        var selModel = grid.getSelectionModel();
        var available = false;
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (Pan.appframework.renderer.isParentDGRec(r)) {
                    available = false;
                    break;
                } else if ((r.json && r.json['@__recordInfo'] && r.json['@__recordInfo'].permission === 'readonly') || Pan.global.isSharedOnlyAccess() || r.json['@__recordInfo'].position == "default-security-rule") {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }
});
Pan.areg("multiMoveAction", Pan.appframework.action.MultiMoveAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MultiCloneAction = Ext.extend(Pan.appframework.action.MultiRemoteAction, {
    actionText: _T('Clone'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: this.actionText,
            iconCls: 'icon-clone',
            ref: '../multiCloneAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        this.api = config.api;
        newConfig.availConfig = Pan.base.util.integrateArray([{
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.MultiCloneAction.superclass.constructor.call(this, newConfig);
    }, preAction: function (element, config, event) {
        if (config.record.length == 0)
            return;
        var selectedRecords = [];
        var uniqueLocations = {};
        var loc;
        if (!Ext.isDefined(config.includeShared))
            config.includeShared = true;
        for (var i = 0; i < config.record.length; i++) {
            var recordInfo = config.record[i].json['@__recordInfo'];
            loc = (recordInfo.xpathId !== 'shared' && recordInfo.xpathId !== 'predefined') ? recordInfo.vsysName : Pan.base.util.capitalize(recordInfo.xpathId);
            if (!loc && !Pan.global.isCms()) {
                loc = Pan.global.getLocVal();
            }
            if (recordInfo.xpathId === 'panorama') {
                if (recordInfo.position === 'pre') {
                    loc = 'Panorama-pre-' + loc;
                } else if (recordInfo.position === 'post') {
                    loc = 'Panorama-post-' + loc;
                } else {
                    loc = 'Panorama-' + loc;
                }
            }
            selectedRecords.push({
                'name': config.record[i].json['@name'],
                'location': loc,
                'xpathId': recordInfo.xpathId
            });
            if (!uniqueLocations[loc]) {
                uniqueLocations[loc] = loc;
            }
        }
        config.selectedRecords = selectedRecords;
        config.uniqueLocations = uniqueLocations;
        this.locationFilter = function (rec) {
            var locName;
            if (Pan.global.isCmsSelected()) {
                locName = rec[0];
            } else {
                locName = rec;
            }
            if (locName && locName.toLowerCase() === "shared" && !config.includeShared) {
                return false;
            }
            return true;
        };
    }, action: function (element, config, event) {
        var baseParams = config.component.store.baseParams;
        config.component.store.recordBinder.dataProxyAPI.api.multiClone(Ext.apply(config.recordsInfo, baseParams), this.createHandleResponse(element, config, event));
    }, availEvaluationAfterChange: function () {
        var grid = this.__component.scope;
        var selModel = grid.getSelectionModel();
        var available = false;
        var selected = selModel.getSelections();
        if (selected.length > 0 && !Pan.global.isSharedOnlyAccess()) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (r.json['@__recordInfo'].position === 'default-security-rule') {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }
});
Pan.areg("multiCloneAction", Pan.appframework.action.MultiCloneAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.MassCloneAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Clone'),
            iconCls: 'icon-clone',
            ref: '../massCloneAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray([{
            type: 'HasSelectionAvail',
            callChainPrepend: config.callChainPrepend,
            hasSelectionMethod: config.hasSelectionMethod
        }, {listenToIfExists: true, match: {evaluate: this.availEvaluationAfterChange}}], newConfig.availConfig);
        Pan.appframework.action.MassCloneAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var selModel = undefined;
        try {
            if (this.__component.callChainPrepend) {
                selModel = Pan.callChain(this.__component, this.__component.callChainPrepend + ".getSelectionModel");
            }
            if (!selModel) {
                selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
            }
        } catch (ex) {
        }
        var available = false;
        var selected = selModel ? selModel.getSelections() : Pan.objects.app.AppViewer.prototype.getSelectedRecords();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (r.json && r.json['@__recordInfo'] && r.json['@__recordInfo'].permission === 'readonly') {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, preAction: function (element, config, event) {
        config.selectedRecords = undefined;
        var isPanorama = Pan.global.isCmsSelected() && !Pan.global.getTemplate();
        var sharedCfg = {
            msg: _T('Do you want <b>{count} cloned {type}</b> {object} to be shared across multiple {vsys}?', {
                count: config.record.length,
                type: config.component.storeInputs.objectType,
                object: config.record.length > 1 ? _T('objects') : _T('object'),
                vsys: isPanorama ? _T('device groups') : _T('virtual systems')
            }), buttons: Ext.Msg.YESNOCANCEL
        };
        var nonSharedCfg = {
            msg: _T('Do you want to clone  <b>{count}  {type}</b> object(s)?', {
                count: config.record.length,
                type: config.component.storeInputs.objectType
            }), buttons: Ext.Msg.OKCANCEL
        };
        config.cloneForm = this.cloneForm;
        var showCfg = (config.cloneForm && (config.cloneForm.hasSameXPathId)) ? nonSharedCfg : sharedCfg;
        var hasSameXPathId = config.component.cloneForm && config.component.cloneForm.hasSameXPathId;
        var noPrompt = hasSameXPathId;
        if (Ext.isFunction(hasSameXPathId)) {
            noPrompt = hasSameXPathId(config.record);
        }
        if ((!Pan.global.isMultiVsys() && !isPanorama) || noPrompt || !Pan.global.canEditShared()) {
            var record = config.record;
            var arrRec = new Array();
            for (var i = 0; i < record.length; i++) {
                var rec = record[i].json;
                var isPredefinedLocation = rec['@__recordInfo'].xpathId === 'predefined' || rec['@__recordInfo'].xpathId === 'panorama' || (!Pan.global.canEditShared() && rec['@__recordInfo'].xpathId === 'shared');
                var defaultVsys = Pan.global.getLoc().type === 'unknown' ? 'vsys1' : Pan.global.getLoc().val;
                var vsysName = isPredefinedLocation ? defaultVsys : rec['@__recordInfo'].vsysName;
                var newXpathId = isPredefinedLocation ? 'vsys' : rec['@__recordInfo'].xpathId;
                arrRec.push({
                    id: rec['@name'],
                    vsysName: vsysName,
                    xpathId: rec['@__recordInfo'].xpathId,
                    position: rec['@__recordInfo'].position ? rec['@__recordInfo'].position : 'main',
                    newXpathId: newXpathId,
                    template: rec['@ptpl']
                });
            }
            config.selectedRecords = arrRec;
            this.action(element, config, event);
        } else {
            Pan.Msg.show({
                title: config.component.storeInputs.objectType,
                msg: showCfg.msg,
                icon: Ext.Msg.QUESTION,
                buttons: showCfg.buttons,
                scope: this,
                fn: function (response) {
                    if ('cancel' === response)
                        return false;
                    var newXpathId = response === 'yes' ? 'shared' : 'vsys';
                    var arrRec = new Array();
                    var record = config.record;
                    for (var i = 0; i < record.length; i++) {
                        var rec = record[i].json;
                        var vsysName = rec['@__recordInfo'].vsysName ? rec['@__recordInfo'].vsysName : Pan.global.getLoc().val;
                        arrRec.push({
                            id: rec['@name'],
                            vsysName: vsysName,
                            position: rec['@__recordInfo'].position ? rec['@__recordInfo'].position : 'main',
                            xpathId: rec['@__recordInfo'].xpathId,
                            newXpathId: newXpathId,
                            template: rec['@ptpl']
                        });
                    }
                    config.selectedRecords = arrRec;
                    this.action(element, config, event);
                }
            });
        }
    }, action: function (element, config, event) {
        var baseParams = config.component.store.baseParams;
        for (var i = 0; i < config.record.length; i++) {
            var rec = config.record[i].json;
            if (config.grid.storeInputs.xpathSuffix) {
                var xpathSuffix = Pan.base.Evaluation.evaluate(config.grid.storeInputs.xpathSuffix, {
                    __record: rec,
                    __recordInfo: rec['@__recordInfo'],
                    __fields: config.record[i].store.fields
                });
                config.selectedRecords[i].xpathSuffix = xpathSuffix;
            }
        }
        config.component.store.recordBinder.dataProxyAPI.api.clone(Ext.apply({
            records: config.selectedRecords,
            template: Pan.global.getTemplate(),
            templateStack: Pan.global.getTemplateStack()
        }, baseParams), this.createHandleResponse(element, config, event));
    }, postFailedAction: function (element, config, event, response) {
        var errResTemplate = new Ext.XTemplate('Number of failed record(s): ' + response.failedRecords.length + '<br>', '<textarea rows="6" cols="80" readonly="readonly">', '<tpl for="failedRecords">', '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{#}-&nbsp;Failed to clone {id}. ', '<tpl if="Ext.isObject(msg)"><tpl for="msg">{line}</tpl>\n</tpl>', '<tpl if="!Ext.isObject(msg)">{msg}\n</tpl>', '</tpl></textarea>', {compiled: true});
        var msg = errResTemplate.apply(response);
        config.component.store.reportStatus({
            error: {
                title: _T("Cloning") + ' ' + config.component.storeInputs.objectType + " " + _T("failed for the following"),
                message: msg
            }
        });
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        } else {
            config.component.store.reload();
        }
    }
});
Pan.areg("massCloneAction", Pan.appframework.action.MassCloneAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.cleanFilename = function (name) {
    var idx = name.lastIndexOf("/");
    if (idx >= 0) {
        name = name.substring(idx + 1);
    }
    idx = name.lastIndexOf("\\");
    if (idx >= 0) {
        name = name.substring(idx + 1);
    }
    return name.replace(/[^a-zA-Z0-9_-]/g, '_');
};
Pan.appframework.action.importRecordAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        var cfg = Ext.apply({
            text: _T('Import'),
            iconCls: 'icon-import',
            ref: '../importRecordAction',
            handler: this.action.createDelegate(this)
        }, config);
        Pan.appframework.action.importRecordAction.superclass.constructor.call(this, cfg);
    }, action: function (element, config, event) {
        var importWindow;
        var msg_handler = function (result, defaulterror) {
            var msg = Pan.base.json.paths(result, "$.result.msg.line").join('');
            if (msg) {
                Pan.base.msg.alert(msg);
            } else {
                msg = Pan.base.json.paths(result, "$.result.msg.*").join('');
                if (msg) {
                    Pan.base.msg.alert(msg);
                } else {
                    msg = Pan.base.json.paths(result, "$.result.result.msg.line").join('');
                    if (msg) {
                        Pan.base.msg.alert(msg);
                    }
                }
            }
            if (!msg && defaulterror) {
                Pan.base.msg.alert(defaulterror);
            }
        };
        var ok_handler = function () {
            var fp = importWindow.find('name', 'upload_form')[0].getForm();
            if (fp.isValid()) {
                var location = fp.findField('location');
                var destination = fp.findField('destination').getValue();
                if (destination == 'shared') {
                    location.setValue('shared');
                } else {
                    location.setValue('vsys');
                    fp.findField('vsysName').setValue(destination);
                }
                fp.submit({
                    url: '/php/objects/import.spyware.php',
                    waitMsg: _T('Uploading...'),
                    success: function (fp, action) {
                        importWindow.close();
                        msg_handler(action);
                        if (config.component.store.recordBinder.dataProxyAPI.api.importConfig.callback) {
                            config.component.store.recordBinder.dataProxyAPI.api.importConfig.callback();
                        }
                        config.component.store.reload();
                    },
                    failure: function (form, action) {
                        importWindow.close();
                        msg_handler(action, 'unspecified error');
                    }
                });
            }
        };
        var data = config.component.store.recordBinder.dataProxyAPI.api.importConfig.getDestinations();
        importWindow = new Pan.base.container.Window({
            width: 400,
            height: 150,
            layout: 'fit',
            title: _T('Import Config'),
            closeAction: 'close',
            modal: true,
            border: false,
            closable: true,
            items: {
                xtype: 'form',
                fileUpload: true,
                frame: false,
                border: false,
                labelWidth: 110,
                name: 'upload_form',
                height: '100%',
                bodyStyle: 'padding:10px;',
                items: [{
                    xtype: 'hidden',
                    name: 'type',
                    value: config.component.store.recordBinder.dataProxyAPI.api.importConfig.type
                }, {xtype: 'hidden', name: 'location', value: 'shared'}, {
                    xtype: 'hidden',
                    name: 'vsysName',
                    value: ''
                }, {
                    xtype: 'fileuploadfield',
                    emptyText: _T('Select a file'),
                    fieldLabel: _T('Import File'),
                    allowBlank: false,
                    width: '100%',
                    id: 'fileuploadfield',
                    name: 'file_upload'
                }, {
                    xtype: 'pan-combo',
                    allowBlank: false,
                    name: "destination",
                    fieldLabel: data.length == 1 ? '' : _T("Destination"),
                    mode: 'local',
                    triggerAction: 'all',
                    selectOnFocus: true,
                    typeAhead: true,
                    forceSelection: true,
                    displayField: 'display',
                    valueField: 'value',
                    value: data[0][1],
                    hidden: data.length == 1,
                    store: new Ext.data.SimpleStore({fields: ['display', 'value'], data: data})
                }]
            },
            buttons: [{text: _T('OK'), handler: ok_handler}, {
                text: _T('Cancel'), handler: function () {
                    importWindow.close();
                }
            }]
        });
        importWindow.show();
        Ext.each(Ext.DomQuery.select('div.x-form-item', importWindow.dom), function (x) {
            Ext.get(x).setStyle({overflow: 'hidden'});
        });
    }
});
Pan.areg("importRecordAction", Pan.appframework.action.importRecordAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.ExportRecordAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Export'),
            iconCls: 'icon-export',
            ref: '../exportRecordAction',
            handler: this.action.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray([{type: 'HasSelectionAvail'}, {
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.ExportRecordAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var selModel = undefined;
        try {
            selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
        } catch (ex) {
            return false;
        }
        var selected = selModel.getSelections();
        return selected.length == 1;
    }, action: function (element, config, event) {
        var len = Pan.base.json.path(config, '$.record.length');
        if (len > 1) {
            Pan.base.msg.warn(_T('You can only export one entry at a time'));
            return false;
        } else if (len != 1) {
            Pan.base.msg.warn(_T('Please select an entry to export'));
            return false;
        }
        var rec = config.record[0].json;
        var url = config.component.store.recordBinder.dataProxyAPI.api.exportURL;
        var urlParams = {
            id: rec['@name'],
            name: rec['@name'],
            vsysName: Pan.base.json.path(rec, '@__recordInfo.vsysName', ''),
            xpathId: Pan.base.json.path(rec, '$.@__recordInfo.xpathId')
        };
        var template = Pan.global.getTemplate();
        if (template) {
            urlParams['template'] = template;
        }
        if (url.indexOf('?') == -1) {
            url += '?';
        }
        url += Ext.urlEncode(urlParams);
        window.open(url);
    }
});
Pan.areg("exportRecordAction", Pan.appframework.action.ExportRecordAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.EnableAppAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Enable'),
            iconCls: 'icon-enable',
            ref: '../enableAppAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray([{
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.EnableAppAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var selModel = undefined;
        var available = false;
        var selected = selModel ? selModel.getSelections() : Pan.objects.app.AppViewer.prototype.getSelectedRecords();
        if (selected.length > 0) {
            available = true;
            if (!Pan.base.json.path(this.__component.scope, "$.disabled-apps"))
                return false;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (this.__component.scope['disabled-apps'].indexOf(r["@name"]) == -1) {
                    available = false;
                    break;
                }
                if (r.path != "predefined" && r.path != "content-preview") {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, getWarningMessage: function (element, config, event) {
        var msg = _T('Note: Applications that depend on selected application(s) will also be enabled.');
        msg += '<br/><br/><span style="margin-right:3px;"><input type="checkbox" id="enable_dependent_apps" checked/></span>';
        msg += _T('Enable dependent App-IDs');
        return _T("Do you really want to enable {count} application(s)?", {count: config.record.length}) + '<br><br><b>' + msg + '</b>';
    }, preAction: function (element, config, event) {
        Pan.Msg.setDefaultButton(2);
        Pan.Msg.show({
            title: config.component.storeInputs.objectType,
            msg: this.getWarningMessage(element, config, event),
            icon: Ext.Msg.QUESTION,
            buttons: Ext.Msg.YESNO,
            closable: false,
            scope: this,
            fn: function (response) {
                if ('yes' === response) {
                    var enableAppIdComp = document.getElementById('enable_dependent_apps');
                    if (enableAppIdComp) {
                        config.enableDependentApps = (enableAppIdComp.checked) ? "yes" : "no";
                    } else {
                        config.enableDependentApps = "no";
                    }
                    this.action(element, config, event);
                }
            }
        });
    }, action: function (element, config, event) {
        if (config.record.length == 0)
            return;
        var apps = [];
        var vsysName = Pan.global.getLocVal();
        for (var i = 0; i < config.record.length; i++) {
            var r = config.record[i];
            apps.push(r['@name']);
        }
        PanDirect.run('ObjectsDirect.setMultipleApplicationStatus', [{
            appNames: apps,
            vsysName: vsysName,
            status: 'enabled',
            enableDependentApps: config.enableDependentApps
        }], this.createHandleResponse(element, config, event));
    }, postSucceedAction: function (element, config, event, response, responseEvent) {
        Pan.appframework.action.EnableAppAction.superclass.postSucceedAction.call(this, element, config, event, response, responseEvent);
        Pan.appframework.PanAppInterface.refresh();
        Pan.global.ContextVariables.doRetrieveConfigChangePending();
    }, postFailedAction: function (element, config, event, response) {
        var templateStr = '';
        if (response.failedRecords) {
            templateStr = _T('Number of failed record(s):') + ' ' + response.failedRecords.length + '<br>' + '<textarea rows="6" cols="100" readonly="readonly">' + '<tpl for="failedRecords">' + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{#}-&nbsp;' + _T('Failed to enable application') + ' - {id}. ';
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">\n&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">\n{line}</tpl>\n';
            } else {
                templateStr += '<tpl if="this.isArray(msg)"><tpl for="msg">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n</tpl>' + '<tpl if="this.isArray(msg) == false && this.isObject(msg)"><tpl for="msg">{line}</tpl>\n</tpl>' + '<tpl if="this.isArray(msg) == false && this.isObject(msg) == false">{msg}\n</tpl>';
            }
            templateStr += '</tpl></textarea>';
        } else {
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">{.}<br></tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">{line}</tpl>\n';
            } else {
                templateStr += '{msg}';
            }
            templateStr += '</tpl>';
        }
        var errResTemplate = new Ext.XTemplate(templateStr, {
            compiled: true, isObject: function (val) {
                return Ext.isObject(val);
            }, isArray: function (val) {
                return Ext.isArray(val);
            }
        });
        var msg = errResTemplate.apply(response);
        config.component.store.reportStatus({error: {title: _T("Error enabling application"), message: msg}});
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        } else {
            config.component.store.reload();
        }
    }
});
Pan.areg("enableAppAction", Pan.appframework.action.EnableAppAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.DisableAppAction = Ext.extend(Pan.appframework.action.MutableRemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Disable'),
            iconCls: 'icon-disable',
            ref: '../disableAppAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray([{
            listenToIfExists: true,
            match: {
                evaluate: '&&',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.availEvaluationAfterChange}]
            }
        }], newConfig.availConfig);
        Pan.appframework.action.DisableAppAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var selModel = undefined;
        var available = false;
        var selected = selModel ? selModel.getSelections() : Pan.objects.app.AppViewer.prototype.getSelectedRecords();
        if (selected.length > 0) {
            available = true;
            var hasDisabledApps = Pan.base.json.path(this.__component.scope, "$.disabled-apps");
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (hasDisabledApps && this.__component.scope['disabled-apps'].indexOf(r["@name"]) !== -1) {
                    available = false;
                    break;
                }
                if (r.path != "predefined" && r.path != "content-preview") {
                    available = false;
                    break;
                }
                if (selected.length == 1 && r['can-disable'] === 'no') {
                    available = false;
                }
            }
        }
        return available;
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, getWarningMessage: function (element, config, event) {
        var msg = _T('Note: Applications that depend on selected application(s) will also be disabled.</b>');
        return _T("Do you really want to disable {count} application(s)?", {count: config.record.length}) + '<br><br><b>' + msg + '</b>';
    }, preAction: function (element, config, event) {
        Pan.Msg.setDefaultButton(2);
        Pan.Msg.show({
            title: config.component.storeInputs.objectType,
            msg: this.getWarningMessage(element, config, event),
            icon: Ext.Msg.QUESTION,
            buttons: Ext.Msg.YESNO,
            closable: false,
            scope: this,
            fn: function (response) {
                if ('yes' === response)
                    this.action(element, config, event);
            }
        });
    }, action: function (element, config, event) {
        if (config.record.length == 0)
            return;
        var apps = [];
        var vsysName = Pan.global.getLocVal();
        for (var i = 0; i < config.record.length; i++) {
            var r = config.record[i];
            apps.push(r['@name']);
        }
        PanDirect.run('ObjectsDirect.setMultipleApplicationStatus', [{
            appNames: apps,
            vsysName: vsysName,
            status: 'disabled'
        }], this.createHandleResponse(element, config, event));
    }, postSucceedAction: function (element, config, event, response, responseEvent) {
        Pan.appframework.action.DisableAppAction.superclass.postSucceedAction.call(this, element, config, event, response, responseEvent);
        Pan.appframework.PanAppInterface.refresh();
        Pan.global.ContextVariables.doRetrieveConfigChangePending();
    }, postFailedAction: function (element, config, event, response) {
        var templateStr = '';
        if (response.failedRecords) {
            templateStr = _T('Number of failed record(s):') + ' ' + response.failedRecords.length + '<br>' + '<textarea rows="6" cols="100" readonly="readonly">' + '<tpl for="failedRecords">' + '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{#}-&nbsp;' + _T('Failed to disable application') + ' - {id}. ';
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">\n&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">\n{line}</tpl>\n';
            } else {
                templateStr += '<tpl if="this.isArray(msg)"><tpl for="msg">\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#176;&nbsp;{.}</tpl>\n</tpl>' + '<tpl if="this.isArray(msg) == false && this.isObject(msg)"><tpl for="msg">{line}</tpl>\n</tpl>' + '<tpl if="this.isArray(msg) == false && this.isObject(msg) == false">{msg}\n</tpl>';
            }
            templateStr += '</tpl></textarea>';
        } else {
            if (Ext.isArray(response.msg)) {
                templateStr += '<tpl for="msg">{.}<br></tpl>\n';
            } else if (Ext.isObject(response.msg)) {
                templateStr += '<tpl for="msg">{line}</tpl>\n';
            } else {
                templateStr += '{msg}';
            }
            templateStr += '</tpl>';
        }
        var errResTemplate = new Ext.XTemplate(templateStr, {
            compiled: true, isObject: function (val) {
                return Ext.isObject(val);
            }, isArray: function (val) {
                return Ext.isArray(val);
            }
        });
        var msg = errResTemplate.apply(response);
        config.component.store.reportStatus({error: {title: _T("Error disabling application"), message: msg}});
        if (Ext.isFunction(config.postFailedAction)) {
            config.postFailedAction.call(config.component, element, config, event, response);
        } else {
            config.component.store.reload();
        }
    }
});
Pan.areg("disableAppAction", Pan.appframework.action.DisableAppAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.PanViewerWindowAction = Ext.extend(Pan.base.action.RemoteAction, {
    defaultWindowConfig: {border: false, width: 480, autoHeight: true, modal: true},
    originalConfig: undefined,
    constructor: function (config) {
        this.originalConfig = Ext.apply({}, config);
        Pan.appframework.action.PanViewerWindowAction.superclass.constructor.call(this, Ext.apply({
            text: _T('Add'),
            iconCls: 'icon-add',
            ref: '../gridRecordFormAction',
            handler: this.doAction.createDelegate(this)
        }, config));
    },
    doAction: function (element) {
        if (this.window) {
            this.window.show();
            return;
        }
        Pan.appframework.schema.PanSchemaRepository.readSchema(this.initialConfig.treePath, this.displayUI, this, {
            treePath: this.initialConfig.treePath,
            element: element
        });
    },
    displayUI: function (arg) {
        var config = {
            actionComponent: arg.element,
            treePath: this.initialConfig.treePath,
            noTitle: true,
            isInWindow: true,
            isCheckAutoRefreshAfterWrite: false
        };
        if (this.initialConfig.recordForm) {
            config.recordForm = Ext.apply({}, this.initialConfig.recordForm);
        }
        if (this.initialConfig.recordFormOverride) {
            config.recordFormOverride = Ext.apply({}, this.initialConfig.recordFormOverride);
        }
        if (this.initialConfig.storeConfigOverride) {
            config.storeConfigOverride = Ext.apply({}, this.initialConfig.storeConfigOverride);
        }
        var window = undefined;
        var panel = Pan.create(Ext.applyIf(config, this.originalConfig));
        if (panel.floating) {
            panel.show();
        } else if (Ext.isFunction(panel.createWindow)) {
            window = panel.createWindow();
        } else {
            window = this.createWindow(panel);
        }
        if (window) {
            window.show(this.initialConfig.animateTarget);
            if (window.closeAction === 'hide') {
                this.window = window;
            }
        }
    },
    createWindow: function (item) {
        var config = Ext.apply({
            xtype: 'pan-window',
            layout: 'fit',
            title: item.title || item.undisplayedTitle,
            iconCls: this.iconCls,
            items: item
        }, item.windowConfig, this.defaultWindowConfig);
        return Ext.ComponentMgr.create(config);
    },
    removeComponent: function (comp) {
        var rv = Pan.appframework.action.PanViewerWindowAction.superclass.removeComponent.apply(this, arguments);
        if (this.window && this.items.length === 0) {
            delete this.window;
        }
        return rv;
    }
});
Pan.areg("panViewerWindowAction", Pan.appframework.action.PanViewerWindowAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.TemplateFormOverrideAction = Ext.extend(Pan.base.action.Action, {
    overrideText: _T('Override All'),
    revertText: _T('Revert All'),
    overrideIconCls: 'x-indicate-override-action',
    revertIconCls: 'x-indicate-revert-action',
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: config.isOverride ? this.overrideText : this.revertText,
            tooltip: config.isOverride ? this.overrideText : this.revertText,
            iconCls: config.isOverride ? this.overrideIconCls : this.revertIconCls,
            ref: '../templateFormOverrideAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        Pan.appframework.action.TemplateFormOverrideAction.superclass.constructor.call(this, newConfig);
    },
    doAction: function (component, event) {
        var form = component.ownerCt.ownerCt;
        if (form.isProtected()) {
            form.unprotect();
            this.setIconClass(this.revertIconCls);
            this.setTooltip(this.revertText);
            this.setText(this.revertText);
        } else {
            var editRecord = form.editRecord;
            var store = editRecord.store;
            var templateRecord = store.templateRecords[editRecord.id];
            store.copyRecordData(templateRecord, editRecord);
            form.loadRecord();
            form.fireEvent('afterformload', form);
            form.protect();
            this.setIconClass(this.overrideIconCls);
            this.setTooltip(this.overrideText);
            this.setText(this.overrideText);
        }
    }
});
Pan.areg("templateFormOverrideAction", Pan.appframework.action.TemplateFormOverrideAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.TemplateFormRemoveAction = Ext.extend(Pan.base.action.Action, {
    revertText: _T('Remove All'),
    revertIconCls: 'x-indicate-remove',
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: this.revertText,
            tooltip: this.revertText,
            iconCls: this.revertIconCls,
            ref: '../templateFormRemoveAction',
            handler: this.doAction.createDelegate(this),
            hidden: true
        }, config);
        this.addAvail({
            availHide: true, match: {
                evaluate: function () {
                    return Pan.common.PanConfigStates.prototype.isShowingTemplateComboOnTop();
                }
            }
        });
        Pan.appframework.action.TemplateFormRemoveAction.superclass.constructor.call(this, newConfig);
    },
    doAction: function (component, event) {
        var form = component.ownerCt.ownerCt;
        var editRecord = form.editRecord;
        var nameIdProperty = editRecord.store.storeInputs.nameIdProperty;
        editRecord.fields.each(function (f) {
            if (f.name !== nameIdProperty) {
                editRecord.data[f.name] = Ext.isDefined(f.overrideDefault) ? f.overrideDefault : f.defaultValue;
            }
        });
        var srcConfig = editRecord.json[Pan.common.Constants.attrSrc];
        var recordInfo = editRecord.json['@__recordInfo'];
        var name = editRecord.json[nameIdProperty];
        editRecord.json = {};
        editRecord.json[Pan.common.Constants.attrSrc] = srcConfig;
        editRecord.json['@__recordInfo'] = recordInfo;
        editRecord.json[nameIdProperty] = name;
        editRecord.isCompletelyEmpty = true;
        form.loadRecord();
        form.fireEvent('afterformload', form);
    }
});
Pan.areg("templateFormRemoveAction", Pan.appframework.action.TemplateFormRemoveAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.TemplateOverrideAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Override'),
            iconCls: 'x-indicate-override-action',
            ref: '../templateOverrideAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: function () {
                        return this.__component.findParentByInstanceof(Ext.grid.GridPanel).store.templateRecords;
                    }
                }]
            }
        }, {
            listenToIfExists: true,
            availHide: false,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {
                    evaluate: config.hasSelectionMethod || function () {
                        var selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
                        var oneSelected = selModel.hasOneSelection() && selModel.getSelected();
                        return Pan.appframework.renderer.isTemplateRec(oneSelected) || Pan.appframework.renderer.isTSTemplateRec(oneSelected);
                    }
                }]
            }
        }]);
        Pan.appframework.action.TemplateOverrideAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.overrideRecord(element, config, event);
    }, overrideRecord: function (element, config, event) {
        var recordFormOverride = Ext.applyIf({additionalInput: {templateOverride: true}, action: 'templateOverride'});
        var record;
        if (this.initialConfig.isPanelTool) {
            var tmp = element;
            element = event;
            event = tmp;
            record = element.editRecord;
            var isProtected = Pan.appframework.renderer.isTemplateRec(record) || Pan.appframework.renderer.isTSTemplateRec(record);
            if (!isProtected) {
                recordFormOverride = {};
            }
            var atype = 'templateFormOverrideAction';
            if (Pan.global.getTemplate()) {
                var tsTplRecord = Pan.appframework.renderer.isTSOverrideRec(record, record.store) || Pan.appframework.renderer.isTSTemplateRec(record);
                if (!tsTplRecord) {
                    atype = 'templateFormRemoveAction';
                }
            }
            Ext.apply(recordFormOverride, {
                'isProtected': isProtected,
                customButtons: [{atype: atype, isOverride: isProtected}],
                updateRecord: function (callback) {
                    if (this.isProtected()) {
                        if (!this.recordForm.isProtected) {
                            if (callback) {
                                this.store.addListener('save', function () {
                                    callback(true);
                                    this.store.reload();
                                }, this, {single: true});
                            }
                            this.store.removeAt(0);
                        } else {
                            callback(true);
                        }
                    } else {
                        this.updateRecord.apply(this, arguments);
                    }
                }
            });
        } else {
            record = element.selModel.getSelected();
        }
        if (this.initialConfig.overrideWithoutUserAction) {
            var json = record.json;
            PanDirect.execute(this.initialConfig.remoteClass + '.templateOverride', {
                id: json['@name'] || json['alias'],
                vsysName: json['@__recordInfo'].vsysName ? json['@__recordInfo'].vsysName : Pan.global.getLoc().val,
                xpathId: json['@__recordInfo'].xpathId
            }, function (re) {
                if (re && re['@status'] != 'success') {
                    Pan.base.msg.warn(Pan.base.extractJsonText(re) || _T('Override failed'));
                }
                record.store.reload();
            });
            return;
        }
        element.editForm(record, recordFormOverride, undefined, undefined);
    }
});
Pan.areg("templateOverrideAction", Pan.appframework.action.TemplateOverrideAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.TemplateRevertAction = Ext.extend(Pan.appframework.action.MassDeleteAction, {
    actionText: _T('revert'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Revert'),
            iconCls: 'x-indicate-revert-action',
            ref: '../templateRevertAction'
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: function () {
                        return this.__component.findParentByInstanceof(Ext.grid.GridPanel).store.templateRecords;
                    }
                }]
            }
        }]);
        Pan.appframework.action.TemplateRevertAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var available = false;
        var selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (!Pan.appframework.renderer.isTemplateOverrideRec(r, r.store) && !Pan.appframework.renderer.isTSOverrideRec(r, r.store)) {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }
});
Pan.areg("templateRevertAction", Pan.appframework.action.TemplateRevertAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.DGOverrideAction = Ext.extend(Pan.base.action.RemoteAction, {
    ref: '../dgOverrideAction',
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Override'),
            iconCls: 'x-indicate-override-action',
            ref: this.ref,
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: config.availHideEvaluate || function () {
                        return Pan.global.isCmsSelected();
                    }
                }]
            }
        }, {
            listenToIfExists: true,
            availHide: false,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {evaluate: this.getSelectionChangeEvalFunction(config)}]
            }
        }]);
        Pan.appframework.action.DGOverrideAction.superclass.constructor.call(this, newConfig);
    },
    getSelectionChangeEvalFunction: function (config) {
        return config.hasSelectionMethod || function () {
            var selModel = this.__component.ownerCt.ownerCt.getSelectionModel();
            var oneSelected = selModel.hasOneSelection() && selModel.getSelected();
            return Pan.appframework.renderer.isParentDGRec(oneSelected) && !oneSelected.get('$.disable-override');
        };
    },
    doAction: function (element, config, event) {
        this.overrideRecord(element, config, event);
    },
    overrideRecord: function (element, config, event) {
        var recordFormOverride = this.initialConfig.recordFormOverride || {
            additionalInput: {dgOverride: true},
            action: 'dgOverride'
        };
        var record = element.selModel.getSelected();
        element.editForm(record, recordFormOverride, undefined, undefined);
    }
});
Pan.areg("dgOverrideAction", Pan.appframework.action.DGOverrideAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.DGRevertAction = Ext.extend(Pan.appframework.action.MassDeleteAction, {
    actionText: _T('revert'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Revert'),
            iconCls: 'x-indicate-revert-action',
            ref: '../dgRevertAction'
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: config.availHideEvaluate || function () {
                        return Pan.global.isCmsSelected();
                    }
                }]
            }
        }]);
        Pan.appframework.action.DGRevertAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var available = false;
        var selModel = this.__component.ownerCt.ownerCt.getSelectionModel();
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (Pan.appframework.renderer.isParentDGRec(r) || !Pan.appframework.renderer.isDGOverrideRec(r)) {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }
});
Pan.areg("dgRevertAction", Pan.appframework.action.DGRevertAction, Pan.appframework.action.ActionMgr.getPermissionAvail());
Ext.ns('Pan.appframework.action');
Pan.appframework.action.SelectAllAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Select All'),
            iconCls: '',
            ref: '../selectAllAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        Pan.appframework.action.SelectAllAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.action(element, config, event);
    }, action: function (element, config, event) {
        if (config.grid) {
            var sm = config.grid.getSelectionModel();
            sm.selectAll();
        }
    }
});
Pan.areg("selectAllAction", Pan.appframework.action.SelectAllAction);
Pan.appframework.action.ToggleAllAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: config.expandAll ? _T('Expand All') : _T('Collapse All'),
            iconCls: '',
            ref: '../toggleAllAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        Pan.appframework.action.ToggleAllAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config) {
        if (config.grid) {
            var grid = config.grid;
            var view = grid.getView();
            if (!view.el) return false;
            var rows = view.getRows();
            for (var i = 0; i < rows.length; i++) {
                var row = Ext.get(rows[i]), nodes, j, n;
                if (config.action.initialConfig.expandAll) {
                    rows[i].style.display = '';
                    nodes = row.query('img.x-tree-elbow-plus');
                    if (nodes.length > 0) {
                        for (j = 0; j < nodes.length; j++) {
                            n = Ext.fly(nodes[j]);
                            n.removeClass('x-tree-elbow-plus');
                            n.addClass('x-tree-elbow-minus');
                        }
                    }
                } else {
                    if (row.query('.x-tree-node-indent img.x-tree-elbow-line').length > 0) {
                        rows[i].style.display = 'none';
                    } else {
                        nodes = row.query('img.x-tree-elbow-minus');
                        if (nodes.length > 0) {
                            for (j = 0; j < nodes.length; j++) {
                                n = Ext.fly(nodes[j]);
                                n.removeClass('x-tree-elbow-minus');
                                n.addClass('x-tree-elbow-plus');
                            }
                        }
                    }
                }
            }
            grid.saveState();
        }
    }
});
Pan.areg("toggleAllAction", Pan.appframework.action.ToggleAllAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.DeSelectAllAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Deselect All'),
            iconCls: '',
            ref: '../deSelectAllAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        Pan.appframework.action.DeSelectAllAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.action(element, config, event);
    }, action: function (element, config, event) {
        if (config.grid) {
            var sm = config.grid.getSelectionModel();
            sm.deselectAll();
        }
    }
});
Pan.areg("deSelectAllAction", Pan.appframework.action.DeSelectAllAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.HyperlinkOnClickAction = function () {
    return {
        showViewerWindow: function (treePath) {
            Pan.createAction({atype: 'panViewerWindowAction', treePath: treePath, scope: this}).doAction();
        }
    };
}();
Ext.ns('Pan.appframework.action');
Pan.appframework.action.GroupHAPeersAction = Ext.extend(Pan.base.action.Action, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            boxLabel: _T('Group HA Peers'),
            xtype: 'pan-checkbox',
            stateful: true,
            iconCls: '',
            ref: '../groupHAPeersAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        Pan.appframework.action.GroupHAPeersAction.superclass.constructor.call(this, newConfig);
    }, doAction: function (element, config, event) {
        this.action(element, config, event);
    }, action: function (element, config, event) {
        var comp = config.grid;
        if (comp && comp.store) {
            comp.store.params = comp.store.params || {};
            Ext.apply(comp.store.params, {groupHAPeers: event});
            this.isGrouped = event;
            if (!comp.hasOwnProperty('rendered') || comp.rendered) {
                comp.store.addListener('load', this.setValueAfterReload, this);
            }
            comp.store.loaded = false;
            comp.store.reload();
        }
    }, setValueAfterReload: function (args) {
        var grid = this.initialConfig.scope;
        if (grid.getFilterView) {
            Pan.common.CommonViewerConfig.updateHAStatusFiltersAfterReload(grid.getFilterView(), this.isGrouped);
        }
        grid.store.removeListener('load', this.setValueAfterReload, this);
    }
});
Pan.areg("groupHAPeersAction", Pan.appframework.action.GroupHAPeersAction);
Pan.appframework.action.PushScopeSelectionGroupHAPeersAction = Ext.extend(Pan.appframework.action.GroupHAPeersAction, {
    action: function (element, config, event) {
        var comp = config.grid;
        if (!this.alreadySetInitialSelection) {
            this.alreadySetInitialSelection = true;
        } else {
            comp.formattedValue = comp.getValue();
            comp.fieldValue = [];
        }
        Pan.appframework.action.PushScopeSelectionGroupHAPeersAction.superclass.action.apply(this, arguments);
    }
});
Pan.areg("pushScopeSelectionGroupHAPeersAction", Pan.appframework.action.PushScopeSelectionGroupHAPeersAction);
Ext.ns('Pan.common.action');
Pan.common.action.UploadAction = Ext.extend(Pan.base.action.RemoteAction, {
    closeWindowOnSucceeded: true, constructor: function (config) {
        var newConfig = Ext.apply({handler: this.doAction.createDelegate(this)}, config);
        this.params = {dummyVar: 'dummy'};
        this.formPanel = undefined;
        this.popupWin = undefined;
        if (Ext.isDefined(config.closeWindowOnSucceeded))
            this.closeWindowOnSucceeded = config.closeWindowOnSucceeded;
        Pan.common.action.UploadAction.superclass.constructor.call(this, newConfig);
    }, setParams: function (params) {
        this.params = params;
    }, closeWindow: function () {
        this.popupWin.close();
    }, afterShowWindow: function () {
    }, preAction: function (element, config, event) {
        this.action(element, config, event, this);
    }, doAction: function (element, config, event) {
        this.preAction(element, config, event);
    }, failureFn: function (fp, action) {
        var err = eval('(' + action.response.responseText + ')');
        var msg = Pan.base.extractJsonMsg(err) || _T('Unknown error');
        Pan.Msg.alert(_T("Error"), msg);
    }, successFn: function (fp, action) {
        fp.ownerCt.close();
    }, action: function (element, config, event) {
        this.component = config ? config.component : element.editorComponent;
        if (this.component && this.component.stopEditing) {
            this.component.stopEditing();
        }
        if (this.component && !this.component.view && this.component.collapse) {
            this.component.collapse();
        }
        var env = {action: this, config: config, element: element, event: event};
        if (!Ext.isDefined(this.url)) {
            Pan.Msg.alert(_T('Error'), _T("Post URL is not defined"));
            return;
        }
        this.okCallback = this.formConfig.okCallback || function (fp, action) {
            return true;
        };
        this.formPanel = Ext.applyIf(this.formConfig, {
            xtype: 'pan-form',
            fileUpload: true,
            itemId: 'theImportFormPanel',
            labelWidth: 100,
            autoHeight: true,
            monitorValid: true,
            bodyStyle: 'padding:15px',
            cls: 'darkblue',
            defaults: {anchor: '100%'},
            buttons: [{
                text: _T('OK'), cls: 'default-btn', formBind: true, env: env, handler: function () {
                    var me = this.env;
                    var action = me.action;
                    if (action.okCallback(this.ownerCt.ownerCt, action)) {
                        var fp = this.ownerCt.ownerCt.ownerCt.findByItemId('theImportFormPanel');
                        if (fp.getForm().isValid()) {
                            fp.getForm().submit({
                                url: action.url,
                                params: action.params,
                                waitMsg: _T('Uploading...'),
                                success: this.env.action.successFn,
                                failure: this.env.action.failureFn
                            });
                        }
                    }
                }
            }, {
                text: _T('Cancel'), handler: function () {
                    this.ownerCt.ownerCt.ownerCt.close();
                }
            }]
        });
        this.popupWin = new Pan.base.container.Window(Ext.applyIf(this.formConfig.windowConfig, {
            width: 500,
            layout: 'form',
            autoHeight: true,
            border: false,
            modal: false,
            items: [this.formPanel]
        }));
        this.popupWin.show();
        this.afterShowWindow();
    }
});
Ext.ns('Pan.appframework.action');
Pan.appframework.action.VariableGetValueFromDeviceAction = Ext.extend(Pan.appframework.action.MassDeleteAction, {
    actionText: _T('getDeviceValue'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Get values used on device'),
            iconCls: 'icon-import',
            ref: '../variableGetValueFromDeviceAction'
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: function () {
                        return Pan.global.isCmsSelected();
                    }
                }]
            }
        }]);
        Pan.appframework.action.VariableGetValueFromDeviceAction.superclass.constructor.call(this, newConfig);
    }, availEvaluationAfterChange: function () {
        var available = false;
        var selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            available = true;
        }
        return available;
    }, doAction: function (element, config, event) {
        this.getValueFromDevice(element, config, event);
    }, getValueFromDevice: function (element, config, event) {
        var variables = [], grid = config.grid, selModel = grid.getSelectionModel(), device = grid.device,
            template = grid.templateName, variableMap = {};
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                variables.push(r['id']);
                variableMap[r['id']] = {type: r.get('$.type')};
            }
        }
        if (variables.length > 0) {
            new Pan.appframework.action.PanViewerWindowAction({
                treePath: 'Pan.device.devices.VariableValueFromDeviceViewer',
                closeAction: 'destroy',
                rbaPath: 'panorama/templates',
                variableMap: variableMap,
                ownerGrid: grid,
                templateName: template,
                device: device,
                storeConfigOverride: {
                    baseParams: {
                        templateName: template,
                        device: device,
                        variables: variables.toString()
                    }
                }
            }).execute();
        }
    }
});
Pan.areg('variableGetValueFromDeviceAction', Pan.appframework.action.VariableGetValueFromDeviceAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.VariableRevertAction = Ext.extend(Pan.appframework.action.MassDeleteAction, {
    actionText: _T('revert'), constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Revert'),
            iconCls: 'x-indicate-revert-action',
            ref: '../variableRevertAction'
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: function () {
                        return (Pan.global.isCmsSelected() && this.__component.findParentByInstanceof(Ext.grid.GridPanel).store.templateRecords);
                    }
                }]
            }
        }]);
        Pan.appframework.action.VariableRevertAction.superclass.constructor.call(this, newConfig);
    }, getTitle: function (config) {
        return config.record.length > 1 ? _T('Revert Variables') : _T('Revert Variable');
    }, availEvaluationAfterChange: function () {
        var available = false;
        var selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
        var selected = selModel.getSelections();
        if (selected.length > 0) {
            available = true;
            for (var i = 0; i < selected.length; i++) {
                var r = selected[i];
                if (Pan.appframework.renderer.isTemplateRec(r) || Pan.appframework.renderer.isTSTemplateRec(r)) {
                    available = false;
                    break;
                } else if (!Pan.appframework.renderer.isTemplateOverrideRec(r, r.store) && !Pan.appframework.renderer.isTSOverrideRec(r, r.store)) {
                    available = false;
                    break;
                }
            }
        }
        return available;
    }
});
Pan.areg('variableRevertAction', Pan.appframework.action.VariableRevertAction);
Ext.ns('Pan.appframework.action');
Pan.appframework.action.VariableOverrideAction = Ext.extend(Pan.base.action.RemoteAction, {
    constructor: function (config) {
        var newConfig = Ext.apply({
            text: _T('Override'),
            title: _T('Override'),
            iconCls: 'x-indicate-override-action',
            ref: '../variableOverrideAction',
            handler: this.doAction.createDelegate(this)
        }, config);
        newConfig.availConfig = Pan.base.util.integrateArray(newConfig.availConfig, [{
            availHide: true,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: 'fieldDataEvt',
                    operands: [{event: ['load'], field: config.scope.itemId, observableCallChain: 'store'}]
                }, {
                    evaluate: function () {
                        return Pan.global.isCmsSelected();
                    }
                }]
            }
        }, {
            listenToIfExists: true,
            availHide: false,
            match: {
                evaluate: 'lastOperand',
                operands: [{
                    evaluate: '||',
                    operands: [{
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: ['selectionchange'],
                            field: config.scope.itemId,
                            observableCallChain: 'getSelectionModel'
                        }]
                    }, {
                        evaluate: 'fieldDataEvt',
                        operands: [{event: ['update'], field: config.scope.itemId, observableCallChain: 'store'}]
                    }]
                }, {
                    evaluate: config.hasSelectionMethod || function () {
                        var selModel = this.__component.findParentByInstanceof(Ext.grid.GridPanel).getSelectionModel();
                        var oneSelected = selModel.hasOneSelection() && selModel.getSelected();
                        return Pan.appframework.renderer.isTemplateRec(oneSelected) || Pan.appframework.renderer.isTSTemplateRec(oneSelected);
                    }
                }]
            }
        }]);
        Pan.appframework.action.VariableOverrideAction.superclass.constructor.call(this, newConfig);
    }, getTitle: function (config) {
        return _T("Variable Override");
    }, doAction: function (element, config, event) {
        this.overrideRecord(element, config, event);
    }, overrideRecord: function (element, config, event) {
        var recordFormOverride = Ext.applyIf({
            additionalInput: {templateOverride: true},
            action: 'templateOverride',
            recordFormTitle: _T('Override Variable'),
            afterUpdateRecord: function (record) {
                record.store.reload();
            }
        });
        var record = element.selModel.getSelected();
        element.editForm(record, recordFormOverride, undefined, undefined);
    }
});
Pan.areg("variableOverrideAction", Pan.appframework.action.VariableOverrideAction);
Ext.ns('Pan.common.component');
Pan.common.component.DeviceGroupCombo = Ext.extend(Ext.form.ComboBox, {
    tpl: new Ext.XTemplate('<tpl for=".">', '{[this.getItemClass(values.__accessible,(values.display || value.value))]}', '{[this.formatDeviceGroup(values.treeLevel,(values.display || value.value))]}', '</div>', '</tpl>', {
        compiled: true, formatDeviceGroup: function (level, name) {
            var ret = "";
            for (var i = 0; i < level; i++) {
                ret += "&nbsp;&nbsp;&nbsp;&nbsp;";
            }
            ret += name;
            return ret;
        }, getItemClass: function (accessible, name) {
            var ret = "x-combo-list-item";
            if (!accessible) {
                ret = "x-item-disabled x-combo-list-item";
            }
            return "<div ext:qtip='" + name + "' class='" + ret + "'>";
        }
    }), constructor: function (config) {
        var cfg = Ext.apply({}, config || {}, {});
        Pan.common.component.DeviceGroupCombo.superclass.constructor.call(this, cfg);
    }, onDestroy: function () {
        Pan.common.component.DeviceGroupCombo.superclass.onDestroy.apply(this, arguments);
        Pan.global.ContextVariables.removeListener('contextvsysinfochanged', this.onContextVsysInfoChanged, this);
    }, setValue: function (v) {
        Pan.common.component.DeviceGroupCombo.superclass.setValue.apply(this, arguments);
        this.fireEvent('valuechange', this, v);
    }, initList: function () {
        Pan.common.component.DeviceGroupCombo.superclass.initList.apply(this, arguments);
    }, triggerAction: 'all', forceSelection: true, selectCurrentVsysOnInitialLoad: true, initComponent: function () {
        this.addEvents('valuechange');
        var data = this.formatData();
        var currentLocObj = Pan.global.getLoc();
        Ext.apply(this, {
            mode: 'local',
            store: new Ext.data.ArrayStore({
                autoLoad: false,
                autoDestroy: true,
                idIndex: 1,
                fields: ['display', 'value', 'dgParent', 'treeLevel', '__accessible'],
                data: data
            }),
            parentRecordField: "dgParent",
            treeRecordIdMainField: "value",
            valueField: 'value',
            displayField: 'display'
        });
        Pan.common.component.DeviceGroupCombo.superclass.initComponent.apply(this, arguments);
        var stateId = this.getStateId();
        var state = Ext.state.Manager.get(stateId);
        if (data.length) {
            var selectedValue = false;
            if (this.selectCurrentVsysOnInitialLoad) {
                Ext.each(data, function (v) {
                    if (v[1] == currentLocObj.val) {
                        selectedValue = currentLocObj.val;
                        return false;
                    }
                });
            } else {
                Ext.each(data, function (v) {
                    if (v[4]) {
                        selectedValue = v[1];
                        return false;
                    }
                });
            }
            if (selectedValue === false) {
                selectedValue = data[0][1];
            }
            if (this.showAllVsysAsOption && !state) {
                selectedValue = data[0][1];
            }
            this.setValue(selectedValue);
        }
    }, initEvents: function () {
        Pan.common.component.DeviceGroupCombo.superclass.initEvents.apply(this, arguments);
        this.keyNav.tab = function (e) {
            this.onViewClick(false);
            return true;
        };
    }, formatData: function () {
        var o = this.getData();
        delete this.sortInfo;
        delete this.multiSortInfo;
        var length = o.length;
        var idMap = {}, i, r;
        for (i = 0; i < length; i++) {
            r = o[i];
            var treeRecordId = r[0];
            idMap[treeRecordId] = true;
        }
        var recordMap = {};
        for (i = 0; i < length; i++) {
            r = o[i];
            var parentRecordId = r[2];
            if (!parentRecordId || !Ext.isDefined(idMap[parentRecordId]) || this.getTreeRecordId(r) === parentRecordId) {
                parentRecordId = "__root__";
            }
            if (!recordMap[parentRecordId]) {
                recordMap[parentRecordId] = [];
            }
            recordMap[parentRecordId].push(r);
        }
        o = new Array();
        var rootNodes = recordMap["__root__"];
        this.createTreeRecords(rootNodes, o, recordMap, 0);
        return o;
    }, createTreeRecords: function (records, allRecords, recordMap, level) {
        if (!Ext.isDefined(records)) {
            return;
        }
        records = _.sortBy(records, function (a) {
            return a[1].toLowerCase();
        });
        for (var i = 0; i < records.length; i++) {
            var allRecordsIndex = allRecords.length;
            var r = allRecords[allRecordsIndex] = records[i];
            r.push(level);
            if (!this.isAccessible || r.push(this.isAccessible(r)))
                r.push(true);
            r.__treeLevel = level;
            r.__treeSnapshotIndex = allRecordsIndex;
            var rid = this.getTreeRecordId(r);
            var childRecords = recordMap[rid];
            if (childRecords) {
                r.__treeChildrenCount = childRecords.length;
                r.__treeChildFirst = childRecords[0].id;
                r.__treeChildLast = childRecords[childRecords.length - 1].id;
                this.createTreeRecords(childRecords, allRecords, recordMap, level + 1);
            }
        }
    }, listeners: {
        beforeselect: function (combo, record, index) {
            if (record.get('__accessible')) {
                return true;
            }
            else {
                return false;
            }
        }
    }, isAccessible: function (r) {
        return true;
    }, getTreeRecordId: function (r) {
        return r[0];
    }, getData: function () {
        Ext.apply(this, new Pan.common.PanConfigStates().getVsysComboConfig());
        return Pan.common.PanConfigStates.prototype.getDeviceGroupDataArray(this);
    }
});
Ext.reg("Pan.common.component.DeviceGroupCombo", Pan.common.component.DeviceGroupCombo);
Ext.ns('Pan.common.component');
Pan.common.component.DGComboRecordForm = Ext.extend(Pan.common.component.DeviceGroupCombo, {
    getData: function () {
        return Pan.common.PanConfigStates.prototype.getDeviceGroupDataArray({includeShared: Ext.isDefined(this.includeShared) ? this.includeShared && !Pan.base.admin.isDeviceGroupAdmin() : !Pan.base.admin.isDeviceGroupAdmin()});
    }
});
Ext.reg("Pan.common.component.DGComboRecordForm", Pan.common.component.DGComboRecordForm);
Ext.ns('Pan.common.component');
Pan.common.component.TemplateComboRecordForm = Ext.extend(Ext.form.ComboBox, {
    tpl: new Ext.XTemplate('<tpl for=".">', '<tpl if="type == &quot;template-0&quot;"><div style="padding: 2px;border-color: #FFFFFF;overflow: hidden;"><span style="padding-left:0;">Template</span></div></tpl>', '<tpl if="type == &quot;templatestack-0&quot;"><div style="padding: 2px;border-color: #FFFFFF;overflow: hidden;"><span style="padding-left:0;">Template Stack</span></div></tpl>', '<div class="x-combo-list-item">', '<tpl if="type.indexOf(&quot;templatestack-&quot;) == 0">', '<span style="padding-left:1em;">{templateId}</span>', '<tpl for="moreInfo">', '<li style="padding-left:2em;font-size:10px;color: #888888;list-style-type: circle;">{.}</li>', '</tpl>', '</tpl>', '<tpl if="type.indexOf(&quot;template-&quot;) == 0">', '<span style="padding-left:1em;">{templateName}</span>', '</tpl>', '</div>', '</tpl>'),
    triggerAction: 'all',
    initComponent: function () {
        var data = this.getData();
        Ext.apply(this, {
            value: null,
            mode: 'local',
            store: new Ext.data.ArrayStore({
                autoDestroy: true,
                idIndex: 0,
                fields: ['templateId', 'templateName', 'type', 'moreInfo'],
                data: data
            }),
            valueField: 'templateId',
            displayField: 'templateName'
        });
        Pan.common.component.TemplateComboRecordForm.superclass.initComponent.apply(this, arguments);
    },
    getData: function () {
        var data = new Array();
        var sortFn = function (a, b) {
            var lhs = (a || "").toLowerCase();
            var rhs = (b || "").toLowerCase();
            if (lhs < rhs) {
                return -1;
            } else if (lhs > rhs) {
                return +1;
            } else {
                return 0;
            }
        };
        var stackSortFn = function (a, b) {
            var lhs = (a.name || "").toLowerCase();
            var rhs = (b.name || "").toLowerCase();
            if (lhs < rhs) {
                return -1;
            } else if (lhs > rhs) {
                return +1;
            } else {
                return 0;
            }
        };
        var list = Pan.global.getTemplateList();
        var stack = Pan.global.getTemplateStackList(true);
        if (Ext.isArray(list)) {
            list.sort(sortFn);
        }
        if (Ext.isArray(stack)) {
            stack.sort(stackSortFn);
        }
        var i = 0;
        if (!Ext.isEmpty(list)) {
            Ext.each(list, function (item) {
                data.push([item, item, 'template-' + i]);
                i++;
            });
        } else {
            var text = _T('No Accessible Template');
            data.push(['', text]);
        }
        i = 0;
        if (!Ext.isEmpty(stack)) {
            Ext.each(stack, function (item) {
                data.push([item.name, item.name, 'templatestack-' + i, item.templates || []]);
                i++;
            });
        }
        return data;
    }
});
Ext.reg("Pan.common.component.TemplateComboRecordForm", Pan.common.component.TemplateComboRecordForm);
Ext.ns('Pan.appframework.action.inspector');
Pan.appframework.action.inspector.PanInspector = Ext.extend(Pan.base.container.Panel, {
    innerWidth: 150,
    titleWidth: 70,
    initialHTML: '<div style="padding: 20px;"><img border="0" src="/images/wait_img.gif"/><span style="padding-left: 5px;">' + _T('Loading, please wait ...') + '</span></div>',
    noValueContent: '<div style="padding: 20px;"><span style="padding-left: 5px;">' + _T('There is no value for the selected item') + '</span></div>',
    noPermissionContent: '<div style="padding: 20px;"><span style="padding-left: 5px;">' + _T('You do not have permission for the selected item') + '</span></div>',
    constructor: function (config) {
        config = config || {};
        this.fieldName = config.fieldName;
        this.grid = config.grid;
        this.vsysName = Pan.global.getLoc().val;
        this.fromViewer = config.fromViewer;
        this.objName = config.objName;
        this.getCellValue = config.getCellValue;
        Pan.appframework.action.inspector.PanInspector.superclass.constructor.call(this, config);
    },
    initComponent: function () {
        var content = this.initialHTML;
        if (this.fromViewer) {
            var cellEventInfo = this.grid.cellEventInfo;
            if (cellEventInfo) {
                var record = cellEventInfo.record;
                var v = this.getFieldValue(record, this.fieldName);
                if (this.fieldName == 'REF_FIELD' && this.getRefFieldValue) {
                    v = this.getRefFieldValue(record);
                }
                this.objName = v;
                if (Ext.isArray(v)) {
                    this.objName = this.getCellValue ? this.getCellValue(v[cellEventInfo.miniCellRowIndex]) : v[cellEventInfo.miniCellRowIndex];
                }
            }
        }
        if (!this.objName || Ext.isEmpty(this.objName) || this.objName == 'any' || this.objName == 'none') {
            content = '<div style="padding: 20px;"><span style="padding-left: 5px;">' + _T('There is no value for the selected item') + '</span></div>';
        }
        Ext.apply(this, {
            autoHeight: true,
            autoWidth: true,
            boxMinWidth: 100,
            boxMaxWidth: 500,
            bodyStyle: 'background-color: transparent; border: none',
            layout: 'fit',
            html: content
        });
        Pan.appframework.action.inspector.PanInspector.superclass.initComponent.apply(this, arguments);
        this.on('afterrender', function () {
            this.updateContent();
        }, this);
    },
    getFieldValue: function (record, fieldName) {
        var fieldNames = Ext.isArray(fieldName) ? fieldName : [fieldName];
        var value, values;
        for (var i = 0, len = fieldNames.length; i < len; i++) {
            fieldName = fieldNames[i];
            if (Ext.isArray(fieldName)) {
                values = [];
                for (var j = 0, len2 = fieldName.length; j < len2; j++) {
                    value = record.get(fieldName[j]);
                    if (!Ext.isEmpty(value)) {
                        values.push(value);
                    }
                }
                if (values.length > 0) {
                    return values;
                }
            }
            else {
                value = record.get(fieldName);
                if (!Ext.isEmpty(value)) {
                    return value;
                }
            }
        }
    },
    getRbaPath: function (type) {
        return this.rbaPath;
    },
    refresh: function (content, obj, data, type) {
        this.update(content);
        if (this.ownerCt) {
            this.renderWidget(obj, data, type);
            this.ownerCt.doLayout(false, true);
            var browserHeight = Ext.getBody().getHeight();
            var menuHeight = this.ownerCt.el.getHeight();
            var currentY = this.ownerCt.getBox().y;
            var extra = menuHeight - (browserHeight - currentY);
            if (extra > 0) {
                this.ownerCt.el.setY(currentY - extra);
            }
        }
    },
    getDetail: function (data) {
        var result = data.result || {};
        var entry = result.entry || [];
        var obj = entry[0];
        data = undefined;
        var type = undefined;
        var content = this.noValueContent;
        if (obj) {
            if (obj['@__recordInfo']) {
                var recordInfo = Ext.decode(obj['@__recordInfo']);
                if (recordInfo)
                    type = recordInfo.type;
            }
            var rbaPath = this.getRbaPath(type);
            if (!Pan.appframework.PanAppInterface.hasReadPermission(rbaPath)) {
                content = this.noPermissionContent;
            } else {
                var tpl = this.getTpl(type);
                if (tpl) {
                    data = this.cleanData(this.convertData(obj, type));
                    content = tpl.apply(data);
                }
            }
        }
        this.refresh(content, obj, data, type);
    },
    convertData: function (data, type) {
        var func = Pan.appframework.action.inspector.DataConverter.get(type);
        if (func) {
            return func.call(func, data, this);
        }
        return null;
    },
    renderWidget: function (obj, data, type) {
        if (!data) {
            return;
        }
        var menus = data.menus;
        if (!Ext.isEmpty(menus)) {
            var prefix = '<span class="shorter-menu-member-prefix">' + _T('Members:') + '</span>';
            var cls = '';
            Ext.each(menus, function (item) {
                this.ownerCt.addMenuItem({
                    hideOnClick: false,
                    text: prefix + item,
                    cls: cls,
                    menu: {
                        items: {
                            hideOnClick: false,
                            xtype: this.xtype,
                            grid: this.grid,
                            fieldName: this.fieldName,
                            rbaPath: this.rbaPath,
                            inspectionTypes: this.inspectionTypes,
                            additional: this.additional,
                            objName: item
                        }
                    }
                });
                prefix = '';
                cls = 'shorter-menu-item';
            }, this);
        }
    },
    getLocation: function (record) {
        var location = record.get('location');
        if (!location || location === 'panorama') {
            location = Pan.base.json.path(record, "$.json.__recordInfo.vsysName") || Pan.global.getLoc().val;
        }
        return location;
    },
    updateContent: function () {
        if (!this.objName)
            return;
        var additionalParam = {};
        var record = this.grid.cellEventInfo.record;
        additionalParam['vsysName'] = this.getLocation(record);
        for (var m in this.additional) {
            if (this.additional.hasOwnProperty(m)) {
                additionalParam[m] = this.getFieldValue(record, this.additional[m]);
            }
        }
        PanDirect.run('PanDirect.getObjectByTypeAndName', [this.inspectionTypes, this.objName, additionalParam], this.getDetail.createDelegate(this));
    },
    cleanData: function (data) {
        if (data && data.data) {
            for (var i = 0; i < data.data.length; i++) {
                var entry = data.data[i];
                if (entry.doHTMLEncode !== false) {
                    if (entry.name) {
                        entry.name = Pan.base.htmlEncode(entry.name);
                    }
                    if (entry.value) {
                        entry.value = Pan.base.htmlEncode(entry.value);
                    }
                }
            }
        }
        return data;
    },
    getTpl: function (type) {
        var innerWidth = this.innerWidth;
        var titleWidth = this.titleWidth;
        var tpl = new Ext.XTemplate('<table style="padding: 0px 4px 0px 4px;white-space:normal">', '<tr><th colspan=2 style="text-align:center"><h3 style="background-color: #f5cf69">{type}</h3></th></tr>', '<tpl for="data">', '<tr>', '<td style="width:' + titleWidth + 'px; text-align:right; vertical-align:top">', '<div><strong>{name}</strong></div>', '</td>', '<td style="width:' + innerWidth + 'px;padding-left:4px;">', '<tpl if="name != \'ID:\'">', '<div>{value}</div>', '</tpl>', '<tpl if="name == \'ID:\'">', '<div>{value} (<em class="x-hyperlink" id={[this.getLinkId(values)]}><span>View in Threat Vault</span></em>)</div>', '</tpl>', '</td>', '</tr>', '</tpl>', '</table>', {
            getLinkId: function (values) {
                var result = Ext.id();
                this.addListener.defer(1, this, [result, values.value]);
                return result;
            }, addListener: function (id, value) {
                Ext.get(id).on('click', function (e) {
                    e.stopEvent();
                    var tid = parseInt(value, 10);
                    window.open(Pan.base.Constants.THREAT_VAULT_API + tid, '_blank');
                });
            }
        });
        tpl.compile();
        return tpl;
    }
});
Ext.reg('pan-inspector', Pan.appframework.action.inspector.PanInspector);
Pan.appframework.action.inspector.DataConverter = function () {
    var dataConverter = {};
    return {
        reg: function (type, func) {
            dataConverter[type] = func;
        }, get: function (type) {
            return dataConverter[type];
        }
    };
}();
Ext.ns('Pan.appframework.action.inspector');
Pan.appframework.action.inspector.PanInspectorAction = Ext.extend(Pan.base.action.Action, {
    inspectorXType: "pan-inspector", constructor: function (config) {
        if (config.inspectorXType) {
            this.inspectorXType = config.inspectorXType;
        }
        var newConfig = Ext.apply({
            hideOnClick: false,
            text: _T("Value"),
            iconCls: 'icon-general-info',
            menu: [],
            listeners: {activate: this.onActivate.createDelegate(this)}
        }, config);
        Pan.appframework.action.inspector.PanInspectorAction.superclass.constructor.call(this, newConfig);
    }, onActivate: function (item) {
        var scope = Pan.base.util.findRootOwnerCt(item).scope;
        if (!scope) {
            return;
        }
        var cellEventInfo = scope.cellEventInfo;
        if (!cellEventInfo)
            return;
        if (cellEventInfo == scope.lastCellEventInfo)
            return;
        scope.lastCellEventInfo = cellEventInfo;
        item.menu.removeAll(true);
        item.menu.destroy();
        item.menu = new Ext.menu.Menu();
        item.menu.addMenuItem({
            hideOnClick: false,
            xtype: this.inspectorXType,
            grid: scope,
            fieldName: this.initialConfig.fieldName,
            rbaPath: this.initialConfig.rbaPath,
            inspectionTypes: this.initialConfig.inspectionTypes,
            additional: this.initialConfig.additional,
            fromViewer: true,
            getCellValue: this.initialConfig.getCellValue,
            getRefFieldValue: this.initialConfig.getRefFieldValue,
            getResolverLoc: this.initialConfig.getResolverLoc
        });
    }
});
Pan.areg("pan-inspectoraction", Pan.appframework.action.inspector.PanInspectorAction);
Ext.ns('Pan.appframework.action.inspector');
Pan.appframework.action.inspector.DataConverter.reg('address', function (data, config) {
    var res = {type: _T('Address'), data: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    var type = '';
    var value = '';
    if (data['ip-netmask']) {
        type = _T('IP Netmask');
        value = data['ip-netmask'];
    } else if (data['ip-range']) {
        type = _T('IP Range');
        value = data['ip-range'];
    } else if (data['fqdn']) {
        type = _T('FQDN');
        value = data['fqdn'];
        if (!Pan.global.isCms()) {
            var treeNode = Pan.base.json.path(Pan.appframework.PanAppInterface.getBranch(), "$.id", 'unknown');
            var template = "<em class='x-hyperlink' onclick=\"Pan.common.resolveFQDN('{0}', '{1}', '{2}', '{4}');\">{3}</em>";
            res.data.push({
                doHTMLEncode: false,
                name: type + ':',
                value: String.format(template, value, treeNode, data['@initialVsys'] ? data['@initialVsys'] : config.vsysName, value, data['@name'])
            });
            return res;
        }
    } else if (data['dynamic']) {
        type = _T('Dynamic');
        value = data['dynamic'];
    }
    res.data.push({name: type + ':', value: value});
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('address-group', function (data, config) {
    var res = {type: _T('Address Group'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    if (data.static) {
        res.data.push({name: _T('Type:'), value: _T('Static')});
        Ext.each(data.static.member, function (m) {
            res.menus.push(m);
        });
    } else if (data.dynamic) {
        res.data.push({name: _T('Type:'), value: _T('Dynamic')});
        res.data.push({name: _T('Match:'), value: data.dynamic.filter});
        var template = "<em class='x-hyperlink' onclick=\"Pan.objects.addressGroups.util.showDynamicAddressGroup('{0}', '{1}', '{2}');\">{3}</em>";
        res.data.push({
            doHTMLEncode: false,
            name: '',
            value: String.format(template, config.objName, config.vsysName, 'vsys', _T("more"))
        });
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('external-list', function (data, config) {
    var res = {type: _T('External Dynamic List'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['type']) {
        if (data['type']['ip']) {
            if (data['type']['ip']['description']) {
                res.data.push({name: _T('Description:'), value: data['type']['ip']['description']});
            }
            if (data['type']['ip']['url']) {
                res.data.push({name: _T('URL:'), value: data['type']['ip']['url']});
            }
            if (data['type']['ip']['certificate-profile']) {
                res.data.push({name: _T('Cert Profile:'), value: data['type']['ip']['certificate-profile']});
            }
            if (data['type']['ip']['recurring']) {
                var recurring = Pan.objects.ExternalDynamicListsViewerHelper.getRecurringString(data['type']['ip']['recurring']);
                res.data.push({name: _T('Frequency:'), value: recurring});
            }
        }
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('region', function (data) {
    var res = {type: _T('Region'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    if (data['@help-string']) {
        res.data.push({name: _T('Type:'), value: _T('Predefined')});
        res.data.push({name: _T('Region:'), value: data['@help-string']});
    } else {
        if (data['geo-location']) {
            res.data.push({name: _T('Latitude:'), value: data['geo-location']['latitude']});
            res.data.push({name: _T('Longiture:'), value: data['geo-location']['longitude']});
        }
        if (data.address) {
            Ext.each(data.address.member, function (m) {
                res.menus.push(m);
            });
        }
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('service', function (data) {
    var res = {type: _T('Service'), data: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    var protocol = '';
    var port = '';
    if (data.protocol.tcp) {
        protocol = 'TCP';
        port = data.protocol.tcp.port;
    }
    else if (data.protocol.udp) {
        protocol = 'UDP';
        port = data.protocol.udp.port;
    }
    res.data.push({name: _T('Protocol:'), value: protocol});
    res.data.push({name: _T('Port:'), value: port});
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('service-group', function (data) {
    var res = {type: _T('Service Group'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    Ext.each(data.members.member, function (m) {
        res.menus.push(m);
    });
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('application', function (data) {
    var appName = data['@name'];
    var descriptionFromCache = undefined;
    var appFromCache = _.filter(Pan.appframework.PanPredefinedCache.getData("app"), {name: appName})[0];
    if (appFromCache) {
        descriptionFromCache = appFromCache['description'];
    }
    var description = Ext.isEmpty(descriptionFromCache) ? data['description'] : descriptionFromCache;
    var res = {type: _T('Application'), data: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    res.data.push({name: _T('Description:'), value: description});
    res.data.push({name: _T('Category:'), value: data['category']});
    res.data.push({name: _T('Subcategory:'), value: data['subcategory']});
    res.data.push({name: _T('Technology:'), value: data['technology']});
    res.data.push({name: _T('Risk:'), value: data['risk']});
    var _stdPorts = jsonPath(data, '$.default.port.member.*');
    if (_stdPorts !== false) {
        if (Ext.isArray(_stdPorts)) {
            for (var j = 0; j < _stdPorts.length; j++) {
                _stdPorts[j] = Pan.base.htmlEncode(_stdPorts[j]);
            }
            res.data.push({doHTMLEncode: false, name: _T('Standard Ports:'), value: _stdPorts.join('<br/>')});
        }
    }
    var _usedApps = jsonPath(data, '$.use-applications.member.*');
    var _implicitUseApps = jsonPath(data, '$.implicit-use-applications.member.*');
    if (_usedApps !== false) {
        if (Ext.isArray(_usedApps)) {
            var displayApps = _usedApps;
            if (Ext.isArray(_implicitUseApps)) {
                displayApps = [];
                for (var i = 0; i < _usedApps.length; i++) {
                    if (_implicitUseApps.indexOf(_usedApps[i]) === -1) {
                        displayApps.push(Pan.base.htmlEncode(_usedApps[i]));
                    }
                }
            }
            res.data.push({doHTMLEncode: false, name: _T('Depends on:'), value: displayApps.join('<br/>')});
        }
    }
    var characteristics = [];
    if (data['evasive-behavior'] == 'yes') {
        characteristics.push(_T('Evasive'));
    }
    if (data['consume-big-bandwidth'] == 'yes') {
        characteristics.push(_T('Excessive Bandwidth'));
    }
    if (data['used-by-malware'] == 'yes') {
        characteristics.push(_T('Used by Malware'));
    }
    if (data['able-to-transfer-file'] == 'yes') {
        characteristics.push(_T('Transfers Files'));
    }
    if (data['has-known-vulnerability'] == 'yes') {
        characteristics.push(_T('Vulnerability'));
    }
    if (data['tunnel-other-application'] == 'yes') {
        characteristics.push(_T('Tunnels Other Apps'));
    }
    if (data['prone-to-misuse'] == 'yes') {
        characteristics.push(_T('Prone to Misuse'));
    }
    if (data['pervasive-use'] == 'yes') {
        characteristics.push(_T('Widely used'));
    }
    if (!Ext.isEmpty(characteristics)) {
        res.data.push({doHTMLEncode: false, name: _T('Characteristic:'), value: characteristics.join('<br/>')});
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('application-container', function (data) {
    var res = {type: _T('Application Container'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    res.data.push({name: _T('Description:'), value: data['description']});
    if (data.functions && data.functions.member) {
        Ext.each(data.functions.member, function (m) {
            res.menus.push(m.text || m);
        });
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('application-group', function (data) {
    var res = {type: _T('Application Group'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    if (data.members && data.members.member) {
        Ext.each(data.members.member, function (m) {
            res.menus.push(m);
        });
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('application-filter', function (data) {
    var label;
    var res = {type: _T('Application Filter'), data: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['description']) {
        res.data.push({name: _T('Description:'), value: data['description']});
    }
    if (data.category && data.category.member) {
        label = _T('Category:');
        Ext.each(data.category.member, function (m) {
            res.data.push({doHTMLEncode: false, name: label, value: Pan.base.htmlEncode(m)});
            label = ' &nbsp;';
        });
    }
    if (data.subcategory && data.subcategory.member) {
        label = _T('Subcategory:');
        Ext.each(data.subcategory.member, function (m) {
            res.data.push({doHTMLEncode: false, name: label, value: Pan.base.htmlEncode(m)});
            label = ' &nbsp;';
        });
    }
    if (data.technology && data.technology.member) {
        label = _T('Technology:');
        Ext.each(data.technology.member, function (m) {
            res.data.push({doHTMLEncode: false, name: label, value: Pan.base.htmlEncode(m)});
            label = ' &nbsp;';
        });
    }
    if (data.risk && data.risk.member) {
        label = _T('Risk:');
        Ext.each(data.risk.member, function (m) {
            res.data.push({doHTMLEncode: false, name: label, value: Pan.base.htmlEncode(m)});
            label = ' &nbsp;';
        });
    }
    var characteristics = [];
    if (data['evasive-behavior'] == 'yes') {
        characteristics.push(_T('Evasive'));
    }
    if (data['consume-big-bandwidth'] == 'yes') {
        characteristics.push(_T('Excessive Bandwidth'));
    }
    if (data['used-by-malware'] == 'yes') {
        characteristics.push(_T('Used by Malware'));
    }
    if (data['able-to-transfer-file'] == 'yes') {
        characteristics.push(_T('Transfers Files'));
    }
    if (data['has-known-vulnerability'] == 'yes') {
        characteristics.push(_T('Vulnerability'));
    }
    if (data['tunnel-other-application'] == 'yes') {
        characteristics.push(_T('Tunnels Other Apps'));
    }
    if (data['prone-to-misuse'] == 'yes') {
        characteristics.push(_T('Prone to Misuse'));
    }
    if (data['pervasive-use'] == 'yes') {
        characteristics.push(_T('Widely used'));
    }
    if (!Ext.isEmpty(characteristics)) {
        res.data.push({doHTMLEncode: false, name: _T('Characteristic:'), value: characteristics.join('<br/>')});
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('server-profile/dns', function (data) {
    var res = {type: _T('DNS Server Profile'), data: [], menus: []};
    res.data.push({name: _T('Name:'), value: data['@name']});
    if (data['primary']) {
        res.data.push({name: _T('Primary:'), value: data['primary']});
    }
    if (data['secondary']) {
        res.data.push({name: _T('Secondary:'), value: data['secondary']});
    }
    return res;
});
Pan.appframework.action.inspector.DataConverter.reg('ike-peer-address', function (data) {
    var res = {type: _T('FQDN'), data: []};
    res.data.push({name: _T('IP:'), value: data['text']});
    return res;
});
Ext.ns('Pan.appframework.builder');
Pan.appframework.builder.PanCompletionBuilder = (function () {
    return Pan.base.util.createExtension(function (comp, config) {
        comp = arguments.callee.superFunction.apply(this, arguments);
        var dollarField = config.fields.get("$");
        var completionConfig = Ext.apply({
            rootJSONPath: dollarField ? dollarField.rootJSONPath : '',
            rootPathInfo: dollarField && dollarField.rootPathInfo,
            completionField: config.field
        }, comp.completionConfig);
        var path = completionConfig.path;
        var completion = comp.completion;
        if (Ext.isFunction(completion) && !completion.directCfg) {
            completion = completion();
        }
        Ext.applyIf(comp, {
            largeSelectionCount: Pan.base.form.RadioCard.prototype.largeSelectionCount,
            store: Pan.appframework.modelview.getCompleteStoreCfg(completion || PanDirect.runCallback('PanDirect.autoComplete'), path, undefined, Ext.applyIf(completionConfig, comp.zconfig))
        });
        if (comp.store.zconfig && completionConfig) {
            Ext.applyIf(comp.store.zconfig, completionConfig);
        }
        if (comp.mode !== 'local') {
            if (comp.association) {
                if (!Ext.isArray(comp.association)) {
                    comp.association = [comp.association];
                }
                else {
                    comp.association = comp.association.slice(0);
                }
            }
            else {
                comp.association = [];
            }
            if (Pan.global.isMultiVsys() || Pan.global.isCmsSelected()) {
                comp.association.push({
                    listenToIfExists: true,
                    listenToAfterInit: false,
                    match: {evaluate: 'fieldEvt', field: 'location'},
                    exec: comp.locationAssociationExec || {
                        evaluate: function () {
                            if (this.__component.clearValueEx && !this.__component.doNotListenToLocationChange) {
                                var clearValue = this.__component.alwaysClearWhenLocationChange || this.__component.getRecord().phantom;
                                this.__component.clearValueEx(true, clearValue);
                            }
                        }
                    }
                });
            }
            if (completionConfig.localCompletionSource) {
                if (comp.isAnEditor) {
                    comp.alwaysReload = true;
                }
                comp.association.push({
                    listenToIfExists: true,
                    listenToAfterInit: false,
                    match: {
                        evaluate: 'fieldDataEvt',
                        operands: [{
                            event: completionConfig.localCompletionEvent || ['add', 'remove', 'datachanged'],
                            field: completionConfig.localCompletionSource,
                            observableCallChain: 'store'
                        }]
                    },
                    exec: comp.locationAssociationExec || {
                        evaluate: function () {
                            var store = this.__component.getStore();
                            if (this.__eventArg.length === 3) {
                                var record = this.__eventArg[1];
                                if (!Ext.isArray(record)) {
                                    var deletedRecordId = record.get(this.__listenField.idProperty);
                                    var id = store.idProperty;
                                    if (deletedRecordId && id) {
                                        store.each(function (r) {
                                            if (r.get(id) === deletedRecordId) {
                                                store.remove(r);
                                            }
                                        }, this);
                                    }
                                }
                            }
                            if (this.__component.clearValueEx) {
                                this.__component.clearValueEx(true, false);
                            }
                        }
                    }
                });
            }
        }
        if (comp.xtype) {
            return comp;
        }
        var multivalue = comp.multivalue;
        if (multivalue === undefined) {
            multivalue = config.field.nodetype === 'array';
        }
        if (multivalue) {
            if (config.field.maxCount == 1) {
                Ext.applyIf(comp, {xtype: 'pan-singleentry'});
            }
            else {
                if (comp.prefilledCompletionGrid) {
                    Ext.applyIf(comp, {
                        xtype: 'pan-grid',
                        supportFastRender: false,
                        height: Pan.base.Constants.defaultCompletionGridHeight,
                        useCheckBoxSelection: true,
                        cls: 'no-background',
                        selectionAlwaysToggleOnAndOff: true,
                        hideHeaders: true,
                        stripeRows: false,
                        columnLines: false,
                        gridColumns: ['display'],
                        useColumns: 'gridColumns',
                        columnConfig: {'display': {header: config.field.uiHint.fieldLabel}},
                        hasGridFilter: false
                    });
                }
                else if (comp.prefilledCompletionTreeGrid) {
                    var columnConfig = Ext.apply({}, comp.columnConfig, {
                        'display': {
                            useTreeNodeRenderer: true,
                            supportTreeSelection: true,
                            renderer: Pan.renderer({
                                xtype: 'PanTreeNodeRenderer',
                                text: function (value) {
                                    return value;
                                },
                                tip: function (value, meta, r, row, col, store, grid) {
                                    return grid.getTreeNodeTooltip.apply(this, arguments);
                                },
                                imgcls: 'x-pan-treegrid-imgcls',
                                image: function (value, meta, r, row, col, store, grid) {
                                    return grid.getTreeNodeImage.apply(this, arguments);
                                },
                                onClick: function () {
                                }
                            })
                        }
                    });
                    Ext.applyIf(comp, {
                        xtype: 'pan-completiontreegrid',
                        showSelectedCount: true,
                        height: Pan.base.Constants.defaultCompletionGridHeight,
                        useCheckBoxSelection: true,
                        enableHdMenu: true,
                        filterStateFul: false,
                        gridColumns: ['display'],
                        useColumns: 'gridColumns',
                        getTreeNodeTooltip: function () {
                            return "";
                        },
                        getTreeNodeImage: function () {
                            return "/js/3rdParty/ext/resources/images/default/s.gif";
                        },
                        multivalue: true
                    });
                    comp.columnConfig = columnConfig;
                    if (!comp.bbar) {
                        comp.bbar = [{atype: 'selectAllAction'}, {atype: 'deSelectAllAction'}];
                    }
                    comp.store.zconfig = comp.store.zconfig || {};
                    if (comp.store.zconfig) {
                        Ext.applyIf(comp.store.zconfig, {
                            parentRecordField: 'parentIDField',
                            sortable: false,
                            sortInfo: {field: 'sortField', direction: "ASC"},
                            treeRecordIdField: ["type", "value"]
                        });
                    }
                }
                else if (comp.itemSelector) {
                    Ext.applyIf(comp, {
                        xtype: 'pan-itemselector',
                        height: Pan.base.Constants.defaultCompletionGridHeight,
                        displayField: 'display',
                        valueField: 'value',
                        availableHeader: config.field.uiHint.availableHeader,
                        selectedHeader: config.field.uiHint.selectedHeader
                    });
                }
                else {
                    Ext.applyIf(comp, {
                        xtype: 'pan-completiongrid',
                        height: comp.isAnEditor ? Pan.base.Constants.defaultCompletionGridEditorHeight : Pan.base.Constants.defaultCompletionGridHeight
                    });
                    if (!comp.bbar) {
                        comp.bbar = [{
                            atype: 'addRecordAction',
                            delayStartEditing: true,
                            checkCount: true,
                            nontransferable: true
                        }, {atype: 'deleteRecordAction'}];
                        if (comp.isOrdered) {
                            comp.bbar.push("moveUpRecordAction", "moveDownRecordAction");
                            Ext.applyIf(comp, {enableDragDrop: true, ddGroup: config.field.name});
                        }
                    }
                }
                if (comp.isAnEditor) {
                    Ext.applyIf(comp, {frame: true});
                }
                else {
                    comp.style = comp.style || {};
                    if (Ext.isObject(comp.style)) {
                        Ext.applyIf(comp.style, {marginBottom: Pan.base.Constants.generatedGridMarginBottom});
                    }
                }
                if (comp.fieldLabel === comp.fieldLabelAutoGen) {
                    Ext.apply(comp, {fieldLabel: ''});
                }
            }
        }
        else {
            if (comp.mode === 'local' && comp['enum']) {
                if (comp.localEnumAppendHelpString && comp.helpStrings) {
                    for (var k = 0; k < comp['enum'].length; k++) {
                        comp['enum'][k] = comp['enum'][k].slice(0);
                        var value = comp['enum'][k][0];
                        if (Ext.isDefined(value)) {
                            comp['enum'][k][1] = value + (Ext.isDefined(comp.helpStrings[value]) ? " (" + comp.helpStrings[value] + ")" : "");
                        }
                    }
                }
                else if (!comp.useHelpStringAsDisplay) {
                    for (var i = 0; i < comp['enum'].length; i++) {
                        comp['enum'][i] = comp['enum'][i].slice(0);
                        comp['enum'][i][1] = comp['enum'][i][0];
                    }
                }
                if (comp['enum'].length < comp.largeSelectionCount && !comp.isAnEditor && (!comp.allowBlank || !(config.field.defaultValue === "" || config.field.defaultValue === undefined))) {
                    if (comp['enum'].length == 1) {
                        Ext.applyIf(comp, {disabled: true, hideTrigger: true});
                    }
                    else {
                        var radioItems = [];
                        for (var j = 0; j < comp['enum'].length; j++) {
                            radioItems.push({
                                boxLabel: _TC(comp['enum'][j][1]),
                                inputValue: comp['enum'][j][0],
                                name: comp.itemId,
                                tooltip: comp.helpTips ? comp.helpTips[comp['enum'][j][0]] : undefined
                            });
                        }
                        Ext.applyIf(comp, {
                            xtype: 'pan-radiogroup',
                            useFlowStyle: true,
                            value: radioItems[0].inputValue,
                            items: radioItems
                        });
                    }
                }
            }
            else {
                if (comp.useHelpStringAsDisplay) {
                    if (comp.store.zconfig) {
                        Ext.applyIf(comp.store.zconfig, {
                            getDisplayStr: function (config, e) {
                                return e['@help-string'];
                            }
                        });
                    }
                }
            }
            Ext.applyIf(comp, {
                remoteFilter: true,
                expandOnInitEditor: true,
                minChars: 0,
                displayCount: Pan.base.Constants.defaultComboDisplayCount
            });
            if (comp.store.zconfig) {
                Ext.applyIf(comp.store.zconfig, {displayCount: comp.displayCount});
            }
            var forceSelection = !config.field['looseMembership'] && !comp.multiValidationInfo;
            Ext.applyIf(comp, {
                xtype: comp.useTextAreaCombo ? 'pan-textareacombo' : 'pan-combo',
                forceSelection: forceSelection,
                autoSelect: forceSelection
            });
            if (config.field['looseMembership']) {
                delete comp.vtype;
            }
            if (config.field.multitypes && comp.multiValidationInfo) {
                if (!config.field.multitypes['enum'] && !config.field.autoComplete) {
                    Ext.applyIf(comp, {hideTrigger: true, mode: 'local'});
                }
            }
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
}());
Pan.breg("PanCompletionBuilder", Pan.appframework.builder.PanCompletionBuilder);
Ext.ns('Pan.appframework.builder');
Pan.appframework.builder.PanEditorDialogBuilder = function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return comp;
        }
        var isInWindow = Ext.isDefined(comp.isInWindow) ? comp.isInWindow : true;
        comp = arguments.callee.superFunction.apply(this, arguments);
        Ext.apply(comp, {isInWindow: isInWindow});
        if (isInWindow) {
            comp.xtype = 'GridRecordDialogEditor';
        } else {
            comp.xtype = 'GridRecordEditor';
        }
        return comp;
    }, Pan.base.autorender.builder.GridRecordFormBuilder);
}();
Pan.breg("PanEditorDialogBuilder", Pan.appframework.builder.PanEditorDialogBuilder);
Ext.ns('Pan.appframework.builder');
Pan.appframework.builder.PanCompletionGridToolbarBuilder = function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        if (config.enumValues.length == 1) {
            Ext.applyIf(comp, {
                xtype: 'pan-checkbox',
                itemId: config.caller.itemId + '-' + 'anyCheckbox',
                boxLabel: config.caller.supportAny,
                handler: function (grid, config, value) {
                    grid.validate();
                }
            });
        } else {
            var values = [];
            var e = config.enumValues;
            for (var i = 0; i < e.length; i++) {
                values.push([e[i][0], e[i][1]]);
            }
            values.push(["", Pan.base.Constants.selectstr]);
            Ext.applyIf(comp, {
                xtype: 'pan-combo',
                onResize: Pan.base.util.createExtension(function (w, h) {
                    arguments.callee.superFunction.apply(this, arguments);
                    this.wrap.setWidth(w);
                }, Ext.form.ComboBox.prototype.onResize),
                itemId: config.caller.itemId + '-' + 'enumSelectionCombo',
                mode: 'local',
                'enum': values,
                width: 140,
                listeners: {
                    'select': function (combo) {
                        if (combo && combo.ownerCt && combo.ownerCt.ownerCt && combo.ownerCt.ownerCt.validate) {
                            combo.ownerCt.ownerCt.validate();
                        }
                    }
                }
            });
        }
        return comp;
    }, Pan.base.autorender.builder.Builder);
}();
Pan.breg("PanCompletionGridToolbarBuilder", Pan.appframework.builder.PanCompletionGridToolbarBuilder);
Ext.ns('Pan.appframework.builder');
Pan.appframework.builder.PanCompletionGroupBuilder = function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return comp;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        if (comp.store.zconfig) {
            var remoteSort = Pan.base.json.path(comp, "$.remoteSort", true);
            Ext.applyIf(comp.store.zconfig, {
                remoteSort: remoteSort,
                remoteFilterHelpString: comp.remoteFilterHelpString
            });
        }
        comp.xtype = 'pan-groupcombo';
        Ext.apply(comp.store.zconfig, {
            checkTypeExist: true,
            multiSortInfo: {
                sorters: [{field: 'type', direction: 'ASC'}, {field: 'sortField', direction: 'ASC'}],
                direction: 'ASC'
            },
            hasMultiSort: true
        });
        if (comp.typeReplacementMap) {
            Ext.applyIf(comp.store.zconfig, {typeReplacementMap: comp.typeReplacementMap});
        }
        return comp;
    }, Pan.appframework.builder.PanCompletionBuilder);
}();
Pan.breg("PanCompletionGroupBuilder", Pan.appframework.builder.PanCompletionGroupBuilder);
Ext.ns('Pan.appframework.builder');
Pan.appframework.builder.PanViewerBuilder = function () {
    return Pan.base.util.createExtension(function (comp, config) {
        if (comp.xtype) {
            return comp;
        }
        comp = arguments.callee.superFunction.apply(this, arguments);
        var viewerConfig = Ext.apply({}, comp);
        Ext.applyIf(comp, {xtype: 'pan-container', layout: 'fit', items: Pan.create(viewerConfig)});
        return comp;
    }, Pan.base.autorender.builder.Builder);
}();
Pan.breg("PanViewerBuilder", Pan.appframework.builder.PanViewerBuilder);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanSingleEntryField = Ext.extend(Pan.base.autorender.GridRecordField, {
    initComponent: function () {
        this.singleEntryFieldName = this.__field.childrenNames[0];
        Ext.applyIf(this, {
            items: {
                itemId: this.singleEntryFieldName,
                anchor: '100%',
                hideLabel: true,
                fieldLabelPlugin: undefined,
                isExtFormField: false
            },
            defaults: {
                allowBlank: this.allowBlank,
                allowBlankValidation: this.allowBlankValidation,
                defaultValue: this.getStarField().defaultValue,
                noneString: this.noneString,
                isExtFormField: false
            },
            layout: 'form',
            cls: 'x-pan-singleentry',
            autoHeight: true
        });
        if (this.getStarField().children) {
            this.setupStore();
        }
        Pan.appframework.component.PanSingleEntryField.superclass.initComponent.apply(this, arguments);
    }, getSingleEntryField: function () {
        return this.singleEntryField || (this.singleEntryField = this.findByItemId(this.singleEntryFieldName));
    }, getRealField: function () {
        return this.getSingleEntryField();
    }, initValueChanged: function () {
        Pan.appframework.component.PanSingleEntryField.superclass.initValueChanged.apply(this, arguments);
        var comps = this.findBy(function (c) {
            if (c.initValueChanged) {
                return true;
            }
        });
        Ext.each(comps, function (a) {
            a.initValueChanged();
        });
    }, hasValueChanged: function () {
        var valueChanged = false;
        var comps = this.findBy(function (c) {
            if (c.hasValueChanged) {
                return true;
            }
        });
        Ext.each(comps, function (a) {
            if (a.hasValueChanged()) {
                valueChanged = true;
                return false;
            }
        });
        return valueChanged;
    }, setValue: function (v) {
        if (this.getStarField().children) {
            if (!Ext.isArray(v)) {
                v = [undefined];
            }
            this.store.setValue(v, this.getStarField());
            this.record = this.store.data.items[0];
            this.populate(this.record.data);
        }
        else {
            var value = Ext.isArray(v) && v.length > 0 && v[0] || (!this.allowBlank && this.getSingleEntryField().defaultValue) || undefined;
            this.getSingleEntryField().setValue(value);
            this.testValueChangedWithoutVerify();
        }
        return this;
    }, getValue: function () {
        if (this.getStarField().children) {
            this.gatherData();
            return this.store.getValue(this.getStarField());
        }
        else {
            var value = this.getSingleEntryField().getValue();
            return value ? [value] : undefined;
        }
    }, reset: function () {
        this.setValue(this.getSingleEntryField().defaultValue);
    }, populate: function (values) {
        var field, id;
        for (id in values) {
            field = this.findByItemId(id);
            if (field) {
                if (Ext.isFunction(field.setValue)) {
                    field.setValue(values[id]);
                }
            }
        }
    }, gatherData: function () {
        this.getStarField().visit(function (f) {
            var field = this.findByItemId(f.name);
            if (field) {
                if (Ext.isFunction(field.getValue)) {
                    this.record.data[f.name] = field.getValue();
                }
            }
        }, this);
    }, setupStore: function () {
        if (this.store && this.store.ztype) {
            this.store = new this.store.ztype(this.createStoreConfig(this.store));
        }
    }, createStoreConfig: function (store) {
        var config = Ext.applyIf({
            record: this.getRecord(),
            __pdefaults: this.__pdefaults,
            starField: this.getStarField()
        }, store.zconfig);
        if (store.zconfig.reader) {
            config.reader = new this.store.zconfig.reader(config);
        }
        return config;
    }, getStarField: function () {
        return this.__field.children[0];
    }, isValid: function () {
        if (this.getSingleEntryField().isValid) {
            return this.getSingleEntryField().isValid();
        }
        return Pan.appframework.component.PanSingleEntryField.superclass.isValid.apply(this, arguments);
    }, validate: function () {
        if (this.getSingleEntryField().validate) {
            return this.getSingleEntryField().validate();
        }
        return Pan.appframework.component.PanSingleEntryField.superclass.validate.apply(this, arguments);
    }, markInvalid: function (msg) {
        if (this.getSingleEntryField().markInvalid) {
            return this.getSingleEntryField().markInvalid(msg);
        }
        return Pan.appframework.component.PanSingleEntryField.superclass.markInvalid.apply(this, arguments);
    }, clearInvalid: function () {
        if (this.getSingleEntryField().clearInvalid) {
            return this.getSingleEntryField().clearInvalid();
        }
        return Pan.appframework.component.PanSingleEntryField.superclass.clearInvalid.apply(this, arguments);
    }
});
Ext.reg("pan-singleentry", Pan.appframework.component.PanSingleEntryField);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanMultitypeGrid = Ext.extend(Pan.base.grid.EditorGridPanel, {
    saveData: true,
    enableHdMenu: false,
    supportAny: false,
    hasGridFilter: false,
    supportScrollOffsetColumn: true,
    useCheckBoxSelection: true,
    allowBlankValidation: true,
    getEnumValues: function () {
        if (!this.enumValues) {
            var e;
            var multitypes = this.getStarField().multitypes;
            if (multitypes) {
                for (var m in multitypes) {
                    if (multitypes.hasOwnProperty(m)) {
                        switch (m) {
                            case'enum':
                                e = multitypes[m];
                                for (var i = 0; i < e.length; i++) {
                                    if (e[i][0] === 'any') {
                                        this.supportAny = _TC(e[i][1] || e[i][0]);
                                        break;
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
            this.enumValues = e;
        }
        return this.enumValues;
    },
    initComponent: function () {
        if (this.isAnEditor) {
            Ext.applyIf(this, {hideHeaders: true});
        }
        var enumValues = this.getEnumValues();
        if (this.supportAny) {
            var tconfig = {
                field: this.__field,
                fields: this.__pdefaults && this.__pdefaults.__fields,
                enumValues: enumValues,
                caller: this
            };
            var tcomp = {};
            Pan.appframework.builder.PanCompletionGridToolbarBuilder(tcomp, tconfig);
            this.tbar = this.tbar || [];
            this.tbar.push(tcomp);
        }
        if (this.drawer) {
            if (this.useToolbar === false) {
                this.tbar = this.tbar || [];
                this.tbar.push('->');
                this.tbar.push({atype: 'browseAction', text: '', tooltip: _T('Browse')});
            }
            else {
                this.bbar = this.bbar || [];
                this.bbar.splice(0, 0, {atype: 'browseAction', text: _T('Browse'), tooltip: _T('Browse')});
            }
        }
        else if (this.initialConfig.selectActionConfig) {
            var selectActionConfig = _.clone(this.initialConfig.selectActionConfig);
            selectActionConfig.atype = 'selectAction';
            this.bbar = this.bbar || [];
            this.bbar.unshift(selectActionConfig);
        }
        if (!this.isOrdered) {
            var cfg = this.store;
            if (cfg.zconfig) {
                cfg = cfg.zconfig;
            }
            Ext.applyIf(cfg, {sortInfo: {field: this.getStarField().name, direction: "ASC"}});
        }
        Pan.appframework.component.PanMultitypeGrid.superclass.initComponent.apply(this, arguments);
        this.store.addListener('add', this.onRecordAdd, this, {delay: 1});
    },
    onBulkRemove: function (store) {
        Pan.appframework.component.PanMultitypeGrid.superclass.onBulkRemove.apply(this, arguments);
        this.checkAnyWhenNeeded(store);
    },
    onRecordRemove: function (store) {
        Pan.appframework.component.PanMultitypeGrid.superclass.onRecordRemove.apply(this, arguments);
        this.checkAnyWhenNeeded(store);
    },
    checkAnyWhenNeeded: function (store) {
        if (this.supportAny) {
            if (store.getCount() == 0) {
                var anyCheckbox = this.topToolbar.findByItemId(this.itemId + '-' + "anyCheckbox");
                if (anyCheckbox) {
                    anyCheckbox.setValue(true);
                }
                else {
                    this.topToolbar.findByItemId(this.itemId + '-' + "enumSelectionCombo").setValue(this.getStarField().defaultValue);
                    this.validate();
                }
            }
        }
    },
    onRecordAdd: function () {
        Pan.appframework.component.PanMultitypeGrid.superclass.onRecordAdd.apply(this, arguments);
        if (this.supportAny) {
            var anyCheckbox = this.topToolbar.findByItemId(this.itemId + '-' + "anyCheckbox");
            if (anyCheckbox) {
                anyCheckbox.setValue(false);
            }
            else {
                this.topToolbar.findByItemId(this.itemId + '-' + "enumSelectionCombo").setValue("");
            }
        }
    },
    setupSelectionModel: function () {
        Pan.appframework.component.PanMultitypeGrid.superclass.setupSelectionModel.apply(this, arguments);
        if (this.selModel) {
            this.selModel.moveEditorOnEnter = false;
        }
    },
    preEditValue: function () {
        var rv = Pan.appframework.component.PanMultitypeGrid.superclass.preEditValue.apply(this, arguments);
        if (this.supportAny) {
            if (rv === 'any') {
                return undefined;
            }
            else if (this.enumValues) {
                var e = this.enumValues;
                for (var i = 0; i < e.length; i++) {
                    if (e[i][0] === rv) {
                        return undefined;
                    }
                }
            }
        }
        return rv;
    },
    postEditValue: function (value, originalValue, r) {
        var rv = Pan.appframework.component.PanMultitypeGrid.superclass.postEditValue.apply(this, arguments);
        if (r && r.store) {
            var doPostEdit = true;
            if (this.supportAny) {
                if (value === 'any' || value === "" || value === undefined) {
                    r.store.remove(r);
                    doPostEdit = false;
                }
                else if (this.enumValues) {
                    var e = this.enumValues;
                    for (var i = 0; i < e.length; i++) {
                        if (e[i][0] === value) {
                            r.store.remove(r);
                            doPostEdit = false;
                            break;
                        }
                    }
                }
            }
            if (doPostEdit) {
                var ae = this.lastActiveEditor;
                if (ae.postEditValue) {
                    ae.postEditValue.apply(this, arguments);
                }
                else if (ae.field.postEditValue) {
                    ae.field.postEditValue.apply(this, arguments);
                }
            }
        }
        return rv;
    },
    stopEditing: function (cancel) {
        if (cancel && this.editing && this.activeEditorIsInitialAdd) {
            var ae = this.activeEditor;
            if (ae) {
                this.store.removeAt(ae.row);
            }
        }
        Pan.base.grid.EditorGridPanel.superclass.stopEditing.apply(this, arguments);
    },
    clearValueEx: function (validate, clearValue) {
        if (clearValue) {
            this.store.removeAll();
        }
        if (validate) {
            this.validate();
        }
    },
    getAuxiliaryValue: function () {
        if (this.supportAny) {
            var anyCheckbox = this.topToolbar.findByItemId(this.itemId + '-' + "anyCheckbox");
            if (anyCheckbox) {
                if (anyCheckbox.getValue()) {
                    return ["any"];
                }
            }
            else {
                var enumSelectionCombo = this.topToolbar.findByItemId(this.itemId + '-' + "enumSelectionCombo");
                if (enumSelectionCombo && enumSelectionCombo.getValue()) {
                    return [enumSelectionCombo.getValue()];
                }
            }
        }
        return undefined;
    },
    isEmpty: function (store) {
        return store.getCount() < 1 && !this.getAuxiliaryValue();
    },
    getValue: function () {
        var value = this.getAuxiliaryValue();
        if (!Ext.isDefined(value)) {
            if (!this.isOrdered) {
                this.store.sort(this.getStarField().name, "ASC");
            }
            value = Pan.appframework.component.PanMultitypeGrid.superclass.getValue.apply(this, arguments);
        }
        return value;
    },
    setValue: function (v) {
        if (this.supportAny) {
            if (this.rendered) {
                var anyCheckbox = this.topToolbar.findByItemId(this.itemId + '-' + "anyCheckbox");
                if (anyCheckbox) {
                    if (v && v[0] === "any") {
                        anyCheckbox.setValue(true);
                        v = [];
                    }
                }
                else {
                    var enumSelectionCombo = this.topToolbar.findByItemId(this.itemId + '-' + "enumSelectionCombo");
                    if (enumSelectionCombo) {
                        var r = enumSelectionCombo.findRecord(enumSelectionCombo.valueField, v[0]);
                        if (r) {
                            enumSelectionCombo.setValue(v[0]);
                            v = [];
                        }
                        else {
                            enumSelectionCombo.setValue("");
                        }
                    }
                }
            }
            else {
                this.delaySetValue = true;
                this.fieldValue = v;
            }
        }
        var rv = Pan.appframework.component.PanMultitypeGrid.superclass.setValue.call(this, v);
        if (!this.isOrdered) {
            this.store.sortData();
        }
        return rv;
    },
    onRender: function () {
        Pan.appframework.component.PanMultitypeGrid.superclass.onRender.apply(this, arguments);
        if (this.delaySetValue) {
            delete this.delaySetValue;
            this.setValue(this.fieldValue);
        }
    }
});
Ext.reg("pan-multitypegrid", Pan.appframework.component.PanMultitypeGrid);
Pan.appframework.component.PanTextAreaCombo = Ext.extend(Pan.base.form.ComboBox, {
    growMin: 60,
    growMax: 1000,
    growAppend: '&#160;\n&#160;',
    enterIsSpecial: false,
    renderFieldBtns: true,
    allowQueryAll: true,
    appendValues: false,
    valueDelimiter: ' ',
    selectOnFocus: false,
    autoSelect: false,
    expandBtnCls: '',
    insertDelimiterOnAppendValue: true,
    preventScrollbars: false,
    hideTrigger: true,
    onRender: function () {
        if (!this.el) {
            this.defaultAutoCreate = {tag: "textarea", style: "width:100px;height:35px;", autocomplete: "off"};
        }
        Pan.appframework.component.PanTextAreaCombo.superclass.onRender.apply(this, arguments);
        if (this.grow) {
            this.textSizeEl = Ext.DomHelper.append(document.body, {tag: "pre", cls: "x-form-grow-sizer"});
            if (this.preventScrollbars) {
                this.el.setStyle("overflow", "hidden");
            }
            this.el.setHeight(this.growMin);
        }
        this.wrapEl = this.el.wrap({tag: 'ul'});
        this.outerWrapEl = this.wrapEl.wrap({
            tag: 'div',
            cls: 'textarea x-superboxselect x-superboxselect-display-btns'
        });
        if (this.renderFieldBtns) {
            this.setupFieldButtons();
        }
    },
    setupFieldButtons: function () {
        this.buttonWrap = this.outerWrapEl.createChild({cls: 'x-superboxselect-btns'});
        if (this.allowQueryAll) {
            this.buttonExpand = this.buttonWrap.createChild({
                tag: 'div',
                cls: 'x-superboxselect-btn-expand ' + this.expandBtnCls
            });
        }
        this.initButtonEvents();
        return this;
    },
    initButtonEvents: function () {
        if (this.allowQueryAll) {
            this.buttonExpand.addClassOnOver('x-superboxselect-btn-over').on('click', function (e) {
                e.stopEvent();
                if (this.disabled) {
                    return;
                }
                if (this.isExpanded()) {
                    this.multiSelectMode = false;
                }
                else if (this.pinList) {
                    this.multiSelectMode = true;
                }
                this.onTriggerClick();
            }, this);
        }
    },
    removeButtonEvents: function () {
        if (this.allowQueryAll) {
            this.buttonExpand.removeAllListeners();
        }
        return this;
    },
    initComponent: function () {
        Ext.apply(this, {style: {"box-shadow": "none"}});
        Pan.appframework.component.PanTextAreaCombo.superclass.initComponent.apply(this, arguments);
    },
    onLoad: function () {
        var editable = this.editable;
        this.editable = false;
        Pan.appframework.component.PanTextAreaCombo.superclass.onLoad.apply(this, arguments);
        this.editable = editable;
    },
    onDestroy: function () {
        Ext.removeNode(this.textSizeEl);
        Ext.destroy(this.magnifier);
        this.destroyMenu();
        Pan.appframework.component.PanTextAreaCombo.superclass.onDestroy.apply(this, arguments);
    },
    fireKey: function (e) {
        if (e.isSpecialKey() && (this.enterIsSpecial || (e.getKey() != e.ENTER || e.hasModifier()))) {
            this.fireEvent("specialkey", this, e);
        }
    },
    addValue: function (record) {
        var val = record.data[this.valueField || this.displayField];
        var currentValue = this.getRawValue().trim();
        if (currentValue != '' && this.insertDelimiterOnAppendValue) {
            currentValue += this.valueDelimiter;
        }
        currentValue += val;
        this.setValue(currentValue);
    },
    onSelect: function (record, index) {
        if (this.fireEvent('beforeselect', this, record, index) !== false) {
            if (this.appendValues) {
                this.addValue(record);
            }
            else {
                this.setValue(record.data[this.valueField || this.displayField]);
                this.collapse();
                this.fireEvent('select', this, record, index);
            }
        }
    },
    doAutoSize: function (e) {
        return !e.isNavKeyPress() || e.getKey() == e.ENTER;
    },
    onKeyUp: function (e) {
        this.collapse();
        Ext.form.ComboBox.superclass.onKeyUp.call(this, e);
    },
    autoSize: function () {
        if (!this.grow || !this.textSizeEl) {
            return;
        }
        var el = this.el, v = Ext.util.Format.htmlEncode(el.dom.value), ts = this.textSizeEl, h;
        Ext.fly(ts).setWidth(this.el.getWidth());
        if (v.length < 1) {
            v = "&#160;&#160;";
        }
        else {
            v += this.growAppend;
            if (Ext.isIE) {
                v = v.replace(/\n/g, '&#160;<br />');
            }
        }
        ts.innerHTML = v;
        h = Math.min(this.growMax, Math.max(ts.offsetHeight, this.growMin));
        if (h != this.lastHeight) {
            this.lastHeight = h;
            this.el.setHeight(h);
            this.fireEvent("autosize", this, h);
        }
    },
    destroyMenu: function () {
        if (this.menu) {
            this.menu.hide();
            this.menu.destroy();
            this.menu = undefined;
        }
    }
});
Ext.reg('pan-textareacombo', Pan.appframework.component.PanTextAreaCombo);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanCompletionGrid = Ext.extend(Pan.appframework.component.PanMultitypeGrid, {
    cls: "pan-completiongrid", initComponent: function () {
        this.completionStore = this.store;
        var enumValues = this.getEnumValues();
        if (this.supportAny) {
            if (this.completionStore && this.completionStore.zconfig) {
                Ext.applyIf(this.completionStore.zconfig, {enumValues: enumValues});
            }
        }
        var config = {field: this.__field, fields: this.__pdefaults && this.__pdefaults.__fields, caller: this};
        var comp = {};
        Pan.base.autorender.builder.EditorGridBuilder(comp, config);
        Ext.apply(this, {store: comp.store});
        Pan.appframework.component.PanCompletionGrid.superclass.initComponent.apply(this, arguments);
    }, setupEditor: function (col) {
        if (this.completionStore && this.completionStore.ztype) {
            var zconfig = this.completionStore.zconfig || {};
            if (zconfig.permanentFilter && !Ext.isArray(zconfig.permanentFilter)) {
                zconfig.permanentFilter = [zconfig.permanentFilter];
            }
            else {
                zconfig.permanentFilter = zconfig.permanentFilter ? zconfig.permanentFilter.slice(0) : [];
            }
            zconfig.permanentFilter.push(function (r) {
                if (this.enumValues) {
                    var e = this.enumValues;
                    for (var i = 0; i < e.length; i++) {
                        if (e[i][0] === r.id) {
                            return false;
                        }
                    }
                }
                return true;
            });
            col.editor.store = this.completionStore;
            if (this.renderToDisplay && !col.renderer) {
                col.renderer = function (v) {
                    var grid = arguments[arguments.length - 1];
                    if (grid && grid.lastActiveEditor && grid.lastActiveEditor.field && grid.lastActiveEditor.field.store) {
                        var record = grid.lastActiveEditor.field.store.getById(v);
                        if (record) {
                            v = record.get('display');
                        }
                    }
                    return v;
                };
            }
        }
        Pan.appframework.component.PanCompletionGrid.superclass.setupEditor.apply(this, arguments);
    }, clearValueEx: function () {
        var editor = this.colModel.getCellEditor(this.firstDataColumn, 0);
        if (editor) {
            editor.field.store.removeAll();
            editor.field.store.isStoreLoaded = false;
            editor.field.clearValue();
            editor.field.lastQuery = null;
            if (editor.field.store.isStoreLoaded !== false) {
                editor.field.store.reload();
            }
        }
        Pan.appframework.component.PanCompletionGrid.superclass.clearValueEx.apply(this, arguments);
    }, setValue: function (v) {
        var editor = this.colModel.getCellEditor(this.firstDataColumn, 0);
        if (editor) {
            editor.field.store.removeAll();
            editor.field.store.isStoreLoaded = false;
            editor.field.clearValue();
            editor.field.lastQuery = null;
        }
        return Pan.appframework.component.PanCompletionGrid.superclass.setValue.call(this, v);
    }
});
Ext.reg("pan-completiongrid", Pan.appframework.component.PanCompletionGrid);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanCompletionTreeGrid = Ext.extend(Pan.base.grid.GridPanel, {
    useArrows: Pan.base.Constants.treeRendererUseArrows,
    returnOnlyParentSelection: false,
    cls: 'x-pan-treegrid',
    setupStore: function () {
        if (this.store) {
            this.store.ztype = Pan.appframework.modelview.PanCompletionTreeGridStore;
        }
        Pan.appframework.component.PanCompletionTreeGrid.superclass.setupStore.apply(this, arguments);
    },
    setupSelectionModel: function () {
        if (this.sm) {
            this.selModel = this.sm;
            delete this.sm;
        }
        if (!this.selModel) {
            this.selModel = new Pan.appframework.component.PanCheckboxTreeSelectionModel();
        }
    },
    selectRecords: function (store, suspendEvents) {
        if (store.isLoading == false) {
            Pan.appframework.component.PanCompletionTreeGrid.superclass.selectRecords.call(this, store, Ext.isDefined(suspendEvents) ? suspendEvents : true);
            this.view.refresh();
        }
    },
    getValueFromSelection: function () {
        if (this.returnOnlyParentSelection) {
            var results = [];
            var store = this.store;
            var rb = store.recordBinder;
            var selModel = this.getSelectionModel();
            var j = 0, len = store.getCount();
            while (j < len) {
                var curRecord = store.getAt(j);
                if (selModel.isSelected(j)) {
                    j++;
                    results.push(rb.getNameId(curRecord.json));
                    if (curRecord.__treeChildrenCount) {
                        var initialLevel = curRecord.__treeLevel;
                        while (j < len) {
                            curRecord = store.getAt(j);
                            j++;
                            if (curRecord.__treeLevel <= initialLevel) {
                                break;
                            }
                        }
                    }
                }
                else {
                    j++;
                }
            }
            return results;
        }
        else {
            return Pan.appframework.component.PanCompletionTreeGrid.superclass.getValueFromSelection.apply(this, arguments);
        }
    },
    createView: function () {
        this.viewConfig = Ext.apply({
            onRowPartialSelect: function (row) {
                var r = this.getRow(row);
                if (r) {
                    if (r.childNodes.length !== 0) {
                        var wrap = Ext.fly(r).select('.x-tree-node-tristate-cb-wrap');
                        wrap.removeClass('x-tree-node-tristate-cb-selected');
                        wrap.removeClass('x-tree-node-tristate-cb-all-children-selected');
                        wrap.addClass('x-tree-node-tristate-cb-some-children-selected');
                    }
                }
            }, onRowSelect: function (row) {
                var r = this.getRow(row);
                if (r) {
                    if (r.childNodes.length !== 0) {
                        var wrap = Ext.fly(r).select('.x-tree-node-tristate-cb-wrap');
                        wrap.addClass('x-tree-node-tristate-cb-selected');
                        wrap.removeClass('x-tree-node-tristate-cb-some-children-selected');
                        wrap.removeClass('x-tree-node-tristate-cb-all-children-selected');
                    }
                    Ext.fly(r).addClass(this.selectedRowClass);
                }
            }, onRowDeselect: function (row) {
                var r = this.getRow(row);
                if (r) {
                    if (r.childNodes.length !== 0) {
                        var wrap = Ext.fly(r).select('.x-tree-node-tristate-cb-wrap');
                        wrap.removeClass('x-tree-node-tristate-cb-selected');
                        wrap.removeClass('x-tree-node-tristate-cb-all-children-selected');
                        wrap.removeClass('x-tree-node-tristate-cb-some-children-selected');
                    }
                    Ext.fly(r).removeClass(this.selectedRowClass);
                }
            }
        }, this.viewConfig);
        return Pan.appframework.component.PanCompletionTreeGrid.superclass.createView.apply(this, arguments);
    }
});
Ext.reg("pan-completiontreegrid", Pan.appframework.component.PanCompletionTreeGrid);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanCheckboxTreeSelectionModel = Ext.extend(Pan.base.grid.CheckboxSelectionModel, {
    handleMouseDown: function () {
    }, selectRecords: function (records, keepExisting) {
        if (!Ext.isDefined(this.grid))
            return;
        if (!keepExisting) {
            this.clearSelections();
        }
        var ds = this.grid.store;
        for (var i = records.length - 1; i >= 0; i--) {
            this.selectRow(ds.indexOf(records[i]), true);
        }
    }, onRefresh: function () {
        var ds = this.grid.store, index;
        var s = this.getSelections();
        for (var i = 0, len = s.length; i < len; i++) {
            var r = s[i];
            if ((index = ds.indexOfId(r.id)) != -1) {
                this.selectRow(index, true);
            }
        }
        if (s.length != this.selections.getCount()) {
            this.fireEvent('selectionchange', this);
        }
    }, selectRow: function (index) {
        var r = this.grid.store.getAt(index);
        if (r && !r.__treeChildrenCount) {
            return Pan.appframework.component.PanCheckboxTreeSelectionModel.superclass.selectRow.apply(this, arguments);
        }
    }, deselectRow: function (index) {
        var r = this.grid.store.getAt(index);
        if (r && !r.__treeChildrenCount) {
            return Pan.appframework.component.PanCheckboxTreeSelectionModel.superclass.deselectRow.apply(this, arguments);
        }
    }, selectTreeRow: function (rowIndex) {
        var store = this.grid.store, len = store.getCount(), j = rowIndex;
        var rowsToBeRefreshedMap = {};
        var initialTreeLevel = store.getAt(j).__treeLevel;
        this.suspendEvents(false);
        while (j < len) {
            var curRecord = store.getAt(j);
            if (j === rowIndex || curRecord.__treeLevel > initialTreeLevel) {
                if (!curRecord.__treeChildrenCount) {
                    this.selectRow(j, true, false);
                    var parentTreeLevel = curRecord.__treeLevel - 1;
                    var jj = j - 1;
                    while (jj >= 0) {
                        var pRecord = store.getAt(jj);
                        if (pRecord.__treeLevel <= parentTreeLevel) {
                            rowsToBeRefreshedMap[jj] = pRecord;
                            if (pRecord.__treeLevel === 0) {
                                break;
                            }
                            parentTreeLevel = pRecord.__treeLevel - 1;
                        }
                        jj--;
                    }
                }
            }
            else {
                break;
            }
            j++;
        }
        for (var key in rowsToBeRefreshedMap) {
            if (rowsToBeRefreshedMap.hasOwnProperty(key)) {
                this.grid.view.refreshRow(rowsToBeRefreshedMap[key]);
            }
        }
        this.resumeEvents();
        this.fireEvent('rowselect', this, rowIndex, store.getAt(rowIndex));
        this.fireEvent('selectionchange', this);
    }, deselectTreeRow: function (rowIndex) {
        var store = this.grid.store, len = store.getCount(), j = rowIndex;
        var rowsToBeRefreshedMap = {};
        var initialTreeLevel = store.getAt(j).__treeLevel;
        this.suspendEvents(false);
        while (j < len) {
            var curRecord = store.getAt(j);
            if (j === rowIndex || curRecord.__treeLevel > initialTreeLevel) {
                if (!curRecord.__treeChildrenCount) {
                    this.deselectRow(j, false);
                    var parentTreeLevel = curRecord.__treeLevel - 1;
                    var jj = j - 1;
                    while (jj >= 0) {
                        var pRecord = store.getAt(jj);
                        if (pRecord.__treeLevel <= parentTreeLevel) {
                            rowsToBeRefreshedMap[jj] = pRecord;
                            if (pRecord.__treeLevel === 0) {
                                break;
                            }
                            parentTreeLevel = pRecord.__treeLevel - 1;
                        }
                        jj--;
                    }
                }
            }
            else {
                break;
            }
            j++;
        }
        for (var key in rowsToBeRefreshedMap) {
            if (rowsToBeRefreshedMap.hasOwnProperty(key)) {
                this.grid.view.refreshRow(rowsToBeRefreshedMap[key]);
            }
        }
        this.resumeEvents();
        this.fireEvent('rowdeselect', this, rowIndex, store.getAt(rowIndex));
        this.fireEvent('selectionchange', this);
    }, selectAll: function () {
        if (this.isLocked()) {
            return;
        }
        var store = this.grid.store, len = store.getCount();
        var snapshot = store.getSnapshot();
        var view = this.grid.getView();
        var queryByResultRootRecords = store.queryByResultRootRecords;
        if (queryByResultRootRecords && queryByResultRootRecords.getCount() > 0 && queryByResultRootRecords.getCount() < snapshot.getCount()) {
            var parentRecords = [];
            for (var ii = 0; ii < len; ii++) {
                var rr = store.getAt(ii);
                if (queryByResultRootRecords.key(rr.id)) {
                    if (!this.selections.key(rr.id)) {
                        if (!rr.__treeChildrenCount) {
                            this.selections.add(rr);
                        }
                        view.onRowSelect(ii);
                        var initialTreeLevel = rr.__treeLevel;
                        for (ii = ii + 1; ii < len; ii++) {
                            rr = store.getAt(ii);
                            if (rr.__treeLevel <= initialTreeLevel) {
                                break;
                            }
                            if (!this.selections.key(rr.id)) {
                                if (!rr.__treeChildrenCount) {
                                    this.selections.add(rr);
                                }
                                view.onRowSelect(ii);
                            }
                        }
                        ii--;
                    }
                }
                else {
                    parentRecords.push({record: rr, index: ii});
                }
            }
            for (var jj = parentRecords.length - 1; jj >= 0; jj--) {
                var obj = parentRecords[jj];
                var result = this.isAllChildrenSelected(obj.record);
                if (result === "all") {
                    view.onRowSelect(obj.index);
                }
                else if (result === "some") {
                    view.onRowPartialSelect(obj.index);
                }
                else {
                    view.onRowSelect(obj.index);
                }
            }
        }
        else {
            for (var i = 0; i < len; i++) {
                var r = store.getAt(i);
                if (!r.__treeChildrenCount) {
                    this.selections.add(r);
                }
                view.onRowSelect(i);
                if (r.__treeLevel === 0) {
                    for (var j = r.__treeSnapshotIndex + 1; j < snapshot.getCount(); j++) {
                        r = snapshot.itemAt(j);
                        if (r.__treeLevel === 0) {
                            break;
                        }
                        if (!r.__treeChildrenCount) {
                            this.selections.add(r);
                        }
                        if (store.getById(r.id)) {
                            i++;
                            view.onRowSelect(i);
                        }
                    }
                }
            }
        }
        this.fireEvent('selectionchange', this);
    }, deselectAll: function () {
        if (this.isLocked()) {
            return;
        }
        var store = this.grid.store, len = store.getCount();
        var snapshot = store.getSnapshot();
        var view = this.grid.getView();
        var queryByResultRootRecords = store.queryByResultRootRecords;
        if (queryByResultRootRecords && queryByResultRootRecords.getCount() > 0 && queryByResultRootRecords.getCount() < snapshot.getCount()) {
            var parentRecords = [];
            for (var ii = 0; ii < len; ii++) {
                var rr = store.getAt(ii);
                if (queryByResultRootRecords.key(rr.id)) {
                    if (!rr.__treeChildrenCount) {
                        this.selections.remove(rr);
                    }
                    view.onRowDeselect(ii);
                    var initialTreeLevel = rr.__treeLevel;
                    for (ii = ii + 1; ii < len; ii++) {
                        rr = store.getAt(ii);
                        if (rr.__treeLevel <= initialTreeLevel) {
                            break;
                        }
                        if (!rr.__treeChildrenCount) {
                            this.selections.remove(rr);
                        }
                        view.onRowDeselect(ii);
                    }
                    ii--;
                }
                else {
                    parentRecords.push({record: rr, index: ii});
                }
            }
            for (var jj = parentRecords.length - 1; jj >= 0; jj--) {
                var obj = parentRecords[jj];
                var result = this.isAllChildrenSelected(obj.record);
                if (result === "all") {
                    view.onRowSelect(obj.index);
                }
                else if (result === "some") {
                    view.onRowPartialSelect(obj.index);
                }
                else {
                    view.onRowDeselect(obj.index);
                }
            }
        }
        else {
            this.clearSelections();
        }
        this.fireEvent('selectionchange', this);
    }, clearSelections: function (fast) {
        if (this.isLocked()) {
            return;
        }
        if (fast !== true) {
            var store = this.grid.store;
            var snapshot = store.getSnapshot();
            for (var i = 0, len = store.getCount(), view = this.grid.getView(); i < len; i++) {
                var r = store.getAt(i);
                if (this.selections.key(r.id)) {
                    this.selections.remove(r);
                }
                view.onRowDeselect(i);
                if (r.__treeLevel === 0) {
                    for (var j = r.__treeSnapshotIndex + 1; j < snapshot.getCount(); j++) {
                        r = snapshot.itemAt(j);
                        if (r.__treeLevel === 0) {
                            break;
                        }
                        if (this.selections.key(r.id)) {
                            this.selections.remove(r);
                        }
                        if (store.getById(r.id)) {
                            i++;
                            view.onRowDeselect(i);
                        }
                    }
                }
            }
        }
        else {
            this.selections.clear();
        }
        this.last = false;
    }, isAllChildrenSelected: function (record) {
        if (record.__treeChildrenCount) {
            var treeSnapshotIndex = record.__treeSnapshotIndex;
            var snapshot = record.store.getSnapshot();
            var initialLevel = record.__treeLevel;
            var j = treeSnapshotIndex + 1, len = snapshot.getCount(), childrenSelected = 0, totalChildren = 0;
            var rv;
            while (j < len) {
                var curRecord = snapshot.itemAt(j);
                if (curRecord.__treeLevel <= initialLevel || (childrenSelected !== 0 && childrenSelected !== totalChildren)) {
                    break;
                }
                if (initialLevel + 1 === curRecord.__treeLevel) {
                    totalChildren++;
                    if (this.isIdSelected(curRecord.id)) {
                        childrenSelected++;
                    }
                    else if (curRecord.__treeChildrenCount) {
                        var result = this.isAllChildrenSelected(curRecord, j);
                        if (result === "all") {
                            childrenSelected++;
                        }
                        else if (result === "some") {
                            rv = "some";
                            break;
                        }
                    }
                }
                j++;
            }
            return rv ? rv : childrenSelected === record.__treeChildrenCount ? "all" : childrenSelected > 0 ? "some" : undefined;
        }
        else {
            return undefined;
        }
    }, isAllVisibleLeafChildrenSelected: function (record, index) {
        if (record.__treeChildrenCount) {
            var data = record.store.data;
            var initialLevel = record.__treeLevel;
            var j = index + 1, len = data.getCount();
            var rv = true;
            while (j < len) {
                var curRecord = data.itemAt(j);
                if (curRecord.__treeLevel <= initialLevel) {
                    break;
                }
                if (initialLevel + 1 === curRecord.__treeLevel) {
                    if (!curRecord.__treeChildrenCount) {
                        if (!this.isIdSelected(curRecord.id)) {
                            rv = false;
                            break;
                        }
                    }
                    else {
                        var result = this.isAllVisibleLeafChildrenSelected(curRecord, j);
                        if (!result) {
                            rv = result;
                            break;
                        }
                    }
                }
                j++;
            }
            return rv;
        }
        else {
            return this.isIdSelected(record.id);
        }
    }, getResultCount: function () {
        var inStoreTotal = 0;
        var total = 0;
        var s = this.selections;
        s.each(function (r) {
            if (!r.__treeChildrenCount || r.store.includeParents) {
                if (r.store && r.store.excludeLeafDG) {
                    if (r.get("serial") || r.get("$.serial")) {
                        total++;
                        if (r.store && r.store.data.key(r.id)) {
                            inStoreTotal++;
                        }
                    }
                }
                else {
                    total++;
                    if (r.store && r.store.data.key(r.id)) {
                        inStoreTotal++;
                    }
                }
            }
        }, this);
        return {total: total, inStoreTotal: inStoreTotal};
    }, rowClicked: function (row, rowIndex) {
        var childSelectionStatus = this.isAllChildrenSelected(row);
        if (this.isSelected(row) || childSelectionStatus === "all") {
            this.deselectTreeRow(rowIndex);
        }
        else if (childSelectionStatus === "some") {
            if (this.isAllVisibleLeafChildrenSelected(row, rowIndex)) {
                this.deselectTreeRow(rowIndex);
            }
            else {
                this.selectTreeRow(rowIndex);
            }
            this.selectRow(rowIndex, true, false);
        }
        else {
            this.selectTreeRow(rowIndex);
        }
    }
});
Pan.appframework.component.PanMoreCombo = Ext.extend(Pan.base.form.ComboBox, {
    hideTrigger: true,
    emptyText: _T('Type to filter'),
    valueField: 'id',
    displayField: 'id',
    expandOnInitEditor: true,
    mode: 'local',
    listClass: 'x-more-combo',
    shadow: false,
    defaultMagnifierWidth: 16,
    onResize: function (w, h) {
        Pan.appframework.component.PanMoreCombo.superclass.onResize.call(this, w, h);
        var tw = this.getAdditionalWidth();
        if (Ext.isNumber(w)) {
            w = this.el.getWidth();
            this.el.setWidth(w - tw);
        }
        this.wrap.setWidth(this.wrap.getWidth() + tw);
    },
    getAdditionalWidth: function () {
        var magnifierWidth = this.magnifier.getWidth();
        if (magnifierWidth === 0) {
            magnifierWidth = this.defaultMagnifierWidth;
        }
        return magnifierWidth;
    },
    onRender: function () {
        Pan.appframework.component.PanMoreCombo.superclass.onRender.apply(this, arguments);
        var height = this.el.getHeight() - 5;
        if (Ext.isWebKit || Ext.isSafari) {
            height -= 2;
        }
        this.magnifier = this.wrap.createChild({
            tag: 'img',
            src: "/images/icons/magnifier.png",
            style: 'box-shadow: none; border-right: none !important; width: ' + this.defaultMagnifierWidth + '; height: ' + height,
            cls: "x-form-text x-form-field x-form-focus"
        }, this.el);
    },
    initComponent: function () {
        Ext.apply(this, {
            store: new Pan.base.autorender.GridRecordStore({fields: [{name: 'id', type: 'string'}]}),
            style: {"border-left": "none", "box-shadow": "none"}
        });
        Pan.appframework.component.PanMoreCombo.superclass.initComponent.apply(this, arguments);
    },
    initList: function () {
        if (!this.list) {
            Pan.appframework.component.PanMoreCombo.superclass.initList.apply(this, arguments);
            var grid = this.grid;
            var columnIndex = grid.lastEdit.col;
            var column = grid.colModel.getColumnAt(columnIndex);
            if (!Ext.isEmpty(column.columnActions)) {
                this.list.addClass('x-column-actions');
            }
            if (column.renderer && column.renderer.onClick) {
                this.list.addClass('x-more-combo-list-editable');
            }
        }
    },
    onDestroy: function () {
        Ext.destroy(this.magnifier);
        this.destroyMenu();
        Pan.appframework.component.PanMoreCombo.superclass.onDestroy.apply(this, arguments);
    },
    destroyMenu: function () {
        if (this.menu) {
            this.menu.hide();
            this.menu.destroy();
            this.menu = undefined;
        }
    },
    getListFieldValue: function (values, parent, xindex, xcount, fieldName) {
        var me = this.scope;
        var grid = me.grid;
        var col = grid.lastEdit.col;
        var spanCellRenderer = grid.colModel.getColumnAt(col).spanCellRenderer;
        var rv = "";
        if (spanCellRenderer) {
            var record = grid.getSelectionModel().getSelected();
            rv += grid.colModel.getColumnAt(col).spanCellRenderer(values[fieldName], {grid: grid}, record, xindex, col, grid.store, grid);
        }
        else {
            rv += Pan.appframework.component.PanMoreCombo.superclass.getListFieldValue.apply(this, arguments);
        }
        return rv;
    },
    setValue: function (v) {
        this.store.setValue(v);
        this.populate();
    },
    isValid: function () {
        return false;
    },
    onViewOver: function () {
        Pan.appframework.component.PanMoreCombo.superclass.onViewOver.apply(this, arguments);
        if (this.menu && this.selectedIndex != this.menuIndex) {
            this.destroyMenu();
        }
    },
    onMouseDown: function () {
        Pan.appframework.component.PanMoreCombo.superclass.onMouseDown.apply(this, arguments);
        this.preFocus();
    },
    applyEmptyTextForce: function () {
        if (this.rendered && this.emptyText && this.getRawValue().length < 1) {
            this.setRawValue(this.emptyText);
            this.el.addClass(this.emptyClass);
            this.blur();
        }
    },
    onViewClick: function (dataView, index, target, e) {
        if (!e) {
            return;
        }
        var eventXY = e.getXY();
        var targetEl = Ext.fly(target);
        var width = targetEl.getWidth();
        var x = targetEl.getX();
        var eventX = eventXY[0];
        var grid = this.grid;
        var rowIndex = grid.lastEdit.row;
        var columnIndex = grid.lastEdit.col;
        var record = grid.getSelectionModel().getSelected();
        var column = grid.colModel.getColumnAt(columnIndex);
        if (Ext.isDefined(index)) {
            var dataViewRecord = dataView.store.getAt(index);
            index = dataView.store.getSnapshot().indexOfKey(dataViewRecord.id);
        }
        var config = {
            record: record,
            grid: grid,
            row: rowIndex,
            col: columnIndex,
            miniCellRowEl: targetEl,
            miniCellRowIndex: index,
            event: e
        };
        if (column.columnActions && eventX >= (x + width - 20)) {
            this.menu = Ext.create({xtype: 'menu', items: column.columnActions, scope: grid});
            grid.cellEventInfo = config;
            this.menuIndex = index;
            this.menu.showAt(eventXY);
        }
        else {
            if (grid.handleClick(grid, rowIndex, columnIndex, e, config) !== false) {
                this.grid.stopEditing(true);
            }
        }
    },
    restrictHeight: function () {
        this.innerList.dom.style.height = '';
        var
            pad = this.list.getFrameWidth('tb') + (this.resizable ? this.handleHeight : 0) + this.assetHeight,
            ha = this.getPosition()[1] - Ext.getBody().getScroll().top,
            hb = Ext.lib.Dom.getViewHeight() - ha - this.getSize().height,
            space = Math.max(ha, hb, this.minHeight || 0) - this.list.shadowOffset - pad - 5;
        var selectedRowIndex = this.grid.store.indexOf(this.grid.getSelectionModel().getSelected());
        var rows = this.grid.view.getRows();
        var selectedRow;
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].rowIndex === selectedRowIndex) {
                selectedRow = rows[i];
                break;
            }
        }
        var selectedRowHeight = 130;
        if (selectedRow) {
            selectedRowHeight = Ext.fly(selectedRow).getHeight();
        }
        var comboHeight = this.getHeight();
        var maxHeight = selectedRowHeight - comboHeight - 4;
        var h = Math.min(space, maxHeight);
        this.innerList.setHeight(h);
        this.list.beginUpdate();
        this.list.setHeight(h + pad);
        this.list.alignTo.apply(this.list, [this.wrap].concat(this.listAlign));
        this.list.endUpdate();
    }
});
Ext.reg('pan-morecombo', Pan.appframework.component.PanMoreCombo);
Pan.appframework.component.PanMoreComboEditor = Ext.extend(Ext.grid.GridEditor, {
    viewOnlyEditor: true,
    initComponent: function () {
        Ext.apply(this, {field: Ext.create({grid: this.field.grid, xtype: 'pan-morecombo'})});
        Pan.appframework.component.PanMoreComboEditor.superclass.initComponent.apply(this, arguments);
    },
    startEdit: function (el, value) {
        var grid = this.field.grid;
        var col = grid.lastEdit.col;
        var row = grid.lastEdit.row;
        var column = grid.colModel.getColumnAt(col);
        var record = grid.getSelectionModel().getSelected();
        this.field.doHTMLEncode = column.doHTMLEncode;
        var realValue = column.renderer(value, {grid: grid}, record, row, col, grid.store, grid);
        Pan.appframework.component.PanMoreComboEditor.superclass.startEdit.call(this, el, realValue);
        this.field.collapse();
        this.field.onTriggerClick();
        this.createDragZone(col, row);
    },
    createDragZone: function (columnIndex, rowIndex) {
        var editor = this;
        var items = this.field.view.getNodes();
        for (var i = 0; i < items.length; i++) {
            var item = Ext.fly(items[i]);
            item.dd = new Ext.dd.DragZone(item, {
                getRepairXY: function () {
                    return false;
                }, onEndDrag: function () {
                    editor.completeEdit();
                }, getDragData: this.getDragData.createDelegate(this, [columnIndex, rowIndex, i], true)
            });
        }
    },
    getDragData: function (e, colIndex, rowIndex, index) {
        var t = e.getTarget('span.x-draggable', 10);
        var grid = this.field.grid;
        if (t && (rowIndex !== false) && (colIndex !== false)) {
            var info = this.getCellEventInfo(rowIndex, colIndex, index, e);
            var node = t.cloneNode(true);
            node.id = Ext.id();
            return {
                ddel: node,
                repairXY: Ext.fly(t).getXY(),
                celldrag: true,
                cellInfo: info,
                fieldName: grid.getColumnModel().getDataIndex(colIndex)
            };
        }
    },
    getCellEventInfo: function (rowIndex, columnIndex, index, e) {
        var grid = this.field.grid;
        var record = grid.store.getAt(rowIndex);
        var editorCell = grid.view.getCell(rowIndex, columnIndex);
        var cell = jQuery(e.target).closest('div').get(0);
        var row = jQuery(editorCell).closest('tr').get(0);
        return {
            record: record,
            grid: this,
            row: rowIndex,
            col: columnIndex,
            miniCellRowEl: row,
            miniCellColEl: cell,
            miniCellRowIndex: index,
            event: e
        };
    }
});
Ext.reg('pan-morecomboeditor', Pan.appframework.component.PanMoreComboEditor);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanGroupComboBox = Ext.extend(Pan.base.form.ComboBox, {
    initComponent: function () {
        this.tpl = this.getTemplate();
        this.itemSelector = 'div.x-tree-lines';
        Pan.appframework.component.PanGroupComboBox.superclass.initComponent.apply(this, arguments);
    }, getTemplate: function () {
        var tpl = ['<table>'];
        Ext.each(this.groups, function (group) {
            tpl.push(this.getTplForType(group.type, group.title, this.displayCount));
        }, this);
        tpl.push('</table>');
        tpl.push(this.getTplForEllipse());
        return new Ext.XTemplate(tpl.join(''), {
            hasValue: function (records, type, displayCount) {
                var count = parseInt(displayCount, 10);
                for (var i = 0; i < count && i < records.length; i++) {
                    var r = records[i];
                    if (r.type == type) {
                        return true;
                    }
                }
                return false;
            }, isSameType: function (type1, type2, xindex, displayCount) {
                var count = parseInt(displayCount, 10);
                return (type1 == type2 && xindex <= count);
            }, showElbowLine: function (records, rec) {
                if (Ext.isEmpty(rec.metaField))
                    return false;
                for (var i = 0; i < records.length; i++) {
                    var r = records[i];
                    if (r.value == rec.metaField) {
                        return true;
                    }
                }
                return false;
            }, showMoreEllipse: function (records) {
                return this.scope.hasExceededDisplayCount(records);
            }, scope: this
        });
    }, getTplForType: function (type, title, displayCount) {
        var ret = ['<tr <tpl if="this.hasValue(values, \'' + type + '\', \'' + displayCount + '\') == false">style="display: none;"</tpl>>', '<td>', '<div><b>' + title + '</b></div>', '<tpl for=".">', '<tpl if="this.isSameType(type, \'' + type + '\', xindex, \'' + displayCount + '\')">', '<div class="x-tree-lines">', '<tpl if="this.showElbowLine(parent, values)">', '<span><img class="x-tree-elbow-line" unselectable="on" src="/images/s.gif"/></span>', '</tpl>', '<span><img class="x-tree-elbow" unselectable="on" src="/images/s.gif"/></span>', '<span title="' + title + ': {value}">{display:htmlEncode}</span>', '</div>', '</tpl>', '</tpl>', '</td>', '</tr>'];
        return ret.join('');
    }
});
Ext.reg('pan-groupcombo', Pan.appframework.component.PanGroupComboBox);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanGroupComboBox4MgmtCustReport = Ext.extend(Pan.base.form.ComboBox, {
    mode: 'local', displayField: 'displayName', valueField: 'data', constructor: function (config) {
        config = config || {};
        Ext.applyIf(config, {editable: false, forceSelection: true});
        if (config.value === undefined && Ext.isArray(config.iData) && config.iData.length > 0) {
            for (var i = 0; i < config.iData.length; i++) {
                var r = config.iData[i];
                if (r.isLeaf) {
                    config.value = r.data;
                    break;
                }
            }
        }
        Pan.appframework.component.PanGroupComboBox4MgmtCustReport.superclass.constructor.call(this, config);
    }, initComponent: function () {
        this.tpl = this.getTemplate();
        this.itemSelector = 'div.pan';
        var _databaseStore = new Ext.data.JsonStore({
            autoDestroy: true,
            storeId: 'myStore',
            fields: ['name', 'displayName', 'data', 'isRoot', 'isLeaf', 'level', 'count', 'end']
        });
        this.store = _databaseStore;
        if (this.iData)
            this.store.loadData(this.iData);
        this.leafNodes = this.store.queryBy(function (record) {
            if (record.get('isLeaf'))
                return true; else
                return false;
        });
        this.initialState = true;
        Ext.apply(this, {
            listeners: {
                'expand': {
                    fn: function () {
                        if (this.initialState) {
                            this.selectByValue(this.getValue());
                            this.initialState = false;
                        }
                    }, scope: this
                }
            }
        });
        Pan.appframework.component.PanGroupComboBox4MgmtCustReport.superclass.initComponent.apply(this, arguments);
    }, getTemplate: function () {
        var tpl = new Ext.XTemplate('<table><tr><td>', '<tpl for=".">', '   {[this.outputHTML(values)]}', '</tpl></td></tr></table>', {
            outputHTML: function (values) {
                var _strHTML = '';
                var _level = values.level ? values.level : 0;
                var _end = values.end ? values.end : false;
                var name = Ext.util.Format.htmlEncode(values.name);
                if (!values.isLeaf) {
                    if (values.isRoot) {
                        _strHTML += '<div><span><b>' + name + '</b></span></div>';
                        this.parentIsClosed = _end;
                    }
                    else {
                        this.parentIsClosed = _end;
                        _strHTML += '<div class="x-tree-lines">'
                            + this.genTreeLine(_level, _end)
                            + '<span><b>' + name + '</b></span></div>';
                    }
                }
                else {
                    _strHTML += '<div class="x-tree-lines pan">'
                        + this.genTreeLine(_level, _end);
                    _strHTML += '<span><elm>' + name + '</elm></span></div>';
                }
                return _strHTML;
            }, genTreeLine: function (level, end) {
                var _retHTML = '';
                var _class = 'x-tree-elbow-line';
                if (this.parentIsClosed) {
                    _class = 'x-tree-icon';
                }
                for (var i = 0; i < level - 1; i++) {
                    _retHTML += '<span><img src="/images/s.gif" unselectable="on" class="' + _class + '" /></span>';
                }
                if (end) {
                    _retHTML += '<span><img src="/images/s.gif" unselectable="on" class="x-tree-elbow-end" /></span>';
                }
                else {
                    _retHTML += '<span><img src="/images/s.gif" unselectable="on" class="x-tree-elbow" /></span>';
                }
                return _retHTML;
            }
        });
        tpl.parentIsClosed = false;
        tpl.compile();
        return tpl;
    }, viewIndex2StoreIdx: function (idx) {
        var s = this.store;
        var r = this.leafNodes.get(idx);
        idx = s.indexOf(r);
        return idx;
    }, storeIndex2ViewIdx: function (idx) {
        var s = this.store;
        var r = s.getAt(idx);
        idx = this.leafNodes.indexOf(r);
        return idx;
    }, onViewClick: function (doFocus) {
        var index = this.view.getSelectedIndexes()[0], s = this.store, r;
        index = this.viewIndex2StoreIdx(index);
        r = s.getAt(index);
        if (r) {
            this.onSelect(r, index);
        }
        else {
            this.collapse();
        }
        if (doFocus !== false) {
            this.el.focus();
        }
    }, selectByValue: function (v, scrollIntoView) {
        if (!Ext.isEmpty(v, true)) {
            var r = this.findRecord(this.valueField || this.displayField, v);
            if (r) {
                var _idx = this.storeIndex2ViewIdx(this.store.indexOf(r));
                this.select(_idx, scrollIntoView);
                return true;
            }
        }
        return false;
    }
});
Ext.reg('pan-gCombo4MgmtCRpt', Pan.appframework.component.PanGroupComboBox4MgmtCustReport);
Pan.appframework.component.StoreStatusField = Ext.extend(Pan.base.form.DisplayField, {
    initComponent: function () {
        Pan.appframework.component.StoreStatusField.superclass.initComponent.call(this);
        this.relayEvents(this.store, ['afterload']);
        this.on('afterload', this.setStatus.createDelegate(this));
    }, setStatus: function () {
        this.setValue(this.warning());
    }
});
Ext.reg('pan-store-status-field', Pan.appframework.component.StoreStatusField);
Pan.appframework.component.PanSequenceCheckBox = Ext.extend(Pan.base.form.Checkbox, {
    setValue: function (v) {
        return Pan.appframework.component.PanSequenceCheckBox.superclass.setValue.call(this, !!v);
    }, getValue: function () {
        var v = Pan.appframework.component.PanSequenceCheckBox.superclass.getValue.apply(this, arguments);
        if (v) {
            return {};
        }
        return false;
    }
});
Ext.reg('pan-sequencecheckbox', Pan.appframework.component.PanSequenceCheckBox);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanStaticTreePanel = Ext.extend(Pan.base.tree.TreePanel, {
    constructor: function (config) {
        Pan.appframework.component.PanStaticTreePanel.superclass.constructor.call(this, config);
    }, initComponent: function () {
        Ext.apply(this, {root: new Ext.tree.AsyncTreeNode({children: this.getTreeChildren()})});
        Pan.appframework.component.PanStaticTreePanel.superclass.initComponent.apply(this, arguments);
    }
});
Ext.reg('pan-static-treepanel', Pan.appframework.component.PanStaticTreePanel);
Ext.ns('Pan.appframework.component');
Pan.appframework.component.AutoWidthToolbars = Ext.extend(Ext.util.Observable, {
    init: function (cmp) {
        if (!cmp.getTopToolbar) {
            return;
        }
        cmp.on('afterrender', function (c) {
            var tbar = c.getTopToolbar();
            if (tbar) {
                this.setAutoSize(tbar);
            }
            var bbar = c.getBottomToolbar();
            if (bbar) {
                this.setAutoSize(bbar);
            }
        }, this);
    }, setAutoSize: function (toolbar) {
        var El = toolbar.getEl();
        El.setSize('auto');
        El.parent().setSize('auto');
    }
});
Ext.preg('autowidthtoolbars', Pan.appframework.component.AutoWidthToolbars);
Pan.appframework.component.PanHAAwareDevicePicker = Ext.extend(Pan.base.tree.CheckTreePanel, {
    rootVisible: false,
    border: false,
    autoScroll: true,
    customSave: true,
    groupHAPeers: true,
    loadingInProgress: false,
    properties: ['connected', 'family'],
    initComponent: function () {
        Ext.apply(this, {root: this.createRootNode({text: _T("Root")})});
        Pan.appframework.component.PanHAAwareDevicePicker.superclass.initComponent.call(this);
    },
    setupBBar: function () {
        Pan.appframework.component.PanHAAwareDevicePicker.superclass.setupBBar.apply(this, arguments);
        this.bbar.push("->", {
            itemId: 'device-picker_groupHAPeersCheckBox',
            xtype: 'pan-checkbox',
            fieldLabel: 'Group HA Peers',
            listeners: {scope: this, check: this.onGroupHAPeers}
        });
    },
    makeRequest: function () {
        var params = {};
        if (this.getAdditionalParams) {
            Ext.apply(params, this.getAdditionalParams.apply(this, [this]));
        }
        var args = [params, this.onLoad, this];
        this.loadingInProgress = true;
        this.deviceTargetCompletion.apply(this, args);
    },
    onGroupHAPeers: function (comp) {
        this.groupHAPeers = comp.getValue();
        this.saveState();
        if (this.getRootNode() && this.getRootNode().rendered)
            this.value = this.getValue();
        if (this.deviceTargets)
            this.constructTree(this.deviceTargets); else if (this.deviceTargetCompletion)
            this.makeRequest();
    },
    setValue: function (v) {
        if (!v || v == '')
            return;
        if (this.loadingInProgress || !this.haPairMap) {
            this.value = v;
            return;
        }
        var devSerial = '';
        var nodeId = '';
        var m, node;
        if (v && v.entry && v.entry.length > 0) {
            for (var i = 0; i < v.entry.length; i++) {
                devSerial = v.entry[i]["@name"];
                if (this.groupHAPeers)
                    devSerial = this.getHAPairId(devSerial);
                if (v.entry[i].vsys && !this.nonVsys) {
                    var vsysArray = (this.returnVsysAsMember) ? v.entry[i].vsys.member : v.entry[i].vsys.entry;
                    if (v.entry[i].vsys.member) {
                        for (m = 0; m < vsysArray.length; m++) {
                            var vsysName = (this.returnVsysAsMember) ? vsysArray[m] : vsysArray[m]['@name'];
                            nodeId = devSerial + '/' + vsysName;
                            node = this.getNodeById(nodeId);
                            if (node) {
                                node.getUI().toggleCheck(true);
                            }
                            else {
                                node = this.getNodeById(devSerial);
                                if (node && node.attributes.isMultiVsys === false) {
                                    node.getUI().toggleCheck(true);
                                }
                            }
                        }
                    }
                    else if (v.entry[i].vsys.entry) {
                        for (m = 0; m < v.entry[i].vsys.entry.length; m++) {
                            nodeId = devSerial + '/' + v.entry[i].vsys.entry[m]["@name"];
                            node = this.getNodeById(nodeId);
                            if (node) {
                                node.getUI().toggleCheck(true);
                            }
                            else {
                                node = this.getNodeById(devSerial);
                                if (node && node.attributes.isMultiVsys === false) {
                                    node.getUI().toggleCheck(true);
                                }
                            }
                        }
                    }
                }
                else {
                    node = this.getNodeById(devSerial);
                    if (node) {
                        node.getUI().toggleCheck(true);
                    }
                }
            }
        }
    },
    getValue: function () {
        var scope = this;

        function getNodeValue(parentNodeId, checkedNode, devices, scope) {
            var myNodeIds = checkedNode.attributes.value;
            var haPair = scope.parseHAPairIds(myNodeIds);
            for (var i = 0; i < haPair.length; i++) {
                var myNodeId = haPair[i];
                var addToList = false;
                var device;
                for (var d = 0; d < devices.entry.length; d++) {
                    if (devices.entry[d]['@name'] === parentNodeId) {
                        device = devices.entry[d];
                    }
                }
                if (device === undefined) {
                    if (scope.nonVsys || checkedNode.attributes.isMultiVsys === false)
                        device = {'@name': parentNodeId}; else if (scope.returnVsysAsMember)
                        device = {'@name': parentNodeId, vsys: {member: []}}; else
                        device = {'@name': parentNodeId, vsys: {entry: []}};
                    addToList = true;
                }
                if (checkedNode.attributes.isMultiVsys === false || scope.nonVsys) {
                    device['@name'] = myNodeId;
                }
                else {
                    if (parentNodeId) {
                        device['@name'] = parentNodeId;
                        var values = myNodeId.split('/');
                        if (values[1])
                            (scope.returnVsysAsMember) ? device.vsys.member.push(values[1]) : device.vsys.entry.push({'@name': values[1]});
                    }
                    else {
                        addToList = false;
                    }
                }
                if (addToList)
                    devices.entry.push(device);
            }
        }

        var rNode = this.getRootNode();
        this.checkedNodes = [];
        var checkedNodes = this.getCheckedNodes(rNode);
        var devices = {entry: []};
        for (var n = 0; n < checkedNodes.length; n++) {
            var parentNodeIds = checkedNodes[n].parentNode.attributes.value;
            if (!parentNodeIds)
                getNodeValue(parentNodeIds, checkedNodes[n], devices, scope); else {
                var haPair = this.parseHAPairIds(parentNodeIds);
                for (var i = 0; i < haPair.length; i++) {
                    getNodeValue(haPair[i], checkedNodes[n], devices, scope);
                }
            }
        }
        return devices;
    },
    createNodeProperty: function (text, id, value, isMultiVsys, checked, leaf, children, isGroup, parent, properties) {
        var aNode = {text: text, id: id, value: value, iconCls: 'device-virtual-systems', expanded: true};
        if (Ext.isObject(properties)) {
            for (var i = 0; i < this.properties.length; i++) {
                var propertyName = this.properties[i];
                if (Ext.isDefined(properties[propertyName])) {
                    aNode[propertyName] = properties[propertyName];
                }
            }
        }
        if (checked !== undefined) Ext.apply(aNode, {checked: checked});
        if (leaf !== undefined) Ext.apply(aNode, {leaf: leaf});
        if (isMultiVsys !== undefined) Ext.apply(aNode, {isMultiVsys: isMultiVsys});
        if (children !== undefined) Ext.apply(aNode, {children: children});
        if (isGroup !== undefined) Ext.apply(aNode, {isGroup: isGroup});
        if (parent != undefined && parent != '') Ext.apply(aNode, {parent: parent});
        return aNode;
    },
    createHAPair: function (childNodes, device, vsysEntries, isGroup, parent) {
        var deviceNode;
        var deviceName = device['@name'];
        var children;
        if (device["multi-vsys"] === 'yes' && !this.nonVsys) {
            children = [];
            deviceNode = this.createNodeProperty(device.hostname || deviceName, parent.id + '/' + deviceName, deviceName, device['multi-vsys'] === 'yes', false, false, children, true, parent, device);
            if (vsysEntries) {
                for (var v = 0; v < vsysEntries.length; v++) {
                    children.push(this.createNodeProperty(vsysEntries[v]['display-name'], deviceName + '/' + vsysEntries[v]['@name'], deviceName + '/' + vsysEntries[v]['@name'], true, false, true, undefined, false, deviceNode, device));
                }
            }
        }
        else {
            deviceNode = this.createNodeProperty(device.hostname || deviceName, deviceName, deviceName, device['multi-vsys'] === 'yes', false, false, children, true, parent, device);
        }
        childNodes.push(deviceNode);
    },
    haSeparator: '~',
    getHAPairId: function (serial) {
        if (!this.groupHAPeers)
            return serial;
        var peerSerial = this.haPairMap[serial];
        if (!peerSerial)
            return serial;
        return (peerSerial < serial) ? (peerSerial + this.haSeparator + serial) : (serial + this.haSeparator + peerSerial);
    },
    parseHAPairIds: function (nodeIds) {
        if (!nodeIds || nodeIds == '')
            return [];
        return nodeIds.split(this.haSeparator);
    },
    processHAPair: function (childNodes, haPairCache, device, vsysEntries, isGroup, parent) {
        var serialNo = device['@name'];
        var peerSerialNo = (device['ha'] && device['ha']['peer']) ? device['ha']['peer']['serial'] : undefined;
        if (!this.groupHAPeers || (peerSerialNo === undefined || peerSerialNo == 'unknown' || peerSerialNo == '' || peerSerialNo.length == 0) || (this.haPairMap[serialNo] !== peerSerialNo || this.haPairMap[peerSerialNo] !== serialNo)) {
            this.createHAPair(childNodes, device, vsysEntries, isGroup, parent);
            return;
        }
        if (!(haPairCache[serialNo])) {
            haPairCache[peerSerialNo] = device;
        }
        else {
            var peerDevice = haPairCache[serialNo];
            var master;
            var peer;
            if (serialNo < peerSerialNo) {
                master = device;
                peer = peerDevice;
            }
            else {
                master = peerDevice;
                peer = device;
            }
            var pair = {};
            pair['multi-vsys'] = master['multi-vsys'];
            pair['hostname'] = (master.hostname || master['serial']) + '(' + (peer.hostname || peer['serial']) + ')';
            pair['@name'] = this.getHAPairId(master['@name']);
            pair['serial'] = pair['@name'];
            pair['ha'] = master['ha'];
            this.createHAPair(childNodes, pair, vsysEntries, isGroup, parent);
            this.haPairCache[peerSerialNo] = undefined;
            this.haPairCache[serialNo] = undefined;
        }
    },
    onLoad: function (result) {
        if (result && result['@status'] == 'success') {
            this.constructTree(result['result']);
        }
        else {
            Pan.base.msg.alert('Error', "Can't load the data");
        }
    },
    constructTree: function (devices) {
        var root = this.getRootNode();
        if (root)
            root.removeAll();
        var deviceEntries = devices["devices"]['entry'] || [];
        var vsysEntry, device, childNodes = [];
        this.haPairMap = devices['ha-pair-map'] || {};
        this.haPairCache = {};
        for (var d = 0; d < deviceEntries.length; d++) {
            device = deviceEntries[d];
            vsysEntry = (!this.nonVsys && device.vsys) ? device.vsys.entry : undefined;
            this.processHAPair(childNodes, this.haPairCache, device, vsysEntry, false, root);
        }
        for (var prop in this.haPairCache) {
            if (this.haPairCache.hasOwnProperty(prop) && this.haPairCache[prop] != undefined) {
                device = this.haPairCache[prop];
                vsysEntry = (!this.nonVsys && device.vsys) ? device.vsys.entry : undefined;
                this.createHAPair(childNodes, device, vsysEntry, false, root);
            }
        }
        if (childNodes && childNodes.length > 0) {
            for (var i = 0; i < childNodes.length; i++) {
                var child = new Pan.base.tree.TreeNode(childNodes[i]);
                if (child)
                    root.appendChild(child);
            }
        }
        this.loadingInProgress = false;
        if (this.value && this.value != '')
            this.setValue(this.value);
    },
    getAdditionalParams: function () {
        return undefined;
    },
    stateful: true,
    stateId: 'ha_groupHAPeers',
    getState: function () {
        return {groupHAPeers: this.groupHAPeers};
    },
    applyState: function (state) {
        if (state && state.groupHAPeers !== undefined) {
            this.groupHAPeers = state.groupHAPeers;
        }
    },
    afterRender: function () {
        Pan.appframework.component.PanHAAwareDevicePicker.superclass.afterRender.apply(this, arguments);
        var checkbox = this.getBottomToolbar().findByItemId('device-picker_groupHAPeersCheckBox');
        var checked = checkbox.getValue();
        if (checked !== this.groupHAPeers)
            checkbox.setValue(this.groupHAPeers); else this.onGroupHAPeers(checkbox);
    }
});
Ext.reg('pan-ha-aware-device-picker', Pan.appframework.component.PanHAAwareDevicePicker);
Ext.override(Ext.form.Field, {
    isValid: function (preventMark) {
        var templateStackSelected = Pan.global.isTemplateStackSelected();
        if (templateStackSelected) {
            preventMark = false;
        }
        if (!templateStackSelected && this.disabled) {
            return true;
        }
        var restore = this.preventMark;
        this.preventMark = preventMark === true;
        var v = this.validateValue(this.processValue(this.getRawValue()));
        this.preventMark = restore;
        return v;
    }
});
Ext.override(Pan.base.form.FieldSet, {
    onDisable: function () {
        if (!Pan.global.isTemplateStackSelected()) {
            if (this.rendered && this.maskDisabled) {
                this.body.mask();
            }
            if (this.strictReadOnly === true) {
                Pan.base.form.FieldSet.superclass.onDisable.call(this);
            }
            else {
                Ext.Panel.superclass.onDisable.call(this);
            }
        }
    }
});
(function (factory) {
    Ext.ns("Pan.appframework.component");
    Pan.appframework.component.PanCustomizeFileField = factory();
    Ext.reg('pan-customizefilefield', Pan.appframework.component.PanCustomizeFileField);
}(function () {
    function loadPreviewContent() {
        var self = this;
        var deferred = $.Deferred();
        if (this.isDirty()) {
            deferred.resolve(this.getDirtyContent());
        }
        else if (this.cachedPreviewContent) {
            deferred.resolve(this.cachedPreviewContent);
        }
        else {
            var value = this.getValue();
            $.when(this.getPreviewContent(value)).done(function (result) {
                self.cachedPreviewContent = result;
                deferred.resolve(result);
            });
        }
        return deferred.promise();
    }

    function updateButtonStates(value) {
        var fileUploadField = this.items.items[0];
        var previewButton = fileUploadField.ownerCt.findByItemId("previewButton");
        var clearButton = fileUploadField.ownerCt.findByItemId("clearButton");
        var self = this;
        if (previewButton) {
            if (typeof previewButton.hasDefaultPreviewContent === "undefined" && !value) {
                $.when(this.getPreviewContent(value)).done(function (result) {
                    previewButton.hasDefaultPreviewContent = result;
                    self.cachedPreviewContent = result;
                    previewButton.setDisabled(!result);
                });
            }
            else {
                previewButton.setDisabled(!previewButton.hasDefaultPreviewContent && !value);
            }
        }
        clearButton.setDisabled(!value);
    }

    var previewHandlers = {
        "text": function previewText(options) {
            var self = this;
            options = options || {};
            Ext.applyIf(options, {width: 700, height: 400});
            options.width = Math.max(options.width, 400);
            options.height = Math.max(options.height, 200);
            loadPreviewContent.call(this).done(show);

            function show(value) {
                if (self.contentEncoding === PanCustomizeFileField.encoding.base64) {
                    value = Base64.decode(value);
                }
                var textarea = {
                    xtype: 'pan-textarea',
                    width: options.width - 12,
                    height: options.height - 76,
                    x: 0,
                    y: 0,
                    value: value
                };
                var container = new Pan.base.container.Container({
                    border: false,
                    width: options.width - 12,
                    height: options.height - 76,
                    x: 0,
                    y: 0,
                    layout: 'fit',
                    items: {xtype: 'pan-panel', layout: 'absolute', items: [textarea]}
                });
                var win = new Pan.base.container.Window(Ext.apply({
                    border: false,
                    constrainHeader: false,
                    resizable: false,
                    modal: true,
                    layout: 'absolute',
                    labelWidth: 5,
                    items: [container],
                    keys: {
                        key: 27, scope: this, handler: function () {
                            win.close();
                        }
                    },
                    buttons: [{
                        text: _T('Close'), handler: function (btn) {
                            btn.ownerCt.ownerCt.close();
                        }
                    }]
                }, options));
                win.show();
            }
        }, "image": function previewImage(options) {
            var img = new Image();
            var src = 'data:image/*;base64,' + this.getValue();
            img.onload = function () {
                var imageWidth = this.width;
                var imageHeight = this.height;
                img.remove();
                var heightMargin = 74;
                var widthMargin = 26;
                var windowWidth = Math.max(Pan.base.Constants.minWindowWidth, Math.min(800, imageWidth + widthMargin));
                var windowHeight = Math.max(Pan.base.Constants.minWindowHeight, Math.min(500, imageHeight + heightMargin));
                var winConfig = Ext.apply({
                    border: false,
                    maximizable: true,
                    width: windowWidth,
                    height: windowHeight,
                    modal: true,
                    layout: 'fit',
                    defaults: {autoScroll: true},
                    items: {
                        xtype: 'pan-container',
                        items: {
                            xtype: 'box',
                            autoEl: {
                                tag: 'img',
                                style: imageWidth < windowWidth - widthMargin ? 'display:block;margin-left:auto;margin-right:auto' : '',
                                src: src
                            }
                        }
                    },
                    buttonAlign: 'right',
                    buttons: [{
                        text: _T('Close'), handler: function () {
                            w.close();
                        }
                    }]
                }, options);
                var w = new Pan.base.container.Window(winConfig);
                w.show();
            };
            img.src = src;
        }
    };
    var PanCustomizeFileField = Ext.extend(Pan.base.form.CompositeField, {
        constructor: function (config) {
            var self = this;
            Ext.applyIf(config, {
                contentType: 'text',
                useFileReader: true,
                contentEncoding: PanCustomizeFileField.encoding.base64
            });
            if (Ext.isEmpty(config.emptyText) || config.emptyText === ' ') {
                config.emptyText = 'Predefined';
            }
            var previewHandler = previewHandlers[config.contentType];
            if (!previewHandler) {
                throw new Error(config.contentType + " not supported");
            }
            var browseButtonConfig = Ext.apply({
                cls: 'plain-btn customize-logo-btn',
                iconCls: 'icon-commit'
            }, config.browseButtonConfig);
            if (browseButtonConfig.iconCls) {
                browseButtonConfig.text = '';
            }
            delete config.browseButtonConfig;
            var previewWindowConfig = config.previewWindowConfig;
            delete config.previewWindowConfig;
            var previewButtonConfig = Ext.apply({
                cls: 'plain-btn customize-logo-btn',
                iconCls: 'icon-preview',
                xtype: 'pan-button',
                name: "previewButton",
                visible: true
            }, config.previewButtonConfig, {
                handler: function () {
                    previewHandler.call(self, previewWindowConfig);
                }
            });
            var clearButtonConfig = Ext.apply({
                cls: 'plain-btn customize-logo-btn',
                iconCls: 'icon-delete',
                xtype: 'pan-button',
                hideMode: 'visibility',
                name: "clearButton"
            }, config.clearButtonConfig, {
                handler: function () {
                    var fileUploadField = self.items.items[0];
                    fileUploadField.emptyText = self.getDisplayText(undefined);
                    self.cachedPreviewContent = undefined;
                    self.setValue(undefined);
                    updateButtonStates.call(self, undefined);
                    fileUploadField.reset();
                }
            });
            delete config.clearButtonConfig;
            var fileUploadFieldConfig = {
                xtype: 'fileuploadfield',
                name: 'fileUploadField',
                buttonCfg: browseButtonConfig,
                flex: 1,
                listeners: {fileselected: onFileSelected}
            };
            if (config.allowBlank) {
                fileUploadFieldConfig.allowBlank = config.allowBlank;
            }
            config.items = previewButtonConfig.visible ? [fileUploadFieldConfig, previewButtonConfig, clearButtonConfig] : [fileUploadFieldConfig, clearButtonConfig];
            PanCustomizeFileField.superclass.constructor.call(this, config);

            function onFileSelected(field, filePath) {
                if (!filePath) {
                    return;
                }
                var file = field.fileInput.dom.files[0];
                var filename = file.name;
                if (config.filenameValidation && config.filenameValidation.regex) {
                    if (!filename.match(config.filenameValidation.regex)) {
                        Pan.Msg.alert(_T('Failure'), config.filenameValidation.failureMessage);
                        this.reset();
                        return;
                    }
                }
                if (config.contentType === 'image' && file.type.indexOf('image/') !== 0) {
                    Pan.Msg.alert(_T('Failure'), _T('Please select an image file.'));
                    this.reset();
                    return;
                }
                if (config.useFileReader && window.File && window.FileReader && window.FileList && window.Blob) {
                    var reader = new FileReader();
                    reader.onloadend = function (event) {
                        var blob = event.target.result;
                        if (self.contentEncoding === PanCustomizeFileField.encoding.base64) {
                            blob = Base64.encode(blob);
                        }
                        self.setValue(blob);
                        updateButtonStates.call(self, blob);
                    };
                    switch (config.contentType) {
                        case"image":
                            reader.readAsBinaryString(file);
                            break;
                        case"text":
                        default:
                            reader.readAsText(file);
                            break;
                    }
                }
                else {
                    var formPanel = PanCustomizeFileField._formPanel;
                    if (!formPanel) {
                        formPanel = PanCustomizeFileField._formPanel = new Ext.form.FormPanel({
                            url: "/php/common/customizeFileField.php?action=set&mode=nameonly",
                            fileUpload: true,
                            renderTo: Ext.getBody()
                        });
                        formPanel.add(new Pan.base.form.FileUploadField({name: 'tempFileField'}));
                        formPanel.doLayout();
                        formPanel.hide();
                    }
                    var form = formPanel.getForm();
                    var tempFileField = form.findField('tempFileField');
                    tempFileField.fileInput.dom.files = field.fileInput.dom.files;
                    form.submit({
                        waitMsg: _T('Uploading...'), success: function (form, action) {
                            var blob = action.result.result;
                            if (self.contentEncoding === PanCustomizeFileField.encoding.base64) {
                                blob = Base64.encode(blob);
                            }
                            self.setValue(blob);
                            updateButtonStates.call(self, blob);
                        }, failure: function (form, action) {
                            var msg;
                            if (action.result) {
                                msg = Pan.base.extractJsonText(action.result);
                            }
                            if (!msg) {
                                msg = _T('unspecified error');
                            }
                            Pan.Msg.alert(_T('Failure'), msg.split("\n").join("<p>"));
                        }
                    });
                }
            }
        }, setValue: function (value) {
            if (this.rendered) {
                var oldValue = this.getValue();
                this.__valueChanged = value !== oldValue;
            }
            return PanCustomizeFileField.superclass.setValue.call(this, value);
        }, getValue: function () {
            return PanCustomizeFileField.superclass.getValue.call(this);
        }, isDirty: function () {
            return this.__valueChanged || PanCustomizeFileField.superclass.isDirty.call(this);
        }, getDirtyContent: function () {
            var value = this.getValue();
            var content = value[this.schemaMapping.content];
            return content || value;
        }, getDisplayText: function (value) {
            if (typeof value === "object") {
                return value[this.schemaMapping.name] || value;
            }
            return value ? _T("Customized") : Pan.i18n(this.emptyText);
        }, getPreviewContent: function (value) {
            if (typeof value === "object") {
                return value[this.schemaMapping.content] || value;
            }
            return value;
        }, schemaMapping: {name: "name", content: "content"}, onRender: function () {
            var fieldData = this.getFieldData ? this.getFieldData() : undefined;
            this.items[0].emptyText = this.getDisplayText(fieldData);
            PanCustomizeFileField.superclass.onRender.apply(this, arguments);
            updateButtonStates.call(this, fieldData);
        }
    });
    PanCustomizeFileField.encoding = {noEncoding: "noEncoding", base64: "base64", split76: "split76"};
    if (Object.freeze) {
        Object.freeze(PanCustomizeFileField.encoding);
    }
    return PanCustomizeFileField;
}));
Ext.ns('Pan.appframework.component');
Pan.appframework.component.PanFirstLevelTabPanel = Ext.extend(Pan.base.container.FirstLevelTabPanel, {
    initComponent: function () {
        Pan.appframework.component.PanFirstLevelTabPanel.superclass.initComponent.call(this);
    }, getStateId: function () {
        var appendToState = '';
        if (Ext.isDefined(Pan.global.getTemplate())) {
            appendToState = Pan.global.getTemplate() + "-";
        }
        return appendToState + Pan.appframework.component.PanFirstLevelTabPanel.superclass.getStateId.call(this);
    }, onBeforeAdd: function (item) {
        if (Ext.isDefined(item) && Ext.isDefined(item.rbaPath) && !Pan.appframework.PanAppInterface.hasReadPermission(item.rbaPath)) {
            return false;
        }
        return Pan.appframework.component.PanFirstLevelTabPanel.superclass.onBeforeAdd.apply(this, arguments);
    }
});
Ext.reg('pan-firstleveltabpanel', Pan.appframework.component.PanFirstLevelTabPanel);
Pan.appframework.component.PanMultiSelectComboBox = Ext.extend(Pan.base.component.MultiSelectCombo, {
    allowAddNewData: (Pan.base.admin.getPermission('objects/tags') === 'enable'),
    ddGroup: 'pan-multiselect-combo-ddGroup',
    itemIconCls: "",
    constructor: function (config) {
        Pan.appframework.plugin.TagPlugin.URLDirects.getAllTags.call(this);
        Pan.appframework.component.PanMultiSelectComboBox.superclass.constructor.call(this, config);
    },
    initList: function () {
        Pan.appframework.component.PanMultiSelectComboBox.superclass.initList.call(this);
        var that = this;
        Ext.apply(this.view, {
            prepareData: function (data) {
                if (Ext.isObject(Pan.global.getAllTags())) {
                    data.iconCls = that.getTagIconCls(data['value']);
                }
                return data;
            }
        });
    },
    getTagIconCls: function (name) {
        var mapping = Pan.global.getAllTags();
        var location = this.store.__pdefaults && this.store.__pdefaults.__dataExtractor('location') || Pan.global.getLoc().val;
        var code;
        if (location == 'shared') {
            code = mapping[name + ',shared'];
            if (!code) {
                code = mapping[name + ',predefined'];
            }
        }
        else {
            code = mapping[name + ',vsys'];
            if (!code) {
                code = mapping[name + ',shared'];
                if (!code) {
                    code = mapping[name + ',panorama'];
                    if (!code) {
                        code = mapping[name + ',predefined'];
                    }
                }
            }
        }
        if (code) {
            return 'icon-combo-' + code;
        }
        else {
            return 'icon-combo-none';
        }
    },
    addReadOnlyItem: function (v) {
        if (Ext.isObject(v)) {
            var val = v["@name"];
            var display = v["display"] || val;
            var caption = v["tooltip"] || val;
            this.extraItemCls = v["iconCls"] || "";
            this.addItemBox(val, display, caption, "", "");
        }
        else {
            this.addItemBox(v, v, v, "", "");
        }
    },
    addItemBox: function (itemVal, itemDisplay, itemCaption, itemClass, itemStyle) {
        if (this.supportClearValue) {
            if (itemVal === this.supportClearValue) {
                this.removeAllItems();
                return;
            }
            else {
                var values = this.getValue();
                var clearValIdx = values.indexOf(this.supportClearValue);
                if (this.store.isStoreLoaded && clearValIdx >= 0) {
                    values.splice(clearValIdx, 1);
                    this.setValue(values);
                }
            }
        }
        Pan.appframework.component.PanMultiSelectComboBox.superclass.addItemBox.call(this, itemVal, itemDisplay, itemCaption, itemClass, itemStyle);
    }
});
Ext.reg('pan-multiselect-combo', Pan.appframework.component.PanMultiSelectComboBox);
Ext.override(Ext.ux.form.SuperBoxSelectItem, {
    onRender: function (ct, position) {
        Ext.ux.form.SuperBoxSelectItem.superclass.onRender.call(this, ct, position);
        var el = this.el;
        if (el) {
            el.remove();
        }
        if (position != undefined) {
            this.el = el = ct.createChild({tag: 'li'}, position);
        }
        else {
            this.el = el = ct.createChild({tag: 'li'}, ct.last());
        }
        el.addClass('x-superboxselect-item');
        if (Ext.isObject(Pan.global.getAllTags()) && Ext.isFunction(this.owner.getTagIconCls)) {
            var tagIconCls = this.owner.getTagIconCls(this.value);
            el.addClass(tagIconCls);
        }
        var iconCls = this.cls.trim() || this.owner.itemIconCls.trim();
        if (iconCls) {
            el.addClass("x-superboxselect-item-bg");
            el.addClass(iconCls);
        }
        el.update(this.display);
        if (this.caption !== this.display) {
            el.set(Ext.apply({
                "ext:qtip": this.caption,
                "ext:hide": (this.owner && Ext.isDefined(this.owner.qtipHide)) ? this.owner.qtipHide : Ext.ToolTip.prototype.hideDelay
            }, (this.owner && Ext.isDefined(this.owner.qtipWidth)) ? {"ext:qwidth": this.owner.qtipWidth} : {"ext:qwidth": 400}));
        }
        if (this.owner.readOnly !== true) {
            var btnEl = this.owner.navigateItemsWithTab ? (Ext.isSafari ? 'button' : 'a') : 'span';
            Ext.apply(el, {
                focus: function () {
                    var c = this.down(btnEl + '.x-superboxselect-item-close');
                    if (c) {
                        c.focus();
                    }
                }, preDestroy: function () {
                    this.preDestroy();
                }.createDelegate(this)
            });
            this.enableElListeners();
            var cfg = {
                tag: btnEl,
                'class': 'x-superboxselect-item-close',
                tabIndex: this.owner.navigateItemsWithTab ? '0' : '-1'
            };
            if (btnEl === 'a') {
                cfg.href = '#';
            }
            this.lnk = el.createChild(cfg);
            if (!this.disabled) {
                this.enableLnkListeners();
            }
            else {
                this.disableAllListeners();
            }
            this.on({disable: this.disableAllListeners, enable: this.enableAllListeners, scope: this});
            this.setupKeyMap();
        }
    }, onDisable: function () {
        if (this.hidden) {
            this.hidden.dom.setAttribute('disabled', 'disabled');
        }
        if (this.owner.readOnly !== true) {
            this.keyMap.disable();
        }
        Ext.ux.form.SuperBoxSelectItem.superclass.onDisable.call(this);
    }, onEnable: function () {
        if (this.hidden) {
            this.hidden.dom.removeAttribute('disabled');
        }
        if (this.owner.readOnly !== true) {
            this.keyMap.enable();
        }
        Ext.ux.form.SuperBoxSelectItem.superclass.onEnable.call(this);
    }
});
Ext.ns('Pan.appframework.renderer');
Pan.rreg("PanType", function (config) {
    if (Ext.isObject(config) && Ext.isString(config.type)) {
        var fn = Pan.renderer(Ext.applyIf({xtype: config.type}, config));
        if (Ext.isFunction(fn)) {
            return fn;
        }
    }
    switch (config.subtype) {
        case"union":
        case"choice":
            return function (value, meta, record) {
                return record.json[value];
            };
        case"choiceName":
            return function (value, meta) {
                if (meta.grid && meta.grid.store && meta.grid.store.fields) {
                    var storeField = meta.grid.store.fields.get(this.dataIndex);
                    if (storeField && storeField.children) {
                        for (var i = 0; i < storeField.children.length; i++) {
                            if (storeField.children[i]['attrName'] == value) {
                                if (storeField.children[i].uiHint['helpstring'])
                                    return storeField.children[i].uiHint['helpstring'];
                            }
                        }
                    }
                }
                return value;
            };
        case"array":
            return function (value) {
                if (Ext.isArray(value)) {
                    return Pan.base.htmlEncode(value.join(', '));
                }
                return value;
            };
        case'textwrap':
            return function (value, meta) {
                var values = [];
                var colWidth = this.width - 18;
                if (meta.grid && meta.grid.el) {
                    var w = meta.grid.el.getTextWidth(value);
                    var rows = Math.round(w / colWidth);
                    if (rows > 1 && Ext.isString(value) && value.indexOf(' ') > 0) {
                        var len = value.length;
                        var lenRow = Math.floor(len / rows);
                        var startIdx = 0;
                        var endIdx = 0;
                        var subStrLen = value.length;
                        var subValue = value;
                        while (rows > 0 || subStrLen > 0) {
                            if (subStrLen < lenRow) {
                                values.push(subValue);
                                endIdx = startIdx + subStrLen;
                            }
                            else {
                                if (subValue.lastIndexOf(' ') < 0) {
                                    values.push(subValue);
                                    break;
                                }
                                else {
                                    var partialStr = subValue.substring(0, lenRow);
                                    var lastSpaceIdx = partialStr.lastIndexOf(' ');
                                    lastSpaceIdx = lastSpaceIdx > 0 ? lastSpaceIdx : (subValue.substring(1).indexOf(' ') > 0 ? subValue.substring(1).indexOf(' ') : subStrLen - 1);
                                    endIdx = startIdx + lastSpaceIdx + 1;
                                    values.push(value.substring(startIdx, endIdx));
                                }
                            }
                            startIdx = endIdx;
                            rows = rows - 1;
                            subValue = value.substring(startIdx);
                            subStrLen = subValue.length;
                        }
                    }
                    else {
                        values.push(value);
                    }
                }
                return values;
            };
        case'csv':
            return function (v) {
                return v.split(",");
            };
        default:
            return function (v) {
                return _TC(v);
            };
    }
});
Pan.rreg("ProgressRenderer", function (config) {
    var textConfig = config.text;
    var valueConfig = config.value;
    var limitConfig = config.limit;
    var scopeConfig = config.scope;
    var clsConfig = config.cls;
    var fn = function () {
        var that = scopeConfig || this;
        var text = "";
        var value = "";
        var limit = "";
        var cls = "";
        if (textConfig) {
            if (Ext.isFunction(textConfig)) {
                text = textConfig.apply(that, arguments);
            } else {
                text = textConfig.toString();
            }
        }
        if (valueConfig) {
            if (Ext.isFunction(valueConfig)) {
                value = valueConfig.apply(that, arguments);
            } else {
                value = valueConfig.toString();
            }
        }
        if (limitConfig) {
            if (Ext.isFunction(limitConfig)) {
                limit = limitConfig.apply(that, arguments);
            } else {
                limit = limitConfig.toString();
            }
        }
        if (clsConfig) {
            if (Ext.isFunction(clsConfig)) {
                cls = clsConfig.apply(that, arguments);
            } else {
                cls = clsConfig.toString();
            }
        }
        return String.format('<div class="x-progress-wrap {0}" style="height:100%">' + '<div class="x-progress-inner" style="height:100%">' + '<div class="x-progress-bar x-progress-bar" style="height:100%; width:{1}%;">&#160;{2}' + '</div>' + '</div>' + '</div>', cls, (value / limit) * 100, Ext.isEmpty(text) ? value : Pan.base.htmlEncode(text));
    };
    return fn;
});
Pan.rreg("number", function () {
    var getNumber = function (num, decimalPlace, unit) {
        var v = num;
        if (Ext.isNumber(decimalPlace)) {
            v = parseFloat(Math.round(v + 'e' + decimalPlace) + 'e-' + decimalPlace).toFixed(decimalPlace);
        }
        if (Ext.isString(unit)) {
            v += "&nbsp;" + Pan.base.htmlEncode(Pan.base.htmlEncode(unit));
        }
        return v;
    };
    return function (value, meta, record) {
        if (Ext.isObject(value)) {
            var v = "";
            var num = value.value;
            if (!Ext.isNumber(num)) {
                num = parseFloat(num);
            }
            if (Ext.isNumber(num)) {
                v = getNumber(num, value['decimal-place'], value.unit);
                var tooltip = Ext.isString(value.tooltip) ? Pan.base.htmlEncode(Pan.base.htmlEncode(value.tooltip)) : value.tooltip;
                var color = Ext.isString(value.color) ? Pan.base.htmlEncode(value.color) : undefined;
                if (Ext.isNumber(value.limit)) {
                    if (value['value-and-percentage'] === true || value.percentage === true) {
                        var percentDecimalPlace = 1;
                        var percent = (num / value.limit) * 100;
                        percent = parseFloat(Math.round(percent + 'e' + percentDecimalPlace) + 'e-' + percentDecimalPlace).toFixed(percentDecimalPlace);
                        if (value['value-and-percentage']) {
                            v += "&nbsp;" + "(" + percent + "%)";
                        } else {
                            if (tooltip === undefined && percent != v) {
                                tooltip = "" + v + " / " + getNumber(value.limit, value['decimal-place'], value.unit);
                            }
                            v = percent + "%";
                        }
                    }
                    v = Ext.isEmpty(value.text) ? v : Pan.base.htmlEncode(value.text);
                    if (value['hide-bar'] !== true) {
                        var cls = value.gauge === true ? "progress-gauge" : (value.value > value.limit || value.error === true) ? "progress-error" : "";
                        v = String.format('<div class="x-progress-wrap {0}" style="height:100%">' + '<div class="x-progress-inner" style="height:100%">' + '<div class="x-progress-bar x-progress-bar" style="height:100%; width:{1}%;">&#160;{2}' + '</div>' + '</div>' + '</div>', cls, (num / value.limit) * 100, v);
                    } else {
                        meta.css += ' ' + ((value.value > value.limit || value.error === true) ? "progress-error" : "");
                    }
                }
                if (Ext.isString(color)) {
                    meta.attr += ' style="color:' + color + ';"';
                }
                if (Ext.isString(tooltip)) {
                    meta.attr += " ext:qtip='" + tooltip + "'";
                }
            }
            return v;
        } else {
            return value;
        }
    };
});
Pan.rreg("timestamp", function () {
    return function (value) {
        if (Ext.isObject(value)) {
            var timeInSeconds = 0;
            var timezoneDisplay = "UTC";
            if (Ext.isNumber(value.value)) {
                timeInSeconds = value.value;
                var localDate = new Date(0);
                localDate.setUTCSeconds(timeInSeconds);
                localDate = new Date(Ext.util.Format.dateRenderer('m/d/Y H:i:s')(localDate));
                timezoneDisplay = localDate.getTimezone();
                var timezoneOffset = -localDate.getTimezoneOffset() * 60;
                var localTimeOffset = timezoneOffset;
                if (Ext.isString(value.timezone) && Ext.isNumber(value.timezoneOffset)) {
                    timezoneOffset = value.timezoneOffset;
                    timezoneDisplay = value.timezone;
                }
                timeInSeconds += timezoneOffset - localTimeOffset;
            }
            var d = new Date(0);
            d.setUTCSeconds(timeInSeconds);
            return Ext.util.Format.dateRenderer('Y-m-d H:i:s')(d) + (value.timezone ? ' ' + timezoneDisplay : '');
        } else {
            return value;
        }
    };
});
Ext.ns('Pan.appframework.renderer');
Pan.rreg("PanTreeNodeRenderer", function (config) {
    var showChildren = function (elbowEl, grid, hide) {
        var elbowRow = elbowEl.findParentNode(".x-grid3-row");
        var elbowRecord = grid.store.getAt(elbowRow.rowIndex);
        var elbowLevel = elbowRecord.__treeLevel;
        var rows = grid.view.getRows();
        var length = rows.length;
        if (hide) {
            elbowEl.removeClass('x-tree-elbow-minus');
            elbowEl.addClass('x-tree-elbow-plus');
        }
        else {
            elbowEl.removeClass('x-tree-elbow-plus');
            elbowEl.addClass('x-tree-elbow-minus');
        }
        var treeLevelHiddenMap = {};
        treeLevelHiddenMap[elbowLevel] = hide;
        for (var i = elbowRow.rowIndex + 1; i < length; i++) {
            var treeLevel = grid.store.getAt(rows[i].rowIndex).__treeLevel;
            if (treeLevel <= elbowLevel) {
                break;
            }
            if (hide) {
                rows[i].style.display = "none";
            }
            else {
                if (treeLevelHiddenMap[treeLevel - 1]) {
                    rows[i].style.display = "none";
                    treeLevelHiddenMap[treeLevel] = true;
                }
                else {
                    rows[i].style.display = "";
                    treeLevelHiddenMap[treeLevel] = Ext.fly(rows[i]).select(".x-tree-elbow-plus").elements.length > 0;
                }
            }
        }
        if (hide && grid.supportFastRender) {
            grid.view.doFastRender();
        }
    };
    var fn = Pan.renderer(Ext.applyIf({xtype: 'LabelRenderer'}, config));
    fn = Pan.base.util.createExtension(function (value, meta, record, row, col, store, grid) {
        var superResult = arguments.callee.superFunction.apply(this, arguments);
        if (!this.useTreeNodeRenderer) {
            return superResult;
        }
        var buf = [];
        if (Ext.isNumber(record.__treeLevel)) {
            var verticalAign = 'style="vertical-align:-5px" border="0"';
            for (var i = 0; i < record.__treeLevel; i++) {
                buf.push('<img ' + verticalAign + ' src="' + Ext.BLANK_IMAGE_URL + '" class="x-tree-elbow-line" />');
            }
            if (record.__treeChildrenCount) {
                buf.push('<img ' + verticalAign + ' src="' + Ext.BLANK_IMAGE_URL + '" class="x-tree-elbow-minus row-selection-disabled" />');
            }
            else {
                buf.push('<img ' + verticalAign + ' src="' + Ext.BLANK_IMAGE_URL + '" class="x-tree-elbow" />');
            }
            if (this.iconCls) {
                buf.push('<img ' + verticalAign + ' src="' + Ext.BLANK_IMAGE_URL + '" class="' + this.iconCls + '" />');
            }
        }
        var rv = ['<span class="', (grid.useArrows ? 'x-tree-arrows' : grid.lines ? 'x-tree-lines' : 'x-tree-no-lines'), '"><span class="x-tree-node-indent">', buf.join(""), "</span></span>"];
        if (this.supportTreeSelection) {
            rv.push('<span class="x-tree-node-tristate-cb-wrap ');
            var selModel = grid.getSelectionModel();
            var isSelected = selModel.isSelected(row);
            if (isSelected) {
                rv.push('x-tree-node-tristate-cb-selected ');
            }
            else if (record.__treeChildrenCount) {
                var result = selModel.isAllChildrenSelected(record);
                if (result === "all") {
                    rv.push('x-tree-node-tristate-cb-all-children-selected ');
                }
                else if (result === "some") {
                    rv.push('x-tree-node-tristate-cb-some-children-selected ');
                }
            }
            rv.push('">', '<input class="x-tree-node-cb x-tree-node-tristate-cb" type="checkbox">', '</span>');
        }
        if (Ext.isArray(superResult)) {
            var preText = rv.join("");
            var ret = [];
            for (var j = 0; j < superResult.length; j++) {
                ret.push(preText + superResult[j]);
            }
            return ret;
        }
        rv.push(superResult);
        return rv.join("");
    }, fn);
    if (fn.superFunction.beforeClick) {
        fn.beforeClick = Pan.base.util.createExtension(function (component, config, event) {
            if (this.useTreeNodeRenderer) {
                var imgTarget = event.getTarget('img');
                if (imgTarget) {
                    var elbowEl = Ext.fly(imgTarget);
                    if (elbowEl.hasClass('x-tree-elbow-minus')) {
                        showChildren(elbowEl, component, true);
                    }
                    else if (elbowEl.hasClass('x-tree-elbow-plus')) {
                        showChildren(elbowEl, component, false);
                    }
                    return false;
                }
                if (this.supportTreeSelection) {
                    var cbTarget = event.getTarget('input.x-tree-node-cb');
                    if (cbTarget) {
                        var el = Ext.fly(cbTarget);
                        var rowIndex = el.findParentNode(".x-grid3-row").rowIndex;
                        var row = component.store.getAt(rowIndex);
                        var selModel = component.getSelectionModel();
                        if (Ext.isFunction(selModel.rowClicked)) {
                            selModel.rowClicked(row, rowIndex);
                        }
                        else {
                            var cbWrap = Ext.fly(el.findParentNode(".x-tree-node-tristate-cb-wrap"));
                            var fullCheck = cbWrap.hasClass('x-tree-node-tristate-cb-selected') || cbWrap.hasClass('x-tree-node-tristate-cb-all-children-selected');
                            if (fullCheck) {
                                selModel.deselectTreeRow(rowIndex);
                            }
                            else if (cbWrap.hasClass('x-tree-node-tristate-cb-some-children-selected')) {
                                if (selModel.isAllVisibleLeafChildrenSelected(row, rowIndex)) {
                                    selModel.deselectTreeRow(rowIndex);
                                }
                                else {
                                    selModel.selectTreeRow(rowIndex);
                                }
                                selModel.selectRow(rowIndex, true, false);
                            }
                            else {
                                selModel.selectTreeRow(rowIndex);
                            }
                        }
                    }
                }
            }
            return arguments.callee.superFunction.apply(this, arguments);
        }, fn.superFunction.beforeClick);
    }
    return fn;
});
Pan.appframework.renderer.isTemplateRec = function (record) {
    return !Pan.global.isCmsSelected() && record && record.json && record.json[Pan.common.Constants.attrSrc] === Pan.common.Constants.srcTemplate;
};
Pan.appframework.renderer.isTemplateOverrideRec = function (record, store) {
    return !Pan.global.isCmsSelected() && !Pan.appframework.renderer.isTemplateRec(record) && store && store.templateRecords && store.templateRecords[record.id];
};
Pan.appframework.renderer.isParentDGRec = function (record) {
    if (record && record.json && Ext.isDefined(record.json['@__recordInfo']) && record.json['@__recordInfo'].position === 'default-security-rule') {
        if (Pan.global.getLoc().type === "shared") {
            return record.json['@__recordInfo'].xpathId !== "shared";
        }
        return record.json['@__recordInfo'].vsysName !== Pan.global.getLocVal();
    }
    return Pan.global.isCmsSelected() && !Ext.isDefined(Pan.global.getTemplate()) && record && record.json && Ext.isDefined(record.json['@__recordInfo']) && Ext.isDefined(record.json['@__recordInfo'].vsysName) && record.json['@__recordInfo'].vsysName !== Pan.global.getLocVal() && record.json['@__recordInfo'].xpathId != 'cms-private' && Pan.common.PanConfigStates.prototype.isShowingVsysComboOnTop();
};
Pan.appframework.renderer.isDGOverrideRec = function (record) {
    return record && record.json && Ext.isDefined(record.json[Pan.common.Constants.attrOverrides]);
};
Pan.appframework.renderer.getParentDGRecName = function (record) {
    if (Pan.appframework.renderer.isParentDGRec(record)) {
        if (Ext.isEmpty(record.json['@__recordInfo'].vsysName)) {
            return record.json['@__recordInfo'].xpathId;
        }
        else {
            return record.json['@__recordInfo'].vsysName;
        }
    }
    return '';
};
Pan.appframework.renderer.getDGOverrideRecName = function (record) {
    return Pan.appframework.renderer.isDGOverrideRec(record) ? record.json[Pan.common.Constants.attrOverrides] : undefined;
};
Pan.appframework.renderer.isParentDGRule = function (record) {
    if (record && record.json && Ext.isDefined(record.json['@__recordInfo']) && record.json['@__recordInfo'].position === 'default-security-rule') {
        if (Pan.global.getLoc().type === "shared") {
            return record.json['@__recordInfo'].xpathId !== "shared";
        }
        else {
            return record.json['@__recordInfo'].vsysName !== Pan.global.getLocVal();
        }
    }
    return false;
};
Pan.appframework.renderer.isTSTemplateRec = function (record) {
    return Pan.global.isCmsSelected() && record && record.json && !Ext.isEmpty(record.json[Pan.common.Constants.attrPtpl]) && record.store && (!record.store.nonMergedRecords || !record.store.nonMergedRecords[record.id]) && (!record.store.__hlRecord || !record.store.__hlRecord.store.nonMergedRecords || !record.store.__hlRecord.store.nonMergedRecords[record.store.additionalInput.__id]);
};
Pan.appframework.renderer.isTSOverrideRec = function (record, store) {
    return Pan.global.isCmsSelected() && !Pan.appframework.renderer.isTSTemplateRec(record) && store && store.templateRecords && store.templateRecords[record.id];
};
Pan.appframework.renderer.PanOverrideIndicationRenderer = function (value, meta, record, row, col, store, grid) {
    if (grid && grid.globalFindPreview === true) {
        return "";
    }
    var icon = '';
    var tip;
    if (Pan.appframework.renderer.isTemplateRec(record)) {
        icon = 'x-indicate-from-template';
        tip = _T('From Template Stack') + ": " + Pan.global.getTemplateName();
    }
    else if (Pan.appframework.renderer.isTemplateOverrideRec(record, store)) {
        icon = 'x-indicate-overridden-template';
        tip = _T('From Template Stack Override') + ": " + Pan.global.getTemplateName();
    }
    else if (Pan.appframework.renderer.isParentDGRec(record)) {
        icon = 'x-indicate-from-parentDG';
        tip = _T('From') + ": " + Pan.appframework.renderer.getParentDGRecName(record);
    }
    else if (Pan.appframework.renderer.isDGOverrideRec(record)) {
        icon = 'x-indicate-overridden-dg';
        tip = _T('Overriding') + ": " + Pan.appframework.renderer.getDGOverrideRecName(record);
    }
    else if (Pan.appframework.renderer.isTSTemplateRec(record)) {
        icon = 'x-indicate-from-template';
        tip = _T('From Template') + ": " + record.json[Pan.common.Constants.attrPtpl];
    }
    else if (Pan.appframework.renderer.isTSOverrideRec(record, store)) {
        icon = 'x-indicate-overridden-template';
        tip = _T('From Template Override') + ": " + store.templateRecords[record.id].json[Pan.common.Constants.attrPtpl];
    }
    else {
        return;
    }
    var align = 'align="' + 'right' + '"';
    var style = 'style="padding-right:20"';
    return '<img ' + align + style + ' ext:qtip="' + Pan.base.htmlEncode(tip) + '" class="' + icon + '" src="/images/s.gif"/>';
};
Pan.appframework.renderer.PanDeviceDetailsRenderer = function (value, meta, record) {
    var tip = '';
    if (record.get('$.entry.*.device-name'))
        tip = Pan.base.htmlEncode(_T('Name') + ': ' + record.get('$.entry.*.device-name'));
    if (record.get('$.entry.*.group-name'))
        tip += '<br/>' + Pan.base.htmlEncode(_T('Device Group') + ': ' + record.get('$.entry.*.group-name'));
    if (record.get('$.entry.*.template'))
        tip += '<br/>' + Pan.base.htmlEncode(_T('Template') + ': ' + record.get('$.entry.*.template'));
    if (record.get('$.entry.*.tags'))
        tip += '<br/>' + Pan.base.htmlEncode(_T('Tags') + ': ' + record.get('$.entry.*.tags'));
    if (record.get('$.entry.*.serial'))
        tip += '<br/>' + Pan.base.htmlEncode(_T('Serial Number') + ': ' + record.get('$.entry.*.serial'));
    if (record.get('$.entry.*.series'))
        tip += '<br/>' + Pan.base.htmlEncode(_T('Model') + ': ' + record.get('$.entry.*.series'));
    var icon = 'icon-comment';
    var align = 'align="' + 'left' + '"';
    return '<img ' + align + ' ext:qtip="' + tip + '" class="' + icon + '" src="/images/s.gif"/>' + value;
};
Ext.ns('Pan.appframework.plugin');
Pan.appframework.plugin.OverrideFieldPlugin = Ext.extend(Ext.util.Observable, {
    indicateOverrideClass: 'x-indicate-from-template',
    indicateRevertClass: 'x-indicate-remove',
    hideDisplayClass: 'x-hide-display',
    baseStringLabel: _T('Base Value'),
    supportFieldPlugin: function () {
        return true;
    },
    initBaseValue: undefined,
    hasOverrideValue: undefined,
    hasBaseValue: undefined,
    getBaseValue: undefined,
    init: function (c) {
        if (c.__field && c.__field.tlo) {
            c.isExtFormField = true;
        }
        if (!c.setValue || c.isExtFormField === false) {
            return;
        }
        var labelFieldPluginEvent = c.labelFieldPluginEvent || 'render';
        c.addListener(labelFieldPluginEvent, function () {
            var label = Ext.get(c.id + "-label");
            if (label) {
                var self = this;
                var needToSetupFieldLabel = true;
                var ownerCt = c;
                while (ownerCt) {
                    if (ownerCt.__field && ownerCt.__field.tlo) {
                        if (ownerCt !== c) {
                            needToSetupFieldLabel = false;
                            break;
                        }
                    }
                    if (ownerCt.getSelectionComponent && ownerCt.__field && ownerCt.__field.isAnAncestorTLO) {
                        ownerCt.cascade(function (comp) {
                            if (ownerCt !== comp && ownerCt.getSelectionComponent() != comp) {
                                comp.__tloAncester = {ancestor: ownerCt};
                            }
                        }, self);
                    }
                    if (Ext.isFunction(ownerCt.hasEvent)) {
                        if (ownerCt.hasEvent('afterinit')) {
                            self.overrideTestValueChangedMethods(c, label, self);
                            ownerCt.addListener('afterinit', function () {
                                this.setupFieldLabel(c, label);
                                ownerCt.removeListener('afterinit', arguments.callee, self);
                            }, self, {delay: 100});
                            needToSetupFieldLabel = false;
                            break;
                        }
                    }
                    ownerCt = ownerCt.ownerCt;
                }
                if (needToSetupFieldLabel) {
                    self.overrideTestValueChangedMethods(c, label, self);
                    this.setupFieldLabel(c, label);
                }
            }
        }, this);
    },
    overrideTestValueChangedMethods: function (c, label, self) {
        c.testValueChangedWithoutVerify = Pan.base.util.createExtension(function () {
            arguments.callee.superFunction.apply(this, arguments);
            if (self.hasBaseValue(c)) {
                self.doIndicateRevertRecursive(c, label);
            }
        }, c.testValueChangedWithoutVerify);
        c.testValueChangedWithVerify = Pan.base.util.createExtension(function () {
            arguments.callee.superFunction.apply(this, arguments);
            if (self.hasBaseValue(c) && this.isDirty()) {
                self.doIndicateRevertRecursive(c, label);
            }
        }, c.testValueChangedWithVerify);
    },
    setupFieldLabel: function (c, label) {
        var self = this;
        var r = c.getRecord && c.getRecord();
        if (self.supportFieldPlugin(r)) {
            self.initBaseValue(r, c);
            if (self.hasBaseValue(c)) {
                c.isFromBase = function () {
                    return self.isFromBase(this);
                };
                if (!c.extractFormValue) {
                    c.extractFormValue = self.extractFormValue.createDelegate(this);
                }
                self.initFieldLabel(c, label);
                c.mon(label, "click", self.onLabelClick, {self: self, c: c, label: label});
                Ext.QuickTips.register({target: label, text: self.getTooltip(c)});
                c.addListener('beforedestroy', function () {
                    Ext.QuickTips.unregister(label);
                }, self);
            }
        }
    },
    initFieldLabel: function (c, label) {
        var self = this;
        if (self.hasOverrideValue(c)) {
            label.removeClass(self.hideDisplayClass);
            self.fieldLabelPluginSetVisible(c, true);
            self.doIndicateRevert(c, label);
        }
        else {
            if (self.hasBaseValue(c)) {
                label.removeClass(self.hideDisplayClass);
                self.fieldLabelPluginSetVisible(c, true);
                var baseValue = self.getBaseValue(c);
                if (c.getValue() != baseValue) {
                    self.setValue(c, baseValue);
                    self.doIndicateOverride.defer(100, self, [c, label]);
                }
                else {
                    self.doIndicateOverride(c, label);
                }
            }
        }
    },
    fieldLabelPluginSetVisible: function (c, visible) {
        if (c.fieldLabelPluginSetVisible) {
            c.fieldLabelPluginSetVisible(visible);
        }
    },
    onLabelClick: function (event, element) {
        var config = this;
        var self = config.self;
        var c = config.c;
        var label = config.label;
        event.stopEvent();
        event.preventDefault();
        event.stopPropagation();
        element = Ext.fly(element);
        if (element.hasClass(self.indicateRevertClass)) {
            self.doIndicateOverrideRecursive(c, label);
        }
        else if (element.hasClass(self.indicateOverrideClass)) {
            if (c.customOverride) {
                c.customOverride();
            }
            else {
                c.testValueChangedWithoutVerify();
            }
            self.doIndicateRevert(c, label);
        }
    },
    extractFormValue: function (c) {
        var value;
        if (this.isContainerTLO(c)) {
            value = !this.isFromBase(c);
        }
        else if (this.canSaveValue(c)) {
            value = c.getValue();
        }
        return value;
    },
    getBaseStringLabel: function () {
        return this.baseStringLabel;
    },
    getTooltip: function (c) {
        var baseValue = this.getBaseValue(c);
        if (Ext.isArray(baseValue)) {
            var newValue = [];
            for (var i = 0; i < baseValue.length; i++) {
                var child = JSON.stringify(baseValue[i], undefined, '\n\t');
                if (Ext.isObject(baseValue[i])) {
                    child = child.replace(/\"[^"]*\"\:/g, "").replace(/^{/, "").replace(/}$/, "");
                }
                newValue.push(child);
            }
            baseValue = newValue.join(",");
        }
        else {
            baseValue = JSON.stringify(baseValue, undefined, '\n\t');
        }
        return this.getBaseStringLabel(c) + ": " + baseValue;
    },
    canSaveValue: function (c) {
        return this.isFromBase(c) !== true;
    },
    isFromBase: function (c) {
        return c.__isFromBase;
    },
    setIsFromBase: function (c, isFromBase) {
        c.__isFromBase = isFromBase;
    },
    isContainerTLO: function (c) {
        return c.__field && c.__field.tlo && !c.__field.isCollection && c.cascade;
    },
    setValue: function (c, v) {
        var self = this;
        if (self.isContainerTLO(c)) {
            c.cascade(function (comp) {
                if (comp.setValue && comp.__field && comp.__field.attrPath) {
                    var value;
                    if (comp.__field.choiceParentAttr) {
                        var parentValue = c.__field.getChildData(v, comp.__field.choiceParentAttr.attrPath);
                        for (var i = 0; i < comp.__field.children.length; i++) {
                            var child = comp.__field.children[i];
                            if (parentValue && parentValue[child.attrName]) {
                                value = child.attrName;
                            }
                        }
                    }
                    else {
                        value = c.__field.getChildData(v, comp.__field.attrPath);
                    }
                    comp.setValue(value);
                }
            }, self);
        }
        else if (c.setValue) {
            c.setValue(v);
        }
    },
    protect: function (c) {
        c.protect();
    },
    unprotect: function (c) {
        c.unprotect();
    },
    doIndicateOverrideRecursive: function (c, label) {
        var self = this;
        if (c.customRevert) {
            c.customRevert();
        }
        else {
            c.testValueChangedWithoutVerify();
        }
        self.doIndicateOverride.defer(100, self, [c, label]);
        if (c.customRevert) {
            return;
        }
        self.setValue(c, self.getBaseValue(c));
        if (!c.cascade) {
            if (c.ownerCt && c.ownerCt.getSelectionComponent) {
                c = c.ownerCt;
            }
        }
        if (c.cascade) {
            c.cascade(function (comp) {
                if (comp.__tloAncester) {
                    return;
                }
                if (self.hasBaseValue(comp)) {
                    var lbl = Ext.get(comp.id + "-label");
                    if (lbl) {
                        if (comp.testValueChangedWithoutVerify) {
                            comp.testValueChangedWithoutVerify();
                        }
                        self.setValue(comp, self.getBaseValue(comp));
                        self.doIndicateOverride.defer(100, self, [comp, lbl]);
                    }
                }
            }, self);
        }
    },
    doIndicateRevertRecursive: function (c, label) {
        this.doIndicateRevert(c, label);
        var ownerCt = c.ownerCt;
        while (ownerCt) {
            if (ownerCt.getSelectionComponent) {
                var comp = ownerCt.getSelectionComponent();
                if (this.hasBaseValue(comp)) {
                    var lbl = Ext.get(comp.id + "-label");
                    if (lbl) {
                        this.doIndicateRevert(comp, lbl);
                    }
                }
            }
            ownerCt = ownerCt.ownerCt;
        }
    },
    doIndicateOverride: function (c, label) {
        if (!c.__tloAncester) {
            if (this.indicateOverrideClass === this.hideDisplayClass) {
                this.fieldLabelPluginSetVisible(c, false);
            }
            label.addClass(this.indicateOverrideClass);
            label.removeClass(this.indicateRevertClass);
            label.parent().parent().removeClass('x-hide-label');
        }
        else {
            label.addClass('x-hide-display');
        }
        if (c.protect && !c.__tloAncester) {
            this.protect(c);
            if (c.ownerCt && c.ownerCt.getSelectionComponent) {
                this.setIsFromBase(c.ownerCt.getSelectionComponent(), true);
                var radioCard = c.ownerCt;
                radioCard.cascade(function (comp) {
                    var lbl = Ext.get(comp.id + "-label");
                    if (lbl) {
                        if (!this.hasBaseValue(comp)) {
                            this.setValue(comp, undefined);
                        }
                        else {
                            var baseValue = this.getBaseValue(comp);
                            if (Ext.isDefined(baseValue) && baseValue != comp.getValue()) {
                                this.setValue(comp, baseValue);
                            }
                        }
                        if (comp.protect) {
                            this.protect(comp);
                        }
                    }
                }, this);
            }
        }
        this.setIsFromBase(c, true);
    },
    doIndicateRevert: function (c, label) {
        if (!c.__tloAncester) {
            if (this.indicateOverrideClass === this.hideDisplayClass) {
                this.fieldLabelPluginSetVisible(c, true);
            }
            label.removeClass(this.indicateOverrideClass);
            label.addClass(this.indicateRevertClass);
            label.parent().parent().removeClass('x-hide-label');
        }
        else {
            label.addClass('x-hide-display');
        }
        if (c.unprotect && !c.__tloAncester) {
            this.unprotect(c);
            if (c.ownerCt && c.ownerCt.getSelectionComponent) {
                this.setIsFromBase(c.ownerCt.getSelectionComponent(), false);
                var radioCard = c.ownerCt;
                radioCard.cascade(function (comp) {
                    var lbl = Ext.get(comp.id + "-label");
                    if (lbl) {
                        if (!this.hasBaseValue(comp)) {
                        }
                        else {
                            this.setIsFromBase(comp, false);
                        }
                        if (comp.unprotect) {
                            this.unprotect(comp);
                        }
                    }
                }, this);
            }
            else if (this.isContainerTLO(c)) {
                c.cascade(function (comp) {
                    var testValueChangedWithoutVerify = comp.testValueChangedWithoutVerify && comp.testValueChangedWithoutVerify.superFunction || comp.testValueChangedWithoutVerify;
                    if (testValueChangedWithoutVerify) {
                        testValueChangedWithoutVerify.call(comp);
                    }
                }, this);
            }
        }
        this.setIsFromBase(c, false);
    }
});
Ext.preg('overridefieldplugin', Pan.appframework.plugin.OverrideFieldPlugin);
Ext.ns('Pan.appframework.plugin');
Pan.appframework.plugin.TemplateFieldPlugin = Ext.extend(Pan.appframework.plugin.OverrideFieldPlugin, {
    indicateRevertClass: 'x-indicate-overridden-template', supportFieldPlugin: function (r) {
        return r && r.store.templateRecord;
    }, initBaseValue: function (r, c) {
        var templateRecordJson = r.store.templateRecord.json;
        var nonMergedRecordJson = r.store.nonMergedRecord.json;
        c.__inTemplate = false;
        c.__inNonMerged = false;
        c.__inTemplateValue = undefined;
        c.__inNonMergedValue = undefined;
        if (c.__field && c.__field.attrPath) {
            if (c.__field.choiceParentAttr) {
                c.__inTemplate = c.__field.choiceParentAttr.getData(templateRecordJson);
                c.__inNonMerged = c.__field.choiceParentAttr.getData(nonMergedRecordJson);
                var i = 0;
                var child;
                if (c.__inNonMerged) {
                    for (i = 0; i < c.__field.children.length; i++) {
                        child = c.__field.children[i];
                        if (c.__inNonMerged[child.attrName]) {
                            c.__inNonMergedValue = child.attrName;
                            break;
                        }
                    }
                }
                if (!Ext.isDefined(c.__inNonMergedValue)) {
                    c.__inNonMerged = undefined;
                }
                if (c.__inTemplate) {
                    for (i = 0; i < c.__field.children.length; i++) {
                        child = c.__field.children[i];
                        if (c.__inTemplate[child.attrName]) {
                            c.__inTemplateValue = child.attrName;
                            break;
                        }
                    }
                }
                if (!Ext.isDefined(c.__inTemplateValue)) {
                    c.__inTemplate = undefined;
                }
            }
            else {
                var attrPath = c.__field.attrPath;
                if (attrPath === '$') {
                    c.__inTemplate = templateRecordJson;
                    c.__inNonMerged = nonMergedRecordJson;
                }
                else {
                    c.__inTemplate = jsonPath(templateRecordJson, attrPath);
                    c.__inNonMerged = jsonPath(nonMergedRecordJson, attrPath);
                    if (c.__inTemplate) {
                        c.__inTemplate = c.__inTemplate[0];
                    }
                    if (c.__inNonMerged) {
                        c.__inNonMerged = c.__inNonMerged[0];
                    }
                }
                if (c.__inNonMerged) {
                    c.__inNonMergedValue = c.__inNonMerged;
                    if (c.__field.convert) {
                        c.__inNonMergedValue = c.__field.convert(c.__inNonMergedValue, nonMergedRecordJson);
                        if (!Ext.isDefined(c.__inNonMergedValue)) {
                            c.__inNonMerged = undefined;
                        }
                    }
                }
                if (c.__inTemplate) {
                    c.__inTemplateValue = c.__inTemplate;
                    if (c.__field.convert) {
                        c.__inTemplateValue = c.__field.convert(c.__inTemplateValue, templateRecordJson);
                        if (!Ext.isDefined(c.__inTemplateValue)) {
                            c.__inTemplate = undefined;
                        }
                    }
                }
            }
        }
    }, hasOverrideValue: function (c) {
        return c.__inNonMerged;
    }, hasBaseValue: function (c) {
        return c.__inTemplate;
    }, getBaseValue: function (c) {
        if (c.__tloAncester && c.__tloAncester.ancestor.getSelectionComponent && !this.isFromBase(c.__tloAncester.ancestor.getSelectionComponent())) {
            return undefined;
        }
        return c.__inTemplateValue;
    }, getBaseStringLabel: function () {
        return _T('{templateName} Value', {templateName: Pan.global.getTemplateName()});
    }
});
Ext.preg('templatefieldplugin', Pan.appframework.plugin.TemplateFieldPlugin);
Pan.appframework.plugin.TemplateStackFieldPlugin = Ext.extend(Pan.appframework.plugin.TemplateFieldPlugin, {
    indicateOverrideClass: 'x-hide-display',
    indicateRevertClass: 'x-indicate-remove',
    indicateTemplateRevertClass: 'x-indicate-overridden-template',
    indicateTemplateOverrideClass: 'x-indicate-from-template',
    supportFieldPlugin: function () {
        return Pan.global.isCmsSelected() && Pan.global.getTemplate();
    },
    initBaseValue: function (r, c) {
        c.__inTemplateName = undefined;
        if (r && r.store.templateRecord) {
            Pan.appframework.plugin.TemplateStackFieldPlugin.superclass.initBaseValue.apply(this, arguments);
            if (c.__inTemplate) {
                var source = r.store.__ptpl;
                var attrPath, attrName;
                if (c.__field.choiceParentAttr) {
                    attrPath = c.__field.choiceParentAttr.attrPath;
                    for (var i = 0; i < c.__field.children.length; i++) {
                        var child = c.__field.children[i];
                        if (c.__inTemplate[child.attrName]) {
                            attrPath = '$..' + child.attrName;
                            c.__inTemplateName = jsonPath(source, attrPath)[0]['@ptpl'];
                            break;
                        }
                    }
                }
                else {
                    attrPath = c.__field.attrPath;
                    attrName = c.__field.attrName;
                    if (attrPath === '$') {
                        c.__inTemplateName = jsonPath(source, '$..result.*')[0]['@ptpl'];
                    }
                    else {
                        if (attrPath.endsWith("entry")) {
                            attrPath = attrPath.substring(0, attrPath.lastIndexOf(".entry"));
                            var parts = attrPath.split('.');
                            attrName = parts.pop();
                            c.__inTemplateName = jsonPath(source, '$..' + attrName)[0]['@ptpl'];
                        }
                        else {
                            if (attrPath.indexOf('$.') >= 0) {
                                attrPath = '$..' + attrName;
                            }
                            c.__inTemplateName = jsonPath(source, attrPath)[0]['@ptpl'];
                        }
                    }
                }
            }
        }
        if (!c.__inTemplate) {
            Pan.appframework.plugin.DefaultFieldPlugin.prototype.initBaseValue.apply(this, arguments);
        }
    },
    hasOverrideValue: function (c) {
        if (c.__inTemplate) {
            return c.__inNonMerged;
        }
        return c.__inOverride;
    },
    hasBaseValue: function () {
        return true;
    },
    canSaveValue: function (c) {
        return !c.allowBlank || (c.__field && c.__field.initialFieldConfig && Ext.isDefined(c.__field.initialFieldConfig.defaultValue)) || Pan.appframework.plugin.TemplateStackFieldPlugin.superclass.canSaveValue.apply(this, arguments);
    },
    getBaseValue: function (c) {
        if (c.__inTemplate) {
            return Pan.appframework.plugin.TemplateStackFieldPlugin.superclass.getBaseValue.apply(this, arguments);
        }
        return c.__inDefaultValue;
    },
    protect: Ext.emptyFn,
    unprotect: Ext.emptyFn,
    getBaseStringLabel: function (c) {
        if (c.__inTemplate) {
            return c.__inTemplateName;
        }
        return _T('Default Value');
    },
    doIndicateOverride: function (c, label) {
        if (c.isExtFormField === false) {
            return;
        }
        if (!c.__inTemplate) {
            this.indicateOverrideClass = 'x-hide-display';
            this.indicateRevertClass = 'x-indicate-remove';
        } else {
            this.indicateOverrideClass = this.indicateTemplateOverrideClass;
            this.indicateRevertClass = this.indicateTemplateRevertClass;
        }
        Pan.appframework.plugin.TemplateStackFieldPlugin.superclass.doIndicateOverride.apply(this, arguments);
    },
    doIndicateRevert: function (c, label) {
        if (c.isExtFormField === false) {
            return;
        }
        if (!c.__inTemplate) {
            this.indicateOverrideClass = 'x-hide-display';
            this.indicateRevertClass = 'x-indicate-remove';
        } else {
            this.indicateOverrideClass = this.indicateTemplateOverrideClass;
            this.indicateRevertClass = this.indicateTemplateRevertClass;
        }
        Pan.appframework.plugin.TemplateStackFieldPlugin.superclass.doIndicateRevert.apply(this, arguments);
    }
});
Ext.preg('templatestackfieldplugin', Pan.appframework.plugin.TemplateStackFieldPlugin);
Pan.appframework.plugin.TemplateStackTLOFieldPlugin = Ext.extend(Pan.appframework.plugin.TemplateStackFieldPlugin, {
    init: function (c) {
        if (!c.setValue || (c.isChildOfStarField && c.isChildOfStarField()) || c.isExtFormField === false || (c.__field && c.__field.uiHint && c.__field.uiHint.isKeyField)) {
            return;
        }
        var labelFieldPluginEvent = c.labelFieldPluginEvent || 'render';
        c.addListener(labelFieldPluginEvent, function () {
            var label = Ext.get(c.id + "-label");
            if (label) {
                var self = this;
                var needToSetupFieldLabel = true;
                var ownerCt = c;
                while (ownerCt) {
                    if (ownerCt.getSelectionComponent && ownerCt.__field && ownerCt.__field.isAnAncestorTLO) {
                        ownerCt.cascade(function (comp) {
                            if (ownerCt !== comp && ownerCt.getSelectionComponent() != comp) {
                                comp.__tloAncester = {ancestor: ownerCt};
                            }
                        }, self);
                    }
                    if (Ext.isFunction(ownerCt.hasEvent)) {
                        if (ownerCt.hasEvent('afterinit')) {
                            self.overrideTestValueChangedMethods(c, label, self);
                            ownerCt.addListener('afterinit', function () {
                                this.setupFieldLabel(c, label);
                                ownerCt.removeListener('afterinit', arguments.callee, self);
                            }, self, {delay: 100});
                            needToSetupFieldLabel = false;
                            break;
                        }
                    }
                    ownerCt = ownerCt.ownerCt;
                }
                if (needToSetupFieldLabel) {
                    self.overrideTestValueChangedMethods(c, label, self);
                    this.setupFieldLabel(c, label);
                }
            }
        }, this);
    }, initBaseValue: function (r, c) {
        c.__inTemplateName = undefined;
        if (r && r.store.templateRecords && r.store.templateRecords[r.id]) {
            var templateRecordJson = r.store.templateRecords[r.id].json;
            var nonMergedRecordJson = r.store.nonMergedRecords && r.store.nonMergedRecords[r.id] ? r.store.nonMergedRecords[r.id].json : false;
            c.__inTemplate = false;
            c.__inNonMerged = false;
            c.__inTemplateValue = undefined;
            c.__inNonMergedValue = undefined;
            if (c.__field && (c.__field.attrPath || c.__field.name)) {
                if (c.__field.choiceParentAttr) {
                    c.__inTemplate = c.__field.choiceParentAttr.getData(templateRecordJson);
                    c.__inNonMerged = c.__field.choiceParentAttr.getData(nonMergedRecordJson);
                    var i = 0;
                    var child;
                    if (c.__inNonMerged) {
                        for (i = 0; i < c.__field.children.length; i++) {
                            child = c.__field.children[i];
                            if (c.__inNonMerged[child.attrName]) {
                                c.__inNonMergedValue = child.attrName;
                                break;
                            }
                        }
                    }
                    if (!Ext.isDefined(c.__inNonMergedValue)) {
                        c.__inNonMerged = undefined;
                    }
                    if (c.__inTemplate) {
                        for (i = 0; i < c.__field.children.length; i++) {
                            child = c.__field.children[i];
                            if (c.__inTemplate[child.attrName]) {
                                c.__inTemplateValue = child.attrName;
                                break;
                            }
                        }
                    }
                    if (!Ext.isDefined(c.__inTemplateValue)) {
                        c.__inTemplate = undefined;
                    }
                }
                else {
                    var attrPath = c.__field.attrPath || c.__field.name;
                    if (attrPath === '$') {
                        c.__inTemplate = templateRecordJson;
                        c.__inNonMerged = nonMergedRecordJson;
                    }
                    else {
                        c.__inTemplate = jsonPath(templateRecordJson, attrPath);
                        c.__inNonMerged = jsonPath(nonMergedRecordJson, attrPath);
                        if (c.__inTemplate) {
                            c.__inTemplate = c.__inTemplate[0];
                        }
                        if (c.__inNonMerged) {
                            c.__inNonMerged = c.__inNonMerged[0];
                        }
                    }
                    if (c.__inNonMerged) {
                        c.__inNonMergedValue = c.__inNonMerged;
                        if (c.__field.convert) {
                            c.__inNonMergedValue = c.__field.convert(c.__inNonMergedValue, nonMergedRecordJson);
                            if (!Ext.isDefined(c.__inNonMergedValue)) {
                                c.__inNonMerged = undefined;
                            }
                        }
                    }
                    if (c.__inTemplate) {
                        c.__inTemplateValue = c.__inTemplate;
                        if (c.__field.convert) {
                            c.__inTemplateValue = c.__field.convert(c.__inTemplateValue, templateRecordJson);
                            if (!Ext.isDefined(c.__inTemplateValue)) {
                                c.__inTemplate = undefined;
                            }
                        }
                    }
                }
            }
            if (c.__inTemplate) {
                var source = r.store.templateRecords[r.id].json;
                c.__inTemplateName = source['@ptpl'];
                this.indicateOverrideClass = this.indicateTemplateOverrideClass;
                this.indicateRevertClass = this.indicateTemplateRevertClass;
            }
        }
        if (!c.__inTemplate) {
            Pan.appframework.plugin.DefaultFieldPlugin.prototype.initBaseValue.apply(this, arguments);
        }
    }
});
Ext.preg('templatestacktlofieldplugin', Pan.appframework.plugin.TemplateStackTLOFieldPlugin);
Ext.ns('Pan.appframework.plugin');
Pan.appframework.plugin.DefaultFieldPlugin = Ext.extend(Pan.appframework.plugin.OverrideFieldPlugin, {
    indicateOverrideClass: 'x-hide-display', baseStringLabel: _T('Default Value'), supportFieldPlugin: function () {
        return Pan.global.isCmsSelected() && Pan.global.getTemplate();
    }, initBaseValue: function (r, c) {
        c.__inDefault = false;
        c.__inOverride = false;
        c.__inDefaultValue = undefined;
        c.__inOverrideValue = undefined;
        if (c.__field && (c.__field.attrPath || c.__field.name)) {
            var field = c.__field;
            if (field.choiceParentAttr) {
                c.__inDefault = Ext.isDefined(field.defaultValue) && field.defaultValue !== "";
                if (c.__inDefault) {
                    c.__inDefaultValue = field.defaultValue;
                }
                c.__inOverride = field.choiceParentAttr.getData(r.json);
                if (c.__inOverride) {
                    for (var i = 0; i < field.children.length; i++) {
                        var child = field.children[i];
                        if (c.__inOverride[child.attrName]) {
                            c.__inOverrideValue = child.attrName;
                            break;
                        }
                    }
                }
            }
            else {
                var attrPath = field.attrPath || field.name;
                if (attrPath === '$') {
                    c.__inDefault = Ext.isDefined(field.defaultValue) && field.defaultValue !== "";
                    if (c.__inDefault) {
                        c.__inDefaultValue = field.defaultValue;
                    }
                    c.__inOverride = r.json;
                    c.__inOverrideValue = c.__inOverride;
                }
                else {
                    c.__inDefault = Ext.isDefined(field.defaultValue) && field.defaultValue !== "";
                    if (c.__inDefault) {
                        c.__inDefaultValue = field.defaultValue;
                    }
                    c.__inOverride = jsonPath(r.json, attrPath);
                    if (c.__inOverride) {
                        c.__inOverride = c.__inOverride[0];
                        c.__inOverrideValue = c.__inOverride;
                    }
                }
                if (c.__inDefault) {
                    if (field.convert) {
                        c.__inDefaultValue = field.convert(c.__inDefaultValue, {});
                        if (!Ext.isDefined(c.__inDefaultValue)) {
                            c.__inDefault = false;
                        }
                    }
                }
            }
            if (c.__inOverride) {
                if (field.convert) {
                    c.__inOverrideValue = field.convert(c.__inOverrideValue, r.json);
                    if (!Ext.isDefined(c.__inOverrideValue)) {
                        c.__inOverride = undefined;
                    }
                }
            }
        }
    }, canSaveValue: function (c) {
        return !c.allowBlank || (c.__field && c.__field.initialFieldConfig && Ext.isDefined(c.__field.initialFieldConfig.defaultValue)) || Pan.appframework.plugin.DefaultFieldPlugin.superclass.canSaveValue.apply(this, arguments);
    }, hasOverrideValue: function (c) {
        return c.__inOverride;
    }, hasBaseValue: function () {
        return true;
    }, getBaseValue: function (c) {
        return c.__inDefaultValue;
    }, protect: Ext.emptyFn, unprotect: Ext.emptyFn
});
Ext.preg('defaultfieldplugin', Pan.appframework.plugin.DefaultFieldPlugin);
Ext.ns('Pan.appframework.plugin');
Pan.appframework.plugin.PanGridFilters = Ext.extend(Ext.util.Observable, {
    ptype: 'pan-gridfilters', hideSearchInfo: false, constructor: function (config) {
        config = config || {};
        Ext.apply(this, config);
    }, init: function (parent) {
        this.parent = parent;
        parent.addEvents("addfilter", "setfilter");
        parent.on({scope: this, destroy: this.onDestroy, addfilter: this.onAddFilter, setfilter: this.onSetFilter});
        if (this.parent.store && this.parent.store.enableUseFilter) {
            this.parent.store.enableUseFilter();
        }
        this.width = 500;
        if (parent.filterConfig && parent.filterConfig.width)
            this.width = parent.filterConfig.width;
        this.filterField = new Pan.base.form.SearchInfoField(Ext.apply({
            hideSearchInfo: this.hideSearchInfo,
            parent: parent,
            width: this.width,
            stateful: parent.filterStateFul,
            stateId: parent.__pdefaults ? parent.__pdefaults.__treePath + parent.itemId + '-filter' : parent.itemId + '-filter',
            stateEvents: ['change'],
            value: parent.filterValue,
            getState: function () {
                var value = this.getValue();
                if (!Ext.isEmpty(value)) {
                    return {value: value};
                }
            },
            applyState: function (state) {
                if (state && state.value && !parent.filterValue) {
                    this.setValue(state.value);
                }
            },
            listeners: {
                scope: this, specialkey: function (field, e) {
                    if (e.getKey() == e.ENTER) {
                        e.stopEvent();
                        this.filterAction.execute();
                    }
                }
            }
        }, parent.filterConfig && parent.filterConfig.filterFieldConfig));
        parent.setFilterFieldValue = function (value) {
            value = value || "";
            this.filterField.setValue(value);
            this.filterAction.execute();
        }.createDelegate(this);
        this.filterField.on('beforestatesave', function (field) {
            if ((!Ext.state.Manager.get(field.getStateId()) || !Ext.state.Manager.get(field.getStateId()).value) && Ext.isEmpty(field.getValue())) {
                return false;
            }
            return true;
        });
        if (parent.filterConfig) {
            parent.filterConfig.autoWidthOffset = parent.filterConfig.autoWidthOffset || 50;
            parent.on('bodyresize', function (p, w) {
                this.filterField.setWidth(w - parent.filterConfig.autoWidthOffset);
            }, this);
        }
        var filterActionHandler = function () {
            var startValue = this.filterField.startValue;
            var filterStr = this.filterField.getValue() || "";
            this.filterField.startValue = filterStr;
            if (Ext.isString(filterStr)) {
                filterStr = filterStr.trim();
            }
            else {
                filterStr = filterStr.join(' or ');
            }
            this.filterField.fireEvent('change', this.filterField, filterStr, startValue);
            this.filterHandler.call(this.parent, filterStr);
        }.createDelegate(this);
        if (parent.filterConfig && parent.filterConfig.localFilter) {
            if (!Ext.isEmpty(this.filterField.getValue())) {
                if (this.parent.store) {
                    this.parent.store.addListener('load', filterActionHandler, this, {single: true});
                }
                else if (this.parent.loader) {
                    this.parent.loader.addListener('load', filterActionHandler, this, {single: true});
                }
            }
        }
        else {
            this.parent.customInitialStoreLoader = filterActionHandler;
        }
        this.parent.__filterActionHandler = filterActionHandler;
        this.parent.__filterField = this.filterField;
        this.parent.addListener('clearfilter', function () {
            this.filterField.setValue("");
        }, this);
        if (parent.filterConfig && Ext.isFunction(parent.filterConfig.filterHandler)) {
            this.filterHandler = parent.filterConfig.filterHandler;
        }
        else {
            this.filterHandler = function (filterStr) {
                function contains(key, val) {
                    return "(contains(translate(" + key + ", 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'),'" + val.toLowerCase() + "' ))";
                }

                var filter = '';
                if (!Ext.isEmpty(filterStr)) {
                    filter = contains('@name', filterStr);
                    Ext.each(parent.filterConfig.contains, function (key) {
                        filter += ' or ' + contains(key, filterStr);
                    });
                }
                var store = parent.store;
                if (store && store.useFilters && store.filters && Ext.isArray(store.filters.keys)) {
                    var substring = [];
                    for (var i = 0, len = store.filters.keys.length; i < len; i++) {
                        var key = store.filters.keys[i];
                        var storeFilter = store.filters.get(key);
                        var values = storeFilter.values;
                        var opt = storeFilter.opt || '=';
                        if (Ext.isArray(values)) {
                            if (values.length == 1) {
                                if (Ext.isArray(values[0]) && values[0].length == 2) {
                                    substring.push(['(', values[0][0], ' ', opt[values[0][0]], ' \'', values[0][1], '\')'].join(''));
                                }
                                else {
                                    substring.push(['(', key, ' ', opt, ' \'', values[0], '\')'].join(''));
                                }
                            }
                            else if (values.length > 1) {
                                var containsList = [];
                                for (var j = 0; j < values.length; j++) {
                                    if (Ext.isArray(values[j]) && values[j].length == 2) {
                                        containsList.push(['(', values[j][0], ' ', opt[values[j][0]], ' \'', values[j][1], '\')'].join(''));
                                    }
                                    else {
                                        containsList.push(['(', key, ' ', opt, ' \'', values[j], '\')'].join(''));
                                    }
                                }
                                substring.push('(' + containsList.join(' or ') + ')');
                            }
                        }
                    }
                    if (Ext.isEmpty(filterStr)) {
                        filterStr = substring.join(' and ');
                    }
                    else {
                        filterStr = filterStr.trim();
                        if (substring.length > 0) {
                            if (Pan.base.util.needWrapParenthesis(filterStr)) {
                                filterStr = '(' + filterStr + ')';
                            }
                            filterStr = filterStr + ' and ' + substring.join(' and ');
                        }
                    }
                }
                this.store.reload.defer(1, this.store, [{params: {filter: filter, substring: filterStr}}]);
            };
        }
        this.filterAction = new Pan.base.action.Action({
            tooltip: _T("Apply Filter"),
            iconCls: 'icon-run',
            scope: this,
            handler: filterActionHandler
        });
        var tbar = {
            items: [this.filterField, {xtype: 'tbspacer'}, this.filterAction, {
                tooltip: _T("Clear Filter"),
                xtype: 'tbbutton',
                iconCls: 'icon-clear',
                scope: this,
                handler: function () {
                    if (Ext.isFunction(this.parent.clearFilter)) {
                        this.parent.clearFilter();
                    }
                    var startValue = this.filterField.startValue;
                    this.filterField.setValue('');
                    this.filterAction.execute();
                    this.filterField.startValue = '';
                    this.filterField.fireEvent('change', this.filterField, '', startValue);
                }
            }]
        };
        if (parent.filterConfig && parent.filterConfig.enableFilterBuilder == true) {
            tbar.items.push({
                xtype: 'tbbutton', iconCls: 'icon-add', tooltip: _T('Add Filter'), scope: this, handler: function () {
                    if (!this.addFilterWin) {
                        this.addFilterWin = new Pan.appframework.component.FilterBuilder({owner: parent});
                    }
                    if (this.addFilterWin && this.addFilterWin.hidden)
                        this.addFilterWin.show();
                }
            });
        }
        if (parent.filterConfig && parent.filterConfig.enableFilterBuilder && Ext.isArray(parent.filterConfig.filterBuilderActions)) {
            tbar.items = tbar.items.concat(parent.filterConfig.filterBuilderActions);
        }
        if (parent.filterConfig && parent.filterConfig.showHelpInFilter === true) {
            tbar.items.push([{xtype: 'tbfill'}, {
                text: _T(''),
                iconCls: 'icon-help-blue',
                scope: this,
                handler: function () {
                    Pan.appframework.help.PanHelpSystem.showHelp(parent.filterConfig.helpTopic);
                }
            }]);
        }
        if (parent.topToolbar) {
            parent.topToolbar.add({xtype: 'tbseparator', width: 20});
            parent.topToolbar.add(tbar.items);
        }
        else {
            parent.elements += ',tbar';
            parent.topToolbar = parent.createToolbar(tbar);
        }
        Ext.apply(parent, this.parentOverrides);
    }, onDestroy: function () {
    }, parentOverrides: {
        notifyFilterAdded: function (filter, operator) {
            operator = operator || 'and';
            this.fireEvent('addfilter', filter, operator);
        }, notifyFilterSet: function (filter) {
            this.fireEvent('setfilter', filter);
        }
    }, onAddFilter: function (filter, operator) {
        var filters = this.filterField.getValue();
        if (Ext.isEmpty(filters))
            filters = filter; else {
            filters = String.format('{0} {1} {2}', filters, operator, filter);
        }
        this.filterField.setValue(filters);
        this.filterField.focus();
    }, onSetFilter: function (filter) {
        this.filterField.setValue(filter);
        this.filterField.focus();
    }
});
Ext.preg('pan-gridfilters', Pan.appframework.plugin.PanGridFilters);
Pan.appframework.component.FilterBuilder = Ext.extend(Pan.base.container.Window, {
    getConnectorConfig: function () {
        return {
            xtype: 'panel',
            layout: 'border',
            title: _T('Connector'),
            items: [{
                xtype: 'multiselect',
                width: undefined,
                height: undefined,
                ignoreValidationResult: true,
                allowBlank: true,
                maxSelections: 1,
                region: 'center',
                name: 'connector',
                value: 'and',
                store: [['and', _T('and')], ['or', _T('or')]]
            }, {region: 'south', xtype: 'checkbox', name: 'negate', hidden: true, boxLabel: _T('Negate')}]
        };
    }, getAttributeConfig: function (grid) {
        var columns = grid.getColumnModel();
        var columnIds = [];
        for (var i = 0; i < columns.getColumnCount(); i++) {
            var col = columns.getColumnAt(i);
            if (col.dataIndex && col.dataIndex.indexOf('$.') == 0) {
                columnIds.push([col.dataIndex.substring(2), col.header]);
            }
        }
        return {
            xtype: 'panel',
            layout: 'fit',
            title: _T('Attribute'),
            items: [{
                xtype: 'multiselect',
                width: undefined,
                height: undefined,
                style: 'overflow: auto;',
                ignoreValidationResult: true,
                allowBlank: false,
                maxSelections: 1,
                name: 'attribute',
                store: columnIds,
                listeners: {scope: this, 'change': this.onColumnChange}
            }]
        };
    }, getOperationConfig: function () {
        return {
            title: _T('Operator'),
            items: [{
                xtype: 'multiselect',
                width: undefined,
                height: undefined,
                ignoreValidationResult: true,
                allowBlank: false,
                maxSelections: 1,
                name: 'operator',
                store: [],
                listeners: {scope: this, 'change': this.onColumnChange}
            }]
        };
    }, getOperator: function (fieldName, type) {
        switch (type) {
            case'bool':
                return [['eq', '='], ['neq', '≠']];
            case'date':
                return [['eq', '='], ['neq', '≠'], ['leq', 'less than'], ['geq', 'more than']];
            default:
                return [['eq', '='], ['neq', '≠'], ['in', 'in'], ['notin', 'not in'], ['leq', 'less than'], ['geq', 'more than']];
        }
    }, onColumnChange: function (sel, val) {
        var panel = sel.ownerCt.ownerCt;
        var type, fields, field, fieldName, attribute = panel.findByItemId('attribute'),
            valueBox = panel.findByItemId('valueBox'), operator = panel.findByItemId('operator');
        if (attribute) {
            fieldName = attribute.getValue();
            fields = panel.owner.store.fields;
            field = fields.get('$.' + fieldName);
            if (field) {
                type = field.type.type;
            }
        }
        valueBox.removeAll(true);
        var editor = {xtype: 'textfield', allowBlank: false}, optOptions = this.getOperator(fieldName, type);
        switch (type) {
            case'string':
                editor = {xtype: 'pan-textfield', allowBlank: false};
                break;
            case'int':
                editor = {xtype: 'pan-numberfield', allowBlank: false};
                break;
            case'bool':
                editor = {xtype: 'pan-checkbox', allowBlank: false};
                break;
            case'date':
                editor = {xtype: 'pan-datetime', allowBlank: false};
                break;
        }
        if (sel.name == 'attribute') {
            operator.store.removeAll();
            var Record = operator.store.recordType;
            for (var i = 0; i < optOptions.length; i++) {
                operator.store.add(new Record({'text': optOptions[i][1], 'value': optOptions[i][0]}, optOptions[i][0]));
            }
        }
        else if (sel.name == 'operator') {
            if (val == 'in' || val == 'not in') {
                valueBox.add({
                    xtype: 'editorgrid',
                    name: 'value',
                    hideHeaders: true,
                    viewConfig: {markDirty: false},
                    clicksToEdit: 1,
                    store: new Ext.data.ArrayStore({autoDestroy: true, data: [], fields: [{name: 'id'}]}),
                    columns: [{dataIndex: 'id', forceFit: true, width: 140, editor: editor}],
                    bbar: [{
                        text: 'Add', iconCls: 'icon-add', handler: function () {
                            var grid = this.findParentByType('editorgrid');
                            var Record = grid.getStore().recordType;
                            var p = new Record({id: ''});
                            grid.stopEditing();
                            grid.getStore().insert(0, p);
                            grid.startEditing(0, 0);
                        }
                    }]
                });
                valueBox.layout = new Ext.Container.LAYOUTS['fit']();
                valueBox.setLayout(valueBox.layout);
            }
            else {
                editor = Ext.apply(editor, {name: 'value', width: '100%'});
                valueBox.add(editor);
                valueBox.layout = new Ext.Container.LAYOUTS['auto']();
                valueBox.setLayout(valueBox.layout);
            }
            valueBox.doLayout();
        }
    }, getValueConfig: function () {
        return {title: _T('Value'), name: 'valueBox', items: []};
    }, constructor: function (config) {
        var owner = config.owner;
        if (owner.filterConfig && owner.filterConfig.filterBuilderConfig) {
            Ext.apply(this, owner.filterConfig.filterBuilderConfig);
        }
        var cfg = {flex: 1};
        var v = Ext.apply(this.getValueConfig(), cfg);
        var o = Ext.apply(this.getOperationConfig(), cfg);
        var a = Ext.apply(this.getAttributeConfig(config.owner), cfg);
        var c = Ext.apply(this.getConnectorConfig(), cfg);
        var form = Ext.apply({
            xtype: 'pan-container',
            layout: 'hbox',
            layoutConfig: {align: 'stretch'},
            items: [c, a, o, v]
        }, config);
        Ext.apply(config, {
            title: _T("Add Filter"),
            maximizable: true,
            resizable: true,
            width: 605,
            height: 350,
            border: false,
            plain: true,
            layout: 'fit',
            items: form,
            buttons: [{
                text: _T('Add'), scope: this, handler: function () {
                    Pan.base.util.invokeLater(100, this.constructFilter.createDelegate(this));
                }
            }, {
                text: _T('Close'), scope: this, handler: function () {
                    this.hide();
                }
            }]
        });
        Pan.appframework.component.FilterBuilder.superclass.constructor.call(this, config);
    }, constructFilter: function () {
        var connector = ' ' + this.findByItemId('connector').getValue() + ' ';
        var filter = [];
        var attribute = this.findByItemId('attribute').getValue();
        var operator = this.findByItemId('operator').getValue('value');
        var valueBoxField = this.findByItemId('value');
        var value;
        filter.push('(');
        filter.push(attribute);
        filter.push(' ' + operator + ' ');
        if (operator == 'in' || operator == 'notin') {
            var store = valueBoxField.getStore();
            value = [];
            var i, id;
            for (i = 0; i < store.getCount(); i++) {
                id = Ext.util.Format.trim(store.getAt(i).data.id);
                if (!Ext.isEmpty(id)) {
                    value.push(id);
                }
            }
            filter.push('\'' + value.join(',') + '\'');
        }
        else {
            value = valueBoxField.getValue() || '';
            if (valueBoxField.xtype == 'pan-checkbox') {
                value = value == true ? 'yes' : 'no';
            }
            filter.push('\'' + Ext.util.Format.trim(value) + '\'');
        }
        filter.push(')');
        var filterField = this.owner.__filterField;
        var q = filterField.getValue();
        var oldLen = 0;
        var v = filter.join('');
        if (q) {
            if (!/^\(.*\)$/.test(q)) {
                q = '(' + q + ')';
            }
            oldLen = q.length;
            v = q + connector + v;
        }
        filterField.setValue(v);
        filterField.selectText(oldLen, v.length);
        filterField.focus();
    }
});
Ext.ns('Pan.appframework.plugin');
Pan.appframework.plugin.TagPlugin = Ext.extend(Ext.util.Observable, {
    typeMap: {
        '$.source.member': 'address',
        '$.destination.member': 'address',
        '$.source.member.*': 'address',
        '$.destination.member.*': 'address',
        '$.service.member': 'service',
        '$.service': 'service',
        '$.service.member.*': 'service',
        '$.service.*': 'service',
        '$.from.member': 'zone',
        '$.to.member': 'zone',
        '$.from.zone.member': 'zone',
        '$.to.zone.member': 'zone',
        '$.from.member.*': 'zone',
        '$.to.member.*': 'zone',
        '$.from.zone.member.*': 'zone',
        '$.to.zone.member.*': 'zone',
        '$.application.member': 'application',
        '$.application': 'application',
        '$.application.member.*': 'application',
        '$.application.*': 'application'
    },
    typePriority: {
        'address': ['region,vsys', 'region,panorama', 'region,shared', 'address-group,vsys', 'address-group,panorama', 'address-group,shared', 'address,vsys', 'address,panorama', 'address,shared'],
        'address-shared': ['region,shared', 'address-group,shared', 'address,shared'],
        'service': ['service-group,vsys', 'service-group,panorama', 'service-group,shared', 'service,vsys', 'service,panorama', 'service,shared'],
        'service-shared': ['service-group,shared', 'service,shared'],
        'zone': ['zone,vsys', 'zone,panorama', 'zone,shared'],
        'zone-shared': ['zone,shared'],
        'application': ['application-filter,vsys', 'application-filter,panorama', 'application-filter,shared', 'application-group,vsys', 'application-group,panorama', 'application-group,shared', 'application-container,vsys', 'application-container,panorama', 'application-container,shared', 'application,vsys', 'application,panorama', 'application,shared'],
        'application-shared': ['application-filter,shared', 'application-group,shared', 'application-container,shared', 'application,shared']
    },
    tagMap: {},
    vsysTagsMap: {},
    init: function (c) {
        if (!c.tagColumnMapConfig) {
            var log = PanLogging.getLogger('appframework:plugin:TagPlugin');
            log.info("TagPlugin::Unable to get 'tagColumnMapConfig' from the plugged component.");
            return;
        }
        this.owner = c;
        this.owner.getColorCode = this.getColorCode.createDelegate(this);
        var i, len = c.colModel.config.length, dataIndex, c_dataIndex, type, colModel = c.colModel;
        for (i = 0; i < len; i++) {
            if (!colModel.isHidden(i)) {
                c_dataIndex = colModel.config[i].dataIndex;
                var tagColumnDataIndexObj = this.owner.tagColumnMapConfig[c_dataIndex];
                if (tagColumnDataIndexObj) {
                    dataIndex = tagColumnDataIndexObj['dataIndex'];
                    type = this.typeMap[dataIndex];
                    if (Ext.isDefined(type)) {
                        Ext.apply(colModel.config[i], {tagable: true, type: type});
                    }
                    else {
                        Ext.apply(colModel.config[i], {tagable: true});
                    }
                }
            }
        }
        Pan.appframework.plugin.TagPlugin.URLDirects.getAllTags.call(this);
        this.populateTagNameMapping();
    },
    populateTagNameMapping: function () {
        var log = PanLogging.getLogger('appframework:plugin:TagPlugin');
        if (!Pan.global.getAllTags()) {
            log.info("TagPlugin::Unable to get 'allTags'.");
            return;
        }
        delete this.tagMap;
        this.tagMap = {};
        var i, j, dataIndex, c_dataIndex, types = [], columnConfig = this.owner.columnConfig;
        for (i in columnConfig) {
            if (columnConfig.hasOwnProperty(i)) {
                c_dataIndex = columnConfig[i].dataIndex;
                if (c_dataIndex && Ext.isDefined(this.owner.tagColumnMapConfig[c_dataIndex])) {
                    dataIndex = this.owner.tagColumnMapConfig[c_dataIndex]['dataIndex'];
                    if (Ext.isDefined(this.typeMap[dataIndex])) {
                        var exist = false;
                        for (j = 0; j < types.length; j++) {
                            if (types[j] == this.typeMap[dataIndex]) {
                                exist = true;
                                break;
                            }
                        }
                        if (!exist) {
                            types.push(this.typeMap[dataIndex]);
                        }
                    }
                }
            }
        }
        for (i = 0; i < types.length; i++) {
            this.getTagsByType(types[i]);
        }
    },
    getColorCode: function (record, value, dataIndex, type) {
        var cls;
        value = Ext.util.Format.htmlDecode(value);
        if (!type && this.owner.columnConfig) {
            var tags = record.get(this.owner.columnConfig.tag.dataIndex);
            var mapping = Pan.global.getAllTags();
            if (!mapping) return '';
            tags = [].concat(tags);
            if (tags.length > 0) {
                var key = tags[0];
                if (dataIndex == '$.tag.member') {
                    key = value;
                }
                var index = record.id.lastIndexOf('---');
                if (index <= 0) {
                    return '';
                }
                var isSharedRecord = record.id.substring(index + 3) == 'shared';
                if (isSharedRecord) {
                    cls = mapping[key + ',shared'];
                    if (Ext.isEmpty(cls)) {
                        cls = mapping[key + ',predefined'];
                    }
                }
                else {
                    cls = mapping[key + ',vsys'];
                    if (Ext.isEmpty(cls)) {
                        cls = mapping[key + ',shared'];
                        if (Ext.isEmpty(cls)) {
                            cls = mapping[key + ',panorama'];
                            if (Ext.isEmpty(cls)) {
                                cls = mapping[key + ',predefined'];
                            }
                        }
                    }
                }
            }
            return cls;
        }
        else {
            var map, priority, i;
            if (value && (type == 'zone' || type == 'custom')) {
                map = Pan.global.getAllTags();
                priority = [',vsys', ',shared', ',panorama'];
                if (map) {
                    for (i = 0; i < priority.length; i++) {
                        if (map[value + priority[i]]) {
                            return map[value + priority[i]];
                        }
                    }
                }
                return '';
            }
            else if (value && this.tagMap[value]) {
                map = this.tagMap[value];
                priority = this.typePriority[type];
                if (map) {
                    for (i = 0; i < priority.length; i++) {
                        if (Ext.isObject(map[priority[i]])) {
                            return map[priority[i]]['tag-colorcode'];
                        }
                    }
                }
            }
            return '';
        }
    },
    getTagsByType: function (type) {
        var requestParams = {
            'vsysName': Pan.global.getLoc().val,
            'isMultiVsys': Pan.global.isMultiVsys(),
            'isCmsSelected': Pan.global.isCmsSelected(),
            'type': type,
            'rulebase': this.owner.storeInputs.type
        };
        Pan.appframework.plugin.TagPlugin.URLDirects.getAllTagsByNames.call(this, requestParams, this.tagMap);
    }
});
Pan.appframework.plugin.TagPlugin.URLDirects = (function () {
    var isRequesting = false;
    var clazz = Ext.extend(Object, {
        getAllTags: function (callback) {
            if (Pan.base.admin.getPermission('objects/tags') === false || isRequesting == true) return;
            var allTags = Pan.global.getAllTags();
            if (Pan.global.isTagChanged() === true || !allTags || (this.vsysTagsMap && !this.vsysTagsMap[Pan.global.getLocVal()])) {
                isRequesting = true;
                var currentVsys = Pan.global.getLocVal();
                PanDirect.execute('Tag.get', {
                    vsysName: currentVsys,
                    isMultiVsys: Pan.global.isMultiVsys(),
                    isCmsSelected: Pan.global.isCmsSelected()
                }, function (response) {
                    var log = PanLogging.getLogger('appframework:plugin:TagPlugin');
                    isRequesting = false;
                    Pan.global.resetTagChanged();
                    if (response && response['@status'] == 'success') {
                        allTags = {};
                        if (Ext.isArray(response['result']['entry'])) {
                            for (var i = 0; i < response['result']['entry'].length; i++) {
                                var r = response['result']['entry'][i];
                                var key = r['@name'] + ',' + Ext.decode(r['@__recordInfo'])['xpathId'];
                                allTags[key] = r['color'];
                            }
                        }
                        Pan.global.CONTEXT.allTags = allTags;
                        if (this.vsysTagsMap) {
                            this.vsysTagsMap[currentVsys] = allTags;
                        }
                        if (Ext.isFunction(callback)) {
                            callback.call(this, allTags);
                        }
                    }
                    else {
                        log.error('error', response);
                    }
                }, this);
            }
            else {
                if (Ext.isFunction(callback)) {
                    callback.call(this, allTags);
                }
            }
        }, getAllTagsByNames: function (requestObj, tagMap) {
            if (requestObj.type !== 'zone') {
                PanDirect.execute('Tag.getTagNameMapping', requestObj, function (response) {
                    var tag, rtag, recordInfoObj, key, recordInfo, xpathId, tagName, colorcode,
                        allTags = Pan.global.getAllTags();
                    for (tag in response.tag) {
                        if (response.tag.hasOwnProperty(tag)) {
                            if (!tagMap[tag]) {
                                tagMap[tag] = {};
                            }
                            rtag = response.tag[tag];
                            for (recordInfo in rtag) {
                                if (rtag.hasOwnProperty(recordInfo)) {
                                    recordInfoObj = Ext.decode(recordInfo);
                                    xpathId = recordInfoObj['xpathId'];
                                    key = recordInfoObj['type'] + ',' + xpathId;
                                    tagName = rtag[recordInfo];
                                    colorcode = allTags[tagName + ',' + xpathId];
                                    if (!colorcode) {
                                        if (xpathId == 'vsys') {
                                            colorcode = allTags[tagName + ',shared'];
                                            if (!colorcode) {
                                                colorcode = allTags[tagName + ',panorama'];
                                            }
                                        }
                                        else if (xpathId == 'shared') {
                                            if (!colorcode) {
                                                colorcode = allTags[tagName + ',panorama'];
                                            }
                                        }
                                    }
                                    tagMap[tag][key] = {'tag-colorcode': colorcode, 'tag-name': tagName};
                                }
                            }
                        }
                    }
                });
            }
        }, onContextLocationChanged: function (oldLoc, newLoc) {
            var log = PanLogging.getLogger('appframework:plugin:TagPlugin');
            log.info(' context location changed ... from ', oldLoc, 'to', newLoc);
            if (Pan.global.isTagChanged()) {
                this.getAllTags();
            }
        }, constructor: function () {
            Pan.global.ContextVariables.addListener('contextlocationchanged', this.onContextLocationChanged, this);
        }
    });
    return new clazz();
}());
Ext.preg('pan-gridtag', Pan.appframework.plugin.TagPlugin);
Ext.ns('Pan.appframework.plugin');
Ext.ns('Pan.base.tree');
Pan.appframework.plugin.PanTreeFilters = Ext.extend(Ext.util.Observable, {
    ptype: 'pan-treefilters', constructor: function (config) {
        this.viewConfig = {region: 'west', layout: 'fit'};
        this.storeConfig = {};
        Ext.apply(this.viewConfig, config.viewConfig);
        Ext.apply(this.storeConfig, config.storeConfig);
        Pan.appframework.plugin.PanTreeFilters.superclass.constructor.call(this, config);
    }, init: function (owner) {
        this.owner = owner;
        this.store = this.owner.store;
        if (this.storeConfig && this.storeConfig.store) {
            this.store = this.storeConfig.store;
        }
        if (this.viewConfig && this.viewConfig.filterStoreField) {
            var filterCmp = this.owner.findByItemId(this.viewConfig.filterStoreField);
            if (filterCmp) {
                this.store = filterCmp.store;
            }
        }
        this.filterTree = new Pan.base.tree.FilterTreePanel(this.viewConfig);
        if (this.store) {
            this.store.loaded = false;
            this.filterTree.bindStore(this.store);
        }
        this.owner.add(this.filterTree);
    }
});
Ext.preg('pan-treefilters', Pan.appframework.plugin.PanTreeFilters);
Pan.base.tree.FilterTreePanel = Ext.extend(Pan.base.tree.CheckTreePanel, {
    hasTreeFilter: false,
    hasSelectionNode: false,
    lines: !Pan.base.Constants.treeRendererUseArrows,
    useArrows: Pan.base.Constants.treeRendererUseArrows,
    autoScroll: true,
    animate: true,
    containerScroll: true,
    rootVisible: false,
    singleSelect: false,
    split: true,
    collapsible: false,
    cls: 'tree-filter',
    width: 190,
    idSeparator: '/',
    stateful: false,
    operatorsMapping: {},
    filtersMapping: {
        'device-group': 'device-group',
        'series': 'series',
        'template': 'template',
        'tags': 'tags',
        'haMode': 'haMode'
    },
    tbar: {
        style: 'height: 22px;',
        items: [{xtype: 'tbtext', text: _T('Filters')}, {xtype: 'tbfill'}, {
            xtype: 'button',
            text: _T('Clear'),
            hidden: true,
            iconCls: 'icon-clear',
            handler: function (t) {
                var tree = t.ownerCt.ownerCt;
                tree.clearFilters();
            }
        }]
    },
    clearFilters: function () {
        delete this.filterNames;
        delete this.updatingCategory;
        delete this.__selections;
        var root = this.getRootNode();
        root.cascade(function () {
            this.attributes.checked = false;
        });
        this.store.deleteStoreFilter(this.getAllGroups());
        this.checkChange(this.root, false, true);
    },
    constructor: function (config) {
        this.treeNodes = {
            'series': {text: _T('Platforms')},
            'device-group': {text: _T('Device Groups')},
            'template': {text: _T('Templates')},
            'tags': {text: _T('Tags'), maxNodes: 500},
            'haMode': {text: _T('HA Status')}
        };
        Ext.apply(config, {root: new Ext.tree.TreeNode({id: 'filter-root'})});
        Ext.applyIf(config, config.treeNodes);
        Pan.base.tree.TreePanel.superclass.constructor.apply(this, [config]);
    },
    checkChange: function (node, checked) {
        Pan.base.tree.FilterTreePanel.superclass.checkChange.call(this, node, checked, true);
    },
    onTreeNodeCheckChangeById: function (id, node, checked) {
        var v;
        if (node.id.indexOf(id) >= 0) {
            v = node.id.substring(id.length + 1);
        }
        else {
            v = node.id;
        }
        if (node.attributes['checkValue'] && node.attributes['checkKey']) {
            v = [node.attributes['checkKey'], node.attributes['checkValue']];
        }
        var len, i;
        if (checked) {
            if (!this.filterNames[id]) {
                this.filterNames[id] = [];
            }
            len = this.filterNames[id].length;
            var exist = false;
            for (i = 0; i < len; i++) {
                if (this.filterNames[id][i] == v) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                this.filterNames[id].push(v);
            }
        }
        else {
            if (Ext.isArray(this.filterNames[id])) {
                len = this.filterNames[id].length;
                for (i = len - 1; i >= 0; i--) {
                    if (Ext.encode(this.filterNames[id][i]) == Ext.encode(v)) {
                        this.filterNames[id].splice(i, 1);
                        break;
                    }
                }
            }
        }
        return id;
    },
    onTreeNodeCheckChange: function (node, checked) {
        var category = node.isLeaf() ? node.parentNode.id : node.id;
        if (this.fireEvent('beforecheckchange', this, category) === false) {
            return;
        }
        this.updatingCategory = category;
        if (!this.filterNames) {
            this.filterNames = {};
        }
        var values, name, func, i;
        if (node.isLeaf()) {
            category = this.onTreeNodeCheckChangeById(category, node, checked);
            values = this.filterNames[category];
            name = this.filtersMapping[category] ? this.filtersMapping[category] : category;
            if (Ext.isArray(values) && values.length > 0) {
                func = this.createFilterFn.createDelegate(this, [values, name], true);
                this.store.fireEvent('updatefilter', category, values, func, this.operatorsMapping[category]);
            }
            else {
                this.store.fireEvent('deletefilter', category);
            }
        }
        else {
            var filterFuncs = [], filterIds = [];
            for (i = 0; i < node.childNodes.length; i++) {
                category = this.onTreeNodeCheckChangeById(category, node.childNodes[i], checked);
                filterIds.push(category);
                if (checked) {
                    values = this.filterNames[category];
                    name = this.filtersMapping[category] ? this.filtersMapping[category] : category;
                    if (Ext.isArray(values) && values.length > 0) {
                        func = this.createFilterFn.createDelegate(this, [values, name], true);
                        filterFuncs.push({
                            id: category,
                            values: values,
                            fn: func,
                            opt: this.operatorsMapping[category] || '='
                        });
                    }
                }
            }
            if (checked) {
                this.store.addStoreFilter(filterFuncs);
            }
            else {
                this.store.deleteStoreFilter(filterIds);
            }
        }
    },
    initComponent: function () {
        this.addEvents('beforecheckchange');
        Pan.base.tree.FilterTreePanel.superclass.initComponent.apply(this, arguments);
        delete this.filterNames;
        this.on('checkchange', this.onTreeNodeCheckChange, this);
    },
    bindStore: function (store, doNotUpdateFilterOnLoad) {
        this.store = store;
        if (this.store.enableUseFilter) {
            this.store.enableUseFilter();
        }
        this.store.on('onfilter', this.onFilter, this);
        this.store.addListener('load', this.constructTree.createDelegate(this), this);
        if (!doNotUpdateFilterOnLoad) {
            this.store.addListener('load', this.onUpdate.createDelegate(this), this);
        }
        this.store.on('datachanged', function (store) {
            delete this.updatingCategory;
            if (store.loaded && Ext.isArray(store.data.items)) {
                this.updateTree(store);
            }
        }, this);
        this.store.on('update', function (store) {
            if (store.loaded && Ext.isArray(store.data.items)) {
                this.updateTree(store);
            }
        }, this);
    },
    getChecked: function (a, startNode) {
        startNode = startNode || this.root;
        var r = [];
        var f = function () {
            if (this.attributes.checked && !this.getUI().partial) {
                if (this.isLeaf()) {
                    if (this.attributes.checkValue && this.attributes.checkKey) {
                        r.push({id: this.attributes.checkKey, v: this.attributes.checkValue});
                    }
                    else {
                        r.push(!a ? this : (a == 'id' ? {
                            v: this.id.indexOf(this.parentNode.id) >= 0 ? this.id.substring(this.parentNode.id.length + 1) : this.id,
                            id: this.parentNode.id
                        } : this.attributes[a]));
                    }
                }
                else {
                    if (this.hasChildNodes()) {
                        for (var i = 0; i < this.childNodes.length; i++) {
                            var node = this.childNodes[i];
                            if (node.attributes.checkValue && node.attributes.checkKey) {
                                r.push({id: node.attributes.checkKey, v: node.attributes.checkValue});
                            }
                            else {
                                r.push(!a ? node : (a == 'id' ? {
                                    v: node.id.indexOf(node.parentNode.id) >= 0 ? node.id.substring(node.parentNode.id.length + 1) : node.id,
                                    id: node.parentNode.id
                                } : node.attributes[a]));
                            }
                        }
                    }
                }
            }
        };
        startNode.cascade(f);
        return r;
    },
    getAllGroups: function () {
        var children = this.root.childNodes;
        var groups = [];
        for (var i = 0; i < children.length; i++) {
            groups.push(children[i].attributes.id);
        }
        return groups;
    },
    setupBBar: function () {
    },
    onUpdate: function () {
        this.store.addStoreFilter(this.getTreeFilters());
    },
    onFilter: function (store, filter, keys) {
        var visible = false;
        if (Ext.isArray(keys)) {
            for (var i = 0; i < keys.length; i++) {
                var node = this.getNodeById(keys[i]);
                if (node) {
                    visible = true;
                    break;
                }
            }
        }
        var clear = this.getTopToolbar().items.get(2);
        if (clear) {
            clear.setVisible(visible);
        }
    },
    createFilterFn: function (record, filterValues, fieldName) {
        if (fieldName == 'selection') {
            if (filterValues.length == 1) {
                if (Ext.isFunction(this.store.isSelected)) {
                    var isSelected = this.store.isSelected(record);
                    return filterValues[0] == 'selected' ? isSelected : !isSelected;
                }
            }
            else {
                return true;
            }
        }
        var type;
        if (record.fields.get(fieldName)) {
            type = record.fields.get(fieldName).type.type;
        }
        var i, j, fv, dv;
        for (i = 0; i < filterValues.length; i++) {
            fv = filterValues[i];
            if (Ext.isArray(fv)) {
                dv = record.data[fv[0]];
                if (Ext.isArray(fv[1]) && fv[1].length == 1) {
                    if (dv == fv[1][0]) {
                        return true;
                    }
                }
                else {
                    if (dv == fv[1]) {
                        return true;
                    }
                }
            }
            else {
                dv = record.data[fieldName];
                if (type == 'array') {
                    dv = [].concat(dv);
                    for (j = 0; j < dv.length; j++) {
                        if (fv == dv[j]) {
                            return true;
                        }
                    }
                }
                else {
                    if (fv == dv) {
                        return true;
                    }
                }
            }
        }
        return false;
    },
    getTreeFilters: function (vs, stringFormat) {
        if (!Ext.isArray(vs)) {
            vs = this.getChecked('id');
        }
        var filterNames = {}, filters = [], i;
        for (i = 0; i < vs.length; i++) {
            var mapping = this.filtersMapping[vs[i]['id']];
            if (!mapping) {
                mapping = vs[i]['id'];
            }
            if (!filterNames[mapping]) {
                filterNames[mapping] = [];
            }
            filterNames[mapping].push(vs[i]['v']);
        }
        for (var fieldName in filterNames) {
            if (filterNames.hasOwnProperty(fieldName)) {
                if (Ext.isDefined(fieldName)) {
                    var names = filterNames[fieldName], fieldType, values = [];
                    if (this.store && this.store.fields.get(fieldName)) {
                        fieldType = this.store.fields.get(fieldName).type.type;
                    }
                    if (fieldType == 'array') {
                        for (var fi = 0; fi < names.length; fi++) {
                            values = values.concat(names[fi]);
                        }
                    }
                    else {
                        values = names;
                    }
                    if (values.length > 0) {
                        if (stringFormat == true) {
                            var ored = [];
                            var opt = this.operatorsMapping && this.operatorsMapping[fieldName] ? this.operatorsMapping[fieldName] : '=';
                            for (var j = 0; j < values.length; j++) {
                                ored.push('(' + fieldName + ' ' + opt + ' \'' + values[j] + '\')');
                            }
                            filters.push(ored.length == 1 ? ored[0] : '(' + ored.join(' or ') + ')');
                        }
                        else {
                            filters.push({
                                values: values,
                                opt: this.operatorsMapping && this.operatorsMapping[fieldName] ? this.operatorsMapping[fieldName] : '=',
                                fn: this.createFilterFn.createDelegate(this, [values, this.filtersMapping[fieldName] ? this.filtersMapping[fieldName] : fieldName], true),
                                id: fieldName
                            });
                        }
                    }
                }
            }
        }
        return filters;
    },
    addAsyncTreeNode: function (id) {
        var text = this.treeNodes[id]['text'];
        return new Ext.tree.AsyncTreeNode({
            text: text, id: id, checked: false, expanded: true, loader: new Pan.base.tree.TreeLoader({
                directFn: this.treeNodes[id]['url'], processResponse: function (response, node, callback, scope) {
                    var json = response.responseText;
                    var mapping = node.ownerTree.filtersMapping;
                    var fieldName = mapping[node.id] ? mapping[node.id] : node.id;
                    var store = node.ownerTree.store;
                    try {
                        var o = json.result.entry, deviceName, e, count, id, record;
                        node.beginUpdate();
                        for (var i = 0, len = o.length; i < len; i++) {
                            id = o[i]['@name'];
                            count = 0;
                            if (o[i].devices && o[i].devices.entry) {
                                e = o[i].devices.entry;
                                for (var j = 0; j < e.length; j++) {
                                    deviceName = e[j]['@name'];
                                    record = store.getById(deviceName);
                                    if (record) {
                                        var t = record.get(fieldName);
                                        if (Ext.isArray(t)) {
                                            record.set(fieldName, t.concat(id));
                                        }
                                        else {
                                            record.set(fieldName, [id]);
                                        }
                                        count++;
                                    }
                                }
                            }
                            if (count > 0) {
                                var n = this.createNode({leaf: true, text: id, checked: false, id: id});
                                if (n) {
                                    node.appendChild(n);
                                }
                            }
                        }
                        node.endUpdate();
                        this.runCallback(callback, scope || node, [node]);
                    }
                    catch (evt) {
                        this.handleFailure(response);
                    }
                }
            })
        });
    },
    getTreeNodeDataMap: function (fieldName) {
        var map = {};
        if (!this.store) return map;
        var data = this.store.getSnapshot();
        data.each(function (device) {
            if (Ext.isNumber(device.__treeLevel) && device.__treeChildrenCount) {
            }
            else {
                var sname = [].concat(device.get(fieldName));
                var fm = this.filterNames;
                for (var i = 0; i < sname.length; i++) {
                    if (Ext.isEmpty(sname[i])) {
                        continue;
                    }
                    if (map[sname[i]] == undefined) {
                        map[sname[i]] = 0;
                    }
                    var globalMatch = true;
                    for (var f in fm) {
                        if (f && fm.hasOwnProperty(f)) {
                            var f_name = this.filtersMapping[f] ? this.filtersMapping[f] : f;
                            if (f_name == fieldName) {
                            }
                            else {
                                var r = [].concat(device.get(f_name));
                                var oneFieldMatch = false;
                                if (Ext.isArray(fm[f])) {
                                    if (fm[f].length == 0) {
                                        oneFieldMatch = true;
                                    }
                                    else {
                                        for (var j = 0; j < fm[f].length; j++) {
                                            if (oneFieldMatch) {
                                                break;
                                            }
                                            var v = fm[f][j];
                                            for (var k = 0; k < r.length; k++) {
                                                if (v == r[k]) {
                                                    oneFieldMatch = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                else {
                                    oneFieldMatch = true;
                                }
                                globalMatch = globalMatch && oneFieldMatch;
                                if (!globalMatch) {
                                    break;
                                }
                            }
                        }
                    }
                    if (globalMatch) {
                        map[sname[i]] = map[sname[i]] + 1;
                    }
                }
            }
        }, this);
        return map;
    },
    addTreeNode: function (id) {
        var maxNodes = 500;
        if (Ext.isNumber(this.treeNodes[id].maxNodes)) {
            maxNodes = this.treeNodes[id].maxNodes;
        }
        var text = this.treeNodes[id]['text'];
        var node = new Ext.tree.TreeNode({text: text, expanded: true, checked: false, id: id});
        var i, children = this.treeNodes[id]['childNodes'];
        if (Ext.isArray(children)) {
            for (i = 0; i < children.length; i++) {
                var child;
                if (children[i]['checkValue'] && children[i]['checkKey']) {
                    child = {
                        nodeName: children['id'],
                        text: children[i]['text'],
                        checked: false,
                        id: children[i]['checkKey'],
                        checkValue: children[i]['checkValue'],
                        checkKey: children[i]['checkKey'],
                        leaf: true
                    };
                }
                else {
                    child = {
                        nodeName: children['id'],
                        text: children[i]['text'],
                        checked: false,
                        id: id + this.idSeparator + children[i]['id'],
                        leaf: true
                    };
                }
                node.appendChild(child);
            }
        }
        var fieldName = this.filtersMapping[id] ? this.filtersMapping[id] : id;
        var map = this.getTreeNodeDataMap(fieldName);
        var keys = Pan.base.objectKeys(map, true);
        var count = 0;
        for (i = 0; i < keys.length; i++) {
            var name = keys[i];
            if (name && map[name] > 0) {
                text = name + ' (' + map[name] + ')';
                node.appendChild({
                    nodeName: name,
                    text: text,
                    checked: false,
                    id: id + this.idSeparator + name,
                    leaf: true
                });
                count++;
            }
            if (count >= maxNodes) {
                this.addMoreChild(node, id);
                count++;
                break;
            }
        }
        return node;
    },
    addMoreChild: function (parentNode, id) {
        parentNode.appendChild({
            nodeName: '',
            ignoreUpdating: true,
            text: _T('More than 500 tags'),
            id: id + this.idSeparator + 'more',
            leaf: true
        });
        return parentNode;
    },
    updateTree: function () {
        var children = this.getRootNode().childNodes;
        for (var i = 0; i < children.length; i++) {
            var id = children[i]['id'];
            var map = this.getTreeNodeDataMap(this.filtersMapping[id] ? this.filtersMapping[id] : id);
            var nodes = children[i].childNodes;
            nodes = [].concat(nodes);
            if (nodes.length == 0 && Pan.base.objectKeys(map).length > 0) {
                this.store.loaded = false;
                this.constructTree();
            }
            else {
                var k, j;
                var count, nodeText, nodeId;
                var nodeMap = {};
                for (j = 0; j < nodes.length; j++) {
                    nodeId = nodes[j].id.indexOf(id) >= 0 ? nodes[j].id.substring(id.length + 1) : nodes[j].id;
                    nodeMap[nodeId] = true;
                }
                for (k in map) {
                    if (map.hasOwnProperty(k) && map[k]) {
                        var nodeName = k;
                        if (!nodeMap[nodeName]) {
                            children[i].appendChild({
                                nodeName: nodeName,
                                text: nodeName + ' (' + map[nodeName] + ')',
                                checked: false,
                                id: id + this.idSeparator + nodeName,
                                leaf: true
                            });
                        }
                    }
                }
                if (id != this.updatingCategory) {
                    for (j = 0; j < nodes.length; j++) {
                        if (nodes[j].ignoreUpdating !== true) {
                            nodeId = nodes[j].id.indexOf(id) >= 0 ? nodes[j].id.substring(id.length + 1) : nodes[j].id;
                            count = map[nodeId] ? map[nodeId] : 0;
                            if (count == 0 && !(nodes[j].ui.isChecked())) {
                                nodes[j].ui.hide();
                            }
                            else {
                                nodes[j].ui.show();
                                nodeText = nodes[j].attributes['nodeName'] + ' (' + count + ')';
                                nodes[j].setText(nodeText);
                            }
                        }
                    }
                }
            }
        }
    },
    getAdditionalTreeNodes: function () {
        return null;
    },
    constructTree: function () {
        var store = this.store;
        if (store && store.loaded === true) {
            return;
        }
        this.__selections = this.getChecked();
        var root = this.getRootNode();
        if (root.childNodes) {
            root.removeAll();
        }
        var nodes = [];
        if (Ext.isFunction(this.addCustomFilters)) {
            var customNodes = [].concat(this.addCustomFilters());
            for (var i = 0; i < customNodes.length; i++) {
                var id = customNodes[i]['id'];
                var map = this.getTreeNodeDataMap(id);
                var children = customNodes[i].childNodes;
                children = [].concat(children);
                for (var j = 0; j < children.length; j++) {
                    var count = map[children[j].id] ? map[children[j].id] : 0;
                    if (count == 0) {
                        children[j]['hidden'] = true;
                    }
                    children[j].attributes['nodeName'] = children[j].attributes['text'];
                    children[j].setText(children[j].attributes['nodeName'] + ' (' + count + ')');
                }
            }
            nodes.push(customNodes);
        }
        if (!Ext.isEmpty(this.getAdditionalTreeNodes())) {
            Ext.applyIf(this.treeNodes, this.getAdditionalTreeNodes());
        }
        for (var k in this.treeNodes) {
            if (this.treeNodes.hasOwnProperty(k)) {
                var url = this.treeNodes[k]['url'];
                if (url) {
                    nodes.push(this.addAsyncTreeNode(k));
                }
                else {
                    nodes.push(this.addTreeNode(k));
                }
            }
        }
        root.appendChild(nodes);
        if (this.__selections && this.__selections.length > 0) {
            var g = this.__selections;
            var f = function () {
                for (var i = 0; i < g.length; i++) {
                    if (this.attributes.id == g[i].attributes.id) {
                        this.getUI().toggleCheck(true);
                    }
                }
            };
            root.cascade(f);
        }
        if (store) {
            store.loaded = true;
        }
    }
});
Ext.reg("Pan.base.tree.FilterTreePanel", Pan.base.tree.FilterTreePanel);
(function (exports) {
    var nConstants = {
        InterestedTypes: ["Completion Update", "Config Change", "Commit Pending", "Job Status", "System", "Device Status", "Config Lock", "Commit Lock", "Other"],
        Events: {
            Completion_Update: "Completion Update",
            Config_Change: "Config Change",
            Commit_Pending: "Commit Pending",
            Job_Status: "Job Status",
            System: "System",
            Device_Status: "Device Status",
            Config_Lock: "Config Lock",
            Commit_Lock: "Commit Lock",
            Other: "Other",
            Refresh: "refresh",
            SocketIOError: 'socketIOError'
        }
    };
    var nEvent = {data: 'dataNotify', sToken: 'sToken'};
    if (Object.freeze)
        Object.freeze(nEvent);
    if (Object.freeze)
        Object.freeze(nConstants);
    exports.nConstants = nConstants;
    exports.nEvent = nEvent;
})(typeof exports === 'undefined' ? this.PanNotificationHandler = {} : exports);
Ext.ns('Pan.appframework');
if (window.io) {
    window.io.util.parseUri = function (str) {
        var re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?(\[[^\/?#]*\]|[^\[][^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
        var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
        var m = re.exec(str || ''), uri = {}, i = 14;
        while (i--) {
            uri[parts[i]] = m[i] || '';
        }
        return uri;
    };
}
(function () {
    var isSecure = function () {
        return window.location.protocol == 'https:';
    };
    var ClientConfig = {
        limits: 20,
        host: window.location.hostname,
        isSecure: isSecure(),
        protocol: isSecure() ? 'https' : 'http'
    };
    var internalMap = {"Version": "0.0.1", "LastNotificationReceived": 0};
    var sToken = '';
    var f = Ext.extend(Ext.util.Observable, {
        paused: false, socket: null, disabled: false, constructor: function () {
            this.addEvents.apply(this, PanNotificationHandler.nConstants.InterestedTypes);
            this.addEvents('SocketError');
            this.refreshTask = new Ext.util.DelayedTask(function () {
                Pan.global.ContextVariables.doRetrieveConfigChangePending();
                Pan.appframework.PanAppInterface.refresh(null, true);
            });
            this.refreshLockTask = new Ext.util.DelayedTask(function () {
                Pan.global.ContextVariables.doRetrieveConfigChangePending();
            });
        }, reconnect: function (opts) {
            if (opts) {
                ClientConfig.limits = opts.limits || ClientConfig.limits;
                ClientConfig.host = opts.host || ClientConfig.host;
            }
            this.connect();
        }, isAvailable: function () {
            return Pan.global.isCmsSelected() && (typeof window['io'] !== undefined) && (window['io'] !== null) && !this.disabled;
        }, connect: function () {
            this.close();
            var self = this;
            if (!this.isAvailable())
                return;
            this.socket = window.io.connect(ClientConfig.protocol + '://' + ClientConfig.host + '/ui', {
                "resource": 'nodejs/socket.io',
                "secure": ClientConfig.isSecure
            });
            this.socket.on('connect', function () {
                var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                log.info('connect to server');
                self.disabled = false;
            });
            this.socket.on(PanNotificationHandler.nEvent.sToken, function (data) {
                if (data && data.sToken) {
                    sToken = data.sToken;
                }
            });
            this.addListener(PanNotificationHandler.nConstants.Events.Refresh, function () {
                if (this.refreshTask) {
                    this.refreshTask.delay(500);
                }
            }, this);
            this.socket.on(PanNotificationHandler.nEvent.data, function (data) {
                if (self.paused || !self.isAvailable() || Ext.isEmpty(sToken))
                    return;
                var processData = {};
                if (internalMap.LastNotificationReceived > 0 && internalMap.LastNotificationReceived < (data.tid - 1)) {
                    internalMap.LastNotificationReceived = 0;
                }
                for (var i = 0; i < data.updates.length; i++) {
                    var nt = data.updates[i];
                    if (!processData.hasOwnProperty(nt.type)) {
                        processData[nt.type] = [];
                    }
                    if (Ext.isEmpty(nt.cookie) || nt.cookie != sToken) {
                        processData[nt.type].push(nt);
                    }
                }
                for (var o in processData) {
                    self.fireEvent(o, processData[o]);
                }
                internalMap.LastNotificationReceived = data.tid;
            });
            this.socket.on('disconnect', function () {
                var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                log.info('web socket is disconnted~');
            });
            this.socket.on('error', function (reason) {
                var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                if (/502 (Bad Gateway)/.test(reason)) {
                    log.info('Unable to connect Socket.IO.', reason);
                    self.disabled = true;
                    if (!self.paused || !self.isAvailable())
                        self.fireEvent(PanNotificationHandler.nConstants.Events.SocketIOError, reason);
                    setTimeout(function () {
                        var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                        log.info('reconnect socket.io');
                        self.socket.socket.connect();
                    }, 10 * 1000);
                }
            });
            this.socket.on('reconnecting', function () {
                var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                log.info('web socket is reconnecting~');
            });
            this.socket.on('reconnect', function () {
                var log = PanLogging.getLogger('appframework:notification:PanNotificationHandler');
                log.info('web socket is reconnected~');
                self.disabled = false;
                if (!self.paused || !self.isAvailable())
                    return;
                internalMap.LastNotificationReceived = 0;
            });
            this.paused = false;
        }, pause: function () {
            this.paused = true;
        }, start: function () {
            this.connect();
        }, close: function () {
            if (this.socket) {
                this.socket.removeAllListeners();
                this.socket.disconnect();
                this.socket = null;
            }
            this.removeListener(PanNotificationHandler.nConstants.Events.Refresh, this);
        }
    });
    var instance = new f();
    Pan.appframework.PanNotificationHandler = function () {
        return instance;
    };
    Pan.appframework.PanNotificationHandler.getInstance = function () {
        return instance;
    };
})();
umd(function (define) {
    define(function (require) {
        var repository = require('pan/appframework/schema/PanSchemaRepository');
        var scanner = {
            treePathRbaMap: {},
            tagRbaPathMap: {},
            inFindMode: false,
            inTemplateMode: false,
            statistics: {
                treeNodeTotal: 0,
                treeNodeRegistered: 0,
                treeNodeNotRegistered: 0,
                treeNodeViewLoad: 0,
                treeNodeProcessedFailed: 0,
                viewRegistered: 0,
                viewCreated: 0
            },
            log: function () {
            },
            panRegHandler: function () {
                this.statistics.viewRegistered++;
            },
            panCreateHandler: function () {
                this.statistics.viewCreated++;
            },
            addToMap: function (tag, rbaPath) {
                var val = this.tagRbaPathMap[tag];
                if (!val) {
                    val = [];
                    this.tagRbaPathMap[tag] = val;
                }
                val.push(rbaPath);
            },
            readSchemaWrapper: function (readSchemaFn) {
                var me = this;
                return function (type, callback, scope, callbackConfig) {
                    var newArgs = arguments;
                    if (me.inFindMode && Pan.global.isCmsSelected()) {
                        if (me.inTemplateMode) {
                            newArgs = [type, callback, scope, callbackConfig, true];
                        }
                    }
                    return readSchemaFn.apply(this, newArgs);
                };
            },
            scanComp: function (comp, treeNode) {
                if (comp.title) {
                    this.addToMap(comp.title, treeNode.id);
                }
                if (comp.fields) {
                    comp.fields.each(function (item) {
                        var label;
                        if (item.fieldLabel) {
                            label = item.fieldLabel;
                        }
                        else if (item.boxLabel) {
                            label = item.boxLabel;
                        }
                        else if (item.uiHint) {
                            var uiHint = item.uiHint;
                            if (uiHint.fieldLabel) {
                                label = uiHint.fieldLabel;
                            }
                            else if (uiHint.boxLabel) {
                                label = uiHint.boxLabel;
                            }
                        }
                        if (Ext.isString(label)) {
                            if (label.startsWith('$')) {
                                this.log('Not stored ' + item.attrPath + ' ' + label);
                            }
                            else {
                                this.addToMap(label, treeNode.id);
                                this.log(' attrPath ' + item.attrPath + ' label ' + label);
                            }
                        }
                        else if (Ext.isFunction(label)) {
                            label = label();
                            this.addToMap(label, treeNode.id);
                            this.log(' attrPath ' + item.attrPath + ' label ' + label);
                        }
                        else if (label) {
                            console.log('Not stored cuz label is an object ' + item.attrPath);
                        }
                    }, this);
                }
                var headers = comp.headers;
                if (headers && headers.rows) {
                    var rows = headers.rows[0];
                    for (var index = 0; index < rows.length; index++) {
                        var row = rows[index];
                        if (row.header) {
                            this.addToMap(row.header, treeNode.id);
                            this.log(' header ' + row.header);
                        }
                    }
                }
                if (comp.items) {
                    comp.items.each(function (item) {
                        this.scanComp(item, treeNode);
                    }, this);
                }
            },
            dump: function () {
                return Ext.apply({
                    tagsCount: Object.keys(Pan.locale.mapping.lookup).length,
                    collectedTagsCount: Object.keys(this.tagRbaPathMap).length
                }, this.statistics);
            },
            lookupByTag: function (tagPattern) {
                var regex = new RegExp(tagPattern, "i");
                var result = {};
                for (var key in this.tagRbaPathMap) {
                    if (regex.test(key)) {
                        var val = this.tagRbaPathMap[key];
                        result[key] = val;
                    }
                }
                return result;
            }
        };
        repository.readSchema = scanner.readSchemaWrapper(repository.readSchema);
        return scanner;
    });
}, "Pan.appframework.search.Scanner", require, exports, module);
umd(function (define) {
    define({
        type: 'dynamic-string', uiHint: {
            builder: 'PanCompletionBuilder',
            editable: true,
            mode: 'local',
            useHelpStringAsDisplay: true,
            renderer: function (value, meta, record, row, column, store, grid) {
                if (store && store.fields) {
                    var field = (grid.colModel.getRealFieldName) ? store.fields.get(grid.colModel.getRealFieldName(record, grid, column)) : store.fields.get(this.dataIndex);
                    if (field && field.uiHint && field.uiHint['enum']) {
                        for (var i = 0; i < field.uiHint['enum'].length; i++) {
                            if (field.uiHint['enum'][i][0] === value) {
                                return Pan.i18n(field.uiHint['enum'][i][1]);
                            }
                        }
                    }
                }
                return (typeof value === 'undefined' ? Pan.base.Constants.nonestr : value);
            }
        }
    });
}, 'Pan.appframework.schema.dynamicStringType', require, exports, module);
umd(function (define) {
    define({
        type: 'dynamic-multi-string', fieldHint: {
            type: {
                convert: function (value) {
                    return (typeof value === 'undefined' ? Pan.base.Constants.nonestr : value.split(','));
                }, rconvert: function (value) {
                    return value.join(',');
                }
            }
        }, uiHint: {uiType: 'pan-textarea', multivalue: true}
    });
}, 'Pan.appframework.schema.dynamicMultiStringType', require, exports, module);
umd(function (define) {
    define(function (require) {
        var Ext = require('Ext');
        var JSON = require('JSON');
        var when = require('when');
        var callbacks = require('when/callbacks');
        var jsonPath = require('jsonPath');
        var $ = require('jQuery');
        var objectMapper = require('pan/base/objectMapper');
        var Exception = require('pan/common/Exception');
        var Pan = require('Pan');
        var locale = require('pan/locale');
        var optionUtility = require('pan/base/optionUtility');
        var PanType = require('pan/appframework/schema/PanType');
        var PanSchema = require('pan/appframework/schema/PanSchema');
        var dynamicStringType = require('pan/appframework/schema/dynamicStringType');
        var dynamicMultiStringType = require('pan/appframework/schema/dynamicMultiStringType');
        var dynamicType = {
            type: 'dynamic',
            fieldHint: {saveLast: true, isNonleaf: true, supportsFindInLeafField: true}
        };
        var DynamicSchema = function (options) {
            optionUtility.inject(this, {Pan: Pan}, options);
            this.transformSchemaDelegate = this.transformSchema.createDelegate(this);
        };
        DynamicSchema.createDataConvertMap = function (dynamicSchema) {
            return {
                map: function (value) {
                    var result = {};
                    for (var i = 0, len = ((value && value.config && value.config.entry && value.config.entry.length) || 0); i < len; i++) {
                        var entry = value.config.entry[i];
                        var name = entry['@name'];
                        if (entry.value.member.length > 1) {
                            result[name] = entry.value.member;
                        }
                        else {
                            var schemaNode = dynamicSchema.config[name];
                            if (schemaNode) {
                                var type = schemaNode['@attr']['type'];
                                result[name] = type === 'array' ? entry.value.member : entry.value.member[0];
                            }
                            else {
                                result[name] = entry.value.member[0];
                            }
                        }
                    }
                    return result;
                }, mode: 'exclusive'
            };
        };
        DynamicSchema.dataRConvertMap = {
            map: function (value) {
                var result = {config: {entry: []}};
                for (var propertyName in value) {
                    if (!value.hasOwnProperty(propertyName)) continue;
                    var propertyValue = value[propertyName];
                    if (propertyValue === '') {
                        continue;
                    }
                    var entry = {'@name': propertyName, 'value': {member: propertyValue}};
                    result.config.entry.push(entry);
                }
                return result;
            }
        };
        DynamicSchema.mappingConfig = {
            map: {
                'allowBlank': {value: true},
                'type': {
                    map: function (value, source, target) {
                        var valueEntries = jsonPath(source, '$.value.entry');
                        if (valueEntries) {
                            if (value !== 'bool' && (!Ext.isDefined(source['loose-membership']) || source['loose-membership'])) {
                                objectMapper.setValue(target, 'fieldHint.looseMembership', true);
                            }
                            value = 'enum';
                            objectMapper.setValue(target, 'uiHint.useHelpStringAsDisplay', true);
                        }
                        var multiValue = source['multi-value'] === 'true';
                        if (value === 'string' && multiValue) {
                            value = 'array';
                            objectMapper.setValue(target, 'uiHint.xtype', 'pan-textarea');
                            objectMapper.setValue(target, 'uiHint.multivalue', true);
                        }
                        return value;
                    }
                },
                'label': {path: 'uiHint.fieldLabel'},
                'regex': {path: 'regex'},
                'default': {
                    map: function (value, source) {
                        if (source.type === 'rangedint') {
                            value = parseInt(value, 10);
                        }
                        return value;
                    }
                },
                'optional': {map: objectMapper.predefined.map.boolToYesNo},
                'validation-label': {
                    map: function (value, source, target) {
                        target.uiHint = target.uiHint || {};
                        target.uiHint.invalidText = value;
                        if (source['regex']) {
                            target.uiHint.regexText = value;
                        }
                    }
                },
                'value': {
                    path: 'enum', map: function (value) {
                        var valueEntries = jsonPath(value, '$.entry');
                        var enumArray = [];
                        if (valueEntries) {
                            valueEntries = valueEntries[0];
                            for (var j = 0, len2 = valueEntries.length; j < len2; j++) {
                                var valueEntry = valueEntries[j];
                                var enumEntry = {value: valueEntry['@name'], 'help-string': valueEntry.label};
                                if (valueEntry['prune-on']) {
                                    enumEntry['prune-on'] = valueEntry['prune-on'];
                                }
                                enumArray.push(enumEntry);
                            }
                        }
                        return enumArray;
                    }
                },
                'min': {map: parseInt},
                'max': {map: parseInt},
                'max-count': {map: parseInt},
                'multi-value': {exclude: true},
                'gen-gp-agent-config-under-xpath': {exclude: true},
                '@name': {exclude: true}
            }, defaultExclude: objectMapper.predefined.exclude.isEmpty
        };
        DynamicSchema.scrubRawDynamicSchema = function (raw) {
            var result = $.extend(true, {}, raw);
            for (var name in result) {
                if (!result.hasOwnProperty(name)) continue;
                var dynamicSchemaEntry = result[name];
                if (!dynamicSchemaEntry.config) throw new Error('DynamicSchema: "' + name + '" missing required property: config');
                dynamicSchemaEntry.config = DynamicSchema.scrubRawDynamicSchemaConfig(dynamicSchemaEntry.config);
                PanSchema._preProcessPruneOn(dynamicSchemaEntry);
                for (var localeCode in dynamicSchemaEntry.locale) {
                    if (!dynamicSchemaEntry.locale.hasOwnProperty(localeCode)) continue;
                    try {
                        dynamicSchemaEntry.locale[localeCode] = JSON.parse(dynamicSchemaEntry.locale[localeCode]);
                    }
                    catch (e) {
                        throw new Exception("Unable to process locale '" + localeCode + "' in dynamic schema '" + name + "'", e);
                    }
                }
            }
            return result;
        };
        DynamicSchema.scrubRawDynamicSchemaConfig = function (config) {
            var schemaConfig = {};
            if (config.entry) {
                for (var i = 0, len = config.entry.length; i < len; i++) {
                    var entry = config.entry[i];
                    schemaConfig[entry['@name']] = {'@attr': objectMapper.map(entry, DynamicSchema.mappingConfig)};
                }
            }
            else {
                $.extend(schemaConfig, config);
            }
            return schemaConfig;
        };
        DynamicSchema.initialize = function (options) {
            DynamicSchema.instance = new DynamicSchema(options);
            return DynamicSchema.instance.enable();
        };
        DynamicSchema.convertData = function (dynamicSchemaName, data) {
            if (DynamicSchema.instance.active) {
                var dynamicSchema = DynamicSchema.instance._dynamicSchema[dynamicSchemaName];
                if (dynamicSchema) {
                    return objectMapper.map(data, DynamicSchema.createDataConvertMap(dynamicSchema));
                }
            }
            return data;
        };
        DynamicSchema.rconvertData = function (dynamicSchemaName, data) {
            if (DynamicSchema.instance.active) {
                var dynamicSchema = DynamicSchema.instance._dynamicSchema[dynamicSchemaName];
                if (dynamicSchema) {
                    return objectMapper.map(data, DynamicSchema.dataRConvertMap);
                }
            }
            return data;
        };
        DynamicSchema.prototype.getDynamicSchema = function () {
            return callbacks.call(this.Pan.direct.run, 'DynamicSchemaService.get', []).then(function (response) {
                var result = jsonPath(response, '$[0].result');
                if (!result) {
                    throw new Error('Invalid server response');
                }
                var dynamicSchemaNodes = jsonPath(result, '$[0].dynamic-schema');
                if (dynamicSchemaNodes) {
                    return DynamicSchema.scrubRawDynamicSchema(dynamicSchemaNodes[0]);
                }
            });
        };
        DynamicSchema.prototype.enable = function () {
            var self = this;
            return this.enable.promise = (this._dynamicSchema ? when(this) : this.getDynamicSchema().then(function (dynamicSchema) {
                self._dynamicSchema = dynamicSchema;
                if (PanSchema.schemaProcessors.indexOf(self.transformSchemaDelegate) < 0) {
                    PanSchema.schemaProcessors.push(self.transformSchemaDelegate);
                }
                PanType.register(dynamicType);
                PanType.register(dynamicStringType);
                PanType.register(dynamicMultiStringType);
                return self;
            })).ensure(function () {
                self.enabled = true;
                self.active = self._dynamicSchema !== undefined;
            });
        };
        DynamicSchema.prototype.transformSchema = function (schema) {
            var self = this;
            return PanSchema.transverse(schema, function (attrs, node, attrName, parentNode) {
                if (!self.active) {
                    return true;
                }
                if (attrs['dynamic-schema']) {
                    attrs.type = 'dynamic';
                    var dynamicSchema = self._dynamicSchema[attrName];
                    if (dynamicSchema) {
                        var newNode = dynamicSchema.config;
                        $.extend(locale.mapping.lookup, dynamicSchema.locale[locale.mapping.locale]);
                        newNode['@attr'] = attrs;
                        newNode['@attr'].originalSchema = node;
                        parentNode[attrName] = newNode;
                    }
                    return true;
                }
            });
        };
        return DynamicSchema;
    });
}, 'Pan.appframework.schema.DynamicSchema', require, exports, module);
Ext.namespace('Pan.test');
Ext.Component.prototype.afterRender = Ext.Component.prototype.afterRender.createInterceptor(function () {
    var el = this.getEl();
    var config = this.initialConfig;
    var itemIdVal = config["itemId"];
    if (itemIdVal != undefined) {
        el.dom.setAttribute("itemId", itemIdVal);
    }
});
Pan.test.QaAutomation = (function () {
    return {
        all: [], registerXPathFunction: function (cls) {
            var log = PanLogging.getLogger('test:QaAutomation');
            if (!Ext.isFunction(cls.prototype.getXPath)) {
                log.warn(cls.xtype + " registration failed since 'getXPath' is not a function.");
                return;
            }
            this.all.push(cls);
        }
    };
}());
Pan.test.QaAutomation.processRegisteredTypes = function (possibleNode) {
    var indx = 0;
    for (indx = 0; indx < this.all.length; indx++) {
        var cls = this.all[indx];
        var result = cls.prototype.getXPath(possibleNode);
        if (result != null) {
            return result;
        }
    }
    return null;
};
Pan.test.QaAutomation.getXPath = function (domId) {
    if (!Ext.isGecko) {
        var log = PanLogging.getLogger('test:QaAutomation');
        log.warn('This utility only works on Firefox.');
        return null;
    }
    var domObjPath = '';
    var isExtGen = (domId.indexOf('ext-gen') == 0);
    var isExtComp = !isExtGen && (domId.indexOf('ext-comp') == 0);
    var isExtRec = !isExtGen && !isExtComp && (domId.indexOf('ext-record') == 0);
    var isXpath = !isExtComp && (domId.indexOf('//') == 0);
    if (!isExtGen && !isExtComp && !isXpath && !isExtRec) {
        return domId;
    }
    if (isExtGen || isExtComp || isExtRec) {
        domObjPath = '//*[@id=\'' + domId + '\']';
    }
    else {
        domObjPath = domId;
    }
    var possibleNodes = document.evaluate(domObjPath, document, null, XPathResult.ANY_TYPE, null);
    var possibleNode = possibleNodes.iterateNext();
    if (possibleNode) {
        var pathValue = this.processRegisteredTypes(possibleNode);
        if (pathValue) {
            return pathValue;
        }
        pathValue = possibleNode.getAttribute("itemId");
        if (pathValue) {
            return '//*[@' + 'itemId' + '=\'' + pathValue + '\']';
        }
        return this.getXPathUpToTopLevel(possibleNode);
    }
    return domId;
};
Pan.test.QaAutomation.getXPathUpToTopLevel = function (possibleNode, getRootPath) {
    if (getRootPath == undefined) {
        getRootPath = this.getRootByPathDefined;
    }
    var parentNode = possibleNode;
    var result = '';
    while (parentNode) {
        var rootPath = getRootPath(parentNode);
        if (rootPath != null) {
            result = rootPath + result;
            break;
        }
        var parentNodeName = parentNode.nodeName.toLowerCase();
        var grandParentNode = parentNode.parentNode;
        var index = 0;
        var realIndex = 1;
        if (grandParentNode) {
            if (parentNodeName == "html" && grandParentNode.nodeName.toLowerCase() == "#document") {
                result = '//' + result;
                break;
            }
            for (index = 0; index < grandParentNode.childNodes.length; index++) {
                var tmpNode = grandParentNode.childNodes[index];
                if (tmpNode == parentNode) {
                    break;
                }
                else if (tmpNode.nodeName.toLowerCase() == parentNodeName) {
                    realIndex++;
                }
            }
        }
        if (parentNode.tagName == "DIV" && parentNode.firstChild.tagName == "TABLE") {
            result = '/' + result;
        }
        else {
            if (realIndex == 1) {
                if (parentNodeName == 'em' && parentNode.firstChild.nodeType == 3) {
                    result = parentNodeName + '[text()="' + parentNode.textContent + '"]';
                }
                else {
                    result = parentNodeName + '/' + result;
                }
            }
            else {
                result = parentNodeName + '[' + realIndex + ']' + '/' + result;
            }
        }
        parentNode = parentNode.parentNode;
    }
    if (result.charAt(result.length - 1) == '/') {
        result = result.substr(0, result.length - 1);
    }
    return result;
};
Pan.test.QaAutomation.getRootByPathDefined = function (parentNode) {
    if (parentNode.getAttribute) {
        var pathValue = parentNode.getAttribute('itemId');
        if (pathValue == null)
            return null;
        return '//*[@' + 'itemId' + '=\'' + pathValue + '\']/';
    }
    return null;
};
Pan.test.QaAutomation.getRootByDateTimeDefined = function (parentNode) {
    var indexValue = parentNode.className.indexOf('x-form-element');
    if (indexValue == -1)
        return null;
    var pathValue = parentNode.firstChild.getAttribute('itemId');
    return '//*[@' + 'itemId' + '=\'' + pathValue + '\']/../';
};
Pan.xreg = Pan.test.QaAutomation.registerXPathFunction;
Ext.namespace('Pan.test.QaAutoUtils');
if (window.location.search.match(/AUTOMATION/)) {
    document.cookie = 'AUTOMATION=true; path=/';
}
if (Pan.base.cookie.get('AUTOMATION')) {
    if (Pan.appframework && Pan.appframework.PanNotificationHandler) {
        Pan.appframework.PanNotificationHandler.getInstance().__proto__.paused = true;
        Pan.appframework.PanNotificationHandler.getInstance().__proto__.disabled = true;
    }
}
Pan.test.QaAutoUtils.textStr = ",pantxt=";
Pan.test.QaAutoUtils.findElements = function (locatorString) {
    var textIndx = locatorString.indexOf(Pan.test.QaAutoUtils.textStr);
    var text = '';
    if (textIndx > 0) {
        text = locatorString.substring(textIndx + Pan.test.QaAutoUtils.textStr.length);
        locatorString = locatorString.substring(0, textIndx);
    }
    var els = Ext.query(locatorString);
    var results = [];
    if (els && els.length > 0) {
        for (var indx = 0; indx < els.length; indx++) {
            if (text == '') {
                results.push(els[indx]);
            }
            else if (els[indx].innerHTML == text) {
                results.push(els[indx]);
            }
            else if (els[indx].value == text) {
                results.push(els[indx]);
            }
        }
    }
    return results;
};
Pan.test.QaAutoUtils.findElement = function (locatorString) {
    var result = Pan.test.QaAutoUtils.findElements(locatorString);
    if (result && result.length > 0) {
        return result[0];
    }
    return null;
};
if (!Object.create) {
    var createEmpty;
    var supportsProto = !({__proto__: null} instanceof Object);
    if (supportsProto || typeof document === 'undefined') {
        createEmpty = function () {
            return {"__proto__": null};
        };
    } else {
        createEmpty = function () {
            var iframe = document.createElement('iframe');
            var parent = document.body || document.documentElement;
            iframe.style.display = 'none';
            parent.appendChild(iframe);
            iframe.src = 'javascript:';
            var empty = iframe.contentWindow.Object.prototype;
            parent.removeChild(iframe);
            iframe = null;
            delete empty.constructor;
            delete empty.hasOwnProperty;
            delete empty.propertyIsEnumerable;
            delete empty.isPrototypeOf;
            delete empty.toLocaleString;
            delete empty.toString;
            delete empty.valueOf;
            empty.__proto__ = null;

            function Empty() {
            }

            Empty.prototype = empty;
            createEmpty = function () {
                return new Empty();
            };
            return new Empty();
        };
    }
    Object.create = function create(prototype) {
        var object;

        function Type() {
        }

        if (prototype === null) {
            object = createEmpty();
        } else {
            if (typeof prototype !== "object" && typeof prototype !== "function") {
                throw new TypeError("Object prototype may only be an Object or null");
            }
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
        }
        return object;
    };
}
Ext.ns("Pan.common");
Pan.common.require = function (moduleName) {
    var config = Pan.common.require.config || {};
    var module = config[moduleName];
    if (!module && moduleName) {
        var names = moduleName.split(/[.\/]/);
        var name = names.shift();
        module = window[name];
        while (module && names.length) {
            name = names.shift();
            module = module[name];
        }
        if (names.length) {
            module = undefined;
        }
    }
    return module;
};
Ext.ns("Pan.common.builders");
Pan.common.builders.OptionBuilder = function OptionBuilder(option) {
    this.option = option || {};
};
(function (factory) {
    'use strict';
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        factory();
    } else if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        Ext.ns("Pan.common.builders");
        Pan.common.builders.utils = factory();
    }
}(function () {
    return {
        push: function (option, propertyPath, value) {
            var names = propertyPath.split(/[./\\]/);
            var parent = option;
            var name = names.shift();
            while (names.length) {
                parent = parent[name] = parent[name] || {};
                name = names.shift();
            }
            var property = parent[name];
            if (property) {
                if ($.isArray(property)) {
                    property.push(value);
                }
                else {
                    parent[name] = [property, value];
                }
            }
            else {
                parent[name] = value;
            }
        }, insertBefore: function (destination, option, newOption) {
            var index = destination.indexOf(option);
            if (index) {
                destination.splice(index + 1, newOption);
            }
            else {
                destination.push(newOption);
            }
        }
    };
}));
(function (factory) {
    'use strict';
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        factory(require);
    } else if (typeof define === "function" && define.amd) {
        define(factory);
    } else {
        Ext.ns("Pan.common.builders.mixin");
        Pan.common.builders.mixin.withAvailableMixin = factory(Pan.common.require);
    }
}(function (require) {
    var adminChecks = require("Pan.base.admin");
    var AvailableMixin = {
        showIf: function (predicate, value) {
            var option = (typeof value === "undefined") ? {
                match: {evaluate: predicate},
                availHide: true
            } : {match: {evaluate: '===', operands: [{field: predicate}, value]}, availHide: true};
            this.set("avail", option);
            return this;
        }, hideIf: function (predicate, value) {
            var option = (typeof value === "undefined") ? {
                match: {
                    evaluate: function () {
                        return !predicate();
                    }
                }, availHide: true
            } : {match: {evaluate: '===', operands: [{field: predicate}, !value]}, availHide: true};
            this.set("avail", option);
            return this;
        }, enableIf: function (predicate, value) {
            var option = (typeof value === "undefined") ? {
                match: {evaluate: predicate},
                availHide: false
            } : {match: {evaluate: '===', operands: [{field: predicate}, value]}, availHide: false};
            this.set("avail", option);
            return this;
        }, disableIf: function (predicate, value) {
            var option = (typeof value === "undefined") ? {
                match: {
                    evaluate: function () {
                        return !predicate();
                    }
                }, availHide: false
            } : {match: {evaluate: '===', operands: [{field: predicate}, !value]}, availHide: false};
            this.set("avail", option);
            return this;
        }, hideForVsysAdmin: function () {
            return this.hideIf(adminChecks.isVsysAdmin);
        }
    };
    return function () {
        $.extend(this, AvailableMixin);
    };
}));
(function () {
    Ext.ns("Pan.common.builders");
    Pan.common.builders.FieldOptionBuilder = function FieldOptionBuilder(option) {
        if (typeof option === "string") {
            option = {name: option};
        }
        Pan.common.builders.OptionBuilder.call(this, option);
    };
    Pan.common.builders.FieldOptionBuilder.prototype = Object.create(Pan.common.builders.OptionBuilder.prototype);
    Pan.common.builders.FieldOptionBuilder.prototype.on = function (sourceFieldName, func, event) {
        var association = {
            match: {evaluate: 'fieldEvt', field: sourceFieldName}, exec: {
                evaluate: function () {
                    var value = this.__component.__pdefaults.__dataExtractor(sourceFieldName);
                    func.call(this, value);
                }
            }
        };
        if (event) {
            association.match.event = event;
        }
        Pan.common.builders.utils.push(this.option, "uiHint.association", association);
        return this;
    };
    Pan.common.builders.FieldOptionBuilder.prototype.addAvailBinding = function (sourceFieldName, evaluatorFunction) {
        return this.on(sourceFieldName, function (value) {
            if (evaluatorFunction) {
                value = evaluatorFunction(value);
            }
            this.__component.setIsAvail(value);
        });
    };
    Pan.common.builders.mixin.withAvailableMixin.call(Pan.common.builders.FieldOptionBuilder.prototype);
    Pan.common.builders.FieldOptionBuilder.prototype.set = function (propertyPath, value) {
        switch (propertyPath) {
            case"avail":
                propertyPath = "uiHint.avail";
                break;
            default:
                break;
        }
        Pan.common.builders.utils.push(this.option, propertyPath, value);
    };
}());
Ext.ns('Pan.common');
Pan.common.builders.FieldOptionComposer = function (option, options) {
    this.options = options;
    Pan.common.builders.FieldOptionBuilder.call(this, option);
};
Pan.common.builders.FieldOptionComposer.prototype = Object.create(Pan.common.builders.FieldOptionBuilder.prototype);
Pan.common.builders.FieldOptionComposer.prototype.indent = function (width) {
    var container = {name: this.name + "-CONTAINER", childrenNames: [this.name], uiHint: {labelWidth: width}};
    Pan.common.builders.utils.insertBefore(this.options, this.option, container);
    return this;
};
Ext.ns('Pan.common.builders');
Pan.common.builders.FieldOptionsBuilder = function (options) {
    this.options = options || [];
};
(function (s) {
    s.createPasswordField = function (xpath, labelWidth) {
        labelWidth = labelWidth || 100;
        return {
            name: xpath,
            uiHint: {labelWidth: labelWidth, passwordLabel: _T('Enter Password'), cpFieldLabel: _T('Confirm Password')}
        };
    };
    s.createUserNameField = function (xpath, labelWidth) {
        labelWidth = labelWidth || 100;
        return {
            name: xpath,
            uiHint: {labelWidth: labelWidth, boxLabel: _T('Fixed'), fieldLabel: _T('Enter Username'), hideLabel: false}
        };
    };
    s.createNameField = function (option) {
        return $.extend(true, option, s.defaultNameField);
    };
    s.defaultNameField = {
        name: 'name', mapping: '@name', uiHint: {
            avail: [{
                match: {
                    evaluate: function () {
                        var r = this.__component.getRecord();
                        if (!r.phantom) {
                            var pdefaults = this.__component.__pdefaults;
                            if (pdefaults && Ext.isDefined(pdefaults.__renameable)) {
                                return pdefaults.__renameable;
                            }
                        }
                        var isCustAppDgOverrideRec = false;
                        if (r.store.treePath === "Objects/Custom Application" && Pan.global.isCmsSelected()) {
                            if (!r.data.$['@loc']) {
                                isCustAppDgOverrideRec = true;
                            }
                        }
                        var permission = r.json['@__recordInfo'].permission;
                        return !(Pan.global.isTemplateStackSelected() || r.store.templateRecords && r.store.templateRecords[r.id] || Pan.appframework.renderer.isParentDGRec(r) || (r.data.location !== r.originalRecord.data.location) || isCustAppDgOverrideRec || (permission === "readonly"));
                    }
                }, availHide: false
            }]
        }
    };
    s.defaultLocationField = {
        name: 'location', defaultValue: '', parentFieldPath: '$', dataMap: function (config) {
            if (config["__recordInfo"].xpathId === 'vsys' || config["__recordInfo"].useVsysName) {
                return config.__recordInfo.vsysName;
            } else {
                return config.__recordInfo.xpathId;
            }
        }, saveMap: function (config) {
            switch (config.__v) {
                case'shared':
                case'panorama':
                case'predefined':
                case'cms-private':
                case'mgt-config':
                case'notify-group':
                case'plugin':
                    config.__recordInfo.xpathId = config.__v;
                    break;
                default:
                    config.__recordInfo.xpathId = 'vsys';
                    config.__recordInfo.vsysName = config.__v;
                    break;
            }
        }, sortType: function (s) {
            return Ext.data.SortTypes.asUCString(Pan.common.PanConfigStates.prototype.getLocationRendererValue(s));
        }, uiHint: {
            avail: [{
                match: {
                    evaluate: function () {
                        if (this.__component.initialConfig.hidden) {
                            return false;
                        }
                        var states = new Pan.common.PanConfigStates(this.__component.__pdefaults.__configStates);
                        return states.isShowingLocation();
                    }
                }, availHide: true
            }, {
                match: {
                    evaluate: function () {
                        if (this.__component.initialConfig.disabled) {
                            return false;
                        }
                        return this.__component.getRecord().phantom;
                    }
                }, availHide: false
            }], emptyText: _T('Select one...'), allowBlank: false, mode: 'local', builder: function (comp, config) {
                if (comp.xtype) {
                    return comp;
                }
                var states = new Pan.common.PanConfigStates(comp.__pdefaults.__configStates);
                var values = states.getLocationChoiceListInConfig(comp.locationFilter, comp);
                var defaultValue = comp.value;
                if (!Ext.isDefined(defaultValue)) {
                    defaultValue = states.getLocationChoiceDefault();
                } else if (Ext.isFunction(defaultValue)) {
                    defaultValue = comp.value();
                    comp.value = defaultValue;
                }
                if (values.length > 1 || comp.onlyUseCombo) {
                    Ext.applyIf(comp, {
                        xtype: 'pan-combo',
                        associationEvent: 'select',
                        displayField: 'display',
                        valueField: 'value',
                        store: {
                            ztype: Ext.data.ArrayStore,
                            zconfig: {
                                autoDestroy: true,
                                fields: [{name: "value", uiHint: {isKeyField: true}}, {
                                    name: "display",
                                    uiHint: {isDisplayField: true}
                                }],
                                data: values,
                                load: function () {
                                    this.loadData(states.getLocationChoiceListInConfig(comp.locationFilter, comp));
                                }
                            }
                        },
                        setValue: function (v) {
                            if (!this.noneString || v !== '') {
                                v = v || defaultValue;
                            }
                            Pan.base.form.ComboBox.prototype.setValue.call(this, v);
                        },
                        getValue: function () {
                            var a = Pan.base.form.ComboBox.prototype.getValue.apply(this, arguments);
                            if (this.noneString && !a) {
                                a = '';
                            }
                            return a;
                        },
                        autoSelect: true
                    });
                    if (comp.fieldLabel === config.field.uiHint.fieldLabelAutoGen) {
                        comp.fieldLabel = _T('Location');
                    }
                } else if (values.length === 1) {
                    var value = values[0][0];
                    var display = values[0][1];
                    if (value === 'cms-private') {
                        Ext.apply(comp, {value: true, hidden: true});
                    } else if (value !== 'shared' || (states.states.isSupportingSharedGateway == false && Pan.global.getLoc().type == 'sg') || (Pan.base.admin.isDeviceGroupAdmin() && Pan.global.getSharedAccess() === "shared-only")) {
                        Ext.apply(comp, {value: true, disabled: true});
                    }
                    Ext.applyIf(comp, {
                        xtype: 'pan-checkbox', setValue: function (v) {
                            if (Ext.isString(v)) {
                                if (this.getRecord().phantom) {
                                    v = this.value;
                                } else {
                                    v = v === value;
                                }
                            }
                            Pan.base.form.Checkbox.superclass.setValue.call(this, v);
                        }, getValue: function () {
                            var v = Pan.base.form.Checkbox.superclass.getValue.apply(this, arguments);
                            return v ? value : defaultValue;
                        }
                    });
                    if (comp.fieldLabel === config.field.uiHint.fieldLabelAutoGen) {
                        comp.fieldLabel = display;
                    }
                } else {
                    Ext.applyIf(comp, {
                        xtype: 'hidden', getValue: function () {
                            return defaultValue;
                        }
                    });
                }
                comp.setDefaultLocation = function (defaultLocation) {
                    defaultValue = defaultLocation;
                };
                return comp;
            }, association: {
                match: {evaluate: 'fieldEvt', field: 'location'}, exec: {
                    evaluate: function () {
                        var location = this.__component;
                        var disableOverride = this.__component.__pdefaults.__recordForm.findByItemId('$.disable-override');
                        if (!Ext.isEmpty(disableOverride)) {
                            if (location.getValue() === 'shared') {
                                disableOverride.setValue(undefined);
                                disableOverride.setVisible(location.getValue() !== 'shared');
                            }
                            else {
                                disableOverride.setVisible(true);
                            }
                            var w = this.__component.findParentByType("pan-window");
                            if (w) {
                                w.syncShadow();
                            }
                        }
                    }
                }
            }
        }
    };
}(Pan.common.builders.FieldOptionsBuilder));
(function (p) {
    p.push = function (option) {
        if (arguments.length > 1) {
            this.options.push.apply(this.options, arguments);
            return;
        }
        if ($.isArray(option)) {
            this.options.push.apply(this.options, option);
            return;
        }
        var builder = new Pan.common.builders.FieldOptionComposer(option, this.options);
        this.options.push(builder.option);
        return builder;
    };
    return p;
}(Pan.common.builders.FieldOptionsBuilder.prototype));
Pan.common.builders.ActionOptionBuilder = function ActionOptionBuilder(option) {
    if (typeof option === "string") {
        option = {atype: option};
    }
    Pan.common.builders.OptionBuilder.call(this, option);
};
(function (p) {
    p.constructor = Pan.common.builders.ActionOptionBuilder;
    p.set = function (propertyPath, value) {
        Pan.common.builders.utils.push(this.option, propertyPath, value);
    };
    Pan.common.builders.mixin.withAvailableMixin.call(p);
}(Pan.common.builders.ActionOptionBuilder.prototype = Object.create(Pan.common.builders.OptionBuilder.prototype)));
Ext.ns('Pan.common.builders');
Pan.common.builders.ActionOptionsBuilder = function (options) {
    this.options = options || [];
};
(function (p) {
    p.push = function (option) {
        if (arguments.length > 1) {
            Array.prototype.push.apply(this.options, arguments);
            return;
        }
        if ($.isArray(option)) {
            Array.prototype.push.apply(this.options, option);
            return;
        }
        option = option || {};
        this.options.push(option);
        return new Pan.common.builders.ActionOptionBuilder(option);
    };
    return p;
}(Pan.common.builders.ActionOptionsBuilder.prototype));
Ext.ns('Pan.common');
Pan.common.PDFPrinter = Ext.extend(Pan.base.container.Window, {
    width: 545,
    height: 125,
    closable: false,
    layout: "form",
    bodyStyle: 'padding: 10px;',
    title: _T('PDF Printer'),
    pdfFileName: _T("PDF Report"),
    _pagesToBeRendered: null,
    _callCount: 0,
    _maxCallsToRender: 500,
    _isStopped: false,
    showPreview: false,
    showHelp: false,
    includeTitlePage: true,
    includeFooter: true,
    y: 100,
    normalizePageSizes: true,
    constructor: function (config) {
        config = config || {};
        var items = [{name: 'progress', xtype: 'progress'}, {
            itemId: 'printPreview',
            xtype: 'panel',
            autoWidth: true,
            autoScroll: true,
            autoHeight: true,
            hideBorders: true
        }, {xtype: 'container', height: 50}, {
            itemId: 'containerForRenderingHiddenElements',
            xtype: 'container',
            cls: 'printing',
            height: 500
        }];
        var buttons = config.actions || [];
        buttons.push([{
            text: _T('Cancel'), cls: 'default-btn', handler: function () {
                this.stop();
                this.close();
            }, scope: this
        }]);
        Ext.apply(config, {
            layout: 'form',
            autoScroll: false,
            items: items,
            plain: true,
            buttons: buttons,
            modal: true,
            shadow: false,
            doHTMLEncode: false,
            resizeable: false
        });
        config.onSuccess = config.onSuccess || this.onSuccess.createDelegate(this);
        config.onFailure = config.onFailure || this.onFailure.createDelegate(this);
        this._pagesToBeRendered = [];
        this._callCount = 0;
        this.pdfFileName = config.pdfFileName || _T("PDF Report");
        this.title = _T("Print") + " " + this.pdfFileName;
        this.showPreview = Ext.isDefined(config.showPreview) ? config.showPreview : this.showPreview;
        this.includeTitlePage = Ext.isDefined(config.includeTitlePage) ? config.includeTitlePage : this.includeTitlePage;
        this.normalizePageSizes = Ext.isDefined(config.normalizePageSizes) ? config.normalizePageSizes : true;
        this.includeFooter = Ext.isDefined(config.includeFooter) ? config.includeFooter : this.includeFooter;
        if (this.showPreview) {
            this.width = 600;
            this.height = 500;
        }
        Pan.common.PDFPrinter.superclass.constructor.call(this, config);
    },
    addToQ: function (domElements, beforeRender, afterRender) {
        if (!Ext.isArray(domElements)) {
            domElements = [domElements];
        }
        var columns = this._pagesToBeRendered[this._pagesToBeRendered.length - 1].columns;
        var currentColumn = null;
        if (columns.length) {
            currentColumn = columns[columns.length - 1];
        } else {
            currentColumn = [];
            columns.push(currentColumn);
        }
        Ext.each(domElements, function (el) {
            currentColumn.push({"element": el, "beforeRender": beforeRender, "afterRender": afterRender});
        }, this);
    },
    addColumn: function () {
        this._pagesToBeRendered[this._pagesToBeRendered.length - 1].columns.push([]);
    },
    addPage: function (orientation) {
        orientation = orientation || "landscape";
        this._pagesToBeRendered.push({"orientation": orientation, "columns": []});
    },
    getPPI: function () {
        if (!this.ppi) {
            var $div = jQuery("<div style = 'width: 1in; visibility:hidden;' />").appendTo("body");
            this.ppi = document.defaultView.getComputedStyle($div.get(0), null).getPropertyValue('width');
            if (Ext.isString(this.ppi)) {
                this.ppi = parseInt(this.ppi.substring(0, this.ppi.length - 2), 10);
            }
            $div.remove();
        }
        return this.ppi;
    },
    stop: function () {
        this._isStopped = true;
    },
    print: function () {
        var log = PanLogging.getLogger('common:PDFPrinter');
        this._callCount = 0;
        this._isStopped = false;
        var renderQueue = [];
        Ext.each(this._pagesToBeRendered, function (page) {
            if (page) {
                var columns = page.columns;
                if (columns && Ext.isArray(columns)) {
                    renderQueue = renderQueue.concat(jQuery.map(columns, function (e) {
                        return e;
                    }));
                }
            }
        });
        var isRendering = false;
        var totalBeingPrinted = renderQueue.length;
        var otherActionsToComplete = 1;
        var otherActionsCompleted = 0;
        var scrolledParents = [];
        var updateProgress = function () {
            var progress = parseInt(100 * (totalBeingPrinted - renderQueue.length + otherActionsCompleted) / (otherActionsToComplete + totalBeingPrinted).toFixed(0), 10);
            var progressBar = this.findByType('progress');
            if (progressBar && progressBar[0] && Ext.isNumber(progress)) {
                var progressText = progress + '%';
                progressBar[0].updateProgress(progress / 100, progressText);
            }
        }.createDelegate(this);
        var renderNext = function () {
            try {
                if (this._callCount >= this._maxCallsToRender) {
                    log.error('Waited too long for rendering to complete for PDF. Reporting an error and quitting.');
                    scrolledParents.reverse();
                    Ext.each(scrolledParents, function (scrolledParent) {
                        scrolledParent.el.scrollTop = scrolledParent.scrollTop;
                        scrolledParent.el.scrollLeft = scrolledParent.scrollLeft;
                    });
                    return;
                } else if (this._isStopped) {
                    log.info('Rendering has been stopped. Quitting.');
                    scrolledParents.reverse();
                    Ext.each(scrolledParents, function (scrolledParent) {
                        scrolledParent.el.scrollTop = scrolledParent.scrollTop;
                        scrolledParent.el.scrollLeft = scrolledParent.scrollLeft;
                    });
                    return;
                }
                ++this._callCount;
                if (Ext.isEmpty(renderQueue)) {
                    scrolledParents.reverse();
                    Ext.each(scrolledParents, function (scrolledParent) {
                        scrolledParent.el.scrollTop = scrolledParent.scrollTop;
                        scrolledParent.el.scrollLeft = scrolledParent.scrollLeft;
                    });
                    var processWindow = this;
                    var pagesToBeSent = [];
                    Ext.each(this._pagesToBeRendered, function (pageToBeRendered) {
                        var colsOfImages = [];
                        Ext.each(pageToBeRendered.columns, function (column) {
                            var colOfImages = jQuery.map(column, function (json) {
                                return json.image;
                            });
                            colsOfImages.push(colOfImages);
                        });
                        pagesToBeSent.push({"orientation": pageToBeRendered.orientation, "images": colsOfImages});
                    });
                    PanDirect.run("PDFPrinterDirect.createReport", [{
                        "pdfFileName": processWindow.pdfFileName,
                        "pages": pagesToBeSent,
                        "ppi": processWindow.getPPI(),
                        "normalizePageSizes": processWindow.normalizePageSizes,
                        "includeTitlePage": this.includeTitlePage,
                        "includeFooter": this.includeFooter
                    }], function (response) {
                        if (!this._isStopped) {
                            ++otherActionsCompleted;
                            updateProgress();
                            if (response.success) {
                                if (Ext.isFunction(this.initialConfig.onSuccess)) {
                                    this.initialConfig.onSuccess.call(this);
                                }
                            } else {
                                if (Ext.isFunction(this.initialConfig.onFailure)) {
                                    this.initialConfig.onFailure.call(this);
                                }
                            }
                        }
                    }, this);
                    return;
                }
                isRendering = true;
                var json = renderQueue.shift();
                if (Ext.isFunction(json.beforeRender)) {
                    try {
                        json.beforeRender.call(json.scope || json, json);
                    } catch (e) {
                        log.error(e.stack || e);
                    }
                }
                var $el = null, el = null, canvas = null, $canvas = null, svg = null, $svg = null;
                if (Ext.isElement(json.element)) {
                    $el = jQuery(json.element);
                    if ($el.is("canvas")) {
                        canvas = $el.get(0);
                        json.image = {width: canvas.width, height: canvas.height, data: canvas.toDataURL('image/png')};
                        $el.removeClass("printing");
                        isRendering = false;
                        if (Ext.isFunction(json.afterRender)) {
                            try {
                                json.afterRender.call(json.scope || json, json, canvas);
                            } catch (e) {
                                log.error(e.stack || e);
                            }
                        }
                        updateProgress();
                    } else if (!$el.is("svg") || $el.find("foreignObject").length > 0) {
                        el = $el.get(0);
                        if (Ext.isFunction(el.getBoundingClientRect)) {
                            for (var e = el, parent = e.parentNode; e && parent && e.parentNode && el.parentNode !== el; parent = parent.parentNode) {
                                if (parent.scrollWidth > parent.clientWidth || parent.scrollHeight > parent.clientHeight) {
                                    var offsetTop = 0, offsetLeft = 0, tmp = e;
                                    var eRect = e.getBoundingClientRect();
                                    var parentRect = parent.getBoundingClientRect();
                                    var parentBottom = parentRect.top + parent.clientHeight;
                                    var parentRight = parentRect.left + parent.clientWidth;
                                    if (eRect.bottom > parentBottom || eRect.top < parentRect.top || eRect.left < parentRect.left || eRect.right > parentRight) {
                                        scrolledParents.push({
                                            "el": parent,
                                            scrollTop: parent.scrollTop,
                                            scrollLeft: parent.scrollLeft
                                        });
                                        parent.scrollTop = parent.scrollTop + (eRect.top - parentRect.top);
                                        parent.scrollLeft = parent.scrollLeft + (eRect.left - parentRect.left);
                                        e = parent;
                                    }
                                }
                            }
                        }
                        $el.addClass("printing");
                        html2canvas(el, {
                            logging: true, svgRendering: true, onrendered: function (canvas) {
                                json.image = {
                                    width: canvas.width,
                                    height: canvas.height,
                                    data: canvas.toDataURL('image/png')
                                };
                                if (Ext.isFunction(json.afterRender)) {
                                    try {
                                        json.afterRender.call(json.scope || json, json, canvas);
                                    } catch (e) {
                                        log.error(e.stack || e);
                                    }
                                }
                                if (this.showPreview) {
                                    $(canvas).appendTo(this.findByItemId("printPreview").body.dom);
                                } else {
                                    $(canvas).remove();
                                }
                                $el.removeClass("printing");
                                isRendering = false;
                                updateProgress();
                            }.createDelegate(this), letterRendering: true, background: undefined, allowTaint: true
                        });
                    } else {
                        canvas = jQuery("<canvas />").get(0);
                        $svg = $("<div />").append($el.clone(false));
                        $svg.find("[style]").removeAttr("style");
                        var svgData = $svg.html();
                        if (svgData.indexOf('xmlns="http://www.w3.org/2000/svg"') !== -1) {
                            svgData = svgData.replace(/xmlns="http:\/\/www\.w3\.org\/2000\/svg"/g, "");
                        }
                        if (svgData.indexOf("xmlns") === -1) {
                            svgData = svgData.replace("<svg", '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
                        }
                        svgData = svgData.replace("Raphaël", "Raphael");
                        $(canvas).addClass("printing");
                        canvg(canvas, svgData, {
                            renderCallback: function () {
                                json.image = {
                                    width: canvas.width,
                                    height: canvas.height,
                                    data: canvas.toDataURL('image/png')
                                };
                                if (Ext.isFunction(json.afterRender)) {
                                    try {
                                        json.afterRender.call(json.scope || json, json, canvas);
                                    } catch (e) {
                                        log.error(e.stack || e);
                                    }
                                }
                                if (this.showPreview) {
                                    $(canvas).appendTo(this.findByItemId("printPreview").body.dom);
                                } else {
                                    $(canvas).remove();
                                }
                                $(canvas).removeClass("printing");
                                isRendering = false;
                                updateProgress();
                            }.createDelegate(this)
                        });
                    }
                } else if (Ext.isObject(json.element)) {
                    var hiddenContainer = this.findByItemId("containerForRenderingHiddenElements");
                    hiddenContainer.setHeight("auto");
                    hiddenContainer.setWidth("auto");
                    var config = json.element;
                    var component = null;
                    if (config.id && Ext.getCmp(config.id)) {
                        component = config;
                    } else if (config.xtype) {
                        component = Ext.create(config);
                    } else if (config.treePath) {
                        component = Pan.create(config);
                    }
                    if (component) {
                        var onReady = function () {
                            hiddenContainer.setHeight(component.getHeight());
                            html2canvas(hiddenContainer.el.dom, {
                                logging: true, svgRendering: true, onrendered: function (canvas) {
                                    json.image = {
                                        width: canvas.width,
                                        height: canvas.height,
                                        data: canvas.toDataURL('image/png')
                                    };
                                    if (Ext.isFunction(json.afterRender)) {
                                        try {
                                            json.afterRender.call(json.scope || json, json, canvas);
                                        } catch (e) {
                                            log.error(e.stack || e);
                                        }
                                    }
                                    if (this.showPreview) {
                                        $(canvas).appendTo(this.findByItemId("printPreview").body.dom);
                                    } else {
                                        $(canvas).remove();
                                    }
                                    hiddenContainer.removeAll(true);
                                    hiddenContainer.doLayout(false, true);
                                    isRendering = false;
                                    updateProgress();
                                }.createDelegate(this), letterRendering: true, background: undefined, allowTaint: true
                            });
                            if (component instanceof Ext.grid.GridPanel) {
                                component.un("viewready", onReady, this);
                            }
                        }.createDelegate(this);
                        hiddenContainer.removeAll(true);
                        hiddenContainer.add(component);
                        hiddenContainer.doLayout();
                        hiddenContainer.setHeight(component.getHeight());
                        hiddenContainer.setWidth(component.getWidth());
                        if (component instanceof Ext.grid.GridPanel) {
                            component.on("viewready", onReady, this);
                        } else {
                            onReady();
                        }
                    } else {
                        isRendering = false;
                    }
                }
                window.setTimeout(function () {
                    if (isRendering) {
                        window.setTimeout(arguments.callee, 50);
                    } else {
                        renderNext();
                    }
                });
            } catch (ex) {
                if (scrolledParents && scrolledParents.length) {
                    scrolledParents.reverse();
                    Ext.each(scrolledParents, function (scrolledParent) {
                        scrolledParent.el.scrollTop = scrolledParent.scrollTop;
                        scrolledParent.el.scrollLeft = scrolledParent.scrollLeft;
                    });
                    log.error(ex);
                }
            }
        }.createDelegate(this);
        renderNext();
    },
    _downscaleIfRequired: function (canvas) {
        if (!canvas) {
            return canvas;
        }
        if (canvas.width > 550 && canvas.width > canvas.height) {
            return this.downscale(canvas, parseFloat((550 / canvas.width).toFixed(1)));
        }
        return canvas;
    },
    downscale: function (canvas, scale) {
        function downScaleCanvas(cv, scale) {
            if (!(scale < 1) || !(scale > 0)) throw('scale must be a positive number <1 ');
            scale = normaliseScale(scale);
            var sqScale = scale * scale;
            var sw = cv.width;
            var sh = cv.height;
            var tw = Math.floor(sw * scale);
            var th = Math.floor(sh * scale);
            var sx = 0, sy = 0, sIndex = 0;
            var tx = 0, ty = 0, yIndex = 0, tIndex = 0;
            var tX = 0, tY = 0;
            var w = 0, nw = 0, wx = 0, nwx = 0, wy = 0, nwy = 0;
            var crossX = false;
            var crossY = false;
            var sBuffer = cv.getContext('2d').getImageData(0, 0, sw, sh).data;
            var tBuffer = new Float32Array(3 * sw * sh);
            var sR = 0, sG = 0, sB = 0;
            for (sy = 0; sy < sh; sy++) {
                ty = sy * scale;
                tY = 0 | ty;
                yIndex = 3 * tY * tw;
                crossY = (tY !== (0 | (ty + scale)));
                if (crossY) {
                    wy = (tY + 1 - ty);
                    nwy = (ty + scale - tY - 1);
                }
                for (sx = 0; sx < sw; sx++, sIndex += 4) {
                    tx = sx * scale;
                    tX = 0 | tx;
                    tIndex = yIndex + tX * 3;
                    crossX = (tX !== (0 | (tx + scale)));
                    if (crossX) {
                        wx = (tX + 1 - tx);
                        nwx = (tx + scale - tX - 1);
                    }
                    sR = sBuffer[sIndex];
                    sG = sBuffer[sIndex + 1];
                    sB = sBuffer[sIndex + 2];
                    if (!crossX && !crossY) {
                        tBuffer[tIndex] += sR * sqScale;
                        tBuffer[tIndex + 1] += sG * sqScale;
                        tBuffer[tIndex + 2] += sB * sqScale;
                    } else if (crossX && !crossY) {
                        w = wx * scale;
                        tBuffer[tIndex] += sR * w;
                        tBuffer[tIndex + 1] += sG * w;
                        tBuffer[tIndex + 2] += sB * w;
                        nw = nwx * scale;
                        tBuffer[tIndex + 3] += sR * nw;
                        tBuffer[tIndex + 4] += sG * nw;
                        tBuffer[tIndex + 5] += sB * nw;
                    } else if (!crossX && crossY) {
                        w = wy * scale;
                        tBuffer[tIndex] += sR * w;
                        tBuffer[tIndex + 1] += sG * w;
                        tBuffer[tIndex + 2] += sB * w;
                        nw = nwy * scale;
                        tBuffer[tIndex + 3 * tw] += sR * nw;
                        tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                        tBuffer[tIndex + 3 * tw + 2] += sB * nw;
                    } else {
                        w = wx * wy;
                        tBuffer[tIndex] += sR * w;
                        tBuffer[tIndex + 1] += sG * w;
                        tBuffer[tIndex + 2] += sB * w;
                        nw = nwx * wy;
                        tBuffer[tIndex + 3] += sR * nw;
                        tBuffer[tIndex + 4] += sG * nw;
                        tBuffer[tIndex + 5] += sB * nw;
                        nw = wx * nwy;
                        tBuffer[tIndex + 3 * tw] += sR * nw;
                        tBuffer[tIndex + 3 * tw + 1] += sG * nw;
                        tBuffer[tIndex + 3 * tw + 2] += sB * nw;
                        nw = nwx * nwy;
                        tBuffer[tIndex + 3 * tw + 3] += sR * nw;
                        tBuffer[tIndex + 3 * tw + 4] += sG * nw;
                        tBuffer[tIndex + 3 * tw + 5] += sB * nw;
                    }
                }
            }
            var resCV = document.createElement('canvas');
            resCV.width = tw;
            resCV.height = th;
            var resCtx = resCV.getContext('2d');
            var imgRes = resCtx.getImageData(0, 0, tw, th);
            var tByteBuffer = imgRes.data;
            var pxIndex = 0;
            for (sIndex = 0, tIndex = 0; pxIndex < tw * th; sIndex += 3, tIndex += 4, pxIndex++) {
                tByteBuffer[tIndex] = 0 | (tBuffer[sIndex]);
                tByteBuffer[tIndex + 1] = 0 | (tBuffer[sIndex + 1]);
                tByteBuffer[tIndex + 2] = 0 | (tBuffer[sIndex + 2]);
                tByteBuffer[tIndex + 3] = 255;
            }
            resCtx.putImageData(imgRes, 0, 0);
            return resCV;
        }

        function polyFillPerfNow() {
            window.performance = window.performance ? window.performance : {};
            window.performance.now = window.performance.now || window.performance.webkitNow || window.performance.msNow || window.performance.mozNow || Date.now;
        }

        function log2(v) {
            var b = [0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000];
            var S = [1, 2, 4, 8, 16];
            var i = 0, r = 0;
            for (i = 4; i >= 0; i--) {
                if (v & b[i]) {
                    v >>= S[i];
                    r |= S[i];
                }
            }
            return r;
        }

        function normaliseScale(s) {
            if (s > 1) throw('s must be <1');
            s = 0 | (1 / s);
            var l = log2(s);
            var mask = 1 << l;
            var accuracy = 4;
            while (accuracy && l) {
                l--;
                mask |= 1 << l;
                accuracy--;
            }
            return 1 / (s & mask);
        }

        return downScaleCanvas(canvas, scale);
    },
    onSuccess: function () {
        window.open("/php/pdf/download_pdf_report.php");
        this.close();
    },
    onFailure: function () {
        Pan.Msg.show("Could not generate report.");
    }
});
Ext.ns('Pan.common');
Pan.common.CSVExporter = Ext.extend(Pan.base.container.Window, {
    width: 545,
    height: 125,
    closable: false,
    layout: "form",
    bodyStyle: 'padding: 10px;',
    title: _T('CSV Export'),
    fileName: _T("CSV Export"),
    _pagesToBeRendered: null,
    _callCount: 0,
    _maxCallsToRender: 500,
    _isStopped: false,
    constructor: function (config) {
        config = config || {};
        var items = {name: 'progress', xtype: 'progress'};
        var buttons = config.actions || [];
        buttons.push([{
            text: _T('Cancel'), cls: 'default-btn', handler: function () {
                this.stop();
                this.close();
            }, scope: this
        }, {
            text: _T('Close'), handler: function () {
                this.stop();
                this.close();
            }, scope: this
        }]);
        Ext.apply(config, {
            layout: 'form',
            autoScroll: false,
            items: items,
            plain: true,
            buttons: buttons,
            modal: true,
            shadow: false,
            doHTMLEncode: false,
            resizeable: false
        });
        this._callCount = 0;
        this.fileName = config.fileName || _T("CSV Export");
        this.title = _T("Export") + " " + this.fileName;
        this.grid = config.grid;
        Pan.common.CSVExporter.superclass.constructor.call(this, config);
    },
    stop: function () {
        this._isStopped = true;
    },
    setGrid: function (grid) {
        this.grid = grid;
    },
    "export": function () {
        this._callCount = 0;
        this._isStopped = false;
        var otherActionsToComplete = 1;
        var otherActionsCompleted = 0;
        var totalRows = 0, rowsRendered = 0;
        var updateProgress = function (to100) {
            var progress = to100 === true ? 100 : parseInt(100 * (rowsRendered + otherActionsCompleted) / (otherActionsToComplete + totalRows).toFixed(0), 10);
            var progressBar = this.findByType('progress');
            if (progressBar && progressBar[0] && Ext.isNumber(progress)) {
                var progressText = progress + '%';
                progressBar[0].updateProgress(progress / 100, progressText);
            }
        }.createDelegate(this);
        var exportRow = function (el) {
            var rows = [];
            var $el = $(el);
            var i = 0;
            var iLen;
            ($el.is("tr") ? $el : $el.find("tr")).each(function (rowIndex) {
                var colIndex = undefined;
                if (rows[rowIndex]) {
                    var row = rows[rowIndex];
                    for (i = 0, iLen = row.length; i < iLen; ++i) {
                        if (row[i] === undefined) {
                            colIndex = i;
                        } else {
                            break;
                        }
                    }
                }
                if (colIndex !== undefined) {
                    colIndex += 1;
                } else {
                    colIndex = 0;
                }
                $(this).find("td").each(function () {
                    var $td = $(this);
                    var rowspan = parseInt($td.attr("rowspan"), 10) || 1;
                    var colspan = parseInt($td.attr("colspan"), 10) || 1;
                    var value = $td.text() || $td.find("[alt]").attr("alt");
                    for (var i = rowIndex, iLen = rowIndex + rowspan; i < iLen; ++i) {
                        var row = rows[i];
                        if (!row) {
                            rows[i] = [];
                        }
                        for (var j = colIndex, jLen = colIndex + colspan; j < jLen; ++j) {
                            rows[i][j] = value;
                        }
                    }
                    colIndex += colspan;
                });
            });
            for (i = 0, iLen = rows.length; i < iLen; ++i) {
                for (var j = 0, jLen = rows[i].length; j < jLen; ++j) {
                    if (rows[i][j] === undefined) {
                        if (i !== 0) {
                            rows[i][j] = rows[i - 1][j];
                        }
                    }
                }
            }
            return rows;
        };
        var grid = this.grid;
        if (grid && grid.el.dom) {
            var rows = [];
            totalRows = $(grid.el.dom).find("tr").length;
            $(grid.el.dom).find(".x-grid3-header table").each(function () {
                rows = rows.concat(exportRow(this));
                ++rowsRendered;
                updateProgress();
            }).end().find(".x-grid3-body .x-grid3-row, .x-treegrid-root-node .x-tree-node-el").each(function () {
                rows = rows.concat(exportRow(this));
                ++rowsRendered;
                updateProgress();
            });
            var lines = [];
            $(rows).each(function () {
                var row = $(this).map(function (index, value) {
                    return value === undefined ? "" : '"' + value.replace(/"/g, '""').replace(String.fromCharCode(160), " ").toString() + '"';
                }).toArray().join(",");
                lines.push(row);
            });
            var csv = lines.join('\n');
            this.buttons[0].hide();
            PanDirect.run("CSVExporterDirect.exportReport", [{
                "fileName": this.fileName,
                "csv": csv
            }], function (response) {
                ++otherActionsCompleted;
                updateProgress();
                if (response.success) {
                    updateProgress(true);
                    if (response.success) {
                        window.open("/php/csv/download_csv_report.php");
                        this.close();
                    }
                }
            }, this);
        }
    }
});